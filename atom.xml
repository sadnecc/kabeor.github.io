<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>K&#39;s House</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kabeor.github.io/"/>
  <updated>2019-08-02T07:09:58.631Z</updated>
  <id>https://kabeor.github.io/</id>
  
  <author>
    <name>kabeor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018护网杯线上 APM233</title>
    <link href="https://kabeor.github.io/2018%E6%8A%A4%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8A%20APM233/"/>
    <id>https://kabeor.github.io/2018护网杯线上 APM233/</id>
    <published>2019-07-31T09:12:43.513Z</published>
    <updated>2019-08-02T07:09:58.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018护网杯线上-APM233"><a href="#2018护网杯线上-APM233" class="headerlink" title="2018护网杯线上 APM233"></a>2018护网杯线上 APM233</h1><p>MFC42的逆向</p><p><img src="https://i.loli.net/2019/07/31/5d4156590c9ba50005.jpg" alt></p><p>一共四层验证，IDA打开后基本全红，直接按P创建函数<br>花指令格式为<code>jz address+1;  jnz address+1;</code>,因此显示出address处的opcode，按D设为数据，address+1处创建函数，平衡栈帧即可</p><p>主流程<br><img src="https://i.loli.net/2019/07/31/5d41579664ffd31971.jpg" alt><br><img src="https://i.loli.net/2019/07/31/5d4157b6c3bce90900.jpg" alt></p><h2 id="Check1"><a href="#Check1" class="headerlink" title="Check1"></a>Check1</h2><p>第一层与字符串1d2e3c4a比较</p><h2 id="Check2"><a href="#Check2" class="headerlink" title="Check2"></a>Check2</h2><p><img src="https://i.loli.net/2019/07/31/5d415857c43ac44867.jpg" alt></p><p>z3直接计算<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">from z3 <span class="keyword">import</span> *</span><br><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">Dr0 = BitVec('Dr0',32)</span><br><span class="line">Dr1 = BitVec('Dr1',32)</span><br><span class="line">Dr2 = BitVec('Dr2',32)</span><br><span class="line">Dr3 = BitVec('Dr3',32)</span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">s.add(Dr0 &lt;= <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">s.add(Dr1 &lt;= <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">s.add(Dr2 &lt;= <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">s.add(Dr3 &lt;= <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">s.add(Dr1+Dr0 == <span class="number">0x899a9d9c</span>)</span><br><span class="line">s.add(Dr2+Dr1 == <span class="number">0x384989ED</span>)</span><br><span class="line">s.add(Dr3+Dr2 == <span class="number">0x2B2C85BC</span>)</span><br><span class="line">s.add(Dr0-Dr3 == <span class="number">0xAFAFDC11</span>)</span><br><span class="line"></span><br><span class="line">s.check()    </span><br><span class="line"></span><br><span class="line">m = s.model() </span><br><span class="line"></span><br><span class="line">Dr0 = int('%s'%m[Dr0])</span><br><span class="line">Dr1 = int('%s'%m[Dr1])</span><br><span class="line">Dr2 = int('%s'%m[Dr2])</span><br><span class="line">Dr3 = int('%s'%m[Dr3])</span><br><span class="line">    </span><br><span class="line">ans = '%s%s%s%s'%(p32(Dr0).encode('hex'),p32(Dr1).encode('hex'),p32(Dr2).encode('hex'),p32(Dr3).encode('hex'))</span><br><span class="line"></span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure></p><p>不知道为什么我这里的数值和别人的不一样，算出来的也不一样。。。正确结果应该是efbe3323adde6666feca1313beba1414</p><h2 id="Check3"><a href="#Check3" class="headerlink" title="Check3"></a>Check3</h2><p>各种反调试虚拟机检测，未检测到的返回值就是key：    0acb7935481efc12<br><img src="https://i.loli.net/2019/07/31/5d4158ff4387664889.jpg" alt></p><h2 id="Check4"><a href="#Check4" class="headerlink" title="Check4"></a>Check4</h2><p><img src="https://i.loli.net/2019/07/31/5d415a2bef10158583.jpg" alt></p><p><img src="https://i.loli.net/2019/07/31/5d415a3fd47ee42987.jpg" alt></p><p>要求玩家的位置不能与三个AI重合，玩家每次的可走的步数为1-4，AI的行动路线如下所示<br><code>a1 = [4, -1, 6, -1, 3, 2, 4, 1, 3, -1, 5, 1, 2, -1, 5, 1, 3, -2, 7, 0, 2, 3, 5, 0, 5, 0, 5, 2, 1, -2, 6, -1, 3, 3, 4, 0, 5, -1, 6, 0, 4, 0, 7, 0, 5, -2, 7, 2, 2, -1, 6, 2, 2, 1, 5, 0, 2, 0, 3, 0, 4, 0, 6, -1, 5, 0, 5, 3, 0, 5, 3, 2]</code><br><code>a2 = [2, 2, 3, 3, 3, -2, 7, 1, 1, 1, 5, 1, 0, 2, 5, 1, 0, 0, 4, 0, 7, 2, 2, 0, 4, 1, 3, 4, 0, 1, 6, -1, 5, -1, 3, 5, 1, 2, 5, 0, 5, 0, 2, 5, 1, 1, 5, 2, 2, 1, 2, 3, 5, -1, 4, 1, 2, -1, 7, 1, 2, 2, 1, 2, 5, 0, 5, 0, 5, -1, 3, 2]</code><br><code>a3 = [3, -1, 6, -1, 5, 0, 4, 0, 2, 5, 0, 5, 1, -1, 5, 1, 0, 2, 4, 0, 5, 0, 4, 0, 6, -1, 6, 1, 2, 1, 3, 3, 2, 3, 3, 0, 5, -1, 4, 0, 6, 0, 5, 0, 5, 1, 2, 2, 3, 0, 5, 5, 0, 0, 6, 2, -1, 1, 5, 1, 0, 3, 4, -1, 4, 5, 0, 2, 5, 1, 4, 1]</code><br>通过上述规则，可以得到玩家的路线为<br><code>[1, 4, 1, 3, 1, 4, 1, 2, 2, 3, 2, 1, 1, 4, 1, 1, 1, 4, 1, 4, 2, 3, 1, 4, 1, 4, 2, 1, 1, 4, 1, 3, 2, 3, 2, 3, 1, 4, 1, 4, 1, 4, 2, 3, 1, 4, 2, 2, 1, 4, 3, 2, 1, 4, 1, 1, 1, 4, 1, 2, 2, 3, 1, 4, 2, 3, 2, 3, 2, 3, 2, 3]</code><br>玩家的行动由输入b64encode后再将编码后的结果拆为两两一组</p><p>脚本<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode,b64encode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level4</span><span class="params">()</span>:</span></span><br><span class="line">    a1 = [<span class="number">4</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">-2</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">-2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">    a2 = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">-2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">    a3 = [<span class="number">3</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    pos1 = <span class="number">0</span></span><br><span class="line">    pos2 = <span class="number">0</span></span><br><span class="line">    pos3 = <span class="number">0</span></span><br><span class="line">    pos4 = <span class="number">0</span></span><br><span class="line">    choice = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a1)):</span><br><span class="line">        pos1 += a1[i]</span><br><span class="line">        pos2 += a2[i]</span><br><span class="line">        pos3 += a3[i]</span><br><span class="line">        <span class="keyword">if</span> (pos4 + <span class="number">4</span> != pos1) <span class="keyword">and</span> (pos4 + <span class="number">4</span> != pos2) <span class="keyword">and</span> (pos4 + <span class="number">4</span> != pos3):</span><br><span class="line">            t = <span class="number">4</span></span><br><span class="line">        <span class="keyword">elif</span> (pos4 + <span class="number">3</span> != pos1) <span class="keyword">and</span> (pos4 + <span class="number">3</span> != pos2) <span class="keyword">and</span> (pos4 + <span class="number">3</span> != pos3):</span><br><span class="line">            t = <span class="number">3</span></span><br><span class="line">        <span class="keyword">elif</span> (pos4 + <span class="number">2</span> != pos1) <span class="keyword">and</span> (pos4 + <span class="number">2</span> != pos2) <span class="keyword">and</span> (pos4 + <span class="number">2</span> != pos3):</span><br><span class="line">            t = <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = <span class="number">1</span></span><br><span class="line">        pos4 += t</span><br><span class="line">        choice.append(t<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> choice</span><br><span class="line"></span><br><span class="line">    b64 = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> choice</span><br><span class="line">    ans = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,len(choice),<span class="number">3</span>):</span><br><span class="line">        t = (choice[i]&lt;&lt;<span class="number">4</span>) + (choice[i+<span class="number">1</span>]&lt;&lt;<span class="number">2</span>) + choice[i+<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">print</span> t,</span><br><span class="line">        ans+=b64[t]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> ans</span><br><span class="line">    <span class="keyword">print</span> b64decode(ans)</span><br><span class="line"></span><br><span class="line"><span class="comment"># level1 1d2e3c4a</span></span><br><span class="line">level2()    <span class="comment"># efbe3323adde6666feca1313beba1414</span></span><br><span class="line"><span class="comment"># level3 0acb7935481efc12</span></span><br><span class="line">level4()    <span class="comment"># 21d03c42f365901cff</span></span><br></pre></td></tr></table></figure></p><p>程序输入有时间限制，可以找到时间call直接jmp，也可以鼠标模拟</p><p>鼠标点击模拟脚本<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymouse <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">m = PyMouse()</span><br><span class="line"></span><br><span class="line">k1 = <span class="string">"1d2e3c4a"</span></span><br><span class="line">key1 = list(k1)</span><br><span class="line">k2 = <span class="string">"efbe3323adde6666feca1313beba1414"</span></span><br><span class="line">key2 = list(k2)</span><br><span class="line">k3 = <span class="string">"0acb7935481efc12"</span></span><br><span class="line">key3 = list(k3)</span><br><span class="line">k4 = <span class="string">"21d03c42f365901cff"</span></span><br><span class="line">key4 = list(k4)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mnclick</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(y):</span><br><span class="line">        <span class="keyword">if</span>(x[i] == <span class="string">'0'</span>): m.click(<span class="number">1075</span>, <span class="number">418</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'1'</span>): m.click(<span class="number">1118</span>, <span class="number">418</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'2'</span>): m.click(<span class="number">1162</span>, <span class="number">418</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'3'</span>): m.click(<span class="number">1205</span>, <span class="number">418</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'4'</span>): m.click(<span class="number">1075</span>, <span class="number">465</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'5'</span>): m.click(<span class="number">1118</span>, <span class="number">465</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'6'</span>): m.click(<span class="number">1162</span>, <span class="number">465</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'7'</span>): m.click(<span class="number">1205</span>, <span class="number">465</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'8'</span>): m.click(<span class="number">1075</span>, <span class="number">511</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'9'</span>): m.click(<span class="number">1118</span>, <span class="number">511</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'a'</span>): m.click(<span class="number">1162</span>, <span class="number">511</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'b'</span>): m.click(<span class="number">1205</span>, <span class="number">511</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'c'</span>): m.click(<span class="number">1075</span>, <span class="number">558</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'d'</span>): m.click(<span class="number">1118</span>, <span class="number">558</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'e'</span>): m.click(<span class="number">1162</span>, <span class="number">558</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'f'</span>): m.click(<span class="number">1205</span>, <span class="number">558</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    m.click(<span class="number">670</span>, <span class="number">624</span>)</span><br><span class="line"></span><br><span class="line">mnclick(key1, <span class="number">8</span>)</span><br><span class="line">mnclick(key2, <span class="number">32</span>)</span><br><span class="line">mnclick(key3, <span class="number">16</span>)</span><br><span class="line">mnclick(key4, <span class="number">18</span>)</span><br></pre></td></tr></table></figure></p><p>按钮位置是用spy++查看窗口属性看到的</p><p>最后   flag{N0t_d1ff1cul7_r1ght?_3d34e}</p><p>From <a href="https://kabeor.github.io/2018护网杯线上 APM233/">https://kabeor.github.io/2018护网杯线上 APM233/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2018护网杯线上-APM233&quot;&gt;&lt;a href=&quot;#2018护网杯线上-APM233&quot; class=&quot;headerlink&quot; title=&quot;2018护网杯线上 APM233&quot;&gt;&lt;/a&gt;2018护网杯线上 APM233&lt;/h1&gt;&lt;p&gt;MFC42的逆向&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向， CTF" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C-CTF/"/>
    
  </entry>
  
  <entry>
    <title>Capstone反汇编引擎数据类型及API分析及示例(四)</title>
    <link href="https://kabeor.github.io/Capstone%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E5%8F%8A%E7%A4%BA%E4%BE%8B(%E5%9B%9B)/"/>
    <id>https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(四)/</id>
    <published>2019-07-27T02:19:05.676Z</published>
    <updated>2019-08-14T04:49:51.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Capstone反汇编引擎数据类型及API分析及示例-四"><a href="#Capstone反汇编引擎数据类型及API分析及示例-四" class="headerlink" title="Capstone反汇编引擎数据类型及API分析及示例(四)"></a>Capstone反汇编引擎数据类型及API分析及示例(四)</h1><h2 id="API分析"><a href="#API分析" class="headerlink" title="API分析"></a>API分析</h2><h3 id="cs-free"><a href="#cs-free" class="headerlink" title="cs_free"></a>cs_free</h3><p><code>void CAPSTONE_API cs_free(cs_insn *insn, size_t count);</code></p><p>释放被cs_malloc() 或 cs_disasm()分配的内存(insn参数)<br>参数<br>insn: 由cs_disasm()或cs_malloc()中的@insn参数返回的指针<br>count: 赋值由cs_disasm()返回的cs_insn结构的数量，或赋值为1表示由cs_malloc()分配给空闲内存的数量</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3bf583b748d86745.jpg" alt><br>直接调用cs_mem_free,也就是默认的free</p><p>示例(释放cs_disasm申请的内存)，代码片段：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">count = cs_disasm(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0x1000</span>, <span class="number">0</span>, &amp;insn);           <span class="comment">//计数由cs_disasm申请的内存</span></span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span><span class="string">"Ix"</span><span class="string">":\t%s\t\t%s\n"</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_free(insn, count);   <span class="comment">//循环依次释放每条insn的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cs-malloc"><a href="#cs-malloc" class="headerlink" title="cs_malloc"></a>cs_malloc</h3><p><code>cs_insn * CAPSTONE_API cs_malloc(csh handle);</code></p><p>被用于在API cs_disasm_iter()中为一条指令分配内存</p><p>参数<br>handle: cs_open()返回的句柄</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3bf97c0299d21615.jpg" alt></p><p>当这条指令所占的内存不再使用时，使用cs_free(insn, 1)释放，示例在下面cs_disasm_iter处</p><h3 id="cs-disasm-iter"><a href="#cs-disasm-iter" class="headerlink" title="cs_disasm_iter"></a>cs_disasm_iter</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> CAPSTONE_API <span class="title">cs_disasm_iter</span><span class="params">(csh handle,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">uint8_t</span> **code, <span class="keyword">size_t</span> *size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">uint64_t</span> *address, cs_insn *insn)</span></span>;</span><br></pre></td></tr></table></figure><p>给定buff、大小、地址和要解码的指令数，更快速的反汇编机器码，<br>这个API将生成的指令放入insn中的给定的缓存中。</p><p>注意1: 此API将更新code、size和address以指向输入缓冲区中的下一条指令。所以，虽然每次反汇编一条指令可以使用cs_disasm(count=1)来实现，但一些基准测试显示，在循环中使用cs_disasm_iter()可以方便地快速迭代所有指令，在随机输入时可以快30%。</p><p>注意2:可以使用cs_malloc()创建insn中的缓存。</p><p>注意3:对于动态分配内存可能产生内存不足的系统(比如OS内核或固件)，建议使用cs_disasm()这个API, 因为cs_disasm()是根据要分解的指令的数量来分配内存。</p><p>参数<br>handle: cs_open()返回的句柄<br>code: 要反汇编的机器码所在的缓冲区<br>size: 机器码缓冲区的大小<br>address: 所给机器码缓冲区中第一个insn的地址<br>insn: 指向这个API要填充的指令的指针。<br>return:如果这个API成功反汇编了一条指令返回true，否则将返回false。</p><p>失败时，调用cs_errno()获取错误代码。</p><p>代码实现，在cs_disasm基础上使用动态内存分配</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> CAPSTONE_API <span class="title">cs_disasm_iter</span><span class="params">(csh ud, <span class="keyword">const</span> <span class="keyword">uint8_t</span> **code, <span class="keyword">size_t</span> *size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">uint64_t</span> *address, cs_insn *insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line"><span class="keyword">uint16_t</span> insn_size;</span><br><span class="line">MCInst mci;</span><br><span class="line"><span class="keyword">bool</span> r;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"><span class="keyword">if</span> (!handle) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_OK;</span><br><span class="line"></span><br><span class="line">MCInst_Init(&amp;mci);</span><br><span class="line">mci.csh = handle;</span><br><span class="line"></span><br><span class="line">mci.address = *address;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为无detail模式保存相关信息</span></span><br><span class="line">mci.flat_insn = insn;</span><br><span class="line">mci.flat_insn-&gt;address = *address;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line">mci.flat_insn-&gt;mnemonic[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">mci.flat_insn-&gt;op_str[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">r = handle-&gt;disasm(ud, *code, *size, &amp;mci, &amp;insn_size, *address, handle-&gt;getinsn_info);</span><br><span class="line"><span class="keyword">if</span> (r) &#123;</span><br><span class="line">SStream ss;</span><br><span class="line">SStream_Init(&amp;ss);</span><br><span class="line"></span><br><span class="line">mci.flat_insn-&gt;size = insn_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将内部指令操作码映射到公共insn ID</span></span><br><span class="line">handle-&gt;insn_id(handle, insn, mci.Opcode);</span><br><span class="line"></span><br><span class="line">handle-&gt;printer(&amp;mci, &amp;ss, handle-&gt;printer_info);</span><br><span class="line"></span><br><span class="line">fill_insn(handle, insn, ss.buffer, &amp;mci, handle-&gt;post_printer, *code);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整伪操作码(X86)</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;arch == CS_ARCH_X86)</span><br><span class="line">insn-&gt;id += mci.popcode_adjust;</span><br><span class="line"></span><br><span class="line">*code += insn_size;</span><br><span class="line">*size -= insn_size;</span><br><span class="line">*address += insn_size;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 遇到中断指令</span></span><br><span class="line"><span class="keyword">size_t</span> skipdata_bytes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有跳过数据的请求，或者剩余数据太小，则退出</span></span><br><span class="line"><span class="keyword">if</span> (!handle-&gt;skipdata || handle-&gt;skipdata_size &gt; *size)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;skipdata_setup.callback) &#123;</span><br><span class="line">skipdata_bytes = handle-&gt;skipdata_setup.callback(*code, *size,</span><br><span class="line"><span class="number">0</span>, handle-&gt;skipdata_setup.user_data);</span><br><span class="line"><span class="keyword">if</span> (skipdata_bytes &gt; *size)</span><br><span class="line"><span class="comment">// 剩余数据太小</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!skipdata_bytes)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">skipdata_bytes = handle-&gt;skipdata_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于架构和模式跳过一些数据</span></span><br><span class="line">insn-&gt;id = <span class="number">0</span>;<span class="comment">// 此“数据”指令的ID无效</span></span><br><span class="line">insn-&gt;address = *address;</span><br><span class="line">insn-&gt;size = (<span class="keyword">uint16_t</span>)skipdata_bytes;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line">insn-&gt;mnemonic[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">insn-&gt;op_str[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="built_in">memcpy</span>(insn-&gt;bytes, *code, skipdata_bytes);</span><br><span class="line"><span class="built_in">strncpy</span>(insn-&gt;mnemonic, handle-&gt;skipdata_setup.mnemonic,</span><br><span class="line"><span class="keyword">sizeof</span>(insn-&gt;mnemonic) - <span class="number">1</span>);</span><br><span class="line">skipdata_opstr(insn-&gt;op_str, *code, skipdata_bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">*code += skipdata_bytes;</span><br><span class="line">*size -= skipdata_bytes;</span><br><span class="line">*address += skipdata_bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE16 <span class="meta-string">"\x8d\x4c\x32\x08\x01\xd8\x81\xc6\x34\x12\x00\x00"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE32 <span class="meta-string">"\x8d\x4c\x32\x08\x01\xd8\x81\xc6\x34\x12\x00\x00"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[4] = &#123;</span>     <span class="comment">//架构及模式</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_16,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE16,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 16bit (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_32,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE32,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 32bit (ATT syntax)"</span>,</span><br><span class="line">CS_OPT_SYNTAX,</span><br><span class="line">CS_OPT_SYNTAX_ATT,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_32,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE32,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 32 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为cs_disasm_iter()分配内存</span></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line"></span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);   <span class="comment">//原机器码</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;   <span class="comment">//cs_disasm_iter反汇编</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s // insn-ID: %u, insn-mnem: %s\n"</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str,</span><br><span class="line">insn-&gt;id, cs_insn_name(handle, insn-&gt;id));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印此指令使用的隐式寄存器</span></span><br><span class="line">detail = insn-&gt;detail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (detail-&gt;regs_read_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tImplicit registers read: "</span>);</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; detail-&gt;regs_read_count; n++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s "</span>, cs_reg_name(handle, detail-&gt;regs_read[n]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印此指令修改的隐式寄存器</span></span><br><span class="line"><span class="keyword">if</span> (detail-&gt;regs_write_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tImplicit registers modified: "</span>);</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; detail-&gt;regs_write_count; n++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s "</span>, cs_reg_name(handle, detail-&gt;regs_write[n]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印此指令所属指令集</span></span><br><span class="line"><span class="keyword">if</span> (detail-&gt;groups_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tThis instruction belongs to groups: "</span>);</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; detail-&gt;groups_count; n++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s "</span>, cs_group_name(handle, detail-&gt;groups[n]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放cs_malloc()分配的内存</span></span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c063cd33b421225.jpg" alt></p><h3 id="cs-reg-name"><a href="#cs-reg-name" class="headerlink" title="cs_reg_name"></a>cs_reg_name</h3><p><code>const char * CAPSTONE_API cs_reg_name(csh handle, unsigned int reg_id);</code></p><p>获取寄存器的名字(string类型)<br>寄存器id可在相关架构的头文件(建立项目时复制到项目文件夹的那些头文件)内找到</p><p>注意： 当处于diet模式时此API不可用，因为引擎不会存储寄存器名</p><p>参数<br>handle: cs_open()返回的句柄<br>reg_id: 寄存器id<br>return: 寄存器的字符名, 如果reg_id不可用返回NULL</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3c0dcfa15c265034.jpg" alt></p><p>示例(打印RAX)：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle = <span class="number">0</span>;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, cs_reg_name(handle, X86_REG_RAX));</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c100276bac46235.jpg" alt></p><h3 id="cs-insn-name"><a href="#cs-insn-name" class="headerlink" title="cs_insn_name"></a>cs_insn_name</h3><p><code>const char * CAPSTONE_API cs_insn_name(csh handle, unsigned int insn_id);</code></p><p>获取指令的名字(string类型)<br>指令id可在相关架构的头文件(建立项目时复制到项目文件夹的那些头文件)内找到</p><p>注意： 当处于diet模式时此API不可用，因为引擎不会存储寄存器名</p><p>参数<br>handle: cs_open()返回的句柄<br>insn_id: 指令id<br>return: 指令的字符名, 如果insn_id不可用返回NULL</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3c18c11f4cc51220.jpg" alt></p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line"></span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s"</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"            instruction:  %s"</span>, cs_insn_name(handle, insn-&gt;id));   <span class="comment">//输出该行的操作指令</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c250a6507076991.jpg" alt></p><h3 id="cs-group-name"><a href="#cs-group-name" class="headerlink" title="cs_group_name"></a>cs_group_name</h3><p><code>const char * CAPSTONE_API cs_group_name(csh handle, unsigned int group_id);</code></p><p>输出指令类型名字<br>指令id可在相关架构的头文件(建立项目时复制到项目文件夹的那些头文件)内找到</p><p>注意： 当处于diet模式时此API不可用，因为引擎不会存储寄存器名</p><p>参数<br>handle: cs_open()返回的句柄<br>insn_id: 指令类型id<br>return: 指令类型的字符名, 如果insn_id不可用返回NULL</p><p>实现代码及示例都与上面类似，略。。</p><h3 id="cs-insn-group"><a href="#cs-insn-group" class="headerlink" title="cs_insn_group"></a>cs_insn_group</h3><p><code>bool CAPSTONE_API cs_insn_group(csh handle, const cs_insn *insn, unsigned int group_id);</code></p><p>检查反汇编后的指令是否属于某个特定指令类型。</p><p>注意：只有当detail选项为ON时这个API可用 (默认OFF).<br>在“diet”模式下，此API没有用，因为引擎不更新insn-&gt;groups数组。</p><p>handle: cs_open()返回的句柄<br>insn: 从cs_disasm()或cs_disasm_iter()接收的反汇编指令结构<br>group_id: 要检查此指令是否属于的指令类型。<br>return: 如果该指令确实属于给定的指令类型，则为true，否则为false。</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3c28779993339180.png" alt></p><p>示例(判断是否属于跳转指令)：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line"></span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s          "</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"is JUMP:   "</span> &lt;&lt;cs_insn_group(handle, insn, CS_GRP_JUMP) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//判断是否为跳转指令</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c2cad6a6ee36943.jpg" alt></p><h3 id="cs-reg-read"><a href="#cs-reg-read" class="headerlink" title="cs_reg_read"></a>cs_reg_read</h3><p><code>bool CAPSTONE_API cs_reg_read(csh handle, const cs_insn *insn, unsigned int reg_id);</code></p><p>检查反汇编指令是否隐式使用特定寄存器。</p><p>注意:此API仅在启用detail选项时有效(默认为关闭)<br>在“diet”模式下，此API没有用，因为引擎不更新insn-&gt;regs_read数组。</p><p>insn: 从cs_disasm()或cs_disasm_iter()接收的反汇编指令结构<br>reg_id: 标注想要检查的这个指令是否使用了它。<br>return: 如果该指令确实隐式使用了给定寄存器，则为true，否则为false。</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3c2ec62282774188.jpg" alt></p><p>示例同API cs_disasm_iter</p><h3 id="cs-reg-write"><a href="#cs-reg-write" class="headerlink" title="cs_reg_write"></a>cs_reg_write</h3><p><code>bool CAPSTONE_API cs_reg_write(csh handle, const cs_insn *insn, unsigned int reg_id);</code></p><p>检查反汇编指令是否隐式修改了特定寄存器。</p><p>注意:此API仅在启用detail选项时有效(默认为关闭)<br>在“diet”模式下，此API没有用，因为引擎不更新insn-&gt;regs_read数组。</p><p>insn: 从cs_disasm()或cs_disasm_iter()接收的反汇编指令结构<br>reg_id: 标注想要检查的这个指令是否修改了它。<br>return: 如果该指令确实隐式修改了给定寄存器，则为true，否则为false。</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3c2f67ee69f50813.jpg" alt></p><p>示例同API cs_disasm_iter</p><h3 id="cs-op-count"><a href="#cs-op-count" class="headerlink" title="cs_op_count"></a>cs_op_count</h3><p><code>int CAPSTONE_API cs_op_count(csh handle, const cs_insn *insn, unsigned int op_type);</code></p><p>计算给定类型的操作数的数量。<br>注意：只有当detail选项为ON时这个API可用 (默认OFF).</p><p>handle: cs_open()返回的句柄<br>insn: 从cs_disasm()或cs_disasm_iter()接收的反汇编指令结构<br>op_type: 要找到的操作数类型。<br>return: 指令insn中给定类型op_type的操作数的数量，返回-1表示查找失败。</p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> CAPSTONE_API <span class="title">cs_op_count</span><span class="params">(csh ud, <span class="keyword">const</span> cs_insn *insn, <span class="keyword">unsigned</span> <span class="keyword">int</span> op_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>, i;</span><br><span class="line"><span class="keyword">if</span> (!ud)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!handle-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;id) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_SKIPDATA;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (handle-&gt;arch) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">handle-&gt;errnum = CS_ERR_HANDLE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_ARM:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;arm.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;arm.operands[i].type == (arm_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_ARM64:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;arm64.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;arm64.operands[i].type == (arm64_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_X86:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;x86.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;x86.operands[i].type == (x86_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_MIPS:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;mips.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;mips.operands[i].type == (mips_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_PPC:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;ppc.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;ppc.operands[i].type == (ppc_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_SPARC:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;sparc.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;sparc.operands[i].type == (sparc_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_SYSZ:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;sysz.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;sysz.operands[i].type == (sysz_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_XCORE:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;xcore.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;xcore.operands[i].type == (xcore_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_M68K:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;m68k.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;m68k.operands[i].type == (m68k_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_TMS320C64X:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;tms320c64x.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;tms320c64x.operands[i].type == (tms320c64x_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_M680X:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;m680x.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;m680x.operands[i].type == (m680x_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_EVM:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;evm.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;evm.operands[i].type == (evm_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿x86指令操作码类型举例<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> x86_op_type &#123;</span><br><span class="line">X86_OP_INVALID = <span class="number">0</span>, <span class="comment">///&lt; = CS_OP_INVALID (未初始化).</span></span><br><span class="line">X86_OP_REG, <span class="comment">///&lt; = CS_OP_REG (寄存操作码).</span></span><br><span class="line">X86_OP_IMM, <span class="comment">///&lt; = CS_OP_IMM (立即操作码).</span></span><br><span class="line">X86_OP_MEM, <span class="comment">///&lt; = CS_OP_MEM (内存操作码).</span></span><br><span class="line">&#125; x86_op_type;</span><br></pre></td></tr></table></figure></p><p>示例(判断寄存操作码)：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line"></span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s          "</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"is REG:   "</span> &lt;&lt; cs_op_count(handle, insn, X86_OP_REG) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//判断是否为寄存操作码</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c32814f9e736661.jpg" alt></p><h3 id="cs-op-index"><a href="#cs-op-index" class="headerlink" title="cs_op_index"></a>cs_op_index</h3><p><code>int CAPSTONE_API cs_op_index(csh handle, const cs_insn *insn, unsigned int op_type, unsigned int position);</code></p><p>检索给定类型的操作数在<code>&lt;arch&gt;.operands[]</code>数组中的位置, 使用返回的位置访问操作数。<br>注意：只有当detail选项为ON时这个API可用 (默认OFF).</p><p>handle: cs_open()返回的句柄<br>insn: 从cs_disasm()或cs_disasm_iter()接收的反汇编指令结构<br>op_type: 要找到的操作数类型。<br>position: 要查找的操作数的位置。范围一定在<code>[1, cs_op_count(handle, insn, op_type)]</code>内<br>return: 指令insn的<code>&lt;arch&gt;.operands[]</code>数组中给定类型op_type的操作数的索引，失败时返回-1。</p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> CAPSTONE_API <span class="title">cs_op_index</span><span class="params">(csh ud, <span class="keyword">const</span> cs_insn *insn, <span class="keyword">unsigned</span> <span class="keyword">int</span> op_type,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> post)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>, i;</span><br><span class="line"><span class="keyword">if</span> (!ud)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!handle-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;id) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_SKIPDATA;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (handle-&gt;arch) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">handle-&gt;errnum = CS_ERR_HANDLE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_ARM:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;arm.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;arm.operands[i].type == (arm_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_ARM64:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;arm64.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;arm64.operands[i].type == (arm64_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_X86:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;x86.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;x86.operands[i].type == (x86_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_MIPS:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;mips.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;mips.operands[i].type == (mips_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_PPC:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;ppc.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;ppc.operands[i].type == (ppc_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_SPARC:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;sparc.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;sparc.operands[i].type == (sparc_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_SYSZ:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;sysz.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;sysz.operands[i].type == (sysz_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_XCORE:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;xcore.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;xcore.operands[i].type == (xcore_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_M68K:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;m68k.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;m68k.operands[i].type == (m68k_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_TMS320C64X:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;tms320c64x.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;tms320c64x.operands[i].type == (tms320c64x_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_M680X:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;m680x.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;m680x.operands[i].type == (m680x_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">cs_x86* x86;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line">x86 = &amp;(insn-&gt;detail-&gt;x86);</span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s          "</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">count = cs_op_count(handle, insn, X86_OP_IMM);  <span class="comment">//查找立即数</span></span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\timm_count: %u\n"</span>, count);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; count + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> index = cs_op_index(handle, insn, X86_OP_IMM, i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\timms[%u]: 0x%"</span> PRIx64 <span class="string">"\n"</span>, i, x86-&gt;operands[index].imm);</span><br><span class="line"><span class="keyword">if</span> (x86-&gt;encoding.imm_offset != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\timm_offset: 0x%x\n"</span>, x86-&gt;encoding.imm_offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x86-&gt;encoding.imm_size != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\timm_size: 0x%x\n"</span>, x86-&gt;encoding.imm_size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c45bfef22464773.jpg" alt></p><h3 id="cs-regs-access"><a href="#cs-regs-access" class="headerlink" title="cs_regs_access"></a>cs_regs_access</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_regs_access</span><span class="params">(csh handle, <span class="keyword">const</span> cs_insn *insn,</span></span></span><br><span class="line"><span class="function"><span class="params">cs_regs regs_read, <span class="keyword">uint8_t</span> *regs_read_count,</span></span></span><br><span class="line"><span class="function"><span class="params">cs_regs regs_write, <span class="keyword">uint8_t</span> *regs_write_count)</span></span>;</span><br></pre></td></tr></table></figure><p>检索由一条指令显式或隐式访问的所有寄存器。</p><p>注意： 在“diet”模式下，此API不可用，因为引擎不存储寄存器。</p><p>handle: cs_open()返回的句柄<br>insn: 从cs_disasm()或cs_disasm_iter()返回的反汇编指令结构<br>regs_read:返回时，这个数组包含所有按指令读取的寄存器。<br>regs_read_count:保存在regs_read数组中的寄存器数。<br>regs_write:返回时，这个数组包含所有由指令修改的寄存器。<br>regs_write_count:保存在regs_write数组中的寄存器数。<br>成功时返回CS_ERR_OK，失败时返回其他值(详细错误请参阅cs_err enum)。</p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_regs_access</span><span class="params">(csh ud, <span class="keyword">const</span> cs_insn *insn,</span></span></span><br><span class="line"><span class="function"><span class="params">cs_regs regs_read, <span class="keyword">uint8_t</span> *regs_read_count,</span></span></span><br><span class="line"><span class="function"><span class="params">cs_regs regs_write, <span class="keyword">uint8_t</span> *regs_write_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ud)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line"><span class="comment">// This API does not work in DIET mode</span></span><br><span class="line">handle-&gt;errnum = CS_ERR_DIET;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_DIET;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">if</span> (!handle-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_DETAIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;id) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_SKIPDATA;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_SKIPDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_DETAIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;reg_access) &#123;</span><br><span class="line">handle-&gt;reg_access(insn, regs_read, regs_read_count, regs_write, regs_write_count);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// this arch is unsupported yet</span></span><br><span class="line">handle-&gt;errnum = CS_ERR_ARCH;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_ARCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">cs_x86* x86;</span><br><span class="line">cs_regs regs_read, regs_write;</span><br><span class="line"><span class="keyword">uint8_t</span> regs_read_count, regs_write_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line">x86 = &amp;(insn-&gt;detail-&gt;x86);</span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s          "</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!cs_regs_access(handle, insn,       <span class="comment">//每条指令所有读取和修改的寄存器</span></span><br><span class="line">regs_read, &amp;regs_read_count,</span><br><span class="line">regs_write, &amp;regs_write_count)) &#123;</span><br><span class="line"><span class="keyword">if</span> (regs_read_count) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tRegisters read:"</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; regs_read_count; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %s"</span>, cs_reg_name(handle, regs_read[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (regs_write_count) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tRegisters modified:"</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; regs_write_count; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %s"</span>, cs_reg_name(handle, regs_write[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c48d04fea172636.jpg" alt></p><p>From <a href="https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(四">https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(四)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Capstone反汇编引擎数据类型及API分析及示例-四&quot;&gt;&lt;a href=&quot;#Capstone反汇编引擎数据类型及API分析及示例-四&quot; class=&quot;headerlink&quot; title=&quot;Capstone反汇编引擎数据类型及API分析及示例(四)&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="反汇编" scheme="https://kabeor.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>SICNU-CTF逆向 Sign</title>
    <link href="https://kabeor.github.io/SICNU-CTF%E9%80%86%E5%90%91%20Sign/"/>
    <id>https://kabeor.github.io/SICNU-CTF逆向 Sign/</id>
    <published>2019-07-26T04:27:46.431Z</published>
    <updated>2019-07-26T04:35:11.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SICNU2018-CTF逆向-Sign"><a href="#SICNU2018-CTF逆向-Sign" class="headerlink" title="SICNU2018-CTF逆向 Sign"></a>SICNU2018-CTF逆向 Sign</h1><p>2018年五月川师的比赛题，一直放着没有看，今天清理文件拿出来看一下</p><p>x86,入口jmp一看就是VS编译，无壳无花</p><p>之前一直好奇大佬们是怎样做到秒题的，做完这道才题知道，只有敏锐的洞察力快速定位核心代码才是王道</p><p>main函数<br><img src="https://i.loli.net/2019/07/26/5d3a7c867363016763.jpg" alt></p><p>很显然有两个判断点<br>第一个直接看赋值v5的函数sub_401186，这道题有意思的点在于每个函数都会有一个二次跳转，因此如果不能及时定位到关键点，在限定的时间内很难分析出来<br><img src="https://i.loli.net/2019/07/26/5d3a7d54bc1be16220.jpg" alt><br>非常无用的跳转，一直想拿IDC脚本剔除，但可惜没什么思路<br>进入之后<br><img src="https://i.loli.net/2019/07/26/5d3a7d9d8e6f428329.jpg" alt></p><p>v8限定字符串长度，开头必须是 ‘SICNU{’  ,算上最后一个一定是‘}’，因此我们还要输入16个字符。<br>动态调试发现下面的判断也只判断了输入前6个字符，然后截断，并没有做其他操作</p><p>回到主函数看到第二个判定在v3，直接进入<br><img src="https://i.loli.net/2019/07/26/5d3a7ecb6d76846189.jpg" alt><br><img src="https://i.loli.net/2019/07/26/5d3a7ee02379c25978.jpg" alt></p><p>如图，动态调试发现，v1是对{后的输入每次取一字符，然后和key1密钥表异或，共操作六次<br>v2是剩余字符长度，其中除去反括号还有10个字符，这里sub_401230的功能F5识别出错，直接看汇编<br><img src="https://i.loli.net/2019/07/26/5d3a7ffddfe4436075.jpg" alt><br>rep stosd循环，ecx,11h为循环次数，eax初始0CCCCCCCCh，最后v2为固定值11</p><p>接下来判断是否是数字，是则+17，不是则与key2密钥表异或</p><p>接下来验证答案，要求C1等于key3-v20，C2等于key4-v13，所以写脚本直接反求即可</p><p>python脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a0 = [<span class="number">0xE5</span>, <span class="number">0xA6</span>, <span class="number">0xE4</span>, <span class="number">0xE2</span>, <span class="number">0xD4</span>, <span class="number">0x95</span>, <span class="number">0xEC</span>]</span><br><span class="line">a1 = [ <span class="number">0xFC</span>, <span class="number">0x11</span>, <span class="number">0x41</span>, <span class="number">0xC7</span>, <span class="number">0x66</span>, <span class="number">0x42</span>, <span class="number">0x5D</span>, <span class="number">0x68</span>, <span class="number">0x28</span>, <span class="number">0x3B</span>]</span><br><span class="line">key1 = [<span class="number">0xB2</span>, <span class="number">0xC3</span>, <span class="number">0xD5</span>, <span class="number">0xA1</span>, <span class="number">0xE4</span>, <span class="number">0xF8</span>, <span class="number">0xA9</span>]</span><br><span class="line">key2 = [<span class="number">0xA3</span>, <span class="number">0x45</span>, <span class="number">0xEA</span>, <span class="number">0x35</span>, <span class="number">0x3E</span>, <span class="number">0x26</span>, <span class="number">0x5D</span>, <span class="number">0x46</span>]</span><br><span class="line"></span><br><span class="line">C1 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">C1[i]=chr(key1[i]^a0[i])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"flag:    SICNU&#123;"</span>, end = <span class="string">''</span>)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">print(C1[a], end = <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line">C2 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">C2[i] = a1[j] - <span class="number">17</span></span><br><span class="line"><span class="keyword">if</span>(C2[i]&gt;=<span class="number">48</span> <span class="keyword">and</span> C2[i]&lt;=<span class="number">57</span>):</span><br><span class="line">C2[i] = chr(C2[i])</span><br><span class="line">i=i+<span class="number">1</span></span><br><span class="line">j=j+<span class="number">1</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">C2[i] = chr(key2[k] ^ a1[j])</span><br><span class="line">i=i+<span class="number">1</span></span><br><span class="line">j=j+<span class="number">1</span></span><br><span class="line">k=k+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">print(C2[a], end = <span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>flag<br><img src="https://i.loli.net/2019/07/26/5d3a8138d970b13890.jpg" alt></p><p>From <a href="https://kabeor.github.io/SICNU-CTF逆向 Sign/">https://kabeor.github.io/SICNU-CTF逆向 Sign/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SICNU2018-CTF逆向-Sign&quot;&gt;&lt;a href=&quot;#SICNU2018-CTF逆向-Sign&quot; class=&quot;headerlink&quot; title=&quot;SICNU2018-CTF逆向 Sign&quot;&gt;&lt;/a&gt;SICNU2018-CTF逆向 Sign&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向， CTF" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C-CTF/"/>
    
  </entry>
  
  <entry>
    <title>逆向分析加解密之TwoFish算法</title>
    <link href="https://kabeor.github.io/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%B9%8BTwoFish%E7%AE%97%E6%B3%95/"/>
    <id>https://kabeor.github.io/逆向分析加解密之TwoFish算法/</id>
    <published>2019-07-25T04:02:55.808Z</published>
    <updated>2019-08-02T07:09:58.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向分析加解密之TwoFish算法"><a href="#逆向分析加解密之TwoFish算法" class="headerlink" title="逆向分析加解密之TwoFish算法"></a>逆向分析加解密之TwoFish算法</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5807" target="_blank" rel="noopener">https://xz.aliyun.com/t/5807</a></p></blockquote><p>前几天某师傅给我发来一个逆向题，拿来分析发现竟是AES决赛算法之一的TwoFish算法，之前网上对此算法的逆向分析竟然一个都没有，对算法的介绍也只有寥寥数语，于是想准备在这里与大家分享对该算法的逆向分析以及CTF中此算法的变体。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>官方有一个68页的pdf，有兴趣可以看一下<br><a href="http://www.schneier.com/twofish-analysis-shiho.pdf" target="_blank" rel="noopener">http://www.schneier.com/twofish-analysis-shiho.pdf</a></p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://i.loli.net/2019/07/25/5d391b311e84491804.jpg" alt></p><p>TwoFish的意思应该就是这样交叉运算的形状吧</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>TwoFish加密需要明文(plain)和密钥(key)<br>总的来说进行一次加解密可分为三个环节</p><ol><li>Input whitening</li><li>16次循环</li><li>Output whitening</li></ol><h4 id="Input-whitening"><a href="#Input-whitening" class="headerlink" title="Input whitening"></a>Input whitening</h4><blockquote><ol><li>拓展密钥</li></ol></blockquote><p>在Twofish 算法中，规定密钥的长度 N = 128, N = 192, N = 256三种。也就是说密钥的长度可以在128-bit ~ 256-bit之间变化。</p><p>我们需要产生40个与密钥相关的K(i)，这里的K(i)是根据密钥算出来的32-bit数据<br>除此以外，我们还需要4个与密钥相关的S-box，也就是s(i)()。</p><p>为计算K和S，定义MDS矩阵</p><p><img src="https://i.loli.net/2019/07/25/5d392304b308519968.jpg" alt> </p><p>且对于MDS 矩阵，有限域GF的定义如下：<br><code>GF(2^8) ≡ GF(2)(x)/v(x)，其中v(x) = x^8 + x^6 + x^5 + x^3 + 1</code>   </p><p>此外还需要h函数</p><pre><code> y(k,j) = x(j)                     j = 0, ... ,3如果：k == 4    y(3,0) = q1[y(4,0)] xor l(3,0)    y(3,1) = q0[y(4,1)] xor l(3,1)    y(3,2) = q0[y(4,2)] xor l(3,2)    y(3,3) = q1[y(4,3)] xor l(3,3)如果：k &gt;= 3    y(2,0) = q1[y(3,0)] xor l(2,0)    y(2,1) = q1[y(3,1)] xor l(2,1)    y(2,2) = q0[y(3,2)] xor l(2,2)    y(2,3) = q0[y(3,3)] xor l(3,3)对于所有情况：    y0 = q1[q0[q0[y(2,0)] xor l(1,0)] xor l(0,0)]    y1 = q0[q0[q1[y(2,1)] xor l(1,1)] xor l(0,1)]    y2 = q1[q1[q0[y(2,2)] xor l(1,2)] xor l(0,2)]    y3 = q0[q1[q1[y(2,3)] xor l(1,3)] xor l(0,3)]</code></pre><p>实现代码稍后来说</p><blockquote><ol><li>输入白化</li></ol></blockquote><p>因为加密前的plain text是128 bits，也就是16 bytes。假设这16 bytes分别是p0, … ,p15。将p0, … ,p15分为4组：<br><code>P(i) = ∑p(4i+j)2^(8j)，其中i,j = 0, ... ,3</code></p><p>然后进行运算<code>R(0,i) = P(i) xor K(i)，其中i = 0, ... ,3</code></p><h4 id="16次运算"><a href="#16次运算" class="headerlink" title="16次运算"></a>16次运算</h4><p>将以下公式循环16次</p><pre><code>(F(r,0), F(r,1)) = F(R(r,0), R(r,1), r) R(r+1,0) = ROR(R(r,2) xor F(r,0), 1) R(r+1,1) = ROL(R(r,3), 1) xor F(r,1) R(r+1,2) = R(r,0) R(r+1,3) = R(r,1)</code></pre><p>其中，F函数为以下操作</p><pre><code>t0 = g(r0)t1 = rol(r1, 8)t1 = g(t1)o = 2*rF0 = (T0 +  T1 + K(2r+8)) mod 2^32F1 = (T0 + 2T1 + K(2r+9)) mod 2^32</code></pre><p>其中g函数为核心函数</p><pre><code>x(i) = [X/2^(8i)] mod 2^8  其中i = 0, ... ,3y(i) = s(i)(x(i))       其中i = 0, ... ,3</code></pre><p><img src="https://i.loli.net/2019/07/25/5d392756d7d6492028.jpg" alt> </p><pre><code>Z = ∑z(i)2^(8i)，其中i = 0, ... ,3</code></pre><h4 id="输出白化"><a href="#输出白化" class="headerlink" title="输出白化"></a>输出白化</h4><pre><code>C(i) = R(16,(i+2) mod 4) xor K(i+4)，其中i = 0, ... ,3</code></pre><p>最后计算组成密文</p><pre><code>c(i) = [C(i/4) / 2^(8(i mod 4))] mod 2^8，其中i = 0, ... ,15</code></pre><p>下面来逆向分析看一下实际实现吧</p><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>拿到题后PEID分析<br><img src="https://i.loli.net/2019/07/25/5d392ac4cd3a266075.jpg" alt><br>分析到了TwoFish算法</p><p>IDA分析一下，进入主函数看到流程<br><img src="https://i.loli.net/2019/07/25/5d392b24602bc32573.jpg" alt><br><img src="https://i.loli.net/2019/07/25/5d392b4b3d71797118.jpg" alt></p><p>发现有五个选项，选项名字在sub_402FDA中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_402FDA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"welcome to jiami jiemi game go.go.go."</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"1._jiemi_(admin only)"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"2._jiami_"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"3._jiemi__flag(admin only)"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"4.exit"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"5._yanzheng__"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有选项2和5可用，即加密和验证flag</p><p>进入验证函数sub_40302B查看<br><img src="https://i.loli.net/2019/07/25/5d392c3cbd53454896.jpg" alt></p><p>这里我已经注释出密文和key，因此我们只需要解密即可，但只用标准解密算法就可以吗？我们来验证一下</p><p>很明显加密函数为sub_402E5D(&amp;key, plain, &amp;v3);  参数v3传出密钥<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_BYTE *__<span class="function">cdecl <span class="title">sub_402E5D</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v3; <span class="comment">// ST1C_4</span></span><br><span class="line"></span><br><span class="line">  v3 = sub_401570(a1, <span class="number">128u</span>);                    <span class="comment">// a1 = key   密钥生成k和s</span></span><br><span class="line">  sub_401626(v3, a2, a3);                          <span class="comment">//输入白化，循环，输出白化</span></span><br><span class="line">  <span class="keyword">return</span> sub_401626(v3, (a2 + <span class="number">16</span>), a3 + <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面来结合标准实现分析<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_401570</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v2; <span class="comment">// ST1C_4</span></span><br><span class="line">  _BYTE *v3; <span class="comment">// ST18_4</span></span><br><span class="line">  <span class="keyword">void</span> *v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// ST14_4</span></span><br><span class="line"></span><br><span class="line">  v2 = sub_402D53(a1, a2 &gt;&gt; <span class="number">3</span>);                 <span class="comment">// key_t* tf_key = expand_key(s, len/8);  拓展密钥</span></span><br><span class="line">  v3 = sub_4025C6(v2);                          <span class="comment">// subkey_t *tf_subkey = Twofish_generate_subkey(tf_key);  生成密钥</span></span><br><span class="line">  v4 = <span class="built_in">malloc</span>(<span class="number">4260u</span>);</span><br><span class="line">  v5 = sub_401B7A(v4, v3, <span class="number">0x1010101</span>, *v2 &gt;&gt; <span class="number">3</span>); <span class="comment">// tf_twofish = Twofish_generate_ext_k_keys(tf_twofish,tf_subkey,0x01010101,(tf_key-&gt;len/8));  生成k</span></span><br><span class="line">  v6 = sub_401CF8(v5, v3, *v2 &gt;&gt; <span class="number">3</span>);            <span class="comment">// tf_twofish = Twofish_generate_ext_s_keys(tf_twofish,tf_subkey,(tf_key-&gt;len/8));  生成s</span></span><br><span class="line">  <span class="built_in">free</span>(v2[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">free</span>(v2);</span><br><span class="line">  <span class="built_in">free</span>(v3);</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>拓展密钥</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d3930a1cc7b017798.jpg" alt><br>可以看到题中对位数分析的判定进行了修改</p><blockquote><p>生成密钥</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d39312bb0d7d18656.jpg" alt><br>c实现<img src="https://i.loli.net/2019/07/25/5d3931a257bc836488.jpg" alt></p><p>rsm函数定义为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rsm(i,a,b,c,d,e,f,g,h)  \</span></span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>),a,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">1</span>),b,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">2</span>),c,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">3</span>),d,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">4</span>),e,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">5</span>),f,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">6</span>),g,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">7</span>),h,<span class="number">0x14d</span>)</span><br></pre></td></tr></table></figure><blockquote><p>k生成</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d3931f15177364722.jpg" alt><br>h函数内部，可以看出，IDA将二维数组直接一维化<br><img src="https://i.loli.net/2019/07/25/5d39322bb987d21871.jpg" alt></p><p>q0,q1都是256大小的数组<br><img src="https://i.loli.net/2019/07/25/5d3932450ddac91007.jpg" alt><br>标准<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> q[<span class="number">2</span>][<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* q0 */</span></span><br><span class="line">    &#123;<span class="number">0xa9</span>,<span class="number">0x67</span>,<span class="number">0xb3</span>,<span class="number">0xe8</span>,<span class="number">0x4</span>,<span class="number">0xfd</span>,<span class="number">0xa3</span>,<span class="number">0x76</span>,<span class="number">0x9a</span>,<span class="number">0x92</span>,<span class="number">0x80</span>,<span class="number">0x78</span>,<span class="number">0xe4</span>,<span class="number">0xdd</span>,<span class="number">0xd1</span>,<span class="number">0x38</span>,</span><br><span class="line"><span class="number">0xd</span>,<span class="number">0xc6</span>,<span class="number">0x35</span>,<span class="number">0x98</span>,<span class="number">0x18</span>,<span class="number">0xf7</span>,<span class="number">0xec</span>,<span class="number">0x6c</span>,<span class="number">0x43</span>,<span class="number">0x75</span>,<span class="number">0x37</span>,<span class="number">0x26</span>,<span class="number">0xfa</span>,<span class="number">0x13</span>,<span class="number">0x94</span>,<span class="number">0x48</span>,</span><br><span class="line"><span class="number">0xf2</span>,<span class="number">0xd0</span>,<span class="number">0x8b</span>,<span class="number">0x30</span>,<span class="number">0x84</span>,<span class="number">0x54</span>,<span class="number">0xdf</span>,<span class="number">0x23</span>,<span class="number">0x19</span>,<span class="number">0x5b</span>,<span class="number">0x3d</span>,<span class="number">0x59</span>,<span class="number">0xf3</span>,<span class="number">0xae</span>,<span class="number">0xa2</span>,<span class="number">0x82</span>,</span><br><span class="line"><span class="number">0x63</span>,<span class="number">0x1</span>,<span class="number">0x83</span>,<span class="number">0x2e</span>,<span class="number">0xd9</span>,<span class="number">0x51</span>,<span class="number">0x9b</span>,<span class="number">0x7c</span>,<span class="number">0xa6</span>,<span class="number">0xeb</span>,<span class="number">0xa5</span>,<span class="number">0xbe</span>,<span class="number">0x16</span>,<span class="number">0xc</span>,<span class="number">0xe3</span>,<span class="number">0x61</span>,</span><br><span class="line"><span class="number">0xc0</span>,<span class="number">0x8c</span>,<span class="number">0x3a</span>,<span class="number">0xf5</span>,<span class="number">0x73</span>,<span class="number">0x2c</span>,<span class="number">0x25</span>,<span class="number">0xb</span>,<span class="number">0xbb</span>,<span class="number">0x4e</span>,<span class="number">0x89</span>,<span class="number">0x6b</span>,<span class="number">0x53</span>,<span class="number">0x6a</span>,<span class="number">0xb4</span>,<span class="number">0xf1</span>,</span><br><span class="line"><span class="number">0xe1</span>,<span class="number">0xe6</span>,<span class="number">0xbd</span>,<span class="number">0x45</span>,<span class="number">0xe2</span>,<span class="number">0xf4</span>,<span class="number">0xb6</span>,<span class="number">0x66</span>,<span class="number">0xcc</span>,<span class="number">0x95</span>,<span class="number">0x3</span>,<span class="number">0x56</span>,<span class="number">0xd4</span>,<span class="number">0x1c</span>,<span class="number">0x1e</span>,<span class="number">0xd7</span>,</span><br><span class="line"><span class="number">0xfb</span>,<span class="number">0xc3</span>,<span class="number">0x8e</span>,<span class="number">0xb5</span>,<span class="number">0xe9</span>,<span class="number">0xcf</span>,<span class="number">0xbf</span>,<span class="number">0xba</span>,<span class="number">0xea</span>,<span class="number">0x77</span>,<span class="number">0x39</span>,<span class="number">0xaf</span>,<span class="number">0x33</span>,<span class="number">0xc9</span>,<span class="number">0x62</span>,<span class="number">0x71</span>,</span><br><span class="line"><span class="number">0x81</span>,<span class="number">0x79</span>,<span class="number">0x9</span>,<span class="number">0xad</span>,<span class="number">0x24</span>,<span class="number">0xcd</span>,<span class="number">0xf9</span>,<span class="number">0xd8</span>,<span class="number">0xe5</span>,<span class="number">0xc5</span>,<span class="number">0xb9</span>,<span class="number">0x4d</span>,<span class="number">0x44</span>,<span class="number">0x8</span>,<span class="number">0x86</span>,<span class="number">0xe7</span>,</span><br><span class="line"><span class="number">0xa1</span>,<span class="number">0x1d</span>,<span class="number">0xaa</span>,<span class="number">0xed</span>,<span class="number">0x6</span>,<span class="number">0x70</span>,<span class="number">0xb2</span>,<span class="number">0xd2</span>,<span class="number">0x41</span>,<span class="number">0x7b</span>,<span class="number">0xa0</span>,<span class="number">0x11</span>,<span class="number">0x31</span>,<span class="number">0xc2</span>,<span class="number">0x27</span>,<span class="number">0x90</span>,</span><br><span class="line"><span class="number">0x20</span>,<span class="number">0xf6</span>,<span class="number">0x60</span>,<span class="number">0xff</span>,<span class="number">0x96</span>,<span class="number">0x5c</span>,<span class="number">0xb1</span>,<span class="number">0xab</span>,<span class="number">0x9e</span>,<span class="number">0x9c</span>,<span class="number">0x52</span>,<span class="number">0x1b</span>,<span class="number">0x5f</span>,<span class="number">0x93</span>,<span class="number">0xa</span>,<span class="number">0xef</span>,</span><br><span class="line"><span class="number">0x91</span>,<span class="number">0x85</span>,<span class="number">0x49</span>,<span class="number">0xee</span>,<span class="number">0x2d</span>,<span class="number">0x4f</span>,<span class="number">0x8f</span>,<span class="number">0x3b</span>,<span class="number">0x47</span>,<span class="number">0x87</span>,<span class="number">0x6d</span>,<span class="number">0x46</span>,<span class="number">0xd6</span>,<span class="number">0x3e</span>,<span class="number">0x69</span>,<span class="number">0x64</span>,</span><br><span class="line"><span class="number">0x2a</span>,<span class="number">0xce</span>,<span class="number">0xcb</span>,<span class="number">0x2f</span>,<span class="number">0xfc</span>,<span class="number">0x97</span>,<span class="number">0x5</span>,<span class="number">0x7a</span>,<span class="number">0xac</span>,<span class="number">0x7f</span>,<span class="number">0xd5</span>,<span class="number">0x1a</span>,<span class="number">0x4b</span>,<span class="number">0xe</span>,<span class="number">0xa7</span>,<span class="number">0x5a</span>,</span><br><span class="line"><span class="number">0x28</span>,<span class="number">0x14</span>,<span class="number">0x3f</span>,<span class="number">0x29</span>,<span class="number">0x88</span>,<span class="number">0x3c</span>,<span class="number">0x4c</span>,<span class="number">0x2</span>,<span class="number">0xb8</span>,<span class="number">0xda</span>,<span class="number">0xb0</span>,<span class="number">0x17</span>,<span class="number">0x55</span>,<span class="number">0x1f</span>,<span class="number">0x8a</span>,<span class="number">0x7d</span>,</span><br><span class="line"><span class="number">0x57</span>,<span class="number">0xc7</span>,<span class="number">0x8d</span>,<span class="number">0x74</span>,<span class="number">0xb7</span>,<span class="number">0xc4</span>,<span class="number">0x9f</span>,<span class="number">0x72</span>,<span class="number">0x7e</span>,<span class="number">0x15</span>,<span class="number">0x22</span>,<span class="number">0x12</span>,<span class="number">0x58</span>,<span class="number">0x7</span>,<span class="number">0x99</span>,<span class="number">0x34</span>,</span><br><span class="line"><span class="number">0x6e</span>,<span class="number">0x50</span>,<span class="number">0xde</span>,<span class="number">0x68</span>,<span class="number">0x65</span>,<span class="number">0xbc</span>,<span class="number">0xdb</span>,<span class="number">0xf8</span>,<span class="number">0xc8</span>,<span class="number">0xa8</span>,<span class="number">0x2b</span>,<span class="number">0x40</span>,<span class="number">0xdc</span>,<span class="number">0xfe</span>,<span class="number">0x32</span>,<span class="number">0xa4</span>,</span><br><span class="line"><span class="number">0xca</span>,<span class="number">0x10</span>,<span class="number">0x21</span>,<span class="number">0xf0</span>,<span class="number">0xd3</span>,<span class="number">0x5d</span>,<span class="number">0xf</span>,<span class="number">0x0</span>,<span class="number">0x6f</span>,<span class="number">0x9d</span>,<span class="number">0x36</span>,<span class="number">0x42</span>,<span class="number">0x4a</span>,<span class="number">0x5e</span>,<span class="number">0xc1</span>,<span class="number">0xe0</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="comment">/* q1 */</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="number">0x75</span>,<span class="number">0xf3</span>,<span class="number">0xc6</span>,<span class="number">0xf4</span>,<span class="number">0xdb</span>,<span class="number">0x7b</span>,<span class="number">0xfb</span>,<span class="number">0xc8</span>,<span class="number">0x4a</span>,<span class="number">0xd3</span>,<span class="number">0xe6</span>,<span class="number">0x6b</span>,<span class="number">0x45</span>,<span class="number">0x7d</span>,<span class="number">0xe8</span>,<span class="number">0x4b</span>,</span><br><span class="line"><span class="number">0xd6</span>,<span class="number">0x32</span>,<span class="number">0xd8</span>,<span class="number">0xfd</span>,<span class="number">0x37</span>,<span class="number">0x71</span>,<span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x30</span>,<span class="number">0xf</span>,<span class="number">0xf8</span>,<span class="number">0x1b</span>,<span class="number">0x87</span>,<span class="number">0xfa</span>,<span class="number">0x6</span>,<span class="number">0x3f</span>,</span><br><span class="line"><span class="number">0x5e</span>,<span class="number">0xba</span>,<span class="number">0xae</span>,<span class="number">0x5b</span>,<span class="number">0x8a</span>,<span class="number">0x0</span>,<span class="number">0xbc</span>,<span class="number">0x9d</span>,<span class="number">0x6d</span>,<span class="number">0xc1</span>,<span class="number">0xb1</span>,<span class="number">0xe</span>,<span class="number">0x80</span>,<span class="number">0x5d</span>,<span class="number">0xd2</span>,<span class="number">0xd5</span>,</span><br><span class="line"><span class="number">0xa0</span>,<span class="number">0x84</span>,<span class="number">0x7</span>,<span class="number">0x14</span>,<span class="number">0xb5</span>,<span class="number">0x90</span>,<span class="number">0x2c</span>,<span class="number">0xa3</span>,<span class="number">0xb2</span>,<span class="number">0x73</span>,<span class="number">0x4c</span>,<span class="number">0x54</span>,<span class="number">0x92</span>,<span class="number">0x74</span>,<span class="number">0x36</span>,<span class="number">0x51</span>,</span><br><span class="line"><span class="number">0x38</span>,<span class="number">0xb0</span>,<span class="number">0xbd</span>,<span class="number">0x5a</span>,<span class="number">0xfc</span>,<span class="number">0x60</span>,<span class="number">0x62</span>,<span class="number">0x96</span>,<span class="number">0x6c</span>,<span class="number">0x42</span>,<span class="number">0xf7</span>,<span class="number">0x10</span>,<span class="number">0x7c</span>,<span class="number">0x28</span>,<span class="number">0x27</span>,<span class="number">0x8c</span>,</span><br><span class="line"><span class="number">0x13</span>,<span class="number">0x95</span>,<span class="number">0x9c</span>,<span class="number">0xc7</span>,<span class="number">0x24</span>,<span class="number">0x46</span>,<span class="number">0x3b</span>,<span class="number">0x70</span>,<span class="number">0xca</span>,<span class="number">0xe3</span>,<span class="number">0x85</span>,<span class="number">0xcb</span>,<span class="number">0x11</span>,<span class="number">0xd0</span>,<span class="number">0x93</span>,<span class="number">0xb8</span>,</span><br><span class="line"><span class="number">0xa6</span>,<span class="number">0x83</span>,<span class="number">0x20</span>,<span class="number">0xff</span>,<span class="number">0x9f</span>,<span class="number">0x77</span>,<span class="number">0xc3</span>,<span class="number">0xcc</span>,<span class="number">0x3</span>,<span class="number">0x6f</span>,<span class="number">0x8</span>,<span class="number">0xbf</span>,<span class="number">0x40</span>,<span class="number">0xe7</span>,<span class="number">0x2b</span>,<span class="number">0xe2</span>,</span><br><span class="line"><span class="number">0x79</span>,<span class="number">0xc</span>,<span class="number">0xaa</span>,<span class="number">0x82</span>,<span class="number">0x41</span>,<span class="number">0x3a</span>,<span class="number">0xea</span>,<span class="number">0xb9</span>,<span class="number">0xe4</span>,<span class="number">0x9a</span>,<span class="number">0xa4</span>,<span class="number">0x97</span>,<span class="number">0x7e</span>,<span class="number">0xda</span>,<span class="number">0x7a</span>,<span class="number">0x17</span>,</span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x94</span>,<span class="number">0xa1</span>,<span class="number">0x1d</span>,<span class="number">0x3d</span>,<span class="number">0xf0</span>,<span class="number">0xde</span>,<span class="number">0xb3</span>,<span class="number">0xb</span>,<span class="number">0x72</span>,<span class="number">0xa7</span>,<span class="number">0x1c</span>,<span class="number">0xef</span>,<span class="number">0xd1</span>,<span class="number">0x53</span>,<span class="number">0x3e</span>,</span><br><span class="line"><span class="number">0x8f</span>,<span class="number">0x33</span>,<span class="number">0x26</span>,<span class="number">0x5f</span>,<span class="number">0xec</span>,<span class="number">0x76</span>,<span class="number">0x2a</span>,<span class="number">0x49</span>,<span class="number">0x81</span>,<span class="number">0x88</span>,<span class="number">0xee</span>,<span class="number">0x21</span>,<span class="number">0xc4</span>,<span class="number">0x1a</span>,<span class="number">0xeb</span>,<span class="number">0xd9</span>,</span><br><span class="line"><span class="number">0xc5</span>,<span class="number">0x39</span>,<span class="number">0x99</span>,<span class="number">0xcd</span>,<span class="number">0xad</span>,<span class="number">0x31</span>,<span class="number">0x8b</span>,<span class="number">0x1</span>,<span class="number">0x18</span>,<span class="number">0x23</span>,<span class="number">0xdd</span>,<span class="number">0x1f</span>,<span class="number">0x4e</span>,<span class="number">0x2d</span>,<span class="number">0xf9</span>,<span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x4f</span>,<span class="number">0xf2</span>,<span class="number">0x65</span>,<span class="number">0x8e</span>,<span class="number">0x78</span>,<span class="number">0x5c</span>,<span class="number">0x58</span>,<span class="number">0x19</span>,<span class="number">0x8d</span>,<span class="number">0xe5</span>,<span class="number">0x98</span>,<span class="number">0x57</span>,<span class="number">0x67</span>,<span class="number">0x7f</span>,<span class="number">0x5</span>,<span class="number">0x64</span>,</span><br><span class="line"><span class="number">0xaf</span>,<span class="number">0x63</span>,<span class="number">0xb6</span>,<span class="number">0xfe</span>,<span class="number">0xf5</span>,<span class="number">0xb7</span>,<span class="number">0x3c</span>,<span class="number">0xa5</span>,<span class="number">0xce</span>,<span class="number">0xe9</span>,<span class="number">0x68</span>,<span class="number">0x44</span>,<span class="number">0xe0</span>,<span class="number">0x4d</span>,<span class="number">0x43</span>,<span class="number">0x69</span>,</span><br><span class="line"><span class="number">0x29</span>,<span class="number">0x2e</span>,<span class="number">0xac</span>,<span class="number">0x15</span>,<span class="number">0x59</span>,<span class="number">0xa8</span>,<span class="number">0xa</span>,<span class="number">0x9e</span>,<span class="number">0x6e</span>,<span class="number">0x47</span>,<span class="number">0xdf</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x6a</span>,<span class="number">0xcf</span>,<span class="number">0xdc</span>,</span><br><span class="line"><span class="number">0x22</span>,<span class="number">0xc9</span>,<span class="number">0xc0</span>,<span class="number">0x9b</span>,<span class="number">0x89</span>,<span class="number">0xd4</span>,<span class="number">0xed</span>,<span class="number">0xab</span>,<span class="number">0x12</span>,<span class="number">0xa2</span>,<span class="number">0xd</span>,<span class="number">0x52</span>,<span class="number">0xbb</span>,<span class="number">0x2</span>,<span class="number">0x2f</span>,<span class="number">0xa9</span>,</span><br><span class="line"><span class="number">0xd7</span>,<span class="number">0x61</span>,<span class="number">0x1e</span>,<span class="number">0xb4</span>,<span class="number">0x50</span>,<span class="number">0x4</span>,<span class="number">0xf6</span>,<span class="number">0xc2</span>,<span class="number">0x16</span>,<span class="number">0x25</span>,<span class="number">0x86</span>,<span class="number">0x56</span>,<span class="number">0x55</span>,<span class="number">0x9</span>,<span class="number">0xbe</span>,<span class="number">0x91</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>MDS矩阵运算<br><img src="https://i.loli.net/2019/07/25/5d39335e7c98176996.jpg" alt></p><blockquote><p>S-box生成</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d3933a271f7034024.jpg" alt></p><blockquote><p>输入白化，循环，输出白化  sub_401626</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d39363aca3b346223.jpg" alt></p><p>c实现<br><img src="https://i.loli.net/2019/07/25/5d393666d494e15914.jpg" alt></p><p>f函数<br><img src="https://i.loli.net/2019/07/25/5d39463d2a01720818.jpg" alt></p><h2 id="算法解密"><a href="#算法解密" class="headerlink" title="算法解密"></a>算法解密</h2><p>解密函数如下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_decryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *cypher, <span class="keyword">uint8_t</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> r0, r1, r2, r3, f0, f1, c2,c3;</span><br><span class="line">    <span class="comment">/* Input Whitenening */</span></span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">4</span>]^pack(cypher);</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">5</span>]^pack(cypher+<span class="number">4</span>);</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">6</span>]^pack(cypher+<span class="number">8</span>);</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">7</span>]^pack(cypher+<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The black box */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">15</span>; i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        Twofish_f(tf_twofish, i, r0, r1, &amp;f0, &amp;f1);</span><br><span class="line">        c2 = (rol(r2,<span class="number">1</span>)^f0);</span><br><span class="line">        c3 = ror((f1^r3),<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* swap */</span></span><br><span class="line">        r2 = r0;</span><br><span class="line">        r3 = r1;</span><br><span class="line">        r0 = c2;</span><br><span class="line">        r1 = c3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output Whitening */</span></span><br><span class="line">    c2 = r0;</span><br><span class="line">    c3 = r1;</span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">0</span>]^r2;</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">1</span>]^r3;</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">2</span>]^c2;</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">3</span>]^c3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]   = unpack(r0,i);</span><br><span class="line">        data[i+<span class="number">4</span>] = unpack(r1,i);</span><br><span class="line">        data[i+<span class="number">8</span>] = unpack(r2,i);</span><br><span class="line">        data[i+<span class="number">12</span>]= unpack(r3,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此TwoFish加解密代码如下</p><p>twofish.h<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TWOFISH__H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TWOFISH__H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWOFISH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  TWOFISH</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">twofish_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;</span><br><span class="line">    <span class="keyword">uint32_t</span> k[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> s[<span class="number">4</span>][<span class="number">256</span>];</span><br><span class="line">&#125;<span class="keyword">twofish_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish MDS Multiply Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   data</span></span><br><span class="line"><span class="comment"> * @param   cypher</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_encryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *data, <span class="keyword">uint8_t</span> *cypher)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Decryption Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @paramtf_twofish</span></span><br><span class="line"><span class="comment"> * @param   cypher</span></span><br><span class="line"><span class="comment"> * @param   data</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_decryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *cypher, <span class="keyword">uint8_t</span> *data)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Setup Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   s</span></span><br><span class="line"><span class="comment"> * @param   len</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">twofish_t</span>*  Twofish_setup(<span class="keyword">uint8_t</span> *s, <span class="keyword">uint32_t</span> len);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>tables.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">ifndef</span> __TABLES__H</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> __TABLES__H</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* The MDS Matrix */</span></span><br><span class="line"> <span class="keyword">uint8_t</span> mds[<span class="number">4</span>][<span class="number">4</span>]=</span><br><span class="line"> &#123;</span><br><span class="line">    &#123;<span class="number">0x01</span>, <span class="number">0xef</span>, <span class="number">0x5b</span>, <span class="number">0x5b</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x5b</span>, <span class="number">0xef</span>, <span class="number">0xef</span>, <span class="number">0x01</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xef</span>, <span class="number">0x5b</span>, <span class="number">0x01</span>, <span class="number">0xef</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xef</span>, <span class="number">0x01</span>, <span class="number">0xef</span>, <span class="number">0x5b</span>&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">uint8_t</span> q[<span class="number">2</span>][<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* q0 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line"><span class="number">0xa9</span>,<span class="number">0x67</span>,<span class="number">0xb3</span>,<span class="number">0xe8</span>,<span class="number">0x4</span>,<span class="number">0xfd</span>,<span class="number">0xa3</span>,<span class="number">0x76</span>,<span class="number">0x9a</span>,<span class="number">0x92</span>,<span class="number">0x80</span>,<span class="number">0x78</span>,<span class="number">0xe4</span>,<span class="number">0xdd</span>,<span class="number">0xd1</span>,<span class="number">0x38</span>,</span><br><span class="line"><span class="number">0xd</span>,<span class="number">0xc6</span>,<span class="number">0x35</span>,<span class="number">0x98</span>,<span class="number">0x18</span>,<span class="number">0xf7</span>,<span class="number">0xec</span>,<span class="number">0x6c</span>,<span class="number">0x43</span>,<span class="number">0x75</span>,<span class="number">0x37</span>,<span class="number">0x26</span>,<span class="number">0xfa</span>,<span class="number">0x13</span>,<span class="number">0x94</span>,<span class="number">0x48</span>,</span><br><span class="line"><span class="number">0xf2</span>,<span class="number">0xd0</span>,<span class="number">0x8b</span>,<span class="number">0x30</span>,<span class="number">0x84</span>,<span class="number">0x54</span>,<span class="number">0xdf</span>,<span class="number">0x23</span>,<span class="number">0x19</span>,<span class="number">0x5b</span>,<span class="number">0x3d</span>,<span class="number">0x59</span>,<span class="number">0xf3</span>,<span class="number">0xae</span>,<span class="number">0xa2</span>,<span class="number">0x82</span>,</span><br><span class="line"><span class="number">0x63</span>,<span class="number">0x1</span>,<span class="number">0x83</span>,<span class="number">0x2e</span>,<span class="number">0xd9</span>,<span class="number">0x51</span>,<span class="number">0x9b</span>,<span class="number">0x7c</span>,<span class="number">0xa6</span>,<span class="number">0xeb</span>,<span class="number">0xa5</span>,<span class="number">0xbe</span>,<span class="number">0x16</span>,<span class="number">0xc</span>,<span class="number">0xe3</span>,<span class="number">0x61</span>,</span><br><span class="line"><span class="number">0xc0</span>,<span class="number">0x8c</span>,<span class="number">0x3a</span>,<span class="number">0xf5</span>,<span class="number">0x73</span>,<span class="number">0x2c</span>,<span class="number">0x25</span>,<span class="number">0xb</span>,<span class="number">0xbb</span>,<span class="number">0x4e</span>,<span class="number">0x89</span>,<span class="number">0x6b</span>,<span class="number">0x53</span>,<span class="number">0x6a</span>,<span class="number">0xb4</span>,<span class="number">0xf1</span>,</span><br><span class="line"><span class="number">0xe1</span>,<span class="number">0xe6</span>,<span class="number">0xbd</span>,<span class="number">0x45</span>,<span class="number">0xe2</span>,<span class="number">0xf4</span>,<span class="number">0xb6</span>,<span class="number">0x66</span>,<span class="number">0xcc</span>,<span class="number">0x95</span>,<span class="number">0x3</span>,<span class="number">0x56</span>,<span class="number">0xd4</span>,<span class="number">0x1c</span>,<span class="number">0x1e</span>,<span class="number">0xd7</span>,</span><br><span class="line"><span class="number">0xfb</span>,<span class="number">0xc3</span>,<span class="number">0x8e</span>,<span class="number">0xb5</span>,<span class="number">0xe9</span>,<span class="number">0xcf</span>,<span class="number">0xbf</span>,<span class="number">0xba</span>,<span class="number">0xea</span>,<span class="number">0x77</span>,<span class="number">0x39</span>,<span class="number">0xaf</span>,<span class="number">0x33</span>,<span class="number">0xc9</span>,<span class="number">0x62</span>,<span class="number">0x71</span>,</span><br><span class="line"><span class="number">0x81</span>,<span class="number">0x79</span>,<span class="number">0x9</span>,<span class="number">0xad</span>,<span class="number">0x24</span>,<span class="number">0xcd</span>,<span class="number">0xf9</span>,<span class="number">0xd8</span>,<span class="number">0xe5</span>,<span class="number">0xc5</span>,<span class="number">0xb9</span>,<span class="number">0x4d</span>,<span class="number">0x44</span>,<span class="number">0x8</span>,<span class="number">0x86</span>,<span class="number">0xe7</span>,</span><br><span class="line"><span class="number">0xa1</span>,<span class="number">0x1d</span>,<span class="number">0xaa</span>,<span class="number">0xed</span>,<span class="number">0x6</span>,<span class="number">0x70</span>,<span class="number">0xb2</span>,<span class="number">0xd2</span>,<span class="number">0x41</span>,<span class="number">0x7b</span>,<span class="number">0xa0</span>,<span class="number">0x11</span>,<span class="number">0x31</span>,<span class="number">0xc2</span>,<span class="number">0x27</span>,<span class="number">0x90</span>,</span><br><span class="line"><span class="number">0x20</span>,<span class="number">0xf6</span>,<span class="number">0x60</span>,<span class="number">0xff</span>,<span class="number">0x96</span>,<span class="number">0x5c</span>,<span class="number">0xb1</span>,<span class="number">0xab</span>,<span class="number">0x9e</span>,<span class="number">0x9c</span>,<span class="number">0x52</span>,<span class="number">0x1b</span>,<span class="number">0x5f</span>,<span class="number">0x93</span>,<span class="number">0xa</span>,<span class="number">0xef</span>,</span><br><span class="line"><span class="number">0x91</span>,<span class="number">0x85</span>,<span class="number">0x49</span>,<span class="number">0xee</span>,<span class="number">0x2d</span>,<span class="number">0x4f</span>,<span class="number">0x8f</span>,<span class="number">0x3b</span>,<span class="number">0x47</span>,<span class="number">0x87</span>,<span class="number">0x6d</span>,<span class="number">0x46</span>,<span class="number">0xd6</span>,<span class="number">0x3e</span>,<span class="number">0x69</span>,<span class="number">0x64</span>,</span><br><span class="line"><span class="number">0x2a</span>,<span class="number">0xce</span>,<span class="number">0xcb</span>,<span class="number">0x2f</span>,<span class="number">0xfc</span>,<span class="number">0x97</span>,<span class="number">0x5</span>,<span class="number">0x7a</span>,<span class="number">0xac</span>,<span class="number">0x7f</span>,<span class="number">0xd5</span>,<span class="number">0x1a</span>,<span class="number">0x4b</span>,<span class="number">0xe</span>,<span class="number">0xa7</span>,<span class="number">0x5a</span>,</span><br><span class="line"><span class="number">0x28</span>,<span class="number">0x14</span>,<span class="number">0x3f</span>,<span class="number">0x29</span>,<span class="number">0x88</span>,<span class="number">0x3c</span>,<span class="number">0x4c</span>,<span class="number">0x2</span>,<span class="number">0xb8</span>,<span class="number">0xda</span>,<span class="number">0xb0</span>,<span class="number">0x17</span>,<span class="number">0x55</span>,<span class="number">0x1f</span>,<span class="number">0x8a</span>,<span class="number">0x7d</span>,</span><br><span class="line"><span class="number">0x57</span>,<span class="number">0xc7</span>,<span class="number">0x8d</span>,<span class="number">0x74</span>,<span class="number">0xb7</span>,<span class="number">0xc4</span>,<span class="number">0x9f</span>,<span class="number">0x72</span>,<span class="number">0x7e</span>,<span class="number">0x15</span>,<span class="number">0x22</span>,<span class="number">0x12</span>,<span class="number">0x58</span>,<span class="number">0x7</span>,<span class="number">0x99</span>,<span class="number">0x34</span>,</span><br><span class="line"><span class="number">0x6e</span>,<span class="number">0x50</span>,<span class="number">0xde</span>,<span class="number">0x68</span>,<span class="number">0x65</span>,<span class="number">0xbc</span>,<span class="number">0xdb</span>,<span class="number">0xf8</span>,<span class="number">0xc8</span>,<span class="number">0xa8</span>,<span class="number">0x2b</span>,<span class="number">0x40</span>,<span class="number">0xdc</span>,<span class="number">0xfe</span>,<span class="number">0x32</span>,<span class="number">0xa4</span>,</span><br><span class="line"><span class="number">0xca</span>,<span class="number">0x10</span>,<span class="number">0x21</span>,<span class="number">0xf0</span>,<span class="number">0xd3</span>,<span class="number">0x5d</span>,<span class="number">0xf</span>,<span class="number">0x0</span>,<span class="number">0x6f</span>,<span class="number">0x9d</span>,<span class="number">0x36</span>,<span class="number">0x42</span>,<span class="number">0x4a</span>,<span class="number">0x5e</span>,<span class="number">0xc1</span>,<span class="number">0xe0</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="comment">/* q1 */</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"><span class="number">0x75</span>,<span class="number">0xf3</span>,<span class="number">0xc6</span>,<span class="number">0xf4</span>,<span class="number">0xdb</span>,<span class="number">0x7b</span>,<span class="number">0xfb</span>,<span class="number">0xc8</span>,<span class="number">0x4a</span>,<span class="number">0xd3</span>,<span class="number">0xe6</span>,<span class="number">0x6b</span>,<span class="number">0x45</span>,<span class="number">0x7d</span>,<span class="number">0xe8</span>,<span class="number">0x4b</span>,</span><br><span class="line"><span class="number">0xd6</span>,<span class="number">0x32</span>,<span class="number">0xd8</span>,<span class="number">0xfd</span>,<span class="number">0x37</span>,<span class="number">0x71</span>,<span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x30</span>,<span class="number">0xf</span>,<span class="number">0xf8</span>,<span class="number">0x1b</span>,<span class="number">0x87</span>,<span class="number">0xfa</span>,<span class="number">0x6</span>,<span class="number">0x3f</span>,</span><br><span class="line"><span class="number">0x5e</span>,<span class="number">0xba</span>,<span class="number">0xae</span>,<span class="number">0x5b</span>,<span class="number">0x8a</span>,<span class="number">0x0</span>,<span class="number">0xbc</span>,<span class="number">0x9d</span>,<span class="number">0x6d</span>,<span class="number">0xc1</span>,<span class="number">0xb1</span>,<span class="number">0xe</span>,<span class="number">0x80</span>,<span class="number">0x5d</span>,<span class="number">0xd2</span>,<span class="number">0xd5</span>,</span><br><span class="line"><span class="number">0xa0</span>,<span class="number">0x84</span>,<span class="number">0x7</span>,<span class="number">0x14</span>,<span class="number">0xb5</span>,<span class="number">0x90</span>,<span class="number">0x2c</span>,<span class="number">0xa3</span>,<span class="number">0xb2</span>,<span class="number">0x73</span>,<span class="number">0x4c</span>,<span class="number">0x54</span>,<span class="number">0x92</span>,<span class="number">0x74</span>,<span class="number">0x36</span>,<span class="number">0x51</span>,</span><br><span class="line"><span class="number">0x38</span>,<span class="number">0xb0</span>,<span class="number">0xbd</span>,<span class="number">0x5a</span>,<span class="number">0xfc</span>,<span class="number">0x60</span>,<span class="number">0x62</span>,<span class="number">0x96</span>,<span class="number">0x6c</span>,<span class="number">0x42</span>,<span class="number">0xf7</span>,<span class="number">0x10</span>,<span class="number">0x7c</span>,<span class="number">0x28</span>,<span class="number">0x27</span>,<span class="number">0x8c</span>,</span><br><span class="line"><span class="number">0x13</span>,<span class="number">0x95</span>,<span class="number">0x9c</span>,<span class="number">0xc7</span>,<span class="number">0x24</span>,<span class="number">0x46</span>,<span class="number">0x3b</span>,<span class="number">0x70</span>,<span class="number">0xca</span>,<span class="number">0xe3</span>,<span class="number">0x85</span>,<span class="number">0xcb</span>,<span class="number">0x11</span>,<span class="number">0xd0</span>,<span class="number">0x93</span>,<span class="number">0xb8</span>,</span><br><span class="line"><span class="number">0xa6</span>,<span class="number">0x83</span>,<span class="number">0x20</span>,<span class="number">0xff</span>,<span class="number">0x9f</span>,<span class="number">0x77</span>,<span class="number">0xc3</span>,<span class="number">0xcc</span>,<span class="number">0x3</span>,<span class="number">0x6f</span>,<span class="number">0x8</span>,<span class="number">0xbf</span>,<span class="number">0x40</span>,<span class="number">0xe7</span>,<span class="number">0x2b</span>,<span class="number">0xe2</span>,</span><br><span class="line"><span class="number">0x79</span>,<span class="number">0xc</span>,<span class="number">0xaa</span>,<span class="number">0x82</span>,<span class="number">0x41</span>,<span class="number">0x3a</span>,<span class="number">0xea</span>,<span class="number">0xb9</span>,<span class="number">0xe4</span>,<span class="number">0x9a</span>,<span class="number">0xa4</span>,<span class="number">0x97</span>,<span class="number">0x7e</span>,<span class="number">0xda</span>,<span class="number">0x7a</span>,<span class="number">0x17</span>,</span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x94</span>,<span class="number">0xa1</span>,<span class="number">0x1d</span>,<span class="number">0x3d</span>,<span class="number">0xf0</span>,<span class="number">0xde</span>,<span class="number">0xb3</span>,<span class="number">0xb</span>,<span class="number">0x72</span>,<span class="number">0xa7</span>,<span class="number">0x1c</span>,<span class="number">0xef</span>,<span class="number">0xd1</span>,<span class="number">0x53</span>,<span class="number">0x3e</span>,</span><br><span class="line"><span class="number">0x8f</span>,<span class="number">0x33</span>,<span class="number">0x26</span>,<span class="number">0x5f</span>,<span class="number">0xec</span>,<span class="number">0x76</span>,<span class="number">0x2a</span>,<span class="number">0x49</span>,<span class="number">0x81</span>,<span class="number">0x88</span>,<span class="number">0xee</span>,<span class="number">0x21</span>,<span class="number">0xc4</span>,<span class="number">0x1a</span>,<span class="number">0xeb</span>,<span class="number">0xd9</span>,</span><br><span class="line"><span class="number">0xc5</span>,<span class="number">0x39</span>,<span class="number">0x99</span>,<span class="number">0xcd</span>,<span class="number">0xad</span>,<span class="number">0x31</span>,<span class="number">0x8b</span>,<span class="number">0x1</span>,<span class="number">0x18</span>,<span class="number">0x23</span>,<span class="number">0xdd</span>,<span class="number">0x1f</span>,<span class="number">0x4e</span>,<span class="number">0x2d</span>,<span class="number">0xf9</span>,<span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x4f</span>,<span class="number">0xf2</span>,<span class="number">0x65</span>,<span class="number">0x8e</span>,<span class="number">0x78</span>,<span class="number">0x5c</span>,<span class="number">0x58</span>,<span class="number">0x19</span>,<span class="number">0x8d</span>,<span class="number">0xe5</span>,<span class="number">0x98</span>,<span class="number">0x57</span>,<span class="number">0x67</span>,<span class="number">0x7f</span>,<span class="number">0x5</span>,<span class="number">0x64</span>,</span><br><span class="line"><span class="number">0xaf</span>,<span class="number">0x63</span>,<span class="number">0xb6</span>,<span class="number">0xfe</span>,<span class="number">0xf5</span>,<span class="number">0xb7</span>,<span class="number">0x3c</span>,<span class="number">0xa5</span>,<span class="number">0xce</span>,<span class="number">0xe9</span>,<span class="number">0x68</span>,<span class="number">0x44</span>,<span class="number">0xe0</span>,<span class="number">0x4d</span>,<span class="number">0x43</span>,<span class="number">0x69</span>,</span><br><span class="line"><span class="number">0x29</span>,<span class="number">0x2e</span>,<span class="number">0xac</span>,<span class="number">0x15</span>,<span class="number">0x59</span>,<span class="number">0xa8</span>,<span class="number">0xa</span>,<span class="number">0x9e</span>,<span class="number">0x6e</span>,<span class="number">0x47</span>,<span class="number">0xdf</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x6a</span>,<span class="number">0xcf</span>,<span class="number">0xdc</span>,</span><br><span class="line"><span class="number">0x22</span>,<span class="number">0xc9</span>,<span class="number">0xc0</span>,<span class="number">0x9b</span>,<span class="number">0x89</span>,<span class="number">0xd4</span>,<span class="number">0xed</span>,<span class="number">0xab</span>,<span class="number">0x12</span>,<span class="number">0xa2</span>,<span class="number">0xd</span>,<span class="number">0x52</span>,<span class="number">0xbb</span>,<span class="number">0x2</span>,<span class="number">0x2f</span>,<span class="number">0xa9</span>,</span><br><span class="line"><span class="number">0xd7</span>,<span class="number">0x61</span>,<span class="number">0x1e</span>,<span class="number">0xb4</span>,<span class="number">0x50</span>,<span class="number">0x4</span>,<span class="number">0xf6</span>,<span class="number">0xc2</span>,<span class="number">0x16</span>,<span class="number">0x25</span>,<span class="number">0x86</span>,<span class="number">0x56</span>,<span class="number">0x55</span>,<span class="number">0x9</span>,<span class="number">0xbe</span>,<span class="number">0x91</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>twofish.c<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"twofish.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tables.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xor(g,r)    (g^r)                   <span class="comment">/* Xor operation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ror(g,n)    ((g&gt;&gt;n)|(g&lt;&lt;(32-n)))    <span class="comment">/* Rotate right  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rol(g,n)    ((g<span class="meta-string">&lt;&lt;n)|(g&gt;&gt;(32-n)))    /* Rotate left   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nxt(g,r)    (*(g+r))                <span class="comment">/* Get next byte */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LITTILE_ENDIAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  LITTILE_ENDIAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unpack(g,r) ((g&gt;&gt;(r*8))&amp;0xff)                               <span class="comment">/* Extracts a byte from a word.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pack(g)     ((*(g))|(*(g+1)&lt;&lt;8)|(*(g+2)&lt;&lt;16)|(*(g+3)&lt;&lt;24))  <span class="comment">/* Converts four byte to a word. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rsm(i,a,b,c,d,e,f,g,h)  \</span></span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>),a,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">1</span>),b,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">2</span>),c,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">3</span>),d,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">4</span>),e,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">5</span>),f,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">6</span>),g,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">7</span>),h,<span class="number">0x14d</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> u(x,a)\</span></span><br><span class="line">        x[<span class="number">0</span>] = unpack(a,<span class="number">0</span>); \</span><br><span class="line">        x[<span class="number">1</span>] = unpack(a,<span class="number">1</span>); \</span><br><span class="line">        x[<span class="number">2</span>] = unpack(a,<span class="number">2</span>); \</span><br><span class="line">        x[<span class="number">3</span>] = unpack(a,<span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> release(a,b,c)  &#123; free(a); free(b);free(c); &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  TWOFISH</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">key_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;</span><br><span class="line">    <span class="keyword">uint8_t</span> *k;</span><br><span class="line">&#125;<span class="keyword">key_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">subkey_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;</span><br><span class="line">    <span class="keyword">uint8_t</span> s[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> me[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> mo[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">&#125;<span class="keyword">subkey_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Expand Key Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   s</span></span><br><span class="line"><span class="comment"> * @param   len</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">key_t</span>* expand_key(<span class="keyword">uint8_t</span> *s, <span class="keyword">uint32_t</span> len);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Galois Field Multiplication Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   x</span></span><br><span class="line"><span class="comment"> * @param   y</span></span><br><span class="line"><span class="comment"> * @param   m</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint8_t</span> gf(<span class="keyword">uint8_t</span> x, <span class="keyword">uint8_t</span> y, <span class="keyword">uint16_t</span> m);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Generate Subkeys Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_key</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">subkey_t</span>* Twofish_generate_subkey(<span class="keyword">key_t</span>* tf_key);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish h Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   x[]</span></span><br><span class="line"><span class="comment"> * @param   y[]</span></span><br><span class="line"><span class="comment"> * @param   s</span></span><br><span class="line"><span class="comment"> * @param   stage</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_h</span><span class="params">(<span class="keyword">uint8_t</span> x[],  <span class="keyword">uint8_t</span> y[], <span class="keyword">uint8_t</span> s[][<span class="number">4</span>], <span class="keyword">int</span> stage)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish MDS Multiply Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   y[]</span></span><br><span class="line"><span class="comment"> * @param   out[]</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_mds_mul</span><span class="params">(<span class="keyword">uint8_t</span> y[],  <span class="keyword">uint8_t</span> out[])</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Genrate Extended K Keys Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   tf_subkey</span></span><br><span class="line"><span class="comment"> * @param   p</span></span><br><span class="line"><span class="comment"> * @param   k</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_generate_ext_k_keys(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">subkey_t</span> *tf_subkey,<span class="keyword">uint32_t</span> p, <span class="keyword">uint8_t</span> k);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Genrate Extended S Keys Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   tf_subkey</span></span><br><span class="line"><span class="comment"> * @param   k</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_generate_ext_s_keys(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">subkey_t</span> *tf_subkey, <span class="keyword">uint8_t</span> k);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish f Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   r</span></span><br><span class="line"><span class="comment"> * @param   r0, r1</span></span><br><span class="line"><span class="comment"> * @param   f0, f1</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_f</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> r,<span class="keyword">uint32_t</span> r0, <span class="keyword">uint32_t</span> r1, <span class="keyword">uint32_t</span>* f0, <span class="keyword">uint32_t</span>* f1)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish g Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   x</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint32_t</span> Twofish_g(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint32_t</span> x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_setup(<span class="keyword">uint8_t</span> *s, <span class="keyword">uint32_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Expand the key if necessary. */</span></span><br><span class="line">    <span class="keyword">key_t</span>* tf_key = expand_key(s, len/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Generate subkeys: s and k */</span></span><br><span class="line">    <span class="keyword">subkey_t</span> *tf_subkey = Twofish_generate_subkey(tf_key);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* Generate 40 K keys */</span></span><br><span class="line">    <span class="keyword">twofish_t</span>* tf_twofish = (<span class="keyword">twofish_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">twofish_t</span>));</span><br><span class="line">    tf_twofish = Twofish_generate_ext_k_keys(tf_twofish,tf_subkey,<span class="number">0x01010101</span>,(tf_key-&gt;len/<span class="number">8</span>));</span><br><span class="line">    <span class="comment">/* Generate 4x256 S keys */</span></span><br><span class="line">    tf_twofish = Twofish_generate_ext_s_keys(tf_twofish,tf_subkey,(tf_key-&gt;len/<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free memory */</span></span><br><span class="line">    release(tf_key-&gt;k, tf_key, tf_subkey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tf_twofish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_encryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *data, <span class="keyword">uint8_t</span> *cypher)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> r0, r1, r2, r3, f0, f1, c2,c3;</span><br><span class="line">    <span class="comment">/* Input Whitenening */</span></span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">0</span>]^pack(data);</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">1</span>]^pack(data+<span class="number">4</span>);</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">2</span>]^pack(data+<span class="number">8</span>);</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">3</span>]^pack(data+<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The black box */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Twofish_f(tf_twofish, i, r0, r1, &amp;f0, &amp;f1);</span><br><span class="line">        c2 = ror((f0^r2), <span class="number">1</span>);</span><br><span class="line">        c3 = (f1^rol(r3,<span class="number">1</span>));</span><br><span class="line">        <span class="comment">/* swap */</span></span><br><span class="line">        r2 = r0;</span><br><span class="line">        r3 = r1;</span><br><span class="line">        r0 = c2;</span><br><span class="line">        r1 = c3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output Whitening */</span></span><br><span class="line">    c2 = r0;</span><br><span class="line">    c3 = r1;</span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">4</span>]^r2;</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">5</span>]^r3;</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">6</span>]^c2;</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">7</span>]^c3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cypher[i]   = unpack(r0,i);</span><br><span class="line">        cypher[i+<span class="number">4</span>] = unpack(r1,i);</span><br><span class="line">        cypher[i+<span class="number">8</span>] = unpack(r2,i);</span><br><span class="line">        cypher[i+<span class="number">12</span>]= unpack(r3,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_decryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *cypher, <span class="keyword">uint8_t</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> r0, r1, r2, r3, f0, f1, c2,c3;</span><br><span class="line">    <span class="comment">/* Input Whitenening */</span></span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">4</span>]^pack(cypher);</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">5</span>]^pack(cypher+<span class="number">4</span>);</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">6</span>]^pack(cypher+<span class="number">8</span>);</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">7</span>]^pack(cypher+<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The black box */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">15</span>; i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        Twofish_f(tf_twofish, i, r0, r1, &amp;f0, &amp;f1);</span><br><span class="line">        c2 = (rol(r2,<span class="number">1</span>)^f0);</span><br><span class="line">        c3 = ror((f1^r3),<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* swap */</span></span><br><span class="line">        r2 = r0;</span><br><span class="line">        r3 = r1;</span><br><span class="line">        r0 = c2;</span><br><span class="line">        r1 = c3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output Whitening */</span></span><br><span class="line">    c2 = r0;</span><br><span class="line">    c3 = r1;</span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">0</span>]^r2;</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">1</span>]^r3;</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">2</span>]^c2;</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">3</span>]^c3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]   = unpack(r0,i);</span><br><span class="line">        data[i+<span class="number">4</span>] = unpack(r1,i);</span><br><span class="line">        data[i+<span class="number">8</span>] = unpack(r2,i);</span><br><span class="line">        data[i+<span class="number">12</span>]= unpack(r3,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_f</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> r,<span class="keyword">uint32_t</span> r0, <span class="keyword">uint32_t</span> r1, <span class="keyword">uint32_t</span>* f0, <span class="keyword">uint32_t</span>* f1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> t0, t1, o;</span><br><span class="line">    t0 = Twofish_g(tf_twofish, r0);</span><br><span class="line">    t1 = rol(r1, <span class="number">8</span>);</span><br><span class="line">    t1 = Twofish_g(tf_twofish, t1);</span><br><span class="line">    o = <span class="number">2</span>*r;</span><br><span class="line">    *f0= (t0 + t1 + tf_twofish-&gt;k[o+<span class="number">8</span>]);</span><br><span class="line">    *f1= (t0 + (<span class="number">2</span>*t1) + tf_twofish-&gt;k[o+<span class="number">9</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_generate_ext_k_keys(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">subkey_t</span> *tf_subkey,<span class="keyword">uint32_t</span> p, <span class="keyword">uint8_t</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> a, b;</span><br><span class="line">    <span class="keyword">uint8_t</span> x[<span class="number">4</span>], y[<span class="number">4</span>], z[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i+=<span class="number">2</span>)                  <span class="comment">/* i = 40/2 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = (i*p);                          <span class="comment">/* 2*i*p */</span></span><br><span class="line">        b = (a+p);                          <span class="comment">/* ((2*i +1)*p */</span></span><br><span class="line">        u(x,a);</span><br><span class="line">        Twofish_h(x, y, tf_subkey-&gt;me, k);</span><br><span class="line">        Twofish_mds_mul(y,z);</span><br><span class="line">        a = pack(z);                        <span class="comment">/* Convert four bytes z[4] to a word (a). */</span></span><br><span class="line">        u(x,b);                             <span class="comment">/* Convert a word (b) to four bytes x[4]. */</span></span><br><span class="line">        Twofish_h(x, y, tf_subkey-&gt;mo, k);</span><br><span class="line">        Twofish_mds_mul(y,z);        </span><br><span class="line">        b = pack(z);</span><br><span class="line">        b = rol(b,<span class="number">8</span>);</span><br><span class="line">        tf_twofish-&gt;k[i] = ((a + b));</span><br><span class="line">        tf_twofish-&gt;k[i+<span class="number">1</span>] = rol(((a + (<span class="number">2</span>*b))),<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tf_twofish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_generate_ext_s_keys(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">subkey_t</span> *tf_subkey, <span class="keyword">uint8_t</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> x[<span class="number">4</span>], y[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x[<span class="number">0</span>] = x[<span class="number">1</span>] = x[<span class="number">2</span>] = x[<span class="number">3</span>] = i;</span><br><span class="line">        Twofish_h(x, y, tf_subkey-&gt;s, k);</span><br><span class="line">        <span class="comment">/* Special MDS multiplication */</span></span><br><span class="line">        tf_twofish-&gt;s[<span class="number">0</span>][i] = (gf(y[<span class="number">0</span>], mds[<span class="number">0</span>][<span class="number">0</span>],<span class="number">0x169</span>) |(gf(y[<span class="number">1</span>],mds[<span class="number">0</span>][<span class="number">1</span>],<span class="number">0x169</span>)&lt;&lt; <span class="number">8</span>)|(gf(y[<span class="number">2</span>], mds[<span class="number">0</span>][<span class="number">2</span>],<span class="number">0x169</span>)&lt;&lt;<span class="number">16</span>) |(gf(y[<span class="number">3</span>], mds[<span class="number">0</span>][<span class="number">3</span>], <span class="number">0x169</span>) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">        tf_twofish-&gt;s[<span class="number">1</span>][i] = (gf(y[<span class="number">0</span>], mds[<span class="number">1</span>][<span class="number">0</span>],<span class="number">0x169</span>) |(gf(y[<span class="number">1</span>],mds[<span class="number">1</span>][<span class="number">1</span>],<span class="number">0x169</span>)&lt;&lt; <span class="number">8</span>)|(gf(y[<span class="number">2</span>], mds[<span class="number">1</span>][<span class="number">2</span>],<span class="number">0x169</span>)&lt;&lt;<span class="number">16</span>) |(gf(y[<span class="number">3</span>], mds[<span class="number">1</span>][<span class="number">3</span>], <span class="number">0x169</span>) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">        tf_twofish-&gt;s[<span class="number">2</span>][i] = (gf(y[<span class="number">0</span>], mds[<span class="number">2</span>][<span class="number">0</span>],<span class="number">0x169</span>) |(gf(y[<span class="number">1</span>],mds[<span class="number">2</span>][<span class="number">1</span>],<span class="number">0x169</span>)&lt;&lt; <span class="number">8</span>)|(gf(y[<span class="number">2</span>], mds[<span class="number">2</span>][<span class="number">2</span>],<span class="number">0x169</span>)&lt;&lt;<span class="number">16</span>) |(gf(y[<span class="number">3</span>], mds[<span class="number">2</span>][<span class="number">3</span>], <span class="number">0x169</span>) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">        tf_twofish-&gt;s[<span class="number">3</span>][i] = (gf(y[<span class="number">0</span>], mds[<span class="number">3</span>][<span class="number">0</span>],<span class="number">0x169</span>) |(gf(y[<span class="number">1</span>],mds[<span class="number">3</span>][<span class="number">1</span>],<span class="number">0x169</span>)&lt;&lt; <span class="number">8</span>)|(gf(y[<span class="number">2</span>], mds[<span class="number">3</span>][<span class="number">2</span>],<span class="number">0x169</span>)&lt;&lt;<span class="number">16</span>) |(gf(y[<span class="number">3</span>], mds[<span class="number">3</span>][<span class="number">3</span>], <span class="number">0x169</span>) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tf_twofish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_mds_mul</span><span class="params">(<span class="keyword">uint8_t</span> y[],  <span class="keyword">uint8_t</span> out[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* MDS multiplication */</span></span><br><span class="line">    out[<span class="number">0</span>] = (gf(y[<span class="number">0</span>], mds[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0x169</span>)^gf(y[<span class="number">1</span>], mds[<span class="number">0</span>][<span class="number">1</span>], <span class="number">0x169</span>)^gf(y[<span class="number">2</span>], mds[<span class="number">0</span>][<span class="number">2</span>], <span class="number">0x169</span>)^gf(y[<span class="number">3</span>], mds[<span class="number">0</span>][<span class="number">3</span>], <span class="number">0x169</span>));</span><br><span class="line">    out[<span class="number">1</span>] = (gf(y[<span class="number">0</span>], mds[<span class="number">1</span>][<span class="number">0</span>], <span class="number">0x169</span>)^gf(y[<span class="number">1</span>], mds[<span class="number">1</span>][<span class="number">1</span>], <span class="number">0x169</span>)^gf(y[<span class="number">2</span>], mds[<span class="number">1</span>][<span class="number">2</span>], <span class="number">0x169</span>)^gf(y[<span class="number">3</span>], mds[<span class="number">1</span>][<span class="number">3</span>], <span class="number">0x169</span>));</span><br><span class="line">    out[<span class="number">2</span>] = (gf(y[<span class="number">0</span>], mds[<span class="number">2</span>][<span class="number">0</span>], <span class="number">0x169</span>)^gf(y[<span class="number">1</span>], mds[<span class="number">2</span>][<span class="number">1</span>], <span class="number">0x169</span>)^gf(y[<span class="number">2</span>], mds[<span class="number">2</span>][<span class="number">2</span>], <span class="number">0x169</span>)^gf(y[<span class="number">3</span>], mds[<span class="number">2</span>][<span class="number">3</span>], <span class="number">0x169</span>));</span><br><span class="line">    out[<span class="number">3</span>] = (gf(y[<span class="number">0</span>], mds[<span class="number">3</span>][<span class="number">0</span>], <span class="number">0x169</span>)^gf(y[<span class="number">1</span>], mds[<span class="number">3</span>][<span class="number">1</span>], <span class="number">0x169</span>)^gf(y[<span class="number">2</span>], mds[<span class="number">3</span>][<span class="number">2</span>], <span class="number">0x169</span>)^gf(y[<span class="number">3</span>], mds[<span class="number">3</span>][<span class="number">3</span>], <span class="number">0x169</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> Twofish_g(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint32_t</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (tf_twofish-&gt;s[<span class="number">0</span>][unpack(x,<span class="number">0</span>)]^tf_twofish-&gt;s[<span class="number">1</span>][unpack(x, <span class="number">1</span>)]^tf_twofish-&gt;s[<span class="number">2</span>][unpack(x,<span class="number">2</span>)]^tf_twofish-&gt;s[<span class="number">3</span>][unpack(x,<span class="number">3</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_h</span><span class="params">(<span class="keyword">uint8_t</span> x[],  <span class="keyword">uint8_t</span> out[], <span class="keyword">uint8_t</span> s[][<span class="number">4</span>], <span class="keyword">int</span> stage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> y[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>;++j)</span><br><span class="line">    &#123;</span><br><span class="line">        y[j] = x[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stage == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y[<span class="number">0</span>] = q[<span class="number">1</span>][y[<span class="number">0</span>]] ^ (s[<span class="number">3</span>][<span class="number">0</span>]);</span><br><span class="line">        y[<span class="number">1</span>] = q[<span class="number">0</span>][y[<span class="number">1</span>]] ^ (s[<span class="number">3</span>][<span class="number">1</span>]);</span><br><span class="line">        y[<span class="number">2</span>] = q[<span class="number">0</span>][y[<span class="number">2</span>]] ^ (s[<span class="number">3</span>][<span class="number">2</span>]);</span><br><span class="line">        y[<span class="number">3</span>] = q[<span class="number">1</span>][y[<span class="number">3</span>]] ^ (s[<span class="number">3</span>][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stage &gt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y[<span class="number">0</span>] = q[<span class="number">1</span>][y[<span class="number">0</span>]] ^ (s[<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">        y[<span class="number">1</span>] = q[<span class="number">1</span>][y[<span class="number">1</span>]] ^ (s[<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">        y[<span class="number">2</span>] = q[<span class="number">0</span>][y[<span class="number">2</span>]] ^ (s[<span class="number">2</span>][<span class="number">2</span>]);</span><br><span class="line">        y[<span class="number">3</span>] = q[<span class="number">0</span>][y[<span class="number">3</span>]] ^ (s[<span class="number">2</span>][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out[<span class="number">0</span>] = q[<span class="number">1</span>][q[<span class="number">0</span>][ q[<span class="number">0</span>][y[<span class="number">0</span>]] ^ (s[<span class="number">1</span>][<span class="number">0</span>])] ^ (s[<span class="number">0</span>][<span class="number">0</span>])];</span><br><span class="line">    out[<span class="number">1</span>] = q[<span class="number">0</span>][q[<span class="number">0</span>][ q[<span class="number">1</span>][y[<span class="number">1</span>]] ^ (s[<span class="number">1</span>][<span class="number">1</span>])] ^ (s[<span class="number">0</span>][<span class="number">1</span>])];</span><br><span class="line">    out[<span class="number">2</span>] = q[<span class="number">1</span>][q[<span class="number">1</span>][ q[<span class="number">0</span>][y[<span class="number">2</span>]] ^ (s[<span class="number">1</span>][<span class="number">2</span>])] ^ (s[<span class="number">0</span>][<span class="number">2</span>])];</span><br><span class="line">    out[<span class="number">3</span>] = q[<span class="number">0</span>][q[<span class="number">1</span>][ q[<span class="number">1</span>][y[<span class="number">3</span>]] ^ (s[<span class="number">1</span>][<span class="number">3</span>])] ^ (s[<span class="number">0</span>][<span class="number">3</span>])];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">subkey_t</span>* Twofish_generate_subkey(<span class="keyword">key_t</span>* tf_key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> k, r, g;</span><br><span class="line">    <span class="keyword">subkey_t</span> *tf_subkey = (<span class="keyword">subkey_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">subkey_t</span>));</span><br><span class="line">    k = tf_key-&gt;len/<span class="number">8</span>;                                  <span class="comment">/* k=N/64 */</span></span><br><span class="line">    <span class="keyword">for</span>(r=<span class="number">0</span>; r&lt;k;++r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Generate subkeys Me and Mo */</span></span><br><span class="line">        tf_subkey-&gt;me[r][<span class="number">0</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span>    );</span><br><span class="line">        tf_subkey-&gt;me[r][<span class="number">1</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">1</span>);</span><br><span class="line">        tf_subkey-&gt;me[r][<span class="number">2</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">2</span>);</span><br><span class="line">        tf_subkey-&gt;me[r][<span class="number">3</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">3</span>);</span><br><span class="line">        tf_subkey-&gt;mo[r][<span class="number">0</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">4</span>);</span><br><span class="line">        tf_subkey-&gt;mo[r][<span class="number">1</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">5</span>);</span><br><span class="line">        tf_subkey-&gt;mo[r][<span class="number">2</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">6</span>);</span><br><span class="line">        tf_subkey-&gt;mo[r][<span class="number">3</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">7</span>);</span><br><span class="line">        </span><br><span class="line">        g=k-r<span class="number">-1</span>;                                        <span class="comment">/* Reverse order */</span></span><br><span class="line">        <span class="comment">/* Generate subkeys S using RS matrix */</span></span><br><span class="line">        tf_subkey-&gt;s[g][<span class="number">0</span>] = rsm(r, <span class="number">0x01</span>, <span class="number">0xa4</span>, <span class="number">0x55</span>, <span class="number">0x87</span>, <span class="number">0x5a</span>, <span class="number">0x58</span>, <span class="number">0xdb</span>, <span class="number">0x9e</span>);</span><br><span class="line">        tf_subkey-&gt;s[g][<span class="number">1</span>] = rsm(r, <span class="number">0xa4</span>, <span class="number">0x56</span>, <span class="number">0x82</span>, <span class="number">0xf3</span>, <span class="number">0x1e</span>, <span class="number">0xc6</span>, <span class="number">0x68</span>, <span class="number">0xe5</span>);</span><br><span class="line">        tf_subkey-&gt;s[g][<span class="number">2</span>] = rsm(r, <span class="number">0x02</span>, <span class="number">0xa1</span>, <span class="number">0xfc</span>, <span class="number">0xc1</span>, <span class="number">0x47</span>, <span class="number">0xae</span>, <span class="number">0x3d</span>, <span class="number">0x19</span>);</span><br><span class="line">        tf_subkey-&gt;s[g][<span class="number">3</span>] = rsm(r, <span class="number">0xa4</span>, <span class="number">0x55</span>, <span class="number">0x87</span>, <span class="number">0x5a</span>, <span class="number">0x58</span>, <span class="number">0xdb</span>, <span class="number">0x9e</span>, <span class="number">0x03</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tf_subkey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">key_t</span>* expand_key(<span class="keyword">uint8_t</span> *s, <span class="keyword">uint32_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">/* Pad factor */</span></span><br><span class="line">    <span class="keyword">if</span> (len&lt;<span class="number">16</span>)       n = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (len&lt;<span class="number">24</span>)  n = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (len&lt;<span class="number">32</span>)  n = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">key_t</span>* tf_key = (<span class="keyword">key_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">key_t</span>));</span><br><span class="line">    <span class="keyword">uint8_t</span>* ss = (<span class="keyword">uint8_t</span>*)<span class="built_in">malloc</span>(n);</span><br><span class="line">    <span class="comment">/* Do actual padding. */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> g=<span class="number">0</span>; g&lt;n; ++g)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            *(ss+g) = *(s+g);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *(ss+g) = <span class="number">0x00</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tf_key-&gt;k = ss;</span><br><span class="line">    tf_key-&gt;len=n;</span><br><span class="line">    <span class="keyword">return</span> tf_key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> gf(<span class="keyword">uint8_t</span> x, <span class="keyword">uint8_t</span> y, <span class="keyword">uint16_t</span> m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> c, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">0x1</span>)</span><br><span class="line">            p ^= x;</span><br><span class="line">        c = x &amp; <span class="number">0x80</span>;</span><br><span class="line">        x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (c)</span><br><span class="line">            x ^= m;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>写一个main函数直接调用即可。</p><h2 id="CTF出题变化分析"><a href="#CTF出题变化分析" class="headerlink" title="CTF出题变化分析"></a>CTF出题变化分析</h2><p>TwoFish算法共有三处可发生变化以提高出题难度</p><ol><li>rsm函数，0x14d可替换为其他数字</li><li>Twofish_generate_ext_s_keys函数中gf的参数0x166可替换</li><li>Twofish_mds_mul函数中gf的参数0x166可替换</li></ol><p>对于这类分组加密算法，即使插件没有识别，只要看出相关函数结构，就可以很快确定具体算法，找到可能变化的参数，相应修改解密函数即可</p><p>附件中附上了题目和idb文件供自行分析</p><p>From <a href="https://kabeor.github.io/逆向分析加解密之TwoFish算法/">https://kabeor.github.io/逆向分析加解密之TwoFish算法/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逆向分析加解密之TwoFish算法&quot;&gt;&lt;a href=&quot;#逆向分析加解密之TwoFish算法&quot; class=&quot;headerlink&quot; title=&quot;逆向分析加解密之TwoFish算法&quot;&gt;&lt;/a&gt;逆向分析加解密之TwoFish算法&lt;/h1&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="TwoFish算法" scheme="https://kabeor.github.io/tags/TwoFish%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Capstone反汇编引擎数据类型及API分析及示例(三)</title>
    <link href="https://kabeor.github.io/Capstone%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E5%8F%8A%E7%A4%BA%E4%BE%8B(%E4%B8%89)/"/>
    <id>https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(三)/</id>
    <published>2019-07-22T05:20:08.274Z</published>
    <updated>2019-07-29T04:08:28.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Capstone反汇编引擎数据类型及API分析及示例-三"><a href="#Capstone反汇编引擎数据类型及API分析及示例-三" class="headerlink" title="Capstone反汇编引擎数据类型及API分析及示例(三)"></a>Capstone反汇编引擎数据类型及API分析及示例(三)</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5772" target="_blank" rel="noopener">https://xz.aliyun.com/t/5772</a></p></blockquote><h2 id="API分析"><a href="#API分析" class="headerlink" title="API分析"></a>API分析</h2><h3 id="cs-open"><a href="#cs-open" class="headerlink" title="cs_open"></a>cs_open</h3><p><code>cs_err CAPSTONE_API cs_open(cs_arch arch, cs_mode mode, csh *handle);</code></p><p>初始化cs句柄</p><p>参数<br>arch: 架构类型 (CS<em>ARCH</em><em>)<br>mode: 硬件模式. CS<em>MODE</em></em>在cs_mode数据类型中可查<br>handle: 指向句柄, 返回时更新<br>return: 创建成功返回CS_ERR_OK，否则返回cs_err枚举中对应的错误信息</p><p>实现代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_open</span><span class="params">(cs_arch arch, cs_mode mode, csh *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">ud</span>;</span></span><br><span class="line"><span class="keyword">if</span> (!cs_mem_malloc || !cs_mem_calloc || !cs_mem_realloc || !cs_mem_free || !cs_vsnprintf)</span><br><span class="line"><span class="comment">// Error: 使用cs_open()前, 必须使用cs_option(CS_OPT_MEM)进行动态内存管理的初始化</span></span><br><span class="line"><span class="keyword">return</span> CS_ERR_MEMSETUP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arch &lt; CS_ARCH_MAX &amp;&amp; cs_arch_init[arch]) &#123;</span><br><span class="line"><span class="comment">// 验证架构是否使用，方式：架构在枚举中且可初始化</span></span><br><span class="line"><span class="keyword">if</span> (mode &amp; cs_arch_disallowed_mode_mask[arch]) &#123;</span><br><span class="line">*handle = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_MODE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ud = cs_mem_calloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(*ud));</span><br><span class="line"><span class="keyword">if</span> (!ud) &#123;</span><br><span class="line"><span class="comment">// 内存不足</span></span><br><span class="line"><span class="keyword">return</span> CS_ERR_MEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ud-&gt;errnum = CS_ERR_OK;</span><br><span class="line">ud-&gt;arch = arch;</span><br><span class="line">ud-&gt;mode = mode;</span><br><span class="line"><span class="comment">// 默认情况指令不打开detail模式</span></span><br><span class="line">ud-&gt;detail = CS_OPT_OFF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认skipdata设置</span></span><br><span class="line">ud-&gt;skipdata_setup.mnemonic = SKIPDATA_MNEM;</span><br><span class="line"></span><br><span class="line">err = cs_arch_init[ud-&gt;arch](ud);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">cs_mem_free(ud);</span><br><span class="line">*handle = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*handle = (<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*handle = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_ARCH;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，cs_struct结构体包含更多细节设定，如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line">Printer_t printer;<span class="comment">// 打印asm</span></span><br><span class="line"><span class="keyword">void</span> *printer_info; <span class="comment">// 打印信息</span></span><br><span class="line">Disasm_t disasm;<span class="comment">// 反编译</span></span><br><span class="line"><span class="keyword">void</span> *getinsn_info; <span class="comment">// 打印辅助信息</span></span><br><span class="line">GetName_t reg_name;</span><br><span class="line">GetName_t insn_name;</span><br><span class="line">GetName_t group_name;</span><br><span class="line">GetID_t insn_id;</span><br><span class="line">PostPrinter_t post_printer;</span><br><span class="line">cs_err errnum;</span><br><span class="line">ARM_ITStatus ITBlock;<span class="comment">// ARM特殊选项</span></span><br><span class="line">cs_opt_value detail, imm_unsigned;</span><br><span class="line"><span class="keyword">int</span> syntax;<span class="comment">//ARM, Mips &amp; PPC等架构的基本asm语法打印</span></span><br><span class="line"><span class="keyword">bool</span> doing_mem;<span class="comment">// 在InstPrinter代码中处理内存操作数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> *insn_cache;<span class="comment">//为mapping.c建立缓存索引</span></span><br><span class="line">GetRegisterName_t get_regname;</span><br><span class="line"><span class="keyword">bool</span> skipdata;<span class="comment">// 如果反编译时要跳过数据，该项设置为True</span></span><br><span class="line"><span class="keyword">uint8_t</span> skipdata_size;<span class="comment">//要跳过bytes的数量</span></span><br><span class="line">cs_opt_skipdata skipdata_setup;<span class="comment">// 自定义skipdata设置</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *regsize_map;<span class="comment">//映射register大小 (目前仅支持x86)</span></span><br><span class="line">GetRegisterAccess_t reg_access;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insn_mnem</span> *<span class="title">mnem_list</span>;</span><span class="comment">// 自定义指令助记符的链接list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例(创建一个x86_64类型的cs句柄)：<br><code>cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)</code></p><h3 id="cs-close"><a href="#cs-close" class="headerlink" title="cs_close"></a>cs_close</h3><p><code>cs_err CAPSTONE_API cs_close(csh *handle);</code></p><p>释放句柄<br>参数<br>handle: 指向一个cs_open()打开的句柄<br>return: 释放成功返回CS_ERR_OK,否则返回cs_err枚举的错误信息</p><p>实现代码，可以看出释放句柄实质为将句柄值设置为0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_close</span><span class="params">(csh *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">ud</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insn_mnem</span> *<span class="title">next</span>, *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*handle == <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 句柄不可用</span></span><br><span class="line"><span class="keyword">return</span> CS_ERR_CSH;</span><br><span class="line"></span><br><span class="line">ud = (struct cs_struct *)(*handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ud-&gt;printer_info)</span><br><span class="line">cs_mem_free(ud-&gt;printer_info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放自定义助记符的链接list</span></span><br><span class="line">tmp = ud-&gt;mnem_list;</span><br><span class="line"><span class="keyword">while</span>(tmp) &#123;</span><br><span class="line">next = tmp-&gt;next;</span><br><span class="line">cs_mem_free(tmp);</span><br><span class="line">tmp = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_mem_free(ud-&gt;insn_cache);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(ud, <span class="number">0</span>, <span class="keyword">sizeof</span>(*ud));</span><br><span class="line">cs_mem_free(ud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle值设置为0，保证这个句柄在cs_close()释放后不可使用</span></span><br><span class="line">*handle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：<br><code>cs_close(&amp;handle);</code></p><h3 id="cs-option"><a href="#cs-option" class="headerlink" title="cs_option"></a>cs_option</h3><p><code>cs_err CAPSTONE_API cs_option(csh handle, cs_opt_type type, size_t value);</code></p><p>反编译引擎的运行时选项</p><p>handle: cs_open()打开的句柄<br>type: 设置选项的类型<br>value: 与type对应的选项值<br>return: 设置成功返回CS_ERR_OK,否则返回cs_err枚举的错误信息</p><p>注意: 在CS_OPT_MEM的情况下，handle可以是任何值，因此cs_option(handle, CS_OPT_MEM, value)必须在cs_open()之前被调用</p><p>实现代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_option</span><span class="params">(csh ud, cs_opt_type type, <span class="keyword">size_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line">cs_opt_mnem *opt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持在所有API前支持 (even cs_open())</span></span><br><span class="line"><span class="keyword">if</span> (type == CS_OPT_MEM) &#123;</span><br><span class="line">cs_opt_mem *mem = (cs_opt_mem *)value;</span><br><span class="line"></span><br><span class="line">cs_mem_malloc = mem-&gt;<span class="built_in">malloc</span>;</span><br><span class="line">cs_mem_calloc = mem-&gt;<span class="built_in">calloc</span>;</span><br><span class="line">cs_mem_realloc = mem-&gt;<span class="built_in">realloc</span>;</span><br><span class="line">cs_mem_free = mem-&gt;<span class="built_in">free</span>;</span><br><span class="line">cs_vsnprintf = mem-&gt;vsnprintf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"><span class="keyword">if</span> (!handle)</span><br><span class="line"><span class="keyword">return</span> CS_ERR_CSH;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_UNSIGNED:</span><br><span class="line">handle-&gt;imm_unsigned = (cs_opt_value)value;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_DETAIL:</span><br><span class="line">handle-&gt;detail = (cs_opt_value)value;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_SKIPDATA:</span><br><span class="line">handle-&gt;skipdata = (value == CS_OPT_ON);</span><br><span class="line"><span class="keyword">if</span> (handle-&gt;skipdata) &#123;</span><br><span class="line"><span class="keyword">if</span> (handle-&gt;skipdata_size == <span class="number">0</span>) &#123;</span><br><span class="line">handle-&gt;skipdata_size = skipdata_size(handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_SKIPDATA_SETUP:</span><br><span class="line"><span class="keyword">if</span> (value)</span><br><span class="line">handle-&gt;skipdata_setup = *((cs_opt_skipdata *)value);</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_MNEMONIC:</span><br><span class="line">opt = (cs_opt_mnem *)value;</span><br><span class="line"><span class="keyword">if</span> (opt-&gt;id) &#123;</span><br><span class="line"><span class="keyword">if</span> (opt-&gt;mnemonic) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insn_mnem</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新指令或替换现有指令</span></span><br><span class="line"><span class="comment">// 查看当前insn释放在list中</span></span><br><span class="line">tmp = handle-&gt;mnem_list;</span><br><span class="line"><span class="keyword">while</span>(tmp) &#123;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;insn.id == opt-&gt;id) &#123;</span><br><span class="line"><span class="comment">// f找到指令，替换助记符</span></span><br><span class="line">(<span class="keyword">void</span>)<span class="built_in">strncpy</span>(tmp-&gt;insn.mnemonic, opt-&gt;mnemonic, <span class="keyword">sizeof</span>(tmp-&gt;insn.mnemonic) - <span class="number">1</span>);</span><br><span class="line">tmp-&gt;insn.mnemonic[<span class="keyword">sizeof</span>(tmp-&gt;insn.mnemonic) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 如果没有就添加这条指令</span></span><br><span class="line"><span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">tmp = cs_mem_malloc(<span class="keyword">sizeof</span>(*tmp));</span><br><span class="line">tmp-&gt;insn.id = opt-&gt;id;</span><br><span class="line">(<span class="keyword">void</span>)<span class="built_in">strncpy</span>(tmp-&gt;insn.mnemonic, opt-&gt;mnemonic, <span class="keyword">sizeof</span>(tmp-&gt;insn.mnemonic) - <span class="number">1</span>);</span><br><span class="line">tmp-&gt;insn.mnemonic[<span class="keyword">sizeof</span>(tmp-&gt;insn.mnemonic) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="comment">// 新指令放在list最前面</span></span><br><span class="line">tmp-&gt;next = handle-&gt;mnem_list;</span><br><span class="line">handle-&gt;mnem_list = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">struct insn_mnem *prev, *tmp;</span><br><span class="line"></span><br><span class="line">tmp = handle-&gt;mnem_list;</span><br><span class="line">prev = tmp;</span><br><span class="line"><span class="keyword">while</span>(tmp) &#123;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;insn.id == opt-&gt;id) &#123;</span><br><span class="line"><span class="comment">// 删除指令</span></span><br><span class="line"><span class="keyword">if</span> (tmp == prev) &#123;</span><br><span class="line">handle-&gt;mnem_list = tmp-&gt;next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">prev-&gt;next = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cs_mem_free(tmp);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">prev = tmp;</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_MODE:</span><br><span class="line"><span class="comment">// 验证所请求的模式是否有效</span></span><br><span class="line"><span class="keyword">if</span> (value &amp; cs_arch_disallowed_mode_mask[handle-&gt;arch]) &#123;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OPTION;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cs_arch_option[handle-&gt;arch](handle, type, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例，更改反汇编后显示的语法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cs_option(handle, CS_OPT_SYNTAX, CS_OPT_SYNTAX_ATT);  <span class="comment">// 以AT&amp;T语法显示</span></span><br><span class="line">count = cs_disasm(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0x1000</span>, <span class="number">0</span>, &amp;insn);</span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span><span class="string">"Ix"</span><span class="string">":\t%s\t\t%s\n"</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disassemble given code!\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出</p><p><img src="https://i.loli.net/2019/07/22/5d35b1e72c20515640.jpg" alt></p><h3 id="cs-errno"><a href="#cs-errno" class="headerlink" title="cs_errno"></a>cs_errno</h3><p><code>cs_err CAPSTONE_API cs_errno(csh handle);</code></p><p>API出错时返回错误消息<br>参数<br>handle: cs_open()打开的句柄<br>return: 无错误返回CS_ERR_OK,否则返回cs_err枚举的错误信息</p><p>实现很简单，判断到句柄不存在直接返回CS_ERR_CSH</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle = <span class="number">0</span>;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cs_errno(handle);    <span class="comment">//关闭句柄后检查将报错</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出，错误码4即CS_ERR_CSH<br><img src="https://i.loli.net/2019/07/22/5d35bad79c9c384228.jpg" alt></p><h3 id="cs-strerror"><a href="#cs-strerror" class="headerlink" title="cs_strerror"></a>cs_strerror</h3><p><code>const char * CAPSTONE_API cs_strerror(cs_err code);</code></p><p>将上个API输出的错误码转换为详细错误信息</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * CAPSTONE_API <span class="title">cs_strerror</span><span class="params">(cs_err code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(code) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Unknown error code"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_OK:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"OK (CS_ERR_OK)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_MEM:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Out of memory (CS_ERR_MEM)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_ARCH:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid/unsupported architecture(CS_ERR_ARCH)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_HANDLE:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid handle (CS_ERR_HANDLE)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_CSH:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid csh (CS_ERR_CSH)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_MODE:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid mode (CS_ERR_MODE)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_OPTION:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid option (CS_ERR_OPTION)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_DETAIL:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Details are unavailable (CS_ERR_DETAIL)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_MEMSETUP:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Dynamic memory management uninitialized (CS_ERR_MEMSETUP)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_VERSION:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Different API version between core &amp; binding (CS_ERR_VERSION)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_DIET:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Information irrelevant in diet engine (CS_ERR_DIET)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_SKIPDATA:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Information irrelevant for 'data' instruction in SKIPDATA mode (CS_ERR_SKIPDATA)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_X86_ATT:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"AT&amp;T syntax is unavailable (CS_ERR_X86_ATT)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_X86_INTEL:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"INTEL syntax is unavailable (CS_ERR_X86_INTEL)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_X86_MASM:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"MASM syntax is unavailable (CS_ERR_X86_MASM)"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例，结合cs_errno使用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle = <span class="number">0</span>;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cs_strerror(cs_errno(handle));  <span class="comment">//直接输出报错信息</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/22/5d35bc1db170a33360.jpg" alt></p><h3 id="cs-disasm"><a href="#cs-disasm" class="headerlink" title="cs_disasm"></a>cs_disasm</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="function">CAPSTONE_API <span class="title">cs_disasm</span><span class="params">(csh handle,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *code, <span class="keyword">size_t</span> code_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">uint64_t</span> address,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">cs_insn **insn)</span></span>;</span><br></pre></td></tr></table></figure><p>给定缓冲区、大小、地址和编号，反编译机器码<br>API动态地分配内存来包含分解的指令，生成的指令将放在*insn中</p><p>注意： 必须释放分配的内存，以避免内存泄漏。对于需要动态分配稀缺内存的系统(如OS内核或固件)，API cs_disasm_iter()可能是比cs_disasm()更好的选择。原因是，使用cs_disasm()时，基于有限的可用内存，必须预先计算要分解多少条指令。</p><p>handle: cs_open()返回的句柄<br>code: 包含要反汇编的机器码的缓冲区。<br>code_size:上面代码缓冲区的大小。<br>address:给定原始代码缓冲区中的第一条指令的地址。<br>insn: 由这个API填写的指令数组。注意: insn将由这个函数分配，应该用cs_free () API释放<br>count: 需要分解的指令数量，或输入0分解所有指令<br>return:成功反汇编指令的数量，如果该函数未能反汇编给定的代码，则为0，失败时，调用cs_errno()获取错误代码。</p><p>源码分析</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="function">CAPSTONE_API <span class="title">cs_disasm</span><span class="params">(csh ud, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">uint64_t</span> offset, <span class="keyword">size_t</span> count, cs_insn **insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line">MCInst mci;</span><br><span class="line"><span class="keyword">uint16_t</span> insn_size;</span><br><span class="line"><span class="keyword">size_t</span> c = <span class="number">0</span>, i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> f = <span class="number">0</span>;<span class="comment">// 缓存中下一条指令的索引</span></span><br><span class="line">cs_insn *insn_cache;<span class="comment">// 缓存反汇编后的指令</span></span><br><span class="line"><span class="keyword">void</span> *total = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span> total_size = <span class="number">0</span>;<span class="comment">//所有insn的输出缓冲区的总大小</span></span><br><span class="line"><span class="keyword">bool</span> r;</span><br><span class="line"><span class="keyword">void</span> *tmp;</span><br><span class="line"><span class="keyword">size_t</span> skipdata_bytes;</span><br><span class="line"><span class="keyword">uint64_t</span> offset_org; <span class="comment">// 保存缓冲区的所有原始信息</span></span><br><span class="line"><span class="keyword">size_t</span> size_org;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *buffer_org;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cache_size = INSN_CACHE_SIZE;</span><br><span class="line"><span class="keyword">size_t</span> next_offset;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"><span class="keyword">if</span> (!handle) &#123;</span><br><span class="line"><span class="comment">// 修复方式:</span></span><br><span class="line"><span class="comment">// handle-&gt;errnum = CS_ERR_HANDLE;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重设ARM架构的IT block</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;arch == CS_ARCH_ARM)</span><br><span class="line">handle-&gt;ITBlock.size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_USE_SYS_DYN_MEM</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; count &lt;= INSN_CACHE_SIZE)</span><br><span class="line">cache_size = (<span class="keyword">unsigned</span> <span class="keyword">int</span>) count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存SKIPDATA原始偏移量</span></span><br><span class="line">buffer_org = buffer;</span><br><span class="line">offset_org = offset;</span><br><span class="line">size_org = size;</span><br><span class="line"></span><br><span class="line">total_size = <span class="keyword">sizeof</span>(cs_insn) * cache_size;</span><br><span class="line">total = cs_mem_malloc(total_size);</span><br><span class="line"><span class="keyword">if</span> (total == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// 内存不足</span></span><br><span class="line">handle-&gt;errnum = CS_ERR_MEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insn_cache = total;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">MCInst_Init(&amp;mci);</span><br><span class="line">mci.csh = handle;</span><br><span class="line"></span><br><span class="line">mci.address = offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;detail) &#123;</span><br><span class="line"><span class="comment">//给detail指针分配内存</span></span><br><span class="line">insn_cache-&gt;detail = cs_mem_malloc(<span class="keyword">sizeof</span>(cs_detail));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">insn_cache-&gt;detail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为non-detailed模式保存所有信息</span></span><br><span class="line">mci.flat_insn = insn_cache;</span><br><span class="line">mci.flat_insn-&gt;address = offset;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line"><span class="comment">//mnemonic &amp; op_str0填充</span></span><br><span class="line">mci.flat_insn-&gt;mnemonic[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">mci.flat_insn-&gt;op_str[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">r = handle-&gt;disasm(ud, buffer, size, &amp;mci, &amp;insn_size, offset, handle-&gt;getinsn_info);</span><br><span class="line"><span class="keyword">if</span> (r) &#123;</span><br><span class="line">SStream ss;</span><br><span class="line">SStream_Init(&amp;ss);</span><br><span class="line"></span><br><span class="line">mci.flat_insn-&gt;size = insn_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内部指令操作码映射到公共insn ID</span></span><br><span class="line">handle-&gt;insn_id(handle, insn_cache, mci.Opcode);</span><br><span class="line"></span><br><span class="line">handle-&gt;printer(&amp;mci, &amp;ss, handle-&gt;printer_info);</span><br><span class="line">fill_insn(handle, insn_cache, ss.buffer, &amp;mci, handle-&gt;post_printer, buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整opcode (X86)</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;arch == CS_ARCH_X86)</span><br><span class="line">insn_cache-&gt;id += mci.popcode_adjust;</span><br><span class="line"></span><br><span class="line">next_offset = insn_size;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 遇到中断指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为detail指针释放内存</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;detail) &#123;</span><br><span class="line">cs_mem_free(insn_cache-&gt;detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!handle-&gt;skipdata || handle-&gt;skipdata_size &gt; size)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;skipdata_setup.callback) &#123;</span><br><span class="line">skipdata_bytes = handle-&gt;skipdata_setup.callback(buffer_org, size_org,</span><br><span class="line">(<span class="keyword">size_t</span>)(offset - offset_org), handle-&gt;skipdata_setup.user_data);</span><br><span class="line"><span class="keyword">if</span> (skipdata_bytes &gt; size)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!skipdata_bytes)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">skipdata_bytes = handle-&gt;skipdata_size;</span><br><span class="line"></span><br><span class="line">insn_cache-&gt;id = <span class="number">0</span>;</span><br><span class="line">insn_cache-&gt;address = offset;</span><br><span class="line">insn_cache-&gt;size = (<span class="keyword">uint16_t</span>)skipdata_bytes;</span><br><span class="line"><span class="built_in">memcpy</span>(insn_cache-&gt;bytes, buffer, skipdata_bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line">insn_cache-&gt;mnemonic[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">insn_cache-&gt;op_str[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="built_in">strncpy</span>(insn_cache-&gt;mnemonic, handle-&gt;skipdata_setup.mnemonic,</span><br><span class="line"><span class="keyword">sizeof</span>(insn_cache-&gt;mnemonic) - <span class="number">1</span>);</span><br><span class="line">skipdata_opstr(insn_cache-&gt;op_str, buffer, skipdata_bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">insn_cache-&gt;detail = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">next_offset = skipdata_bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一条新指令进入缓存</span></span><br><span class="line">f++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反汇编了一条指令</span></span><br><span class="line">c++;</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; c == count)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (f == cache_size) &#123;</span><br><span class="line">cache_size = cache_size * <span class="number">8</span> / <span class="number">5</span>; </span><br><span class="line">total_size += (<span class="keyword">sizeof</span>(cs_insn) * cache_size);</span><br><span class="line">tmp = cs_mem_realloc(total, total_size);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;<span class="comment">//内存不足</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;detail) &#123;</span><br><span class="line">insn_cache = (cs_insn *)total;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; c; i++, insn_cache++)</span><br><span class="line">cs_mem_free(insn_cache-&gt;detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_mem_free(total);</span><br><span class="line">*insn = <span class="literal">NULL</span>;</span><br><span class="line">handle-&gt;errnum = CS_ERR_MEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total = tmp;</span><br><span class="line"><span class="comment">//在最后一条指令之后继续填充缓存</span></span><br><span class="line">insn_cache = (cs_insn *)((<span class="keyword">char</span> *)total + <span class="keyword">sizeof</span>(cs_insn) * c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将f重置为0，从一开始就填入缓存</span></span><br><span class="line">f = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">insn_cache++;</span><br><span class="line"></span><br><span class="line">buffer += next_offset;</span><br><span class="line">size -= next_offset;</span><br><span class="line">offset += next_offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!c) &#123;</span><br><span class="line"><span class="comment">//未反汇编任何指令</span></span><br><span class="line">cs_mem_free(total);</span><br><span class="line">total = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (f != cache_size) &#123;</span><br><span class="line"><span class="comment">// 没有完全使用最后一个缓存，缩小大小</span></span><br><span class="line">tmp = cs_mem_realloc(total, total_size - (cache_size - f) * <span class="keyword">sizeof</span>(*insn_cache));</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;<span class="comment">// 内存不足</span></span><br><span class="line"><span class="comment">// 释放所有detail指针</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;detail) &#123;</span><br><span class="line">insn_cache = (cs_insn *)total;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; c; i++, insn_cache++)</span><br><span class="line">cs_mem_free(insn_cache-&gt;detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_mem_free(total);</span><br><span class="line">*insn = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_MEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*insn = total;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例，x86_64:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle = <span class="number">0</span>;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count = cs_disasm(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0x1000</span>, <span class="number">0</span>, &amp;insn);   <span class="comment">//所有指令，基址0x1000，放入insn</span></span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span><span class="string">"Ix"</span><span class="string">":\t%s\t\t%s\n"</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disassemble given code!\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出</p><p><img src="https://i.loli.net/2019/07/22/5d35c5087d17d31194.jpg" alt></p><p>From <a href="https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(三">https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(三)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Capstone反汇编引擎数据类型及API分析及示例-三&quot;&gt;&lt;a href=&quot;#Capstone反汇编引擎数据类型及API分析及示例-三&quot; class=&quot;headerlink&quot; title=&quot;Capstone反汇编引擎数据类型及API分析及示例(三)&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="反汇编" scheme="https://kabeor.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Capstone反汇编引擎数据类型及API分析及示例(二)</title>
    <link href="https://kabeor.github.io/Capstone%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E5%8F%8A%E7%A4%BA%E4%BE%8B(%E4%BA%8C)/"/>
    <id>https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(二)/</id>
    <published>2019-07-21T04:55:52.086Z</published>
    <updated>2019-07-27T02:17:41.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Capstone反汇编引擎数据类型及API分析及示例-二"><a href="#Capstone反汇编引擎数据类型及API分析及示例-二" class="headerlink" title="Capstone反汇编引擎数据类型及API分析及示例(二)"></a>Capstone反汇编引擎数据类型及API分析及示例(二)</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5761" target="_blank" rel="noopener">https://xz.aliyun.com/t/5761</a></p></blockquote><p>上篇分析了Capstone开放的数据类型，下面就来正式看看API吧<br>官方开放的API只有二十个左右，但为了能写的更易懂，我将结合实例，分多篇写。<br>API中作者将capstone缩写为cs，下面我也用这种方式描述</p><h2 id="API分析"><a href="#API分析" class="headerlink" title="API分析"></a>API分析</h2><h3 id="cs-malloc-t"><a href="#cs-malloc-t" class="headerlink" title="cs_malloc_t"></a>cs_malloc_t</h3><p><code>void* (CAPSTONE_API *cs_malloc_t)(size_t size);</code></p><p>cs的动态内存分配，用于<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_mem</span> &#123;</span></span><br><span class="line"><span class="keyword">cs_malloc_t</span> <span class="built_in">malloc</span>;</span><br><span class="line"><span class="keyword">cs_calloc_t</span> <span class="built_in">calloc</span>;</span><br><span class="line"><span class="keyword">cs_realloc_t</span> <span class="built_in">realloc</span>;</span><br><span class="line"><span class="keyword">cs_free_t</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="keyword">cs_vsnprintf_t</span> vsnprintf;</span><br><span class="line">&#125; cs_opt_mem;</span><br></pre></td></tr></table></figure></p><p>cs_malloc_t定义于capstone.lib和capstone.dll的cs.c中，<br><img src="https://i.loli.net/2019/07/21/5d33f804831d248926.jpg" alt></p><blockquote><p>在用户模式下，cs_mem_malloc默认使用系统malloc</p><p>Windows driver模式下，<code>cs_malloc_t cs_mem_malloc = cs_winkernel_malloc;</code><br>cs_winkernel_malloc定义于\capstone-4.0.1\windows\winkernel_mm.c,</p></blockquote><p>实现代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * CAPSTONE_API <span class="title">cs_winkernel_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 长度不能分配为0</span></span><br><span class="line">NT_ASSERT(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// FP; NonPagedPool用于支持 Windows 7 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> prefast(suppress : 30030)<span class="comment">// 分配可执行的POOL_TYPE内存</span></span></span><br><span class="line"><span class="keyword">size_t</span> number_of_bytes = <span class="number">0</span>;</span><br><span class="line">CS_WINKERNEL_MEMBLOCK *block = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 特定的值能造成溢出</span></span><br><span class="line"><span class="comment">// 如果value中的和超出或低于类型容量，函数将返回NULL。</span></span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(RtlSizeTAdd(size, <span class="keyword">sizeof</span>(CS_WINKERNEL_MEMBLOCK), &amp;number_of_bytes))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(</span><br><span class="line">NonPagedPool, number_of_bytes, CS_WINKERNEL_POOL_TAG);</span><br><span class="line"><span class="keyword">if</span> (!block) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">block-&gt;size = size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> block-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>OSX kernel模式下，<code>cs_malloc_t cs_mem_malloc = kern_os_malloc;</code>，这里暂且不探讨。</p></blockquote><h3 id="cs-calloc-t"><a href="#cs-calloc-t" class="headerlink" title="cs_calloc_t"></a>cs_calloc_t</h3><p><code>void* (CAPSTONE_API *cs_calloc_t)(size_t nmemb, size_t size);</code></p><p>cs申请内存并初始化<br>用于<code>struct cs_opt_mem</code>，定义于cs.c<br>用户模式： <code>cs_calloc_t cs_mem_calloc = calloc;</code>,使用系统calloc<br>Windows driver模式： <code>cs_calloc_t cs_mem_calloc = cs_winkernel_calloc;</code><br>实现代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * CAPSTONE_API <span class="title">cs_winkernel_calloc</span><span class="params">(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> total = n * size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *new_ptr = cs_winkernel_malloc(total);</span><br><span class="line"><span class="keyword">if</span> (!new_ptr) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> RtlFillMemory(new_ptr, total, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OSX kernel模式： <code>cs_calloc_t cs_mem_calloc = cs_kern_os_calloc;</code><br><img src="https://i.loli.net/2019/07/21/5d340703367d259403.jpg" alt><br>直接调用kern_os_malloc了</p><h3 id="cs-realloc-t"><a href="#cs-realloc-t" class="headerlink" title="cs_realloc_t"></a>cs_realloc_t</h3><p><code>void* (CAPSTONE_API *cs_realloc_t)(void *ptr, size_t size);</code></p><p>cs重新分配内存<br>用于<code>struct cs_opt_mem</code>，定义于cs.c<br>用户模式： <code>cs_realloc_t cs_mem_realloc = realloc;</code>,调用系统realloc<br>Windows driver模式： <code>cs_realloc_t cs_mem_realloc = cs_winkernel_realloc;</code></p><p>实现代码，可以看出是利用cs_winkernel_malloc重新申请</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * CAPSTONE_API <span class="title">cs_winkernel_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *new_ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span> current_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> smaller_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line"><span class="keyword">return</span> cs_winkernel_malloc(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_ptr = cs_winkernel_malloc(size);</span><br><span class="line"><span class="keyword">if</span> (!new_ptr) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">current_size = CONTAINING_RECORD(ptr, CS_WINKERNEL_MEMBLOCK, data)-&gt;size;</span><br><span class="line">smaller_size = (current_size &lt; size) ? current_size : size;</span><br><span class="line">RtlCopyMemory(new_ptr, ptr, smaller_size);</span><br><span class="line">cs_winkernel_free(ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> new_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OSX kernel模式： <code>cs_realloc_t cs_mem_realloc = kern_os_realloc;</code></p><h3 id="cs-free-t"><a href="#cs-free-t" class="headerlink" title="cs_free_t"></a>cs_free_t</h3><p><code>typedef void (CAPSTONE_API *cs_free_t)(void *ptr);</code></p><p>cs释放内存<br>用于<code>struct cs_opt_mem</code>，定义于cs.c<br>用户模式： <code>cs_free_t cs_mem_free = free;</code>,调用系统free<br>Windows driver模式： <code>cs_free_t cs_mem_free = cs_winkernel_free;</code></p><p>实现代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> CAPSTONE_API <span class="title">cs_winkernel_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">ExFreePoolWithTag(CONTAINING_RECORD(ptr, CS_WINKERNEL_MEMBLOCK, data), CS_WINKERNEL_POOL_TAG);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OSX kernel模式：  <code>cs_free_t cs_mem_free = kern_os_free;</code></p><h3 id="cs-vsnprintf-t"><a href="#cs-vsnprintf-t" class="headerlink" title="cs_vsnprintf_t"></a>cs_vsnprintf_t</h3><p><code>int (CAPSTONE_API *cs_vsnprintf_t)(char *str, size_t size, const char *format, va_list ap);</code></p><p>按size大小输出到字符串str中</p><p>用户模式：<br><img src="https://i.loli.net/2019/07/21/5d340c613ba1e61273.jpg" alt><br>值得注意的是，如果系统为wince，将使用_vsnprintf函数<br>vsnprintf ()和_vsnprintf()对于驱动程序都是可用的，但是它们有一些不同。<br>在需要返回值和设置空终止符时应使用vsnprintf()</p><p>vsnprintf定义在stdio.h<br><img src="https://i.loli.net/2019/07/21/5d340d423babc62961.jpg" alt></p><p>Windows driver模式： <code>cs_vsnprintf_t cs_vsnprintf = cs_winkernel_vsnprintf;</code></p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> CAPSTONE_API <span class="title">cs_winkernel_vsnprintf</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list argptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = _vsnprintf(buffer, count, format, argptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// _vsnprintf()在字符串被截断时返回-1，在整个字符串被存储但“buffer”末尾没有“\0”时返回“count”。在这两种情况下，都需要手动添加空终止符。</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">-1</span> || (<span class="keyword">size_t</span>)result == count) &#123;</span><br><span class="line">buffer[count - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">// 在返回-1时，函数必须获取并返回一些本来要写入的字符。因此，通过重试使用temp buffer进行相同的转换，这个缓冲区就可能足够大来完成格式化，并且获得很多本应写入的字符。</span></span><br><span class="line"><span class="keyword">char</span>* tmp = cs_winkernel_malloc(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = _vsnprintf(tmp, <span class="number">0x1000</span>, format, argptr);</span><br><span class="line">NT_ASSERT(result != <span class="number">-1</span>);</span><br><span class="line">cs_winkernel_free(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OSX kernel模式： <code>cs_vsnprintf_t cs_vsnprintf = vsnprintf;</code>，使用默认vsnprintf</p><h3 id="cs-skipdata-cb-t"><a href="#cs-skipdata-cb-t" class="headerlink" title="cs_skipdata_cb_t"></a>cs_skipdata_cb_t</h3><p>size_t (CAPSTONE_API <em>cs_skipdata_cb_t)(const uint8_t </em>code, size_t code_size, size_t offset, void *user_data);</p><p>SKIPDATA选项的用户自定义回调函数。</p><p>code:包含要分解的代码的输入缓冲区。和传递给cs_disasm()的缓冲区相同。<br>code_size:上面的code缓冲区的大小(以字节为单位)。<br>offset:上面提到的输入缓冲区code中当前检查字节的位置。<br>user_data:用户数据通过cs_opt_skipdata结构中的@user_data字段传递给cs_option()。<br>return:返回要跳过的字节数，或者0表示立即停止反汇编。</p><p>cs_skipdata_cb_t在<code>struct cs_opt_skipdata</code>中调用，下面来看一个例子<br>分析写在注释中<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">cs_opt_type opt_skipdata;</span><br><span class="line"><span class="keyword">size_t</span> skipdata;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span>  <span class="comment">//输出机器码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE32 <span class="meta-string">"\x8d\x4c\x32\x08\x01\xd8\x81\xc6\x34\x12\x00\x00\x00\x91\x92"</span>  <span class="comment">//测试用机器码</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RANDOM_CODE <span class="meta-string">"\xed\x00\x00\x00\x00\x1a\x5a\x0f\x1f\xff\xc2\x09\x80\x00\x00\x00\x07\xf7\xeb\x2a\xff\xff\x7f\x57\xe3\x01\xff\xff\x7f\x57\xeb\x00\xf0\x00\x00\x24\xb2\x4f\x00\x78"</span></span></span><br><span class="line"></span><br><span class="line">cs_opt_skipdata skipdata = &#123;</span><br><span class="line"><span class="comment">// 把默认 "data" 描述符从 ".byte" 重命名为 "db"</span></span><br><span class="line"><span class="string">"db"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[2] = &#123;</span>         <span class="comment">//以默认描述符和自定义描述符两种方式建立一个数组</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_32,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE32,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 32 (Intel syntax) - Skip data"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_32,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE32,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 32 (Intel syntax) - Skip data with custom mnemonic"</span>,</span><br><span class="line">CS_OPT_INVALID,</span><br><span class="line">CS_OPT_OFF,</span><br><span class="line">CS_OPT_SKIPDATA_SETUP,</span><br><span class="line">(<span class="keyword">size_t</span>)&amp; skipdata,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;   <span class="comment">//建立capstone句柄</span></span><br><span class="line"><span class="keyword">uint64_t</span> address = <span class="number">0x1000</span>;  <span class="comment">//设置起始地址</span></span><br><span class="line">cs_insn* insn;  <span class="comment">//具体信息结构体</span></span><br><span class="line">cs_err err;  <span class="comment">//错误枚举</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">size_t</span> count;  <span class="comment">//成功反汇编行数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);  <span class="comment">//错误检查</span></span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开SKIPDATA 模式</span></span><br><span class="line">cs_option(handle, CS_OPT_SKIPDATA, CS_OPT_ON);</span><br><span class="line">cs_option(handle, platforms[i].opt_skipdata, platforms[i].skipdata);</span><br><span class="line"></span><br><span class="line">count = cs_disasm(handle, platforms[i].code, platforms[i].size, address, <span class="number">0</span>, &amp;insn);</span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;  <span class="comment">//输出汇编</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s\n"</span>,</span><br><span class="line">insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一行代码后打印偏移</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\n"</span>, insn[j - <span class="number">1</span>].address + insn[j - <span class="number">1</span>].size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放cs_disasm()申请的内存</span></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disasm given code!\n"</span>);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下，可以看出，默认的 .byte数据类型被改为db描述符<br><img src="https://i.loli.net/2019/07/21/5d3457518e35444335.jpg" alt></p><h3 id="cs-version"><a href="#cs-version" class="headerlink" title="cs_version"></a>cs_version</h3><p><code>unsigned int CAPSTONE_API cs_version(int *major, int *minor);</code></p><p>用来输出capstone版本号<br>参数<br>major: API主版本<br>minor: API次版本<br>return: 返回主次版本的16进制，如4.0版本返回 0x0400</p><p>通过分析源码发现<br><img src="https://i.loli.net/2019/07/21/5d345fe61e3c630129.jpg" alt></p><p><img src="https://i.loli.net/2019/07/21/5d34602a326f528259.jpg" alt><br>该版本定义于cs.c中，编译后不可更改，不接受自定义版本</p><p>示例1：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> cs_version(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> version = test();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%X"</span>, version);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/21/5d3465239ff2d14595.jpg" alt></p><p>示例2，强行修改版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ma[] = &#123; <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> mi[] = &#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cs_version(ma, mi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> version = test();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%X"</span>, version);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><img src="https://i.loli.net/2019/07/21/5d3465bc7716b49405.jpg" alt><br>可以看到并不能改变</p><h3 id="cs-support"><a href="#cs-support" class="headerlink" title="cs_support"></a>cs_support</h3><p>bool CAPSTONE_API cs_support(int query);</p><p>用来检查capstone库是否支持参数输入的架构或处于某编译选项<br>通过查看源码得知，共有四种查询参数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> CAPSTONE_API <span class="title">cs_support</span><span class="params">(<span class="keyword">int</span> query)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (query == CS_ARCH_ALL)</span><br><span class="line"><span class="keyword">return</span> all_arch == ((<span class="number">1</span> &lt;&lt; CS_ARCH_ARM) | (<span class="number">1</span> &lt;&lt; CS_ARCH_ARM64) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_MIPS) | (<span class="number">1</span> &lt;&lt; CS_ARCH_X86) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_PPC) | (<span class="number">1</span> &lt;&lt; CS_ARCH_SPARC) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_SYSZ) | (<span class="number">1</span> &lt;&lt; CS_ARCH_XCORE) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_M68K) | (<span class="number">1</span> &lt;&lt; CS_ARCH_TMS320C64X) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_M680X) | (<span class="number">1</span> &lt;&lt; CS_ARCH_EVM));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)query &lt; CS_ARCH_MAX)</span><br><span class="line"><span class="keyword">return</span> all_arch &amp; (<span class="number">1</span> &lt;&lt; query);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (query == CS_SUPPORT_DIET) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (query == CS_SUPPORT_X86_REDUCE) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CAPSTONE_HAS_X86) &amp;&amp; defined(CAPSTONE_X86_REDUCE)</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unsupported query</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例1(CS_ARCH_ALL，检查是否支持所有架构)：<br><img src="https://i.loli.net/2019/07/21/5d3469069954048775.jpg" alt></p><p>示例2(CS<em>ARCH</em>*，检查是否支持指定架构)<br><img src="https://i.loli.net/2019/07/21/5d34698a9ee7d33247.jpg" alt></p><p>示例3(检查是否处于DIET编译模式)：<br><img src="https://i.loli.net/2019/07/21/5d346a147b7e947704.jpg" alt></p><p>示例4(检查是否处于X86_REDUCE编译模式)：<br><img src="https://i.loli.net/2019/07/21/5d346a844b5b058873.jpg" alt>)</p><p>From <a href="https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(二">https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(二)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Capstone反汇编引擎数据类型及API分析及示例-二&quot;&gt;&lt;a href=&quot;#Capstone反汇编引擎数据类型及API分析及示例-二&quot; class=&quot;headerlink&quot; title=&quot;Capstone反汇编引擎数据类型及API分析及示例(二)&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="反汇编" scheme="https://kabeor.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Capstone反汇编引擎数据类型及API分析及示例(一)</title>
    <link href="https://kabeor.github.io/Capstone%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E5%8F%8A%E7%A4%BA%E4%BE%8B(%E4%B8%80)/"/>
    <id>https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(一)/</id>
    <published>2019-07-20T07:14:11.341Z</published>
    <updated>2019-07-26T04:39:24.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Capstone反汇编引擎数据类型及API分析及示例-一"><a href="#Capstone反汇编引擎数据类型及API分析及示例-一" class="headerlink" title="Capstone反汇编引擎数据类型及API分析及示例(一)"></a>Capstone反汇编引擎数据类型及API分析及示例(一)</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5753" target="_blank" rel="noopener">https://xz.aliyun.com/t/5753</a></p></blockquote><p>最近准备用开源的反汇编引擎做个项目，研究了OllyDebug的ODDisasm，disasm与assembl部分代码的思想都很值得学习，但毕竟是2000年的产物，指令集只支持x86，也没有对语义的深度分析，于是转向了对Capstone的研究。</p><p>Capstone反汇编引擎可以说是如今世界上最优秀的反汇编引擎，IDA，Radare2，Qemu等著名项目都使用了Capstone Engine，所以选择它来开发是一个不错的选择。<br>但在开发时发现官方并未给出详细API文档，网上也没有类似的分析，因此想到自己阅读源码和试验，由此写出了一个简单的非官方版本的API手册，希望能与大家分享。</p><h2 id="0x0-开发准备"><a href="#0x0-开发准备" class="headerlink" title="0x0 开发准备"></a>0x0 开发准备</h2><p>  Capstone官网： <a href="http://www.capstone-engine.org" target="_blank" rel="noopener">http://www.capstone-engine.org</a></p><h3 id="自行编译lib和dll方法"><a href="#自行编译lib和dll方法" class="headerlink" title="自行编译lib和dll方法"></a>自行编译lib和dll方法</h3><p>  源码： <a href="https://github.com/aquynh/capstone/archive/4.0.1.zip" target="_blank" rel="noopener">https://github.com/aquynh/capstone/archive/4.0.1.zip</a></p><p>  下载后解压<br>  文件结构如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   .                   &lt;- 主要引擎core engine + README + 编译文档COMPILE.TXT 等</span><br><span class="line">├── arch            &lt;- 各语言反编译支持的代码实现</span><br><span class="line">│   ├── AArch64     &lt;- ARM64 (aka ARMv8) 引擎</span><br><span class="line">│   ├── ARM         &lt;- ARM 引擎</span><br><span class="line">│   ├── EVM         &lt;- Ethereum 引擎</span><br><span class="line">│   ├── M680X       &lt;- M680X 引擎</span><br><span class="line">│   ├── M68K        &lt;- M68K 引擎</span><br><span class="line">│   ├── Mips        &lt;- Mips 引擎</span><br><span class="line">│   ├── PowerPC     &lt;- PowerPC 引擎</span><br><span class="line">│   ├── Sparc       &lt;- Sparc 引擎</span><br><span class="line">│   ├── SystemZ     &lt;- SystemZ 引擎</span><br><span class="line">│   ├── TMS320C64x  &lt;- TMS320C64x 引擎</span><br><span class="line">│   ├── X86         &lt;- X86 引擎</span><br><span class="line">│   └── XCore       &lt;- XCore 引擎</span><br><span class="line">├── bindings        &lt;- 中间件</span><br><span class="line">│   ├── java        &lt;- Java 中间件 + 测试代码</span><br><span class="line">│   ├── ocaml       &lt;- Ocaml 中间件 + 测试代码</span><br><span class="line">│   └── python      &lt;- Python 中间件 + 测试代码</span><br><span class="line">├── contrib         &lt;- 社区代码</span><br><span class="line">├── cstool          &lt;- Cstool 检测工具源码</span><br><span class="line">├── docs            &lt;- 文档，主要是capstone的实现思路</span><br><span class="line">├── include         &lt;- C头文件</span><br><span class="line">├── msvc            &lt;- Microsoft Visual Studio 支持（Windows）</span><br><span class="line">├── packages        &lt;- Linux/OSX/BSD包</span><br><span class="line">├── windows         &lt;- Windows 支持(Windows内核驱动编译)</span><br><span class="line">├── suite           &lt;- Capstone开发测试工具</span><br><span class="line">├── tests           &lt;- C语言测试用例</span><br><span class="line">└── xcode           &lt;- Xcode 支持 (MacOSX 编译)</span><br></pre></td></tr></table></figure></p><p>下面演示Windows10使用Visual Studio2019编译</p><p>复制msvc文件夹到一个比较清爽的位置（强迫症专用），内部结构如下：</p><p><img src="https://i.loli.net/2019/07/20/5d32b771e4c0118081.jpg" alt></p><p>VS打开capstone.sln项目文件，解决方案自动载入这些</p><p><img src="https://i.loli.net/2019/07/20/5d32b810db76b87698.jpg" alt></p><p>可以看到支持的所有语言都在这里了，如果都需要的话，直接编译就好了，只需要其中几种，则右键解决方案-&gt;属性-&gt;配置属性  如下</p><p><img src="https://i.loli.net/2019/07/20/5d32b92a26e1328865.jpg" alt></p><p>生成选项中勾选你需要的支持项即可<br>编译后会在当前文件夹Debug目录下生成capstone.lib静态编译库和capstone.dll动态库这样就可以开始使用Capstone进行开发了</p><p>如果不想自己编译，官方也提供了官方编译版本<br>Win32： <a href="https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win32.zip" target="_blank" rel="noopener">https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win32.zip</a><br>Win64： <a href="https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win64.zip" target="_blank" rel="noopener">https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win64.zip</a></p><p>选x32或x64将影响后面开发的位数</p><h3 id="引擎调用测试"><a href="#引擎调用测试" class="headerlink" title="引擎调用测试"></a>引擎调用测试</h3><p>新建一个VS项目，将..\capstone-4.0.1\include\capstone中的头文件以及编译好的lib和dll文件全部拷贝到新建项目的主目录下</p><p><img src="https://i.loli.net/2019/07/20/5d32bbbde025889046.jpg" alt></p><p>在VS解决方案中，头文件添加现有项capstone.h，资源文件中添加capstone.lib，重新生成解决方案</p><p><img src="https://i.loli.net/2019/07/20/5d32bc284c4e175661.jpg" alt></p><p>那么现在来测试一下我们自己的capstone引擎吧</p><p>主文件写入如下代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cinttypes&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count = cs_disasm(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0x1000</span>, <span class="number">0</span>, &amp;insn);</span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span><span class="string">"Ix"</span><span class="string">":\t%s\t\t%s\n"</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disassemble given code!\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上这是官方给出的C语言开发唯一几个例子之一，但注意到代码cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)，测试的是archx64的反编译，因此编译选项也需要设置为x64，除此以外，如果你的项目像我一样是c++开发，那么printf(“0x%””Ix””:\t%s\t\t%s\n”, insn[j].address, insn[j].mnemonic, insn[j].op_str);处官方给出的”0x%”PRIx64”:\t%s\t\t%s\n”应修改为我这里的”0x%””Ix””:\t%s\t\t%s\n”，这是inttypes支持问题。</p><p>运行结果<br><img src="https://i.loli.net/2019/07/20/5d32ca5adbd7040022.jpg" alt></p><h2 id="0x1-数据类型及API分析"><a href="#0x1-数据类型及API分析" class="headerlink" title="0x1 数据类型及API分析"></a>0x1 数据类型及API分析</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="csh"><a href="#csh" class="headerlink" title="csh"></a>csh</h4><p>用于生成调用capstone API的句柄<br><code>size_t csh</code> </p><blockquote><p>用法： <code>csh handle;</code></p></blockquote><h4 id="cs-arch"><a href="#cs-arch" class="headerlink" title="cs_arch"></a>cs_arch</h4><p>架构选择</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">enum</span> cs_arch &#123;</span><br><span class="line">CS_ARCH_ARM = <span class="number">0</span>,<span class="comment">///&lt; ARM 架构 (包括 Thumb, Thumb-2)</span></span><br><span class="line">CS_ARCH_ARM64,<span class="comment">///&lt; ARM-64, 也叫 AArch64</span></span><br><span class="line">CS_ARCH_MIPS,<span class="comment">///&lt; Mips 架构</span></span><br><span class="line">   CS_ARCH_X86,<span class="comment">///&lt; X86 架构 (包括 x86 &amp; x86-64)</span></span><br><span class="line">CS_ARCH_PPC,<span class="comment">///&lt; PowerPC 架构</span></span><br><span class="line">CS_ARCH_SPARC,<span class="comment">///&lt; Sparc 架构</span></span><br><span class="line">CS_ARCH_SYSZ,<span class="comment">///&lt; SystemZ 架构</span></span><br><span class="line">CS_ARCH_XCORE,<span class="comment">///&lt; XCore 架构</span></span><br><span class="line">CS_ARCH_M68K,<span class="comment">///&lt; 68K 架构</span></span><br><span class="line">CS_ARCH_TMS320C64X,<span class="comment">///&lt; TMS320C64x 架构</span></span><br><span class="line">CS_ARCH_M680X,<span class="comment">///&lt; 680X 架构</span></span><br><span class="line">CS_ARCH_EVM,<span class="comment">///&lt; Ethereum 架构</span></span><br><span class="line">CS_ARCH_MAX,</span><br><span class="line">CS_ARCH_ALL = <span class="number">0xFFFF</span>, <span class="comment">// All 架构 - for cs_support()</span></span><br><span class="line">&#125; cs_arch;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API中cs_arch参数填入枚举内容，如API中cs_open(cs_arch arch, cs_mode mode, csh *handle);第一个参数填CS_ARCH_X86则支持X86 架构</p></blockquote><h4 id="cs-mode"><a href="#cs-mode" class="headerlink" title="cs_mode"></a>cs_mode</h4><p>模式选择</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_mode &#123;</span><br><span class="line">CS_MODE_LITTLE_ENDIAN = <span class="number">0</span>,<span class="comment">///&lt; little-endian 模式 (default 模式)</span></span><br><span class="line">CS_MODE_ARM = <span class="number">0</span>,<span class="comment">///&lt; 32-bit ARM</span></span><br><span class="line">CS_MODE_16 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,<span class="comment">///&lt; 16-bit 模式 (X86)</span></span><br><span class="line">CS_MODE_32 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,<span class="comment">///&lt; 32-bit 模式 (X86)</span></span><br><span class="line">CS_MODE_64 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,<span class="comment">///&lt; 64-bit 模式 (X86, PPC)</span></span><br><span class="line">CS_MODE_THUMB = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,<span class="comment">///&lt; ARM's Thumb 模式, 包括 Thumb-2</span></span><br><span class="line">CS_MODE_MCLASS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,<span class="comment">///&lt; ARM's Cortex-M 系列</span></span><br><span class="line">CS_MODE_V8 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,<span class="comment">///&lt; ARM解码方式ARMv8 A32 </span></span><br><span class="line">CS_MODE_MICRO = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; MicroMips 模式 (MIPS)</span></span><br><span class="line">CS_MODE_MIPS3 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">///&lt; Mips III ISA</span></span><br><span class="line">CS_MODE_MIPS32R6 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">///&lt; Mips32r6 ISA</span></span><br><span class="line">CS_MODE_MIPS2 = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">///&lt; Mips II ISA</span></span><br><span class="line">CS_MODE_V9 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; SparcV9 模式 (Sparc)</span></span><br><span class="line">CS_MODE_QPX = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; Quad Processing eXtensions 模式 (PPC)</span></span><br><span class="line">CS_MODE_M68K_000 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">///&lt; M68K 68000 模式</span></span><br><span class="line">CS_MODE_M68K_010 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">///&lt; M68K 68010 模式</span></span><br><span class="line">CS_MODE_M68K_020 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">///&lt; M68K 68020 模式</span></span><br><span class="line">CS_MODE_M68K_030 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; M68K 68030 模式</span></span><br><span class="line">CS_MODE_M68K_040 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">///&lt; M68K 68040 模式</span></span><br><span class="line">CS_MODE_M68K_060 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">///&lt; M68K 68060 模式</span></span><br><span class="line">CS_MODE_BIG_ENDIAN = <span class="number">1</span> &lt;&lt; <span class="number">31</span>,<span class="comment">///&lt; big-endian 模式</span></span><br><span class="line">CS_MODE_MIPS32 = CS_MODE_32,<span class="comment">///&lt; Mips32 ISA (Mips)</span></span><br><span class="line">CS_MODE_MIPS64 = CS_MODE_64,<span class="comment">///&lt; Mips64 ISA (Mips)</span></span><br><span class="line">CS_MODE_M680X_6301 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">///&lt; M680X Hitachi 6301,6303 模式</span></span><br><span class="line">CS_MODE_M680X_6309 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">///&lt; M680X Hitachi 6309 模式</span></span><br><span class="line">CS_MODE_M680X_6800 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">///&lt; M680X Motorola 6800,6802 模式</span></span><br><span class="line">CS_MODE_M680X_6801 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; M680X Motorola 6801,6803 模式</span></span><br><span class="line">CS_MODE_M680X_6805 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">///&lt; M680X Motorola/Freescale 6805 模式</span></span><br><span class="line">CS_MODE_M680X_6808 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">///&lt; M680X Motorola/Freescale/NXP 68HC08 模式</span></span><br><span class="line">CS_MODE_M680X_6809 = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">///&lt; M680X Motorola 6809 模式</span></span><br><span class="line">CS_MODE_M680X_6811 = <span class="number">1</span> &lt;&lt; <span class="number">8</span>, <span class="comment">///&lt; M680X Motorola/Freescale/NXP 68HC11 模式</span></span><br><span class="line">CS_MODE_M680X_CPU12 = <span class="number">1</span> &lt;&lt; <span class="number">9</span>, <span class="comment">///&lt; M680X Motorola/Freescale/NXP CPU12</span></span><br><span class="line"><span class="comment">///&lt; 用于 M68HC12/HCS12</span></span><br><span class="line">CS_MODE_M680X_HCS08 = <span class="number">1</span> &lt;&lt; <span class="number">10</span>, <span class="comment">///&lt; M680X Freescale/NXP HCS08 模式</span></span><br><span class="line">&#125; cs_mode;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API中cs_mode参数填入枚举内容，如API中cs_open(cs_arch arch, cs_mode mode, csh *handle);第二个参数填CS_MODE_64则支持X64模式</p></blockquote><h4 id="cs-opt-mem"><a href="#cs-opt-mem" class="headerlink" title="cs_opt_mem"></a>cs_opt_mem</h4><p>内存操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_mem</span> &#123;</span></span><br><span class="line"><span class="keyword">cs_malloc_t</span> <span class="built_in">malloc</span>;</span><br><span class="line"><span class="keyword">cs_calloc_t</span> <span class="built_in">calloc</span>;</span><br><span class="line"><span class="keyword">cs_realloc_t</span> <span class="built_in">realloc</span>;</span><br><span class="line"><span class="keyword">cs_free_t</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="keyword">cs_vsnprintf_t</span> vsnprintf;</span><br><span class="line">&#125; cs_opt_mem;</span><br></pre></td></tr></table></figure><blockquote><p>用法：可使用用户自定义的malloc/calloc/realloc/free/vsnprintf()函数，默认使用系统自带malloc(), calloc(), realloc(), free() &amp; vsnprintf()</p></blockquote><h4 id="cs-opt-mnem"><a href="#cs-opt-mnem" class="headerlink" title="cs_opt_mnem"></a>cs_opt_mnem</h4><p>自定义助记符</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_mnem</span> &#123;</span></span><br><span class="line"><span class="comment">/// 需要自定义的指令ID</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="comment">/// 自定义的助记符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mnemonic;</span><br><span class="line">&#125; cs_opt_mnem;</span><br></pre></td></tr></table></figure><h4 id="cs-opt-type"><a href="#cs-opt-type" class="headerlink" title="cs_opt_type"></a>cs_opt_type</h4><p>反编译的运行时选项</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_opt_type &#123;</span><br><span class="line">CS_OPT_INVALID = <span class="number">0</span>,<span class="comment">///&lt; 无特殊要求</span></span><br><span class="line">CS_OPT_SYNTAX,<span class="comment">///&lt; 汇编输出语法</span></span><br><span class="line">CS_OPT_DETAIL,<span class="comment">///&lt; 将指令结构分解为多个细节</span></span><br><span class="line">CS_OPT_MODE,<span class="comment">///&lt; 运行时改变引擎模式</span></span><br><span class="line">CS_OPT_MEM,<span class="comment">///&lt; 用户定义的动态内存相关函数</span></span><br><span class="line">CS_OPT_SKIPDATA, <span class="comment">///&lt; 在反汇编时跳过数据。然后引擎将处于SKIPDATA模式</span></span><br><span class="line">CS_OPT_SKIPDATA_SETUP, <span class="comment">///&lt; 为SKIPDATA选项设置用户定义函数</span></span><br><span class="line">CS_OPT_MNEMONIC, <span class="comment">///&lt;自定义指令助记符</span></span><br><span class="line">CS_OPT_UNSIGNED, <span class="comment">///&lt; 以无符号形式打印立即操作数</span></span><br><span class="line">&#125; cs_opt_type;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API cs_option(csh handle, cs_opt_type type, size_t value);中第二个参数</p></blockquote><h4 id="cs-opt-value"><a href="#cs-opt-value" class="headerlink" title="cs_opt_value"></a>cs_opt_value</h4><p>运行时选项值(与cs_opt_type关联)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_opt_value &#123;</span><br><span class="line">CS_OPT_OFF = <span class="number">0</span>,  <span class="comment">///&lt; 关闭一个选项 - 默认为CS_OPT_DETAIL, CS_OPT_SKIPDATA, CS_OPT_UNSIGNED.</span></span><br><span class="line">CS_OPT_ON = <span class="number">3</span>, <span class="comment">///&lt; 打开一个选项 (CS_OPT_DETAIL, CS_OPT_SKIPDATA).</span></span><br><span class="line">CS_OPT_SYNTAX_DEFAULT = <span class="number">0</span>, <span class="comment">///&lt; 默认asm语法 (CS_OPT_SYNTAX).</span></span><br><span class="line">CS_OPT_SYNTAX_INTEL, <span class="comment">///&lt; X86 Intel asm语法 - 默认开启 X86 (CS_OPT_SYNTAX).</span></span><br><span class="line">CS_OPT_SYNTAX_ATT,   <span class="comment">///&lt; X86 ATT 汇编语法 (CS_OPT_SYNTAX).</span></span><br><span class="line">CS_OPT_SYNTAX_NOREGNAME, <span class="comment">///&lt; 只打印寄存器名和编号 (CS_OPT_SYNTAX)</span></span><br><span class="line">CS_OPT_SYNTAX_MASM, <span class="comment">///&lt; X86 Intel Masm 语法 (CS_OPT_SYNTAX).</span></span><br><span class="line">&#125; cs_opt_value;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API cs_option(csh handle, cs_opt_type type, size_t value);中第三个参数</p></blockquote><h4 id="cs-op-type"><a href="#cs-op-type" class="headerlink" title="cs_op_type"></a>cs_op_type</h4><p>通用指令操作数类型，在所有架构中保持一致</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_op_type &#123;</span><br><span class="line">CS_OP_INVALID = <span class="number">0</span>,  <span class="comment">///&lt; 未初始化/无效的操作数</span></span><br><span class="line">CS_OP_REG,          <span class="comment">///&lt; 寄存器操作数</span></span><br><span class="line">CS_OP_IMM,          <span class="comment">///&lt; 立即操作数</span></span><br><span class="line">CS_OP_MEM,          <span class="comment">///&lt; 内存操作数</span></span><br><span class="line">CS_OP_FP,           <span class="comment">///&lt; 浮点数</span></span><br><span class="line">&#125; cs_op_type;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p></blockquote><h4 id="cs-ac-type"><a href="#cs-ac-type" class="headerlink" title="cs_ac_type"></a>cs_ac_type</h4><p>通用指令操作数访问类型，在所有架构中保持一致<br>可以组合访问类型，例如:CS_AC_READ | CS_AC_WRITE</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_ac_type &#123;</span><br><span class="line">CS_AC_INVALID = <span class="number">0</span>,        <span class="comment">///&lt; 未初始化/无效的访问类型</span></span><br><span class="line">CS_AC_READ    = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,   <span class="comment">///&lt; 操作数从内存或寄存器中读取</span></span><br><span class="line">CS_AC_WRITE   = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,   <span class="comment">///&lt; 操作数从内存或寄存器中写入</span></span><br><span class="line">&#125; cs_ac_type;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p></blockquote><h4 id="cs-group-type"><a href="#cs-group-type" class="headerlink" title="cs_group_type"></a>cs_group_type</h4><p>公共指令组，在所有架构中保持一致</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cs_group_type &#123;</span><br><span class="line">CS_GRP_INVALID = <span class="number">0</span>,  <span class="comment">///&lt; 未初始化/无效指令组</span></span><br><span class="line">CS_GRP_JUMP,    <span class="comment">///&lt; 所有跳转指令(条件跳转+直接跳转+间接跳转)</span></span><br><span class="line">CS_GRP_CALL,    <span class="comment">///&lt; 所有调用指令</span></span><br><span class="line">CS_GRP_RET,     <span class="comment">///&lt; 所有返回指令</span></span><br><span class="line">CS_GRP_INT,     <span class="comment">///&lt; 所有中断指令(int+syscall)</span></span><br><span class="line">CS_GRP_IRET,    <span class="comment">///&lt; 所有中断返回指令</span></span><br><span class="line">CS_GRP_PRIVILEGE,    <span class="comment">///&lt; 所有特权指令</span></span><br><span class="line">CS_GRP_BRANCH_RELATIVE, <span class="comment">///&lt; 所有相关分支指令</span></span><br><span class="line">&#125; cs_group_type;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p></blockquote><h4 id="cs-opt-skipdata"><a href="#cs-opt-skipdata" class="headerlink" title="cs_opt_skipdata"></a>cs_opt_skipdata</h4><p>用户自定义设置SKIPDATA选项</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_skipdata</span> &#123;</span></span><br><span class="line"><span class="comment">/// Capstone认为要跳过的数据是特殊的“指令”</span></span><br><span class="line"><span class="comment">/// 用户可以在这里指定该指令的“助记符”字符串</span></span><br><span class="line"><span class="comment">/// 默认情况下(@mnemonic为NULL)， Capstone使用“.byte”</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mnemonic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用户定义的回调函数，当Capstone命中数据时调用</span></span><br><span class="line"><span class="comment">/// 如果这个回调返回的值是正数(&gt;0)，Capstone将跳过这个字节数并继续。如果回调返回0,Capstone将停止反汇编并立即从cs_disasm()返回</span></span><br><span class="line"><span class="comment">/// 注意:如果这个回调指针为空，Capstone会根据架构跳过一些字节，如下所示:</span></span><br><span class="line"><span class="comment">/// Arm:     2 bytes (Thumb mode) or 4 bytes.</span></span><br><span class="line"><span class="comment">/// Arm64:   4 bytes.</span></span><br><span class="line"><span class="comment">/// Mips:    4 bytes.</span></span><br><span class="line"><span class="comment">/// M680x:   1 byte.</span></span><br><span class="line"><span class="comment">/// PowerPC: 4 bytes.</span></span><br><span class="line"><span class="comment">/// Sparc:   4 bytes.</span></span><br><span class="line"><span class="comment">/// SystemZ: 2 bytes.</span></span><br><span class="line"><span class="comment">/// X86:     1 bytes.</span></span><br><span class="line"><span class="comment">/// XCore:   2 bytes.</span></span><br><span class="line"><span class="comment">/// EVM:     1 bytes.</span></span><br><span class="line"><span class="keyword">cs_skipdata_cb_t</span> callback; <span class="comment">// 默认值为 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用户自定义数据将被传递给@callback函数指针</span></span><br><span class="line"><span class="keyword">void</span> *user_data;</span><br><span class="line">&#125; cs_opt_skipdata;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p><h4 id="cs-detail"><a href="#cs-detail" class="headerlink" title="cs_detail"></a>cs_detail</h4><p>注意:只有当CS_OPT_DETAIL = CS_OPT_ON时，cs_detail中的所有信息才可用</p></blockquote><p>在arch/ARCH/ARCHDisassembler.c的ARCH_getInstruction中初始化为memset(., 0, offsetof(cs_detail, ARCH)+sizeof(cs_ARCH))</p><p>如果cs_detail发生了变化，特别是在union之后添加了字段，那么相应地更新arch/ arch/ archdisassembly .c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_detail</span> &#123;</span></span><br><span class="line"><span class="keyword">uint16_t</span> regs_read[<span class="number">12</span>]; <span class="comment">///&lt; 这个参数读取隐式寄存器列表</span></span><br><span class="line"><span class="keyword">uint8_t</span> regs_read_count; <span class="comment">///&lt; 这个参数读取隐式寄存器计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span> regs_write[<span class="number">20</span>]; <span class="comment">///&lt; 这个参数修改隐式寄存器列表</span></span><br><span class="line"><span class="keyword">uint8_t</span> regs_write_count; <span class="comment">///&lt; 这个参数修改隐式寄存器计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> groups[<span class="number">8</span>]; <span class="comment">///&lt; 此指令所属的指令组的列表</span></span><br><span class="line"><span class="keyword">uint8_t</span> groups_count; <span class="comment">///&lt; 此指令所属的组的数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 特定于体系结构的信息</span></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">cs_x86 x86;     <span class="comment">///&lt; X86 架构, 包括 16-bit, 32-bit &amp; 64-bit 模式</span></span><br><span class="line">cs_arm64 arm64; <span class="comment">///&lt; ARM64 架构 (aka AArch64)</span></span><br><span class="line">cs_arm arm;     <span class="comment">///&lt; ARM 架构 (包括 Thumb/Thumb2)</span></span><br><span class="line">cs_m68k m68k;   <span class="comment">///&lt; M68K 架构</span></span><br><span class="line">cs_mips mips;   <span class="comment">///&lt; MIPS 架构</span></span><br><span class="line">cs_ppc ppc;    <span class="comment">///&lt; PowerPC 架构</span></span><br><span class="line">cs_sparc sparc; <span class="comment">///&lt; Sparc 架构</span></span><br><span class="line">cs_sysz sysz;   <span class="comment">///&lt; SystemZ 架构</span></span><br><span class="line">cs_xcore xcore; <span class="comment">///&lt; XCore 架构</span></span><br><span class="line">cs_tms320c64x tms320c64x;  <span class="comment">///&lt; TMS320C64x 架构</span></span><br><span class="line">cs_m680x m680x; <span class="comment">///&lt; M680X 架构</span></span><br><span class="line">cs_evm evm;    <span class="comment">///&lt; Ethereum 架构</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; cs_detail;</span><br></pre></td></tr></table></figure><h4 id="cs-insn"><a href="#cs-insn" class="headerlink" title="cs_insn"></a>cs_insn</h4><p>指令的详细信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_insn</span> &#123;</span></span><br><span class="line"><span class="comment">/// 指令ID(基本上是一个用于指令助记符的数字ID)</span></span><br><span class="line"><span class="comment">/// 应在相应架构的头文件中查找'[ARCH]_insn' enum中的指令id，如ARM.h中的'arm_insn'代表ARM, X86.h中的'x86_insn'代表X86等…</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="comment">/// 注意:在Skipdata模式下，这个id字段的“data”指令为0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令地址 (EIP)</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令长度</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">uint16_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 此指令的机器码，其字节数由上面的@size表示</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">uint8_t</span> bytes[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令的Ascii文本助记符</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">char</span> mnemonic[CS_MNEMONIC_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令操作数的Ascii文本</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">char</span> op_str[<span class="number">160</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// cs_detail指针</span></span><br><span class="line"><span class="comment">/// 注意:只有同时满足以下两个要求时，detail指针才有效:</span></span><br><span class="line"><span class="comment">/// (1) CS_OP_DETAIL = CS_OPT_ON</span></span><br><span class="line"><span class="comment">/// (2) 引擎未处于Skipdata模式(CS_OP_SKIPDATA选项设置为CS_OPT_ON)</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 注意2:当处于Skipdata模式或detail模式关闭时，即使这个指针不是NULL，它的内容仍然是不相关的。</span></span><br><span class="line">cs_detail *detail;</span><br><span class="line">&#125; cs_insn;</span><br></pre></td></tr></table></figure><h4 id="cs-err"><a href="#cs-err" class="headerlink" title="cs_err"></a>cs_err</h4><p>Capstone API遇到的各类型的错误时cs_errno()的返回值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> cs_err &#123;</span><br><span class="line">CS_ERR_OK = <span class="number">0</span>,   <span class="comment">///&lt; 无错误</span></span><br><span class="line">CS_ERR_MEM,      <span class="comment">///&lt; 内存不足: cs_open(), cs_disasm(), cs_disasm_iter()</span></span><br><span class="line">CS_ERR_ARCH,     <span class="comment">///&lt; 不支持的架构: cs_open()</span></span><br><span class="line">CS_ERR_HANDLE,   <span class="comment">///&lt;句柄不可用: cs_op_count(), cs_op_index()</span></span><br><span class="line">CS_ERR_CSH,      <span class="comment">///&lt; csh参数不可用: cs_close(), cs_errno(), cs_option()</span></span><br><span class="line">CS_ERR_MODE,     <span class="comment">///&lt; 无效的或不支持的模式: cs_open()</span></span><br><span class="line">CS_ERR_OPTION,   <span class="comment">///&lt; 无效的或不支持的选项: cs_option()</span></span><br><span class="line">CS_ERR_DETAIL,   <span class="comment">///&lt; 信息不可用，因为detail选项是关闭的</span></span><br><span class="line">CS_ERR_MEMSETUP, <span class="comment">///&lt; 动态内存管理未初始化(见 CS_OPT_MEM)</span></span><br><span class="line">CS_ERR_VERSION,  <span class="comment">///&lt; 不支持版本 (bindings)</span></span><br><span class="line">CS_ERR_DIET,     <span class="comment">///&lt; 在“diet”引擎中访问不相关的数据</span></span><br><span class="line">CS_ERR_SKIPDATA, <span class="comment">///&lt; 在SKIPDATA模式下访问与“数据”指令无关的数据</span></span><br><span class="line">CS_ERR_X86_ATT,  <span class="comment">///&lt; X86 AT&amp;T 语法不支持(在编译时退出)</span></span><br><span class="line">CS_ERR_X86_INTEL, <span class="comment">///&lt; X86 Intel 语法不支持(在编译时退出)</span></span><br><span class="line">CS_ERR_X86_MASM, <span class="comment">///&lt; X86 Intel 语法不支持(在编译时退出)</span></span><br><span class="line">&#125; cs_err;</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(一">https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(一)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Capstone反汇编引擎数据类型及API分析及示例-一&quot;&gt;&lt;a href=&quot;#Capstone反汇编引擎数据类型及API分析及示例-一&quot; class=&quot;headerlink&quot; title=&quot;Capstone反汇编引擎数据类型及API分析及示例(一)&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="反汇编" scheme="https://kabeor.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C++调用线程实现QQ消息循环发送</title>
    <link href="https://kabeor.github.io/C++%E8%B0%83%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0QQ%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E5%8F%91%E9%80%81/"/>
    <id>https://kabeor.github.io/C++调用线程实现QQ消息循环发送/</id>
    <published>2019-04-24T11:35:50.051Z</published>
    <updated>2019-04-24T11:44:48.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-调用线程实现QQ消息循环发送"><a href="#C-调用线程实现QQ消息循环发送" class="headerlink" title="C++调用线程实现QQ消息循环发送"></a>C++调用线程实现QQ消息循环发送</h1><p>##函数原型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned long _beginthread(  </span><br><span class="line">             void(_cdecl *start_address)(void *), //声明为void (*start_address)(void *)形式  </span><br><span class="line">             unsigned stack_size, //是线程堆栈大小，一般默认为0  </span><br><span class="line">             void *arglist //向线程传递的参数，一般为结构体</span><br><span class="line">           ); </span><br><span class="line"></span><br><span class="line">unsigned long _beginthreadex( //推荐使用   </span><br><span class="line">             void *security,//安全属性，NULL表示默认安全性  </span><br><span class="line">             unsigned stack_size, //是线程堆栈大小，一般默认为0  </span><br><span class="line">             unsigned(_stdcall  *start_address)(void *),//声明为unsigned(*start_address)(void *)形式  </span><br><span class="line">             void *argilist,//向线程传递的参数，一般为结构体  </span><br><span class="line">             unsigned initflag, //新线程的初始状态，0表示立即执行，CREATE_SUSPEND表示创建后挂起。  </span><br><span class="line">             unsigned *thrdaddr //该变量存放线程标识符，它是CreateThread函数中的线程ID。); //创建成功条件下的将线程句柄转化为unsigned long型返回，创建失败条件下返回0</span><br></pre></td></tr></table></figure></p><blockquote><p>使用_beginthreadex而不是CreateThread的原因</p></blockquote><p> _beginthreadex在内部调用了CreateThread，在调用之前_beginthreadex做了很多的工作，从而使得它比CreateThread更安全。</p><p>通常建议使用_beginthreadex函数，而不是CreateThread函数，这使得线程中的代码不需要考虑C/C++代码的线程安全性，除非你清楚地知道在新的线程中不会调用到线程不安全的C/C++代码，这时候放心地使用CreateThread也无可厚非(实际上这种情况很难判定)。_beginthreadex保证了某些C/C++运行库代码的线程安全性，而CreateThread没有对这些特殊的C/C++代码做出保证，这里再次强调这两个函数的区别。不要含糊地认为CreateThread的设计存在缺陷，CreateThread的功能并不专门针对于C/C++运行库，理所当然不必为其多线程安全性而负责。</p><p>##实现<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> _<span class="function">stdcall <span class="title">ThreadOne</span><span class="params">(<span class="keyword">void</span>* Parg)</span>                   <span class="comment">//stdcall自动平衡堆栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入发送次数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i &lt; j; i++)</span><br><span class="line">&#123;</span><br><span class="line">SendMessage((HWND)<span class="number">0x002401E8</span>, WM_PASTE, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">//获取窗口线程   获取剪切板内容</span></span><br><span class="line">        Sleep(<span class="number">300</span>);</span><br><span class="line">keybd_event(VK_RETURN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);                  <span class="comment">//模拟按下回车</span></span><br><span class="line">keybd_event(VK_RETURN, <span class="number">0</span>, KEYEVENTF_KEYUP, <span class="number">0</span>);    <span class="comment">//模拟弹起回车</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_beginthreadex(<span class="literal">NULL</span>,<span class="literal">NULL</span>,ThreadOne,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);        <span class="comment">//线程调用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入发送次数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>From <a href="https://kabeor.github.io/C++调用线程实现QQ消息循环发送/">https://kabeor.github.io/C++调用线程实现QQ消息循环发送/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-调用线程实现QQ消息循环发送&quot;&gt;&lt;a href=&quot;#C-调用线程实现QQ消息循环发送&quot; class=&quot;headerlink&quot; title=&quot;C++调用线程实现QQ消息循环发送&quot;&gt;&lt;/a&gt;C++调用线程实现QQ消息循环发送&lt;/h1&gt;&lt;p&gt;##函数原型&lt;br&gt;&lt;f
      
    
    </summary>
    
      <category term="Code" scheme="https://kabeor.github.io/categories/Code/"/>
    
    
      <category term="C++多线程" scheme="https://kabeor.github.io/tags/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>逆向的难点、如何进阶和逆向其他题型</title>
    <link href="https://kabeor.github.io/%E9%80%86%E5%90%91%E7%9A%84%E9%9A%BE%E7%82%B9%E3%80%81%E5%A6%82%E4%BD%95%E8%BF%9B%E9%98%B6%E5%92%8C%E9%80%86%E5%90%91%E5%85%B6%E4%BB%96%E9%A2%98%E5%9E%8B/"/>
    <id>https://kabeor.github.io/逆向的难点、如何进阶和逆向其他题型/</id>
    <published>2019-03-31T05:59:01.761Z</published>
    <updated>2018-07-14T10:50:37.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向的难点、如何进阶和逆向其他题型"><a href="#逆向的难点、如何进阶和逆向其他题型" class="headerlink" title="逆向的难点、如何进阶和逆向其他题型"></a>逆向的难点、如何进阶和逆向其他题型</h1><p><img src="https://i.loli.net/2018/07/14/5b49d5799e7f8.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d579c3cb7.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d579ea235.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d57a18654.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d57a2dff1.jpg" alt="mark"></p><p>From <a href="https://kabeor.github.io/逆向的难点、如何进阶和逆向其他题型/">https://kabeor.github.io/逆向的难点、如何进阶和逆向其他题型/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逆向的难点、如何进阶和逆向其他题型&quot;&gt;&lt;a href=&quot;#逆向的难点、如何进阶和逆向其他题型&quot; class=&quot;headerlink&quot; title=&quot;逆向的难点、如何进阶和逆向其他题型&quot;&gt;&lt;/a&gt;逆向的难点、如何进阶和逆向其他题型&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/i%E6%98%A5%E7%A7%8B/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/tags/i%E6%98%A5%E7%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>逆向的地位作用</title>
    <link href="https://kabeor.github.io/%E9%80%86%E5%90%91%E7%9A%84%E5%9C%B0%E4%BD%8D%E4%BD%9C%E7%94%A8/"/>
    <id>https://kabeor.github.io/逆向的地位作用/</id>
    <published>2019-03-31T05:59:01.745Z</published>
    <updated>2018-07-14T10:47:57.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向的地位作用"><a href="#逆向的地位作用" class="headerlink" title="逆向的地位作用"></a>逆向的地位作用</h1><p><img src="https://i.loli.net/2018/07/14/5b49d4db33ae2.jpg" alt="mark"></p><p>From <a href="https://kabeor.github.io/逆向的地位作用/">https://kabeor.github.io/逆向的地位作用/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逆向的地位作用&quot;&gt;&lt;a href=&quot;#逆向的地位作用&quot; class=&quot;headerlink&quot; title=&quot;逆向的地位作用&quot;&gt;&lt;/a&gt;逆向的地位作用&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/14/5b49d4db33
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/i%E6%98%A5%E7%A7%8B/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/tags/i%E6%98%A5%E7%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>逆向的定义和核心</title>
    <link href="https://kabeor.github.io/%E9%80%86%E5%90%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%A0%B8%E5%BF%83/"/>
    <id>https://kabeor.github.io/逆向的定义和核心/</id>
    <published>2019-03-31T05:59:01.745Z</published>
    <updated>2018-07-14T10:49:33.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向的定义和核心"><a href="#逆向的定义和核心" class="headerlink" title="逆向的定义和核心"></a>逆向的定义和核心</h1><p><img src="https://i.loli.net/2018/07/14/5b49d50101064.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d50126ac9.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d5014bb4c.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d5016fd69.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d50195bb3.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d501bc366.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d501e3796.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d50215bfa.jpg" alt="mark">!</p><p><img src="https://i.loli.net/2018/07/14/5b49d5023a801.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d50263bd4.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d52d1742c.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d52d3cc68.jpg" alt="mark"></p><p>From <a href="https://kabeor.github.io/逆向的定义和核心/">https://kabeor.github.io/逆向的定义和核心/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逆向的定义和核心&quot;&gt;&lt;a href=&quot;#逆向的定义和核心&quot; class=&quot;headerlink&quot; title=&quot;逆向的定义和核心&quot;&gt;&lt;/a&gt;逆向的定义和核心&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/14/5b49d5
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/i%E6%98%A5%E7%A7%8B/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/tags/i%E6%98%A5%E7%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>逆向的基础和入门</title>
    <link href="https://kabeor.github.io/%E9%80%86%E5%90%91%E7%9A%84%E5%9F%BA%E7%A1%80%E5%92%8C%E5%85%A5%E9%97%A8/"/>
    <id>https://kabeor.github.io/逆向的基础和入门/</id>
    <published>2019-03-31T05:59:01.745Z</published>
    <updated>2018-07-14T10:50:05.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向的基础和入门"><a href="#逆向的基础和入门" class="headerlink" title="逆向的基础和入门"></a>逆向的基础和入门</h1><p><img src="https://i.loli.net/2018/07/14/5b49d552b4f94.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d552db7c4.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d5530cfe4.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d55334e63.jpg" alt="mark"></p><p>From <a href="https://kabeor.github.io/逆向的基础和入门/">https://kabeor.github.io/逆向的基础和入门/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逆向的基础和入门&quot;&gt;&lt;a href=&quot;#逆向的基础和入门&quot; class=&quot;headerlink&quot; title=&quot;逆向的基础和入门&quot;&gt;&lt;/a&gt;逆向的基础和入门&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/14/5b49d5
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/i%E6%98%A5%E7%A7%8B/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/tags/i%E6%98%A5%E7%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>第八届swpu网络安全大赛逆向r2 r3</title>
    <link href="https://kabeor.github.io/%E7%AC%AC%E5%85%AB%E5%B1%8Aswpu%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E9%80%86%E5%90%91r2%20r3/"/>
    <id>https://kabeor.github.io/第八届swpu网络安全大赛逆向r2 r3/</id>
    <published>2019-03-31T05:59:01.730Z</published>
    <updated>2018-09-04T03:07:48.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八届swpu网络安全大赛逆向r2-r3"><a href="#第八届swpu网络安全大赛逆向r2-r3" class="headerlink" title="第八届swpu网络安全大赛逆向r2 r3"></a>第八届swpu网络安全大赛逆向r2 r3</h1><p>也是以前的题了</p><h2 id="R2：bin100"><a href="#R2：bin100" class="headerlink" title="R2：bin100"></a>R2：bin100</h2><p>打开程序<br><img src="https://i.loli.net/2018/09/04/5b8deefecd76d.jpg" alt></p><p>。。。。。什么也没有<br>尝试输入，输到16位后提醒重试<br>用OD打开</p><p>界面像是输序列号，正好在看雪论坛看到以下内容</p><p><img src="https://i.loli.net/2018/09/04/5b8def1d19c71.jpg" alt></p><p>于是查找windowtextA</p><p><img src="https://i.loli.net/2018/09/04/5b8def2d25c46.jpg" alt><br><img src="https://i.loli.net/2018/09/04/5b8def34d0fae.jpg" alt></p><p>一直F8，看到cmp，应该是判断输入是否满足16位<br>打开IDA ，F5看伪代码</p><p><img src="https://i.loli.net/2018/09/04/5b8def45a9635.jpg" alt></p><p>然后接下来应记下关键跳转的地址，在IDA中分析，<br>输入的数字经过一系列计算，最后与一个字符串对比<br>得出flag</p><h2 id="R3：bin200"><a href="#R3：bin200" class="headerlink" title="R3：bin200"></a>R3：bin200</h2><p>先查壳</p><p><img src="https://i.loli.net/2018/09/04/5b8defbc9e8a2.jpg" alt></p><p>VC++写的<br>先用IDA调试：<br>查找字符串，发现一串数字08067<br>跟随后F5</p><p><img src="https://i.loli.net/2018/09/04/5b8defccf0ede.jpg" alt></p><p>可以看到result=8，应该是要对比已通关数和总关数8<br>然后跟着往下发现对比的if语句，找到相等时的跳转的地址，在OD上找到这个地址，就可以找出flag</p><p>From <a href="https://kabeor.github.io/第八届swpu网络安全大赛逆向r2 r3/">https://kabeor.github.io/第八届swpu网络安全大赛逆向r2 r3/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第八届swpu网络安全大赛逆向r2-r3&quot;&gt;&lt;a href=&quot;#第八届swpu网络安全大赛逆向r2-r3&quot; class=&quot;headerlink&quot; title=&quot;第八届swpu网络安全大赛逆向r2 r3&quot;&gt;&lt;/a&gt;第八届swpu网络安全大赛逆向r2 r3&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>第三届上海市大学生网络安全大赛crackme</title>
    <link href="https://kabeor.github.io/%E7%AC%AC%E4%B8%89%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9Bcrackme/"/>
    <id>https://kabeor.github.io/第三届上海市大学生网络安全大赛crackme/</id>
    <published>2019-03-31T05:59:01.730Z</published>
    <updated>2018-07-15T15:18:48.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三届上海市大学生网络安全大赛crackme"><a href="#第三届上海市大学生网络安全大赛crackme" class="headerlink" title="第三届上海市大学生网络安全大赛crackme"></a>第三届上海市大学生网络安全大赛crackme</h1><p>用PEID查壳</p><p><img src="https://i.loli.net/2018/07/15/5b4b6580a49f8.jpg" alt="image"></p><p>发现是个nSPack的壳</p><blockquote><p>手脱</p></blockquote><p><img src="https://i.loli.net/2018/07/15/5b4b6580b764f.jpg" alt="image"></p><p>OD自动载入之后停在了这里，发现是pushfd和pushad</p><p>所以有两种方法</p><p>A：popad寻找法</p><p>用Ctrl+F去查找popad</p><p>B：ESP定律法</p><p>第一个命令先F8，单步执行</p><p><img src="https://i.loli.net/2018/07/15/5b4b6580cc0cc.jpg" alt="image"></p><p>在ESP右击，选择数据窗口中跟随</p><p><img src="https://i.loli.net/2018/07/15/5b4b6580df236.jpg" alt="image"></p><p>跟踪这个值</p><p>选中46 02 00 00这四个字节，右击断点，硬件访问，Dword，选择</p><p>然后F9运行，跳转到这儿</p><p><img src="https://i.loli.net/2018/07/15/5b4b6581003d2.jpg" alt="image"></p><p>看到了这个长跳转，知道了401336离OEP很近了，单步F8，再次单步</p><p><img src="https://i.loli.net/2018/07/15/5b4b6581150e7.jpg" alt="image"></p><p>所以，1621是OEP的RVA</p><p>接下来是用PETools来DUMP文件</p><p>在PETools选中这个crackme，右击选择，完整转存</p><p>然后是使用Import REC</p><p><img src="https://i.loli.net/2018/07/15/5b4b658127cbc.jpg" alt="image"></p><p>点击IAT AutoSearch，Get Imports</p><p>然后把OEP改成1621</p><p><img src="https://i.loli.net/2018/07/15/5b4b65813cf35.jpg" alt="image"></p><p>Fix Dump</p><p>选中刚才Dump的文件<br><img src="https://i.loli.net/2018/07/15/5b4b65815165f.jpg" alt="image"></p><p>然后再使用PETools</p><p>Tools - Rebuild PE，重建那个DUMP文件<br><img src="https://i.loli.net/2018/07/15/5b4b659ad5787.jpg" alt="image"></p><p>脱壳成功</p><p>IDA查看Strings，发现有error和right：</p><p><img src="https://i.loli.net/2018/07/15/5b4b659ae8c4d.jpg" alt="image"></p><p><img src="https://i.loli.net/2018/07/15/5b4b659b090f5.jpg" alt="image"></p><p><img src="https://i.loli.net/2018/07/15/5b4b659b1d992.jpg" alt="mark"><br>开头的t就是74h换算过来的ASCII码116，摁R就能看到</p><p>Python脚本<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serial_1 = <span class="string">"this_is_not_flag"</span></span><br><span class="line">serial_2 = [<span class="number">0x12</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">0x14</span>,<span class="number">0x24</span>,<span class="number">0x5c</span>,<span class="number">0x4a</span>,<span class="number">0x3d</span>,<span class="number">0x56</span>,<span class="number">0xa</span>,<span class="number">0x10</span>,<span class="number">0x67</span>,<span class="number">0</span>,<span class="number">0x41</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0x46</span>,<span class="number">0x5a</span>,<span class="number">0x44</span>,<span class="number">0x42</span>,<span class="number">0x6e</span>,<span class="number">0x0c</span>,<span class="number">0x44</span>,<span class="number">0x72</span>,<span class="number">0x0c</span>,<span class="number">0x0d</span>,<span class="number">0x40</span>,<span class="number">0x3e</span>,<span class="number">0x4b</span>,<span class="number">0x5f</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0x4c</span>,<span class="number">0x5e</span>,<span class="number">0x5b</span>,<span class="number">0x17</span>,<span class="number">0x6e</span>,<span class="number">0xc</span>,<span class="number">0x16</span>,<span class="number">0x68</span>,<span class="number">0x5b</span>,<span class="number">0x12</span>,<span class="number">0x48</span>,<span class="number">0x0e</span>]</span><br><span class="line">result = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">42</span>):</span><br><span class="line">    result += chr(serial_2[i] ^ ord(serial_1[i%<span class="number">16</span>]))</span><br><span class="line">    <span class="keyword">print</span> result</span><br></pre></td></tr></table></figure></p><p>  得出</p><p>  flag{59b8ed8f-af22-11e7-bb4a-3cf862d1ee75}</p><p>From <a href="https://kabeor.github.io/第三届上海市大学生网络安全大赛crackme/">https://kabeor.github.io/第三届上海市大学生网络安全大赛crackme/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第三届上海市大学生网络安全大赛crackme&quot;&gt;&lt;a href=&quot;#第三届上海市大学生网络安全大赛crackme&quot; class=&quot;headerlink&quot; title=&quot;第三届上海市大学生网络安全大赛crackme&quot;&gt;&lt;/a&gt;第三届上海市大学生网络安全大赛crack
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋Reverse赛题" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/i%E6%98%A5%E7%A7%8BReverse%E8%B5%9B%E9%A2%98/"/>
    
    
      <category term="CTF" scheme="https://kabeor.github.io/tags/CTF/"/>
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/tags/i%E6%98%A5%E7%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>第9章 OllyDbg</title>
    <link href="https://kabeor.github.io/%E7%AC%AC9%E7%AB%A0%20OllyDbg/"/>
    <id>https://kabeor.github.io/第9章 OllyDbg/</id>
    <published>2019-03-31T05:59:01.699Z</published>
    <updated>2018-09-02T12:36:57.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OllyDbg"><a href="#OllyDbg" class="headerlink" title="OllyDbg"></a>OllyDbg</h1><p>OllyDbg被普遍用来分析恶意代码之前,最初的用途是破解软件。 Immunity Security公司买下 OllyDbg1.1的基础代码,并将其更名为Immunity Debugger(ImmDbg)。在此之前, OllyDbg直都是恶意代码分析师和漏洞开发者们的首选调试器。Immunity的目的是使这个工具适合漏洞开发者们使用,并且修复了OllDbg中的一些Bug。<br>在完成 OllyDbg的外观GUI修改,提供带有完整功能的 Python解释器API后,一些用户开始用ImmDbg替代OllyDbg</p><h2 id="9x1-加载恶意代码"><a href="#9x1-加载恶意代码" class="headerlink" title="9x1 加载恶意代码"></a>9x1 加载恶意代码</h2><h3 id="1-打开一个可执行文件"><a href="#1-打开一个可执行文件" class="headerlink" title="1. 打开一个可执行文件"></a>1. 打开一个可执行文件</h3><p>选择OllyDbg界面中的File-&gt;Open, 然后浏览到要加载的可执行文件。<br>如果要调试的程序需要参数,则在Open对话框的 Arguments输入框给出(只能在加载期间给OllyDgb传入命令行参数)</p><p>默认情况下,如果能够确定软件的入口点位置,即 WinMain, OllyDbg会在这个位置暂停程序的执行。否则OllyDbg会在软件PE头部提供的入口点处中断。另外,你也可以选择 OllyDbg的DebuggingOptions菜单(Options→Debugging Options)来修改这些启动选项。</p><h3 id="2-附加调试器到一个运行程序"><a href="#2-附加调试器到一个运行程序" class="headerlink" title="2. 附加调试器到一个运行程序"></a>2. 附加调试器到一个运行程序</h3><p>为将OllyDbg附加到一个进程上,选择OllyDbg界面的File→ Attach。然后会弹出一个菜单,你可以在这个菜单中选择要附加的进程(如果有多个同名的进程,你需要知道调试进程的ID)。接下来选择要调试的进程,并从菜单中选择Attach。此刻OllyDbg会立即暂停这个程序以及它所有的线程。</p><p>OllyDbg附加上进程后,进程当前执行线程的代码会被暂停,并显示在OllyDbg的窗口中。然而，有可能在进程正在执行一个系统DLL中的指令时把它暂停了,当这种情况发生时,回到主代码最简单的办法就是在整个代码段中设置一个访问断点。这样就会让这个程序在下次访问代码段时中断执行。</p><h2 id="9x2-OllyDbg的接口"><a href="#9x2-OllyDbg的接口" class="headerlink" title="9x2 OllyDbg的接口"></a>9x2 OllyDbg的接口</h2><blockquote><p> <strong>反汇编面板窗口</strong><br> 这个窗口显示了被调试程序的代码一当前指令指针的前后一些指令。通常，下一条将要被执行的指令在这个窗口中高亮显示。如果想要修改指令或数据(或添加一些汇编指令),请在这个窗口中按空格键。</p><p><strong>寄存器面板窗口</strong><br>这个窗口用来显示被调试程序寄存器的当前状态，代码被调试时，如果一条指令运行过程中修改了寄存器的值，则寄存器窗口中的这个寄存器就会从黑色变为红色。</p><p><strong>栈面板窗口</strong><br>这个窗口用来显示被调试线程堆栈在内存中的当前状态。这个窗口总是显示给定线程的栈项。可以通过右击一个栈单元，选择Modify，来操作这个窗口中的栈。OllyDbg会在一些栈单元上显示一些有用的注释，这些注释描述了调用一个API之前栈中存放的参数。</p><p><strong>内存转储面板窗口</strong><br>这个窗口用来显示被调试进程的实时内存转储。在这个窗口中按CtrI+G组合键，并输入一个内存位置，可以跳转到任何内存地址（也可以单击一个内存地址，然后选择Follow in Dump，来转储那个内存地址）。如果想要编辑这个窗口中的内存，右击它并选择Binary-&gt;Edit。使用这种方式也可以修改恶意代码存储在RAM中的全局变量以及其他一些数据。</p></blockquote><h2 id="9x3-内存映射"><a href="#9x3-内存映射" class="headerlink" title="9x3 内存映射"></a>9x3 内存映射</h2><p>内存映射窗口( View-&gt;Memory)显示了被调试程序分配的所有内存块。<br>内存映射是查看程序在内存中布局的一个好方式。你可以双击内存映射中的任意一行，显示那个段的内存转储。你也可以通过右击一段内存转储，然后选择View in Disassembler的方式，将其中的数据发送到反汇编窗口。</p><h3 id="1-基地址重定位"><a href="#1-基地址重定位" class="headerlink" title="1. 基地址重定位"></a>1. 基地址重定位</h3><p>内存映射能够帮助你理解一个PE文件在运行时如何被重定位。基地址重定位是指Windows中的一个模块没有被加载到其预定基地址时发生的情况。</p><blockquote><p><strong>基地址</strong><br>   Windows中的所有PE文件都有一个预定的基地址，它在PE文件头中被称为映像基地址。</p><p>  Windows允许映像基地址与要被加载到内存的实际地址不一致，虽然大部分情况下是一致的。大部分执行程序都被预定加载到0x00400000处，这个地址是Windows平台下大多数编译器使用的默认地址。不过，开发者可以选择将执行程序的基地址设置为一个与此不同的地址。支持地址空间布局随机化( ASLR)安全增强特性的可执行程序会经常被重定位。这就是说.DLL的重定位变得更加普遍。<br>    因为一个应用程序可能导入许多DLL，而每个DLL都有一个希望被加载到内存中的预定基地址，所以重定位十分必要。假设有两个DLL被加载，并且它们拥有相同的预加载地址0x10000000，则它们不可能都加载到这个位置,Windows会将其中一个DLL加载到这个地址，另一个DLL重定位到另外某个地址。<br>    Windows操作系统自带的大多数DLL有不同的预定基地址，而且它们之间不会产生冲突。然而第三方应用程序会经常出现使用同一个预定基地址的情况。</p><p><strong>绝对地址与相对地址</strong><br>重定位过程比简单将代码加载到另一个位置要复杂得多。虽然多数指令会引用内存中的相对地址，但是有些却引用内存的绝对地址。</p></blockquote><h2 id="9x4-查看线程和堆栈"><a href="#9x4-查看线程和堆栈" class="headerlink" title="9x4 查看线程和堆栈"></a>9x4 查看线程和堆栈</h2><p>恶意代码经常使用多线程。你可以通过选择View-&gt;Threads，调出线程面板窗口，查看一个程序的当前线程。这个窗口显示了线程的内存位置，以及它们当前的活动状态（活动、暂停，或者挂起）。<br>    由OllyDbg是单线程的，可能需要你先暂停所有的线程，设置一个断点后，继续运行程序，这样可以确保在一个特定线程内调试。单击主工具栏中的暂停按钮，可以暂停所有活动的线程。</p><h2 id="9x5-执行代码"><a href="#9x5-执行代码" class="headerlink" title="9x5 执行代码"></a>9x5 执行代码</h2><p><img src="https://i.loli.net/2018/07/20/5b519235da3c2.jpg" alt="im"></p><h2 id="9x6-断点"><a href="#9x6-断点" class="headerlink" title="9x6 断点"></a>9x6 断点</h2><p><img src="https://i.loli.net/2018/07/20/5b5192c91c650.jpg" alt="enter description here"></p><h3 id="1-软件断点"><a href="#1-软件断点" class="headerlink" title="1. 软件断点"></a>1. 软件断点</h3><p>调试字符串解码函数时，软件断点特别有用。</p><h3 id="2-条件断点"><a href="#2-条件断点" class="headerlink" title="2. 条件断点"></a>2. 条件断点</h3><p>条件断点是软件断点的一种，只有某些条件得到满足时这个断点才能中断执行程序。OllyDbg调试器允许使用表达式，来设置断点，每当断点命中时，都会先计算表达式的值，如果其值不等于零，断点生效，程序运行中断。</p><p>对于调用频繁的API函数，仅当特定参数传给它时才中断程序执行，这种情况下，条件软件断点特别有用。</p><blockquote><p><strong>设置条件断点的步骤</strong></p><ol><li>右击反汇编面板窗口中函数的第一条指令，选择Breakpoint-&gt;Conditional。然后会弹出一个对话框，要求你输入条件表达式.</li><li>在步骤l弹出的对话框中输入表达式，然后单击OK按钮。</li><li>单击Play按钮，并等待条件断点命中。</li></ol></blockquote><h3 id="3-硬件断点"><a href="#3-硬件断点" class="headerlink" title="3. 硬件断点"></a>3. 硬件断点</h3><p>硬件断点非常强大，它可以在不改变你的代码、堆栈以及任何目标资源的前提下进行调试。</p><p>OllyDbg中，在某一指令上设置硬件断点的方法是：右击该指令选择Breakpoint-&gt;Hardware，on Execution。</p><p>通过使用Debugging Options菜单，你可以告诉OllyDbg默认使用硬件断点来代替软件断点。同时，使用硬件断点可以帮助你防御反调试技术，如软件断点扫描。</p><h3 id="4-内存断点"><a href="#4-内存断点" class="headerlink" title="4. 内存断点"></a>4. 内存断点</h3><p>在一个内存块上设置内存断点，可以让被调试程序在访问这段内存时中断执行。OllyDbg支持软件内存断虑和硬件内存断点，此外还支持对内存进行读、写、执行或其他权限访问是否产生中断的设置。</p><p>为了设置一个基本的内存断点，在内存转储面板窗口中选择一部分内存，或者在内存映射面板窗口中选择一个内存段，然后右击它，选择Breakpoint-&gt;Memory,on Access。OllyDbg只允许你一次设置一个内存断点。如果你设置了一个新的内存断点，那么之前设置的内存断点会被移除。</p><p>在分析恶意代码时，如果想知道恶意代码何时使用了某个加载的DLL，这时内存断点将变得特别有用。可以设置这样一个内存断点，当DLL中的代码运行时程序被中断。下面是实现这种功能的步骤：</p><blockquote><p>1．打开内存映射面板窗门，并右i键单击需要跟踪DLL的.text段（.text段包含DLL的可执行代码）。<br>2．选择Set Memory Breakpoint on Access.<br>3．按F9键或者单击Play按钮恢复程序运行。<br>    当心用程序运行到DLL的．text段代码时．会中断执行。</p></blockquote><h2 id="9x7-加载DLL"><a href="#9x7-加载DLL" class="headerlink" title="9x7 加载DLL"></a>9x7 加载DLL</h2><p>除了可以调试加载的或者附加的可执行程序，OllyDbg还可以调试DLL。然而由于DLL不能直接运行．OllyDbg使用了一个名为loaddll. exe的虚拟程序来加载它。由于恶意代码经常打包成DLL．且其大部分代码都包含在DLL的DlIMain函数（DLL的初始化函数，当DLL被加载到进程时被调用）中，因此OllyDbg的这种技术非常有用。默认情况下，一旦DLL被加载，OllyDbg会在DLL的入口点(DllMain)处中断。</p><p>如果要用参数调用被调试DLL中的导出函数，首先用OllyDbg加载DLL．然后在其入口点处暂停DLL的执行，最后单击Play按钮，运行DllMain函数，以及其他一些DLL要求的初始化操作。</p><h2 id="9x8-跟踪"><a href="#9x8-跟踪" class="headerlink" title="9x8 跟踪"></a>9x8 跟踪</h2><p>跟踪是一种强大的调试技术，它可以记录程序详细的运行信息，供你查阅。OllyDbg支持多种跟踪功能，包括：标准回溯跟踪、堆栈调用跟踪和运行跟踪等。</p><h3 id="1-标准回溯跟踪"><a href="#1-标准回溯跟踪" class="headerlink" title="1. 标准回溯跟踪"></a>1. 标准回溯跟踪</h3><p>每次你在反汇编面板窗口上执行Step Into和Step Over操作时，OllyDbg都会记录下这种动作。你可以使用键盘上的减号键（一）。退回到上一步运行的指令：使用加号键(+)．执行下一条指令。<br>如果使用Step Into，你可以跟踪每一步的执行。如果使用Step Over，只能单步跟踪step over之前区域，回溯之后再决定是否进入另一个区域。</p><h3 id="2-堆栈调用跟踪"><a href="#2-堆栈调用跟踪" class="headerlink" title="2. 堆栈调用跟踪"></a>2. 堆栈调用跟踪</h3><p>在OllyDbg中，通过堆栈跟踪可以查看一个给定函数的执行路径。为了查看堆栈调用，在主菜单中选择View-&gt;Call Stack．会弹出一个窗口，窗口中显示了当前位置之前的调用序列。<br>    为了跟踪堆栈调用，单击地址或者堆栈调用窗口中的某段。当你在那个堆栈位置时，寄存器和堆栈并不会显示什么，除非你执行运行跟踪操作。</p><h3 id="3-运行跟踪"><a href="#3-运行跟踪" class="headerlink" title="3. 运行跟踪"></a>3. 运行跟踪</h3><p>运行跟踪是指在运行代码时，OllyDbg会保存所有运行过的指令，以及它们运行过程中对寄存器和标志所做的改变。</p><blockquote><p><strong>几种激活运行跟踪的方法</strong><br>·  在反汇编面板窗口中高亮你要跟踪的代码。右键单击代码，选择Run Trace–Add Selection。代码运行后，选择View-&gt;Run Trace，查看运行过的指令。使用键盘上的一（减号键）和+（加号键），来上下浏览代码（与标准回溯跟踪小节讨论的一样）。使用这种方法，可以查看每条指令执行时所有寄存器发生的变化。<br>    ·  使用Trace Into与Trace Ovcr选项。这些选项比Add Selection更容易使用，因为它们不需要你选择需要跟踪的代码。Trace Into可以单步执行并且记录命中断点前所有的运行指令，但Trace Over仅记录当前正在运行函数的指令。<br>·  选择Select Debug-&gt;Set Condition。可以在命中条件使程序暂停之前，跟踪程序的运行。如果你想在条件断点命中时停止跟踪，并且从发生中断的位置，回溯跟踪查看如何或者为什么发生中断，这种跟踪方法将对你非常有帮助。</p></blockquote><h3 id="4-跟踪Poison-lvy"><a href="#4-跟踪Poison-lvy" class="headerlink" title="4. 跟踪Poison lvy"></a>4. 跟踪Poison lvy</h3><h2 id="9x9-异常处理"><a href="#9x9-异常处理" class="headerlink" title="9x9 异常处理"></a>9x9 异常处理</h2><p>默认情况下．OllyDbg被附加后会产生异常，附加程序也会停止运行，此时调试器开始接管控制权。调试器可以处理该异常，也可以将异常转到被调试的应用程序处理。当异常发生时．OllyDbg会暂停运行，然后你可以使用下列任一种方法，来决定是否将异常转到应用程序处理：</p><blockquote><p>·  Shift+F7将进入异常。<br>·  Shift+F8将跳过异常。<br>·  Shift+F9将运行异常处理。</p></blockquote><p>OllyDbg提供异常处理的选项，这些选项可以告诉调试器忽略某些特定异常，并且将它们直接转到应用程序处理。<br><img src="https://i.loli.net/2018/07/20/5b519f1aae2be.png" alt="im"></p><h2 id="9x10-修补"><a href="#9x10-修补" class="headerlink" title="9x10 修补"></a>9x10 修补</h2><p>OllyDbg可以很容易修改实时数据，如寄存器和标志。它也可以将汇编形式的修补代码直接插入到一个程序。你可以通过高亮选择某块区域来修改指令或内存，右击这块区域，选择Binary-&gt;Edit，会弹出让你添加操作码和数据的窗口（OllyDbg具有一些特殊功能，可以使用00项或NOP指令填充程序）。</p><h2 id="9x11-分析shellcode"><a href="#9x11-分析shellcode" class="headerlink" title="9x11 分析shellcode"></a>9x11 分析shellcode</h2><p>OllyDbg有一种分析shellcodc的简单方法。下面是使用这种方法的步骤:</p><blockquote><p>1．将shellcode从一个十六进制编辑器复制到剪切板。<br>2．在内存映射面板窗口中，选择类型为Priv的内存区域（这是分配给进程的私有内存，与只读的可执行镜像不同，这些内存被多个进程共享）。<br>3．双击内存映射面板窗口的某行，会弹出一个十六进制转储窗口，你可以检查它的内容。该区域应该包含几百个连续为0的字节。<br>4．在内存映射面板窗口中，右击被选择的区域，选择Set Access—Full Access，赋予该区域读、写、运行的权限。<br>5．返回内存转储窗口。0字节填充的高亮区域足以容纳整个sheUcode，右键单击选择的内存区域，然后选择Binary一Binary Paste。这个操作将步骤l中复制的shellcode粘贴到选择的区域。<br>6．设置EIP寄存器，指向你修改的内存区域（右击反汇编面板窗口的一条指令，选择New Origin Here，你可以很容易设置EIP寄存器的值）。</p></blockquote><p>上述步骤结束后，你就可以像对待正常应用程序一样运行、调试和单步整个shellcode了</p><h2 id="9x12-协助功能"><a href="#9x12-协助功能" class="headerlink" title="9x12 协助功能"></a>9x12 协助功能</h2><p>OllyDbg提供了多种机制来帮助分析，包括下面几种：</p><blockquote><p>  <strong>日志( Logging)</strong><br>  OllyDbg维护一个持续可用的事件日志。要访问这个日志，选择View-&gt;Log。此日志显示了加载的可执行模块、触发的断点，以及其他一些信息。另外，在分析过程中，日志还可以帮助你找出为到达某一特定状态而执行的那些操作。<br>    <strong>监视(Watches)窗口</strong><br>    OllyDbg支持使用监视窗口，用它可以查看你生成表达式的值。程序运行时，这个表达式会不断更新。你可以通过View—Watches，来访问监视窗口，你也可以在监视窗口中按下空格键，来设置表达式。<br>    <strong>帮助（Help）</strong>  OllyDbg的Help-&gt;Contents选项为运算表达式的书写提供了详细说明。当你想监视一些特定数据或者复杂函数时，这个帮助非常有用。例如，如果想监控EAX+ESP+4处的内存，你只需要输入表达式[EAX+ESP+4]。<br>    <strong>标注（Labeling）</strong>  如IDA Pro一样，你可以为OllyDbg中的子例程和循环添加标注。OllyDbg中的标注是为调试程序中某个地址设置的一个简单符号名称。为了在反汇编面板窗口设置标注，右击一个地址选择Label，此时会弹出提示输入标注的窗口。设置完标注以后，对这个地址的所有引用都会被该标注代替。</p></blockquote><h2 id="9x13-插件"><a href="#9x13-插件" class="headerlink" title="9x13 插件"></a>9x13 插件</h2><p>OllyDbg拥有一些标准插件，其中一些可以免费下载到。在网站 <a href="http://www.openrce.org/downloads/browse/OllyDbg_Plugins" target="_blank" rel="noopener">http://www.openrce.org/downloads/browse/OllyDbg_Plugins</a> 中，你可以找到一些对分析恶意代码有用的OllyDbg插件。<br>    OllyDbg的插件以DLL形式存在，如果要安装某个插件，你将这个插件的DLL放到OllyDbg的安装根目录下即可。一旦将DLL放入OllyDbg的安装根目录，OllyDbg会自动识别这个插件，并将其添加到插件菜单。</p><h3 id="1-OllyDump"><a href="#1-OllyDump" class="headerlink" title="1. OllyDump"></a>1. OllyDump</h3><p>OllyDump是OllyDbg最常使用的插件，它能够将一个被调试的进程转储成一个PE文件。当加载器加载一个可执行文件时，OllyDump会尝试逆向这个进程。然而，OllyDump利用的是进程内存中各段（代码段、数据段等）的状态。OllyDbg最典型的应用就是脱壳。</p><h3 id="2-调试器隐藏插件"><a href="#2-调试器隐藏插件" class="headerlink" title="2. 调试器隐藏插件"></a>2. 调试器隐藏插件</h3><p>调试器隐藏插件用多种方法对探测者隐藏调试器的存在。为了防止恶意代码使用反调试技术，恶意代码分析人员通常在分析恶意代码期间，一直运行调试器隐藏插件。这个插件主要针对IsDebuggerPresent检测、FindWindow检测、未处理异常欺骗以及用OutputDebugString反OllyDbg调试等反调试技术。</p><h3 id="3-命令行"><a href="#3-命令行" class="headerlink" title="3. 命令行"></a>3. 命令行</h3><p>要打开命令行窗口，选择Plugins-&gt;Command  Line-&gt;Command  Line。<br><img src="https://i.loli.net/2018/07/20/5b51a90a13474.jpg" alt="im"></p><h3 id="4-书签"><a href="#4-书签" class="headerlink" title="4. 书签"></a>4. 书签</h3><p>OllyDbg默认情况下自带书签插件，书签插件可以将一个内存位置加到书签中，利用书签，下次不需要记住就可以轻松获取那个内存地址。右击反汇编面板窗口中的地址，选择Bookmark-&gt;Insert Bookmark．可以添加书签。选择Plugins-&gt;Bookmarks-&gt;Bookmarks，可以浏览书签，然后单击书签可以跳转到该书签代表的地址。</p><h2 id="9x14-脚本调试"><a href="#9x14-脚本调试" class="headerlink" title="9x14 脚本调试"></a>9x14 脚本调试</h2><p>因为OllyDbg的插件被编译成DLL，创建或者修改一个插件往往是一个复杂的过程。因此，当需要扩展调试功能时，我们采用ImmDbg。它使用Python脚本来扩展功能，并且提供了易于使用的API接口。<br>    ImmDbg的Python API包含很多实用工具和函数。例如，可以将你的脚本像本地代码一样集成到调试器中，创建自定义的表格、图形和各种接u。利用脚本分析恶意代码的原因有多种，典型的包括反调试器补丁、内联函数钩子( hook)以及函数参数日志等，其中许多代码可以在网上找到。<br>    ImmDbg最常见的Python脚本类型是PyCommand．这个Python脚本位于ImmDbg安装目录下的PyCommands\目录中。编写好Python脚本后，必须将其放到这个目录下才能运行。这些脚本从命令栏运行，并且需要加上前缀“!”，如在命令行中输入!list命令，可以列出可用的PyCommand列表。<br>    PyCommand类型脚本拥有如下结构：</p><blockquote><p>．  一系列Import导入语句，用来导入Python的模块（同所有的Python脚本一样）。通过immlib或immutils模块访问ImmDbg的功能。<br>．    一个主函数，用来读取命令行参数（以Python列表传递）。<br>·  PyCommand的代码实现部分。<br>·  返回包含字符串的值。一旦脚本运行结束，主调试器会用这个返回字符串更新状态栏。</p></blockquote><p>From <a href="https://kabeor.github.io/第9章 OllyDbg/">https://kabeor.github.io/第9章 OllyDbg/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OllyDbg&quot;&gt;&lt;a href=&quot;#OllyDbg&quot; class=&quot;headerlink&quot; title=&quot;OllyDbg&quot;&gt;&lt;/a&gt;OllyDbg&lt;/h1&gt;&lt;p&gt;OllyDbg被普遍用来分析恶意代码之前,最初的用途是破解软件。 Immunity Security
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第三篇 动态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第8章 动态调试</title>
    <link href="https://kabeor.github.io/%E7%AC%AC8%E7%AB%A0%20%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"/>
    <id>https://kabeor.github.io/第8章 动态调试/</id>
    <published>2019-03-31T05:59:01.683Z</published>
    <updated>2018-09-02T12:36:59.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第8章-动态调试"><a href="#第8章-动态调试" class="headerlink" title="第8章 动态调试"></a>第8章 动态调试</h1><h2 id="8x1-源代码级与汇编级的调试器"><a href="#8x1-源代码级与汇编级的调试器" class="headerlink" title="8x1 源代码级与汇编级的调试器"></a>8x1 源代码级与汇编级的调试器</h2><h2 id="8x2-内核模式与用户模式调试"><a href="#8x2-内核模式与用户模式调试" class="headerlink" title="8x2 内核模式与用户模式调试"></a>8x2 内核模式与用户模式调试</h2><p>在用户模式中，调试器与被调试的代码运行在同一个系统中<br>内核模式调试一般需要两个不同的系统<br>WinDbg是当前唯一支持内核调试的流行调试器</p><h2 id="8x3-使用调试器"><a href="#8x3-使用调试器" class="headerlink" title="8x3 使用调试器"></a>8x3 使用调试器</h2><h3 id="1-单步调试"><a href="#1-单步调试" class="headerlink" title="1. 单步调试"></a>1. 单步调试</h3><h3 id="2-单步跳过-Stepping-Over-和单步跳入-Stepping-Into"><a href="#2-单步跳过-Stepping-Over-和单步跳入-Stepping-Into" class="headerlink" title="2. 单步跳过(Stepping-Over)和单步跳入(Stepping-Into)"></a>2. 单步跳过(Stepping-Over)和单步跳入(Stepping-Into)</h3><blockquote><p>现在是使用VMware record/replay功能的最佳时机。当你单步跳过一个不会返回的函教时，可以通过重放调试会话来纠正你的错误。开始调试时就启动记录。然后，当单步跳过一个不会返回的函数时，停止记录。重放到单步跳过的函数前面，然后停止重放，取得控制权,但这次单步跳入该函数。</p></blockquote><h3 id="3-用断点暂停执行"><a href="#3-用断点暂停执行" class="headerlink" title="3. 用断点暂停执行"></a>3. 用断点暂停执行</h3><blockquote><p>软件执行断点</p></blockquote><p>调试器通过使用0XCC,即指令INT 3的机器码，重写指令的首个字节来实现软件断点，0XCC被设计来供调试器使用。当0XCC指令执行后，操作系统会产生一个异常，然后控制权转到调试器。</p><blockquote><p>硬件执行断点</p></blockquote><p>利用专门的硬件寄存器，x86结构可以支持硬件执行断点。处理器每次执行一个指令时，硬件都会检测指令的指针是否与断点地址相等。硬断点并不关心断点地址存储哪些字节。当调试修改自身的代码时，硬断点会非常有益。硬断点相比于软断点的另一个优点是，它们可以设置访问中断的断点而不是执行中断的断点。</p><p>硬件执行断点有个明显缺点：只有四个硬件寄存器存储断点的地址。<br>硬断点的深层缺陷之一是它们容易被运行的程序修改。虽然CPU芯片有八个调试寄存器，但只有六个在使用。前四个寄存器DR0〜DR3用来存储断点地址，调试控制寄存器（DR7)存储DR0〜DR3寄存器中的值是否有效，以及它们是否表示读、写或者执行断点等信息。恶意代码可以修改这些寄存器来干扰调试器。x86芯片组具有防御该干扰的功能。通过设置DR7寄存器中的通用探测（General Detect)标志位，任何执行mov指令访问调试寄存器的操作都会触发中断。而这让你能够探测调试寄存器的改变。</p><blockquote><p>条件断点</p></blockquote><p>条件断点是软件断点的一种，它在某些条件满足时才会被触发。条件断点通过调试器总是接收的软断点来实现的。调试器计算条件，如果条件不满足，它自动继续执行而不通知用户。另外，不同的调试器支持不同的条件。</p><h2 id="8x4-异常"><a href="#8x4-异常" class="headerlink" title="8x4 异常"></a>8x4 异常</h2><p>异常是调试器取得运行程序控制权的基本方式。本质上，除了断点产生异常外，与调试无关的事件，如非法内存访问、除0操作也会产生异常</p><h3 id="1-首次和二次异常处理"><a href="#1-首次和二次异常处理" class="headerlink" title="1. 首次和二次异常处理"></a>1. 首次和二次异常处理</h3><p>调试器通常有两次机会来处理同一个异常：首次处理异常和二次处理异常。调试器第一次附加到进程时，会发生一个异常，然后被调试的程序停止执行，此时调试器开始获得控制权。调试器可以自己处理异常，也可以将异常转给被调试的应用程序处理。</p><p>如果程序注册了一个异常处理函数，它会在调试器处理异常后，获得处理异常的权限。<br>如果应用程序没有处理异常，调试器将获得另一个处理它的机会—— 二次异常处理。调试器接收到一个二次处理的异常后，意味着如果程序没有附加到调试器就会崩溃。为了让应用程序正常运行，调试器必须处理异常。</p><h3 id="2-常见异常"><a href="#2-常见异常" class="headerlink" title="2. 常见异常"></a>2. 常见异常</h3><blockquote><p>最常见的是执行INT 3指令时产生的异常。调试器有专门的代码处理INT 3<br>异常，而操作系统则把它和其他异常一样对待。<br>应用程序可能包含处理INT 3异常的指令，但附加调试器到程序后，调试器将获得首先处理异常权限。如果调试器将异常传给程序，程序的异常处理函数会处理它。</p><p>单步调试也作为操作系统内的一个异常来实现。标志寄存器中的陷阱标志（trap flag)用于单步 调试。陷阱标志置位后，处理器每执行一条指令就会产生异常。</p><p>当程序试图去访问一个它无权访问的内存位置时，将产生内存访问冲突（memory-access violation)异常。这种异常经常因为内存地址无效而发生，也可能是因为访问了受保护而无权访问的内存位置。</p><p>另外，一些指令只在处理器处于特权模式时才能执行。如果程序尝试着在非特权模式下执行它们，则处理器会产生异常。</p></blockquote><h2 id="8x5-使用调试器修改可执行文件"><a href="#8x5-使用调试器修改可执行文件" class="headerlink" title="8x5 使用调试器修改可执行文件"></a>8x5 使用调试器修改可执行文件</h2><p>调试器可以用来改变程序的执行方式。可以通过修改控制标志、指令指针或者代码本身等方式来改变程序执行的方式。</p><h2 id="8x6-修改可执行程序的实践"><a href="#8x6-修改可执行程序的实践" class="headerlink" title="8x6 修改可执行程序的实践"></a>8x6 修改可执行程序的实践</h2><p>End..</p><p>From <a href="https://kabeor.github.io/第8章 动态调试/">https://kabeor.github.io/第8章 动态调试/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第8章-动态调试&quot;&gt;&lt;a href=&quot;#第8章-动态调试&quot; class=&quot;headerlink&quot; title=&quot;第8章 动态调试&quot;&gt;&lt;/a&gt;第8章 动态调试&lt;/h1&gt;&lt;h2 id=&quot;8x1-源代码级与汇编级的调试器&quot;&gt;&lt;a href=&quot;#8x1-源代码级与汇编级的
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第三篇 动态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第7章 分析恶意Windows程序</title>
    <link href="https://kabeor.github.io/%E7%AC%AC7%E7%AB%A0%20%E5%88%86%E6%9E%90%E6%81%B6%E6%84%8FWindows%E7%A8%8B%E5%BA%8F/"/>
    <id>https://kabeor.github.io/第7章 分析恶意Windows程序/</id>
    <published>2019-03-31T05:59:01.683Z</published>
    <updated>2018-07-19T05:22:29.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-分析恶意Windows程序"><a href="#第七章-分析恶意Windows程序" class="headerlink" title="第七章 分析恶意Windows程序"></a>第七章 分析恶意Windows程序</h1><h2 id="7x1-Windows-API"><a href="#7x1-Windows-API" class="headerlink" title="7x1 Windows API"></a>7x1 Windows API</h2><h3 id="1-类型和匈牙利表达法"><a href="#1-类型和匈牙利表达法" class="headerlink" title="1. 类型和匈牙利表达法"></a>1. 类型和匈牙利表达法</h3><p>Windows总体上使用匈牙利表达法作为API函数标识符，表达式使用前缀命名模式</p><blockquote><p>Windows API常见类型<br><img src="https://i.loli.net/2018/07/19/5b5020109dc75.jpg" alt="mark"></p></blockquote><h3 id="2-句柄"><a href="#2-句柄" class="headerlink" title="2. 句柄"></a>2. 句柄</h3><p>句柄是在操作系统中被打开或被创建的项(一个窗口，进程，模块，菜单，文件等)<br>句柄不能用来做数学操作<br>我们所能做的只有保存它，并在后续函数调用中使用它来引用同一个对象</p><h3 id="3-文件系统函数"><a href="#3-文件系统函数" class="headerlink" title="3. 文件系统函数"></a>3. 文件系统函数</h3><p>恶意代码与系统交互的一个最常用的方式就是创建或修改文件<br>独特文件名或修改为既有文件名是明显的基于主机的感染迹象</p><blockquote><p>CreateFile</p></blockquote><p>用来创建和打开文件，可打开已存在的文件，管道，流，及I/O设备，能创建新文件</p><blockquote><p>ReadFile和WriteFile</p></blockquote><p>用来对文件进行读和写操作</p><blockquote><p>CreatFileMapping和MapViewOfFile</p></blockquote><p>从磁盘加载一个文件到内存和返回一个指向映射的基地址指针(可用来访问内存中的文件)</p><p><img src="https://i.loli.net/2018/07/19/5b502010b0ca7.jpg" alt="mark"></p><h3 id="4-特殊文件"><a href="#4-特殊文件" class="headerlink" title="4. 特殊文件"></a>4. 特殊文件</h3><blockquote><p>共享文件</p></blockquote><p>以\serverName\share或\?\serverName\share开头命名的特殊文件，用来访问在共享目录中的目录或文件</p><blockquote><p>通过名字空间访问的文件</p></blockquote><p>名字空间可以被认为是固定数目的文件夹，每一个文件夹中保存不同类型的对象。底层的名字空间是NT名字空间，以前缀＼开始。NT名字空间可以访问所有设备，以及所有在NT名字空间中存在的其他名字空间。</p><p>以前缀\.\开始的Win32设备名字空间，经常被恶意代码用来直接访问物理设备，并且像一个文件一样进行读写操作</p><p>使用\Device\PhysicalMemory 来直接访问物理内存，这允许用户空间程序写到内核空间中。这个技术已经被恶意代码用来修改内核，并隐藏用户空间的程序。</p><blockquote><p>备用数据流</p></blockquote><p>备用数据流(ADS）特性允许附加数据被添加到一个已存在的NTFS文件中，相当于添加一 个文件到另外一 文件中。额外数据在列一 个目录时不会被显示出来，并且当显示文件内容时也不显示；而只有在你访问流时，它才是可见的。<br>ADS数据流根据约定normalFile.txt:Stream:$DATA来命名，这允许一个程序去读写一个流。恶意代码作者喜欢ADS，因为它能被用来隐藏数据。</p><h2 id="7x2-Windows注册表"><a href="#7x2-Windows注册表" class="headerlink" title="7x2 Windows注册表"></a>7x2 Windows注册表</h2><p>Windows注册表被用来保存操作系统与程序的配置信息<br><img src="https://i.loli.net/2018/07/19/5b502010c596d.jpg" alt="mark"></p><h3 id="1-注册表根键"><a href="#1-注册表根键" class="headerlink" title="1. 注册表根键"></a>1. 注册表根键</h3><p><img src="https://i.loli.net/2018/07/19/5b502010de480.jpg" alt="mark"></p><h3 id="2-Regedit"><a href="#2-Regedit" class="headerlink" title="2. Regedit"></a>2. Regedit</h3><p>注册表编辑器，Windows内建的用来查看和编辑注册表的工具</p><h3 id="3-自启动程序"><a href="#3-自启动程序" class="headerlink" title="3. 自启动程序"></a>3. 自启动程序</h3><p>向Run子键中写入项，可设置程序自启动<br>Autoruns工具列举在操作系统启动时会自动启动运行的代码</p><h3 id="4-常用注册表函数"><a href="#4-常用注册表函数" class="headerlink" title="4. 常用注册表函数"></a>4. 常用注册表函数</h3><p><img src="https://i.loli.net/2018/07/19/5b50201101f17.jpg" alt="mark"></p><h3 id="5-练习分析注册表操作代码"><a href="#5-练习分析注册表操作代码" class="headerlink" title="5. 练习分析注册表操作代码"></a>5. 练习分析注册表操作代码</h3><h3 id="6-使用-reg文件的注册表脚本"><a href="#6-使用-reg文件的注册表脚本" class="headerlink" title="6. 使用.reg文件的注册表脚本"></a>6. 使用.reg文件的注册表脚本</h3><h2 id="7x3-网络API"><a href="#7x3-网络API" class="headerlink" title="7x3 网络API"></a>7x3 网络API</h2><h3 id="1-伯克利兼容套接字"><a href="#1-伯克利兼容套接字" class="headerlink" title="1. 伯克利兼容套接字"></a>1. 伯克利兼容套接字</h3><p>网络功能在Windows系统中由Winsock库实现，主要在ws2_32.dll中<br><img src="https://i.loli.net/2018/07/19/5b50201121de3.jpg" alt="mark"><br>WSAStartup函数必须在其他网络函数之前被调用<br>调试代码查找网络接口时，可在WSAStartup函数中设置断点</p><h3 id="2-网络的服务器和客户端"><a href="#2-网络的服务器和客户端" class="headerlink" title="2. 网络的服务器和客户端"></a>2. 网络的服务器和客户端</h3><p>一个网络程序通常有两个端点:服务器端，它维护一个打开套接字并等待入站连接：客户端，它连接到一个正在等待的套接字。而恶意代码可以是这两端中的任意一个。</p><h3 id="3-WinINet-API"><a href="#3-WinINet-API" class="headerlink" title="3. WinINet API"></a>3. WinINet API</h3><p><img src="https://i.loli.net/2018/07/19/5b50201135003.jpg" alt="mark"></p><h2 id="7x4-跟踪恶意代码的运行"><a href="#7x4-跟踪恶意代码的运行" class="headerlink" title="7x4 跟踪恶意代码的运行"></a>7x4 跟踪恶意代码的运行</h2><h3 id="1-DLL"><a href="#1-DLL" class="headerlink" title="1. DLL"></a>1. DLL</h3><blockquote><p>动态链接库（DLL)是使用库来在多个应用程序之间共享代码的Windows特有方式。一个DLL程序是不能独自运行的可执行文件，但它可以导出一些被其他应用程序使用的函数。<br>被DLL程序使用的内存可以在正运行的进程之间共享。<br>在发布一个可执行文件时，你可以使用Windows系统上已 知的DLL程序，而无须去重新发布它们。这帮助软件开发者和恶意代码作者最小化发布软件的大小规模。<br>DLL程序也是一种有用的代码复用方式</p></blockquote><h4 id="恶意代码作者如何使用DLL"><a href="#恶意代码作者如何使用DLL" class="headerlink" title="恶意代码作者如何使用DLL"></a>恶意代码作者如何使用DLL</h4><blockquote><p>保存恶意代码<br>通过使用Windows DLL<br>通过使用第三方DLL</p></blockquote><h4 id="基本DLL结构"><a href="#基本DLL结构" class="headerlink" title="基本DLL结构"></a>基本DLL结构</h4><blockquote><p>DLL使用PE文件格式，并且只有一个单一标志，指示这个文件是一个<br>DLL,而不是一个.exeDLL经常有更多导出函数，并且通常导入函数较少。<br>DLL的主函数是DllMain。它没有标记，而且并不是一个DLL中的导出函数，但是它在PE头中被指定为文件的入口点。任何时候一个进程加载或卸载库，会创建一个新线程，或一个已程结束时，这个函数都会被调用来通知DLL。这个通知允许DLL来管理每个进程或每个线程的资源存在的线<br>程的资源。</p></blockquote><h3 id="2-进程"><a href="#2-进程" class="headerlink" title="2. 进程"></a>2. 进程</h3><h4 id="创建一个新进程"><a href="#创建一个新进程" class="headerlink" title="创建一个新进程"></a>创建一个新进程</h4><p>恶意代码最常使用的创建新进程函数是CreateProcess</p><blockquote><p>恶意代码通常使用C reateP rocess,来创建一个简单的远程shell- CreateProcess函数的一个参数，STARTUPINFO结构，包含一个进程的标准输入、标准输出以及标准错误流的句柄。一个恶意程序可以设置这些值为套接字，这样当这个程序写入标准输出时，它实际上会写到套接字上，因而允许一个攻击者执行远程shell,而不需要运行除CreateProcess之外的任何函数。</p></blockquote><h3 id="3-线程"><a href="#3-线程" class="headerlink" title="3. 线程"></a>3. 线程</h3><p>进程是执行代码的容器，线程才是Windows操作系统真正要执行的内容。线程是被CPU执行的独立指令序列，而不需要等待其他线程。一个进程包含一个或多个线程，它们执行进程中的一部分代码。一个进程中的所有线程共享同样的内存空间，但是每一个有它自己的处理器、寄存器和栈。</p><h4 id="线程上下文"><a href="#线程上下文" class="headerlink" title="线程上下文"></a>线程上下文</h4><blockquote><p>当一个线程运行时，它对CPU或CPU核有着完全的控制，并且其他线程不能影响CPU或核的状态。当一个线程改变CPU中某个寄存器的值时，它不会影响任何其他线程。一个操作系统在线程间切换之前，在CPU中的所有值会被保存到一个称为线程上下文的结构体中。然后操作系统加载这个线程上下文到一个新的线程中，并使这个新线程在CPU中执行</p></blockquote><h4 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h4><blockquote><p>CreateThread函数被用来创建一个新线程。函数的调用者指定一个起始地址，它经常被叫做sta rt函数。执行从这个起始地址开始直到这个函数返回，尽管这个函数不需要返回，这个线程可以在进程结束前一直运行。<br>CreateThread的调用者可以指定线程开始的函数位置，并且一个单一参数可以被传递给这个start函数。这个参数可以是任意值，依赖于这个线程要开始执行的函数。</p><p>• 恶意代码可以使用CreateThread,来加载一个新的恶意库文件到进程中，通过在调用CreateThread时将起始地址设置为Load Library的地址。 （传递给CreateThread的参数是要被加载库的名字。新的DLL被加载到这个进程的内存中，然后DllMain被调用。）<br>• 恶意代码可以为输入和输出创建两个线程：一个用来在套接字或管道上监听，并输出到一个进程的标准输入里，另一个用来从标准输出读取数据，并发送到套接字或管道上，恶意代码的目标是发送所有信息到单一的套接字或管道，来和运行的应用程序进行无缝通信。</p></blockquote><h3 id="4-使用互斥量的进程间协作"><a href="#4-使用互斥量的进程间协作" class="headerlink" title="4. 使用互斥量的进程间协作"></a>4. 使用互斥量的进程间协作</h3><blockquote><p>互斥量（mutex), 在内核中也称为互斥门（mutant)是全局对象，用于协调多个进程和线程。<br>互斥量主要用于控制共享资源的访问，并且经常被恶意代码所使用。<br>同一时刻，只有一个线程拥有一个互斥量。</p><p>线程通过一个对WaitForSingleObject的调用，获取对互斥量的访问，井且任何后续线程试图获取对它的访问时，都必须等待。当一个线程完成对互斥量的使用后，需要使用ReleaseMutex函数。</p><p>一个互斥量可以通过CreateMutex函数进行创建。而进程可以通过OpenMutex调用来获取另一个进程中互斥量的句柄。恶意代码通常创建一个互斥量，并试图使用同一个名字来打开一个已存在的互斥量，通过这种方式，可以确定恶意代码一次只有一个唯一实例在运行。</p></blockquote><h3 id="5-服务"><a href="#5-服务" class="headerlink" title="5. 服务"></a>5. 服务</h3><p>恶意代码执行附加代码的另一种方式是将它作为服务安装。Windows允许通过使用服务，来使任务作为后台应用程序运行，而不需要它们自己的进程或线程；代码被Windows服务管理器调度和运行，但没有用户输入。在Windows操作系统上的任何指定时间，都会有多个服务在运行。</p><p>服务也提供另一种在系统上维护持久化驻留的方式，因为它们可以被设置成当操作系统启动时 自动运行，并且可能甚至不在任务管理器中作为一个进程显示出来。一个用户查找所有运行的应用程序，也不会找到任何可疑的东西，因为恶意代码不是运行在一个独立进程中。</p><p>服务可以通过一些Windows API函数来进行安装和操作</p><blockquote><p>OpenSCManager： 返回一个服务控制管理器的句柄，它被用来进行所有后续与服务相关的函数调用。所有要和服务交互的代码会调用这个函数。<br>CreateService： 添加一个新服务到服务控制管理器，并且允许调用者指定服务是否在引导时自动启动，或者必须手动启动。<br>StartService： 启动一个服务，并且仅在服务被设置成手动启动时使用。</p></blockquote><p>Windows操作系统支持多种服务类型，它们以独特的方式执行。恶意代码最常使用的是WIN32_SHARE_PR0CESS类型，这种类型将这个服务的代码保存在一个DLL中，并且在一个共享的进程中组合多个同的服务。在任务管理器中，你可以找到一个名为svchost.exe进程的多个实例，它们在运行WIN32_SHARE_PR0CESS类型的服务。</p><blockquote><p>WIN32_OWN_PROCESS类型有时也被使用，因为它在一个.exe文件中保存代码，而且作为一个独立进程运行。</p><p>最后一个常见的服务类型是KERNEL_DRIVER,它被用来加载代码到内核中执行。</p><p>关于本地系统上服务的信息被保存在注册表中。每个服务在HKLM\SYSTEM\CurrentControlSet\Services下面有一个子键。</p></blockquote><h3 id="6-组件对象模型"><a href="#6-组件对象模型" class="headerlink" title="6. 组件对象模型"></a>6. 组件对象模型</h3><p>微软组件对象模型（COM)是一个接口标准，它使得不同软件组件在不知道其他组件代码的接口规范时，相互之间可以进行调用。</p><p>COM可以支持任何编程语言，并且被设计成一种可复用的软件组件，并可以被所有程序所利用。COM使用了一个对象结构，在与面向对象的编程语言中可以很好配合使用，COM也并不排斥非面向对象的编程语言。</p><p>COM被实现成一个客户-服务器框架。客户端是那些使用COM对象的程序，服务器是那些可复用的软件组件——也就是COM对象本身。微软提供了很多COM对象给程序使用。</p><p>每一个使用COM的线程，必须在调用任何其他COM库函数之前，至少调用一次Olelnitialize或CoInitializeEx函数。所以，一个恶意代码分析师可以搜索这些调用，来判断一个程序是否使用了COM功能，然而，知道恶意代码片段作为客户端程序使用COM对象并没有提供很多信息，因为COM对象是繁杂且广泛的。一旦你判断程序在使用COM,你就需要找到一些正在被使用对象的标识符来继续分析。</p><h4 id="CLSID、IID-以及COM对象的使用"><a href="#CLSID、IID-以及COM对象的使用" class="headerlink" title="CLSID、IID ,以及COM对象的使用"></a>CLSID、IID ,以及COM对象的使用</h4><blockquote><p>COM对象通过它们的全局唯一标识符(GUID),分为类型标识符(CLSID)以及接口标识符(IID)来进行访问。</p><p>CoCreatelnstance函数被用来获取对COM功能的访问。恶意代码使用的一个常用函数是Navigate , 它允许一个 程 序 启 动 Internet Explorer, 并访问一 个 Web地 址。Navigate函数是IWebBrowser2组件接口的一部分，这个接口指定了一个必须被实现的函数列表，但是它没有指定哪个程序会提供这个功能。提供这个功能的程序就是实现了IWebBrowser2接口的COM类。在多数例子中，IWebBrowser2接口被Internet Explorer实现。接口通过一个叫做IID的GUID来标识，而COM类通过一个叫做CLS1D的GUID来标识。</p></blockquote><h4 id="COM服务器恶意代码"><a href="#COM服务器恶意代码" class="headerlink" title="COM服务器恶意代码"></a>COM服务器恶意代码</h4><p>有些恶意代码实现了一个恶意COM服务器，继而被其他应用使用。对恶意代码来说，常用的COM服务器功能是通过浏览器帮助对象（B H O ), 这是Internet Explorer的第三方插件。BHO没有限制，所以恶意代码作者使用它们在Internet Explorer®程中运行代码，这允许他们监控互联网流量、跟踪浏览器的使用，以及与互联网通信，而且并不使用它们自己的进程。</p><p>实现一个COM服务器的恶意代码通常很容易检测，因为它导出了几个函数，包括DllCanUnloadNow、DllGetClassObject、Dlllnstall、DI 1 RegisterServer, 以及DllUnregisterServer，它们都必须由COM服务器软件导出。</p><h3 id="7-异常：当事情出错时"><a href="#7-异常：当事情出错时" class="headerlink" title="7. 异常：当事情出错时"></a>7. 异常：当事情出错时</h3><p>异常机制允许一个程序在普通执行流程之外处理事件。多数时间里，异常是由错误引起的，诸如除零错误。当一个异常发生时，执行转移到处理这个异常的特殊例程。有些异常，比如除零异常，是由硬件抛出的；其他的，比如无效内存访问，是由操作系统抛出的。你也可以在代码中使用RaiseException调用，显式地抛出一个异常。</p><p>结构化异常处理(SEH)是Windows的异常处理机制。在一个32位系统中，SEH信息被保存在桟上。</p><p>异常处理器是可嵌套的，并且不是所有的处理器都会对应着所有异常。如果当前帧的异常处理器不处理这个异常，这个异常会被传递给调用者帧的异常处理器。最终，如果这些异常处理器中没有一个响应这个异常，那么顶层的异常处理器将使应用程序崩溃。</p><p>异常处理器可以让恶意代码获得执行机会。一个指向异常处理信息的指针被保存在栈上，在栈溢出时，一个攻击者可以覆盖这个指针。通过指定一个新的异常处理器，攻击者可以在一个异常发生时获得执行机会。</p><h2 id="7x5-内核与用户模式"><a href="#7x5-内核与用户模式" class="headerlink" title="7x5 内核与用户模式"></a>7x5 内核与用户模式</h2><p>Windows使用两种处理器特权级别：内核模式与用户模式。</p><p>几乎所有代码都运行在用户模式，除了操作系统和硬件驱动，它们运行在内核模式。在用户模式，每一个进程有它自己的内存、安全权限，以及资源。如果一个用户模式程序执行一个无效指令并崩溃，Windows可以回收所有资源，并终止这个程序</p><p>通常，用户模式不能直接访问硬件，并且它被限制只能访问CPU上所有寄存器和可用指令的一个子集。为了在用户模式中操作硬件或改变内核中的状态，你必须依赖于Windows API。</p><p>当你调用一个Windows API函数操作内核结构体时，它会通过一个调用进入内核。在反汇编中SYSENTER、SYSCALL或者INT 0x2E的存在，指明一个调用被使用进入到内核。直接通过跳转从用户模式到内核模式是不可能的，这些指令使用查找表来定位一个预定义函数，从而在内核中执行代码。</p><p>所有运行在内核的进程共享资源和内存地址。内核模式代码有更少的安全检查。如果在内核运行的代码执行并且包含无效指令，操作系统就不能继续运行，产生的结果就是著名的Windows蓝屏。</p><p>运行在内核中的代码可以操纵运行在用户空间的代码，但是运行在用户空间的代码只能通过定义好的接口来影响内核。即使所有运行在内核的代码共享内存和资源，处于活跃状态的进程上下文也总是只有一个。</p><h2 id="7x6-原生API"><a href="#7x6-原生API" class="headerlink" title="7x6 原生API"></a>7x6 原生API</h2><p>原生API是用来和Windows进行交互的底层API。<br>调用原生API函数可以绕过普通的Windows API。</p><p>当调用Windows API中的一个函数时，这个函数通常不会直接执行请求的动作，因为大多数重要数据结构都被保存在内核中，在内核外面的代码 （用户模式代码）是无法访问它们的。微软为了使用户应用程序能够达到必需的功能，创建了一个多步骤的调用过程。<br><img src="https://i.loli.net/2018/07/19/5b5020114d7ce.jpg" alt="mark"></p><p>用户应用程序被给予对用户API (比如kernel32.dll和其他DLL)的访问，这些DLL会调用ntdlLdll,这是一个特殊的DLL程序，它管理用户空间与内核的交互。然后处理器切换到内核模式,并执行一个内核中的函数，通常它位于ntoskrnl.exe中。这个过程是令人费解的，但是内核和用户API之间的分离，允许微软修改内核而不会影响应用程序。</p><p>ntdll函数像内核中的函数一样，使用API和结构体。这些函数组成了原生API。</p><blockquote><p>尽管微软不提供关于原生API的完整文档，还是有网站和书来文档化这些函数。最好的参考书是由GaryNebbett (Sams, 2000)撰写的Windows NT/2000 Native API Reference，尽管它已经很旧了。在线资源如 <a href="http://undocumented.ntinternals.net" target="_blank" rel="noopener">http://undocumented.ntinternals.net</a> 以提供最近的信息。</p></blockquote><p>有一系列的原生API调用可以被用来获取关于系统的信息、进程、线程、句柄，以及其他项目。这 些 包 括 NtQuerySystemlnformation , NtQuerylnformationProcess &gt; NtQuerylnformationThread &gt; NtQuerylnformationFile, 以及NtQuerylnformationKey。这些调用提供比任何可用Win32调用更详细的信息，并且其中一些函数允许你给文件、进程、线程等设置细粒度的属性。</p><p>另一个恶意代码普遍使用的原生API函数是NtContinue。这个函数被用来从一个异常处理返回，并且它的意图是在一个异常被处理后转移执行回到一个程序的主线程。然而，要返回的位置在异常上下文中被指定，并且它可以被修改。恶意代码经常使用这个函数来以复杂的方式转移执行，从而使一个分析师感到困惑，并且使一个程序更加难调试。</p><p>原生应用程序是那些不使用Win32子系统而只调用原生API的应用程序。这样的应用程序对恶意代码来说是罕见的，对非恶意代码来说几乎是不存在的，所以一个原生应用程序很可能就是恶意的。在PE头中的子系统指明了一个程序是不是原生应用程序。</p><p>From <a href="https://kabeor.github.io/第7章 分析恶意Windows程序/">https://kabeor.github.io/第7章 分析恶意Windows程序/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第七章-分析恶意Windows程序&quot;&gt;&lt;a href=&quot;#第七章-分析恶意Windows程序&quot; class=&quot;headerlink&quot; title=&quot;第七章 分析恶意Windows程序&quot;&gt;&lt;/a&gt;第七章 分析恶意Windows程序&lt;/h1&gt;&lt;h2 id=&quot;7x1-W
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第二篇 静态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第6章 识别汇编中的C代码结构</title>
    <link href="https://kabeor.github.io/%E7%AC%AC6%E7%AB%A0%20%E8%AF%86%E5%88%AB%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84C%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>https://kabeor.github.io/第6章 识别汇编中的C代码结构/</id>
    <published>2019-03-31T05:59:01.667Z</published>
    <updated>2018-07-19T05:20:52.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第6章-识别汇编中的C代码结构"><a href="#第6章-识别汇编中的C代码结构" class="headerlink" title="第6章 识别汇编中的C代码结构"></a>第6章 识别汇编中的C代码结构</h1><h2 id="6x1-全局与局部变量"><a href="#6x1-全局与局部变量" class="headerlink" title="6x1 全局与局部变量"></a>6x1 全局与局部变量</h2><blockquote><p>全局变量可以被一个程序中的任意函数访问和使用<br>局部变量只能在它被定义的函数中访问</p></blockquote><p>在反汇编代码中： </p><p><strong>全局变量通过内存地址引用</strong><br><strong>局部变量通过栈地址引用</strong></p><h2 id="6x2-反汇编算术操作"><a href="#6x2-反汇编算术操作" class="headerlink" title="6x2 反汇编算术操作"></a>6x2 反汇编算术操作</h2><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f7218cec.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f724a277.jpg" alt="mark"></p></blockquote><p>反汇编中，1~2行为赋值，3~5行为a=a+11，6~9行为a=a-b，10~12和13~15分别为a–和b++，16~19为b=a%3</p><h2 id="6x3-识别if语句"><a href="#6x3-识别if语句" class="headerlink" title="6x3 识别if语句"></a>6x3 识别if语句</h2><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f7260e22.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f72760c1.jpg" alt="mark"></p></blockquote><p>cmp比较var_4是否等于var_8</p><h3 id="1-用IDA-Pro图形化分析函数"><a href="#1-用IDA-Pro图形化分析函数" class="headerlink" title="1. 用IDA Pro图形化分析函数"></a>1. 用IDA Pro图形化分析函数</h3><p><img src="https://i.loli.net/2018/07/19/5b501f72992fc.jpg" alt="mark"></p><h3 id="2-识别嵌套的if语句"><a href="#2-识别嵌套的if语句" class="headerlink" title="2. 识别嵌套的if语句"></a>2. 识别嵌套的if语句</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f72ad72e.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f72d0602.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501f72e9ab6.jpg" alt="mark"></p></blockquote><h2 id="6x4-识别循环"><a href="#6x4-识别循环" class="headerlink" title="6x4 识别循环"></a>6x4 识别循环</h2><h3 id="1-找到for循环"><a href="#1-找到for循环" class="headerlink" title="1. 找到for循环"></a>1. 找到for循环</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f7312652.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f7381097.jpg" alt="mark"></p><p><strong>IDA Pro图形化</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f86da225.jpg" alt="mark"></p></blockquote><p>汇编代码中，for循环可通过以下4个组件识别出来</p><blockquote><p>初始化<br>比较<br>执行指令<br>递增/递减</p></blockquote><h3 id="2-找到while循环"><a href="#2-找到while循环" class="headerlink" title="2. 找到while循环"></a>2. 找到while循环</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f8751178.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f8764b45.jpg" alt="mark"></p></blockquote><p>汇编代码和for循环非常相似，唯一区别在于它缺少一个递增</p><h2 id="6x5-理解函数调用约定"><a href="#6x5-理解函数调用约定" class="headerlink" title="6x5 理解函数调用约定"></a>6x5 理解函数调用约定</h2><blockquote><p><strong>一个函数调用的伪代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f8779503.jpg" alt="mark"></p></blockquote><p>最常见的三个调用约定：cdecl，stdcall，fastcall</p><h3 id="1-cdecl"><a href="#1-cdecl" class="headerlink" title="1. cdecl"></a>1. cdecl</h3><p><img src="https://i.loli.net/2018/07/19/5b501f879153f.jpg" alt="mark"></p><p>在cdecl约定中，参数从右到左按序被压入栈，当函数完成时由调用者清理栈。</p><h3 id="2-stdcall"><a href="#2-stdcall" class="headerlink" title="2. stdcall"></a>2. stdcall</h3><p>stdcall是Windows API的标准调用约定。任何调用这些API的代码都不需要清理栈，清理栈由实现API函数代码的DLL程序所承担</p><h3 id="3-fastcall"><a href="#3-fastcall" class="headerlink" title="3. fastcall"></a>3. fastcall</h3><p>在fastcall中，前面的一些参数被传到寄存器，备用的寄存器是EDX和ECX。如果需要，剩下的参数再以从右到左的次序被加载到栈上。<br>使用fastcall比其他约定更高效，因为代码不需要涉及过多的栈操作</p><h3 id="4-压栈与移动"><a href="#4-压栈与移动" class="headerlink" title="4. 压栈与移动"></a>4. 压栈与移动</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f87a906f.jpg" alt="mark"></p><p><strong>adder函数汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f87c20db.jpg" alt="mark"></p><p><strong>使用两种不同调用约定时一个函数调用的汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f87d5f2a.jpg" alt="mark"></p></blockquote><h2 id="6x6-分析switch语句"><a href="#6x6-分析switch语句" class="headerlink" title="6x6 分析switch语句"></a>6x6 分析switch语句</h2><p>switch语句通常以两种方式被编译：</p><ol><li>if样式</li><li>跳转表</li></ol><h3 id="1-if样式"><a href="#1-if样式" class="headerlink" title="1. if样式"></a>1. if样式</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f87e703c.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f880c31f.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501f9daa16e.jpg" alt="mark"></p><p><strong>IDA Pro图形化</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9dd4356.jpg" alt="mark"></p></blockquote><h3 id="2-跳转表"><a href="#2-跳转表" class="headerlink" title="2. 跳转表"></a>2. 跳转表</h3><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9dece2d.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e12198.jpg" alt="mark"></p><p><strong>IDA Pro图形化</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e36c12.jpg" alt="mark"></p></blockquote><h2 id="6x7-反汇编数组"><a href="#6x7-反汇编数组" class="headerlink" title="6x7 反汇编数组"></a>6x7 反汇编数组</h2><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e4d524.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e62590.jpg" alt="mark"></p></blockquote><p>数组a的基地址对应var_14，数组b的基地址对应dword_40A000.</p><p>ecx被作为索引使用，它被乘以4，来指明元素的大小，结果值与数组的基地址相加，来访问正确的数组元素。</p><h2 id="6x8-识别结构体"><a href="#6x8-识别结构体" class="headerlink" title="6x8 识别结构体"></a>6x8 识别结构体</h2><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e7869e.jpg" alt="mark"></p><p><strong>main函数反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9e8ef54.jpg" alt="mark"></p><p><strong>test函数反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501f9ea93bc.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501faf4c785.jpg" alt="mark"></p></blockquote><p>arg_0是这个结构体的基地址，偏移0x14保存了结构中的字符，并且0x61对应ASCII中的字母a</p><h2 id="6x9-分析链表遍历"><a href="#6x9-分析链表遍历" class="headerlink" title="6x9 分析链表遍历"></a>6x9 分析链表遍历</h2><blockquote><p><strong>C代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501faf632ab.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501faf7be8b.jpg" alt="mark"></p><p><strong>反汇编代码</strong></p><p><img src="https://i.loli.net/2018/07/19/5b501faf96083.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501fafb3fab.jpg" alt="mark"></p></blockquote><p>var_C对应i，它是这个循环的计数。<br>var_8对应head变量。<br>var_4是一个指向拥有两个被赋值变量结构体的指针</p><p>From <a href="https://kabeor.github.io/第6章 识别汇编中的C代码结构/">https://kabeor.github.io/第6章 识别汇编中的C代码结构/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第6章-识别汇编中的C代码结构&quot;&gt;&lt;a href=&quot;#第6章-识别汇编中的C代码结构&quot; class=&quot;headerlink&quot; title=&quot;第6章 识别汇编中的C代码结构&quot;&gt;&lt;/a&gt;第6章 识别汇编中的C代码结构&lt;/h1&gt;&lt;h2 id=&quot;6x1-全局与局部变量&quot;&gt;
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第二篇 静态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第5章 IDA Pro</title>
    <link href="https://kabeor.github.io/%E7%AC%AC5%E7%AB%A0%20IDA%20Pro/"/>
    <id>https://kabeor.github.io/第5章 IDA Pro/</id>
    <published>2019-03-31T05:59:01.660Z</published>
    <updated>2018-07-19T05:18:43.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第5章-IDA-Pro"><a href="#第5章-IDA-Pro" class="headerlink" title="第5章 IDA Pro"></a>第5章 IDA Pro</h1><p>本章介绍了IDA Pro的使用方法，本文就只大致记录常用功能</p><h2 id="5x1-加载一个可执行文件"><a href="#5x1-加载一个可执行文件" class="headerlink" title="5x1 加载一个可执行文件"></a>5x1 加载一个可执行文件</h2><p>默认情况下，IDA Pro反汇编代码中不包含PE头或资源节，这些地方常被恶意代码用来隐藏恶意指令，我们可以指定手动加载</p><h2 id="5x2-IDA-Pro接口"><a href="#5x2-IDA-Pro接口" class="headerlink" title="5x2 IDA Pro接口"></a>5x2 IDA Pro接口</h2><h3 id="1-反汇编窗口模式"><a href="#1-反汇编窗口模式" class="headerlink" title="1. 反汇编窗口模式"></a>1. 反汇编窗口模式</h3><blockquote><p>图形模式</p></blockquote><p>显示行号的操作码：Options-&gt;General，选择Line prefixes并设置Number of Opcode Bytes为6.（如果这些设置让所有指令都在屏幕右对齐，尝试设置Instruction Indentation为8）</p><p>箭头颜色：</p><ol><li>红色：一个条件跳转没有被采用</li><li>绿色：这个条件跳转被采用</li><li>蓝色：一个无条件跳转被采用</li></ol><blockquote><p>文本模式</p></blockquote><p>打开自动注释： Options-&gt;General，选择Auto comments</p><h3 id="2-对分析有用的窗口"><a href="#2-对分析有用的窗口" class="headerlink" title="2. 对分析有用的窗口"></a>2. 对分析有用的窗口</h3><blockquote><p>函数窗口<br>名字窗口<br>字符串窗口<br>导入表窗口<br>导入表窗口<br>结构窗口</p></blockquote><h3 id="3-返回到默认窗口"><a href="#3-返回到默认窗口" class="headerlink" title="3. 返回到默认窗口"></a>3. 返回到默认窗口</h3><p>Windows-&gt;Reset Desktop<br>Windows-&gt;Save desktop   保存新视图</p><h3 id="4-导航IDA-Pro"><a href="#4-导航IDA-Pro" class="headerlink" title="4. 导航IDA Pro"></a>4. 导航IDA Pro</h3><blockquote><p>使用链接和交叉引用<br>浏览历史<br>导航栏</p><pre><code>1. 浅蓝色： 被FLIRT识别的库代码2. 红色： 编译器生成的代码3. 深蓝色： 用户编写的代码4. 粉红色： 导入的数据5. 灰色： 已定义的数据6. 棕色： 未定义的数据</code></pre><p>跳转到位置   <strong>G</strong></p></blockquote><h3 id="5-搜索"><a href="#5-搜索" class="headerlink" title="5. 搜索"></a>5. 搜索</h3><blockquote><p>Search-&gt;Next Code  移动光标到包含你所指定的指令的下一个位置<br>Search-&gt;Text  在整个反汇编窗口中搜索一个指定的字符串<br>Search-&gt;Sequence of Bytes  在十六进制视图窗口中对一个特定字节序列执行二进制搜索</p></blockquote><h2 id="5x3-使用交叉引用"><a href="#5x3-使用交叉引用" class="headerlink" title="5x3 使用交叉引用"></a>5x3 使用交叉引用</h2><p>交叉引用（xref）<br>查看一个函数的所有交叉引用：单机函数名并按X键</p><h2 id="5x4-分析函数"><a href="#5x4-分析函数" class="headerlink" title="5x4 分析函数"></a>5x4 分析函数</h2><p>创建函数：  P<br>无法识别出基于EBP的一个栈帧的修复： 按Alt+P，选择BP Based Frame，然后指定4 bytes for Saved Registers</p><h2 id="5x5-使用图形选项"><a href="#5x5-使用图形选项" class="headerlink" title="5x5 使用图形选项"></a>5x5 使用图形选项</h2><p><img src="https://i.loli.net/2018/07/19/5b501e9930e37.jpg" alt="mark"></p><h2 id="5x6-增强反汇编"><a href="#5x6-增强反汇编" class="headerlink" title="5x6 增强反汇编"></a>5x6 增强反汇编</h2><p>IDA Pro没有撤销</p><ol><li>重命名</li><li>注释：将光标放在反汇编的某行上，并按冒号（:）</li><li>格式化操作数</li><li>使用命名的常量—-手动加载有关类型库：选择View-&gt;Open Subviews-&gt;Type Libraries</li><li>重新定义代码和数据<ol><li>按U取消函数，代码或数据的定义</li><li>按C定义原始字节为代码</li><li>按D定义原始字节为数据</li><li>按A定义原始字节为ASCII字符串</li></ol></li></ol><h2 id="5x7-用插件扩展IDA"><a href="#5x7-用插件扩展IDA" class="headerlink" title="5x7 用插件扩展IDA"></a>5x7 用插件扩展IDA</h2><h3 id="1-IDC脚本"><a href="#1-IDC脚本" class="headerlink" title="1. IDC脚本"></a>1. IDC脚本</h3><p>File-&gt;Script File   简单运行<br>File-&gt;IDC Command  作为单独命令运行</p><h3 id="2-IDAPython"><a href="#2-IDAPython" class="headerlink" title="2. IDAPython"></a>2. IDAPython</h3><h3 id="3-使用商业插件"><a href="#3-使用商业插件" class="headerlink" title="3. 使用商业插件"></a>3. 使用商业插件</h3><p>Hex-Rays生成伪代码<br>zynamics BinDiff比较两个IDA Pro数据库</p><p>From <a href="https://kabeor.github.io/第5章 IDA Pro/">https://kabeor.github.io/第5章 IDA Pro/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第5章-IDA-Pro&quot;&gt;&lt;a href=&quot;#第5章-IDA-Pro&quot; class=&quot;headerlink&quot; title=&quot;第5章 IDA Pro&quot;&gt;&lt;/a&gt;第5章 IDA Pro&lt;/h1&gt;&lt;p&gt;本章介绍了IDA Pro的使用方法，本文就只大致记录常用功能&lt;/p&gt;
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第二篇 静态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第4章 x86反汇编速成班</title>
    <link href="https://kabeor.github.io/%E7%AC%AC4%E7%AB%A0%20x86%E5%8F%8D%E6%B1%87%E7%BC%96%E9%80%9F%E6%88%90%E7%8F%AD/"/>
    <id>https://kabeor.github.io/第4章 x86反汇编速成班/</id>
    <published>2019-03-31T05:59:01.644Z</published>
    <updated>2018-07-19T05:16:17.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第4章-x86反汇编速成班"><a href="#第4章-x86反汇编速成班" class="headerlink" title="第4章 x86反汇编速成班"></a>第4章 x86反汇编速成班</h1><h2 id="4x1-抽象层次"><a href="#4x1-抽象层次" class="headerlink" title="4x1 抽象层次"></a>4x1 抽象层次</h2><blockquote><p>恶意代码分析时的三种编码层次<br><img src="https://i.loli.net/2018/07/19/5b501e70df5dd.jpg" alt="mark"></p><p>计算机系统的六个抽象层次</p></blockquote><p><strong>硬件</strong>   硬件层是唯一的一个物理层，由电子电路组成。这些电路实现了XOR门、AND门、OR门和NOT门等逻辑运算器的复杂组合，称为数字逻辑（digital logic）。由于物理特性，硬件很难被软件所操纵。</p><p><strong>微指令</strong>  微指令层又称为固件（firmware）。微指令只能在为它设计的特定电路上执行。这层由一些微指令构成，它们从更高的机器码层翻译而来，提供了访问硬件的接口。当分析恶意代码时，我们通常不关心微指令，因为它们通常是为特定的计算机硬件设计的。</p><p><strong>机器码</strong>  机器码层由操作码（opcode ）组成，操作码是一 些十六进制形式的数字，用于告诉处理器你想要它做什么。机器码一般由多条微指令实现，这样底层硬件就能实际执行代码了。而机器码本身又由高级语言编写的计算机程序编译而来。</p><p><strong>低级语言</strong>  低级语言是计算机体系结构指令集的人类易读版本，主要是汇编语言。恶意代码分析师使用这一层，因为对人来说，机器码太难理解了。我们使用反汇编器来生成低级语言的文本，这些文本由一些简单的助记符组成，如mov和jmp。</p><p><strong>高级语言</strong> 大部分程序员使用高级语言。高级语言对机器层做了很强的抽象，从而可以很轻松地使用程序逻辑和流控制机制。高级语言包括C、C＋＋等。它们被一个编译器经过称为编译的过程转化为机器码。</p><p><strong>解释性语言</strong>  解释型语言位于最高层。很多程序员使用诸如C＃、Perl、.NET、Java等解释语言。这一层的代码不会被编译为机器码，而是被翻译为了字节码。字节码 （bytecode）是特定于该语言的一种中间表示，它在解释器中执行。解释器（interpreter）是一个在运行时将字节码实时翻译为可执行机器码的程序。相比于传统被编译的代码，解释器提供了一种自动的抽象层次，因为它可以独立于操作系统，自己处理错误和管理内存。</p><h2 id="4x2-逆向工程"><a href="#4x2-逆向工程" class="headerlink" title="4x2 逆向工程"></a>4x2 逆向工程</h2><blockquote><p>恶意代码存储在磁盘上时，通常是机器码层的二进制形式。前面提到，机器码是一种计算机可以快速高效执行的代码形式。而我们反汇编恶意代码，就是使用反汇编器（disassembler），将恶意代码二进制文件作为输入，输出汇编语言代码。</p><p>汇编语言实际上是一类语言的统称。每种汇编语言的方言，都是用来对一 类微处理器家族编程的，例如，x86、x64、SPARC、PowerPC、MIPS、ARM 等。目前，x86是PC上最流行的体系结构。</p><p>x86，又称为IntelIA-32，是大部分32位PC使用的体系结构，微软目前所有的32位Windows系统也都运行在 x86上。此外，大部分运行在AM D64和Intel64体系结构上的W indows也都支持x86的32位二进制程序。正因如此，大部分恶意代码是为x86编译的。</p></blockquote><h2 id="4x3-x86体系结构"><a href="#4x3-x86体系结构" class="headerlink" title="4x3 x86体系结构"></a>4x3 x86体系结构</h2><p>大部分现代计算机体系结构（包括x86）在内部实现上遵循冯·诺依曼结构。这种结构包含3种硬件组件：</p><blockquote><p>•    中央处理单元（ CPU ），负责执行代码<br>•    内存（RAM），负责存储所有的数据和代码。<br>•    输入／输出系统（IO），为硬盘、键盘、显示器等设备提供接口。</p></blockquote><p>指针（instruction pointer）的寄存器（register）从内存取得要执行的指令，这个寄存器中存有指令的地址。寄存器是CPU中数据的基本存储单元，通过它，很多时候CPU不再需要访问内存，从而节省了时间。算术逻辑单元（arithmetic logic unit, ALU）执行从内存取来的指令，并将结果放到寄存器或内存中。一条条取指令、执行指令的过程不断重复，就形成了程序的运行。</p><p>冯诺依曼体系结构<br><img src="https://i.loli.net/2018/07/19/5b501e7100c59.jpg" alt="mark"></p><h3 id="1-内存"><a href="#1-内存" class="headerlink" title="1.内存"></a>1.内存</h3><p>一个程序的内存可分为如下四个主要的节<br><img src="https://i.loli.net/2018/07/19/5b501e71145f6.jpg" alt="mark"></p><blockquote><p><strong>数据</strong> 这个词指的是内存中一 个特定的节，名为数据节 （data section），其中包含了一 些值。这些值在程序初始加载时被放到这里，称为静态值（static value），因为程序运行时它们可能并不发生变化，还可以称为全局值（global value），因为程序的任何部分都可以使用它们。</p><p><strong>代码</strong> 代码节包含了在执行程序任务时CPU所取得的指令。这些代码决定了程序是做什么的，以及程序中的任务如何协调工作。</p><p><strong>堆</strong> 堆是为程序执行期间需要的动态内存准备的，用于创建（分配）新的值，以及消除（释放）不再需要的值。将其称为动态内存（dynamic memory），是因为其内容在程序运行期间经常被改变。</p><p><strong>栈</strong> 栈用于函数的局部变量和参数，以及控制程序执行流。</p></blockquote><h3 id="2-指令"><a href="#2-指令" class="headerlink" title="2. 指令"></a>2. 指令</h3><p>指令是汇编程序的构成块。在x86、汇编语言中，一条指令由一个助记符，以及零个或多个操作数组成。</p><h3 id="3-操作码和字节序"><a href="#3-操作码和字节序" class="headerlink" title="3. 操作码和字节序"></a>3. 操作码和字节序</h3><p>每条指令使用操作码告诉CPU程序要执行什么样的操作。<br>反汇编器将操作码翻译为人类易读的指令。</p><p>数据的字节序（enclianness）是指在一个大数据项中，最高位（大端，big-endian）还是最低位（小端，little-enclian）被排在第一位 （即排在最低的地址上）。</p><h3 id="4-操作数"><a href="#4-操作数" class="headerlink" title="4. 操作数"></a>4. 操作数</h3><p>操作数说明指令要使用的数据。有以下三种类型：</p><blockquote><p>立即数（immediate）操作数是一个固定的值<br>寄存器（register）操作数指向寄存器<br>内存地址（memory address）操作数指向感兴趣的值所在的内存地址，一般由方括号内包含值、寄存器或方程式组成，如［eax］。</p></blockquote><h3 id="5-寄存器"><a href="#5-寄存器" class="headerlink" title="5. 寄存器"></a>5. 寄存器</h3><p>寄存器是可以被CPU使用的少量数据存储器，访问其中内容的速度会比访问其他存储器要快。x86处理器中有一组寄存器，可以用于临时存储或者作为工作区。</p><p>最常用的x86寄存器，可以将它们归为以下四类：</p><blockquote><p>通用寄存器，CPU在执行期间使用。<br>段寄存器，用于定位内存节。<br>状态标志，用于做出决定。<br>指令指针，用于定位要执行的下一条指令。</p></blockquote><p>x86寄存器<br><img src="https://i.loli.net/2018/07/19/5b501e712850c.jpg" alt="mark"></p><p>所有通用寄存器的大小都是32位，可以在汇编代码中以32位或16位引用。</p><p>有4个寄存器（EAX、EBX、ECX、EDX）还可以8位值的方式引用，从而使用其最低的8位，或次低的8位。</p><p><strong>通用寄存器</strong>  通用寄存器一般用于存储数据或内存地址，而且经常交换着使用以完成程序。不过，虽然它们被称为通用寄存器，但它们并不完全通用。</p><p>一些x86指令只能使用特定的寄存器。例如，乘法和除法指令就只能使用EAX和EDX。</p><p><strong>标志寄存器</strong>  EFLAGS寄存器是一个标志寄存器。在x86架构中，它是32位的，每一位是一个标志。在执行期间，每一位表示要么是置位（值为1），要么是清除（值为0），并由这些值来控制CPU 的运算，或者给出某些CPU运算的值。</p><p>对恶意代码分析来说，最重要的一些标志介绍如下：</p><blockquote><p><strong>ZF</strong>  当一个运算的结果等于0时，ZF被置位，否则被清除。<br><strong>CF</strong>  当一个运算的结果相对于目标操作数太大或太小时，CF被置位，否则被清除。<br><strong>SF</strong>  当一 个运算的结果为负数，SF被置位；若结果为正数，SF被清除。对算术运算，当运算结果的最高位值为l时，SF也会被置位。<br><strong>TF</strong> TF用于调试。当它被置位时，x86处理器每次只执行一条指令。</p></blockquote><p><strong>EIP指令指针</strong><br>在x86架构中，EIP寄存器，又称为指令指针或程序计数器，保存了程序将要执行的下一条指令在内存中的地址。EIP的唯一作用就是告诉处理器接下来要做什么。</p><blockquote><p>注意：当EIP被破坏（即指向了一个不包含合法程序代码的内存地址 ）时，CPU 无法取得一条合法指令来执行，此时正在运行的程序就可能崩溃。当你控制了EIP，也就控制了CPU将要执行什么，这也就是为什么攻击者试图通过漏洞利用获得对EIP的控制。通常，攻击者先妥使攻击代码进入内存，然后改变EIP使其指向那段代码，从而攻击系统。</p></blockquote><h3 id="6-简单指令"><a href="#6-简单指令" class="headerlink" title="6. 简单指令"></a>6. 简单指令</h3><h4 id="mov"><a href="#mov" class="headerlink" title="mov"></a><strong>mov</strong></h4><p>用于将数据从一个位置移动到另一个位置</p><p>mov指令可以将数据移动到寄存器或内存，其格式是：mov destination, source</p><p>由方括号括起来的操作数是对内存中数据的引用。例如，［ebx]指向内存中地址为EBX处的数据。</p><h4 id="lea"><a href="#lea" class="headerlink" title="lea"></a><strong>lea</strong></h4><p>lea指令用来将一个内存地址赋给目的操作数。</p><p> “load effective address“（加载有效地址）的缩写。它的格式是lea destination, source。</p><p>例如，lea eax, [ebx+8］就将EBX+8的值给EAX。</p><p>lea指令并非专门用于计算内存地址。它还被用来计算普通的值，因为它所需的指令更少。</p><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><p>加法和减法是从目标操作数中加上或减去一个值。</p><p>加法指令的格式是add destination, value。</p><p>减法的指令是sub destination, value。<br>sub指令会修改两个重要的标志：ZF和CF。<br>如果结果为零，ZF被置位；如果目标操作数比要减去的值小，则CF被置位。</p><p>inc和dec指令将一个寄存器加一和减一 。</p><p><img src="https://i.loli.net/2018/07/19/5b501e713bdd5.jpg" alt="mark"></p><p>乘法和除法都使用了一个预先规定的寄存器，因此其指令很简单，就是指令码加上寄存器要去乘或除的值。</p><p>mul指令的格式是mul value;<br>div指令的格式是div value。</p><p>mul或div指令要操作的寄存器一般会在之前许多条指令的地方被赋值，因此你可能需要在程序的上下文中来寻找。</p><p><img src="https://i.loli.net/2018/07/19/5b501e7150bf6.jpg" alt="mark"></p><p>mul value指令总是将eax乘上value。因此，EAX寄存器必须在乘法指令出现前就赋值好。乘法的结果以64位的形式分开存储在两个寄存器中：EDX和EAX。其中，EDX存储了高的32位，EAX存储低的32位。</p><p>div value指令将EDX和EAX合起来存储的64位值除以value。因此，在做除法之前，EDX和EAX这两个寄存器必须赋值好。除法的商将存储到EAX，余数则存储在EDX中。</p><p><strong>模（mod）</strong>运算会被编译为在div指令后取EDX寄存器的值（因为除法保留了余数）</p><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>x86架构还使用逻辑运算符，例如OR、AND和XOR。其相应指令的用法与add和sub类似，对源操作数和目的操作数做相应的操作，并将结果保存在目的操作数中。</p><p><em>xor eax, eax就一种将EAX寄存器快速置0的方法。这么做是为了优化，因为这条指令只需要2个字节，而mov eax, 0需要5个字节。</em></p><p>shr和shl指令用于对寄存器做移位操作。</p><p>shr指令的格式是 “shr destination, count”<br>shl指令的格式是 “shl destination, count” </p><p>shr和shl指令对目的操作数右移或左移，由count决定移多少位。移出目的操作数边界的位则会先移动到CF标志位中。在移位时，使用0填充新的位。移位运算全部完成后，CF标志位中就包含了最后移出目的操作数的那一位。</p><p>循环移位指令ror和rol与移位指令类似，但移出的那一位会被填到另一端空出来的位上，即右循环移位（ror）会将最低位循环移到最高位；左循环移位Crol)则相反。</p><p>移位经常被用于对乘法运算的优化。由于不需要像乘法那样设置寄存器、移动数据，移位会更简单、更快。</p><p>在分析恶意代码时，如果遇到一个函数中只有xor、or、and、shl、ror、shr、rol这样的指令，并且它们反复出现，看起来随机排列的样子，就可能是遇到了一个加密或者压缩函数。最好是将其标记为一个加密函数，然后继续后面的分析。</p><p><img src="https://i.loli.net/2018/07/19/5b501e7165db8.jpg" alt="mark"></p><h4 id="NOP指令"><a href="#NOP指令" class="headerlink" title="NOP指令"></a><strong>NOP指令</strong></h4><p>当它出现时，直接执行下一条指令。</p><p>这条指令的opcode是Ox90。在缓冲区溢出攻击中，当攻击者无法完美地控制利用代码，就经常使用NOP滑板。它起到了填充代码的作用，以降低shellcode可能在中间部分开始执行所造成的风险。</p><h3 id="7-栈"><a href="#7-栈" class="headerlink" title="7. 栈"></a>7. 栈</h3><p>用于函数的内存、局部变量、流控制结构等被存储在栈中。</p><p>栈是一种用压和弹操作来刻画的数据结构，向战中压入一些东西，然后再把它们弹出来。</p><p>它是一种后入先出（LIFO）的结构。</p><p>与栈有关的指令包括push、pop、call、leave、enter、和ret。在内存中，栈被分配成自顶向下的，最高的地址最先被使用。当一个值被压入战时，使用低一点的地址。</p><p>栈只能用于短期存储。它经常用于保存局部变量、参数和返回地址。其主要用途是管理函数调用之间的数据交换。而不同的编译器对这种管理方法的具体实现有所不同，但大部分常见约定都使用相对EBP的地址来引用局部变量与参数。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>许多函数包含一 段 “序言” （prologue），它是在函数开始处的少数几行代码，用于保存函数中要用到的栈和寄存器。相应的，在函数结尾的 “结语” （epilogue）则将技和这些寄存器恢复至函数被调用前的状态。</p><p>下面列举了函数调用最常见的实现流程</p><blockquote><ol><li>使用push指令将参数压入栈中。</li><li>使用call memory_location来调用函数。此时，当前指令地址（指EIP寄存器中的内容）被压入栈中。这个地址会在函数结束后，被用于返回到主代码。当函数开始执行时，EIP的值被设为memory_location （即函数的起始地址）。</li><li>通过函数的序言部分，分配栈中用于局部变量的空间，EBP （基址指针）也被压入栈中。这样就达到了为调用函数保存EBP的目的。</li><li>函数开始做它的工作。</li><li>通过函数的结语部分，恢复。调整E回来释放局部变量，恢复EBP，以使得调用函数可以准确地定位它的变量。leave指令可以用作结语，因为它的功能是使ESP等于EBP，然后从栈中弹出EBP。</li><li>函数通过调用ret指令返回。这个指令会从栈中弹出返回地址给EIP，因此程序会从原来调用的地方继续执行。</li><li>调整栈，以移除此前压入的参数，除非它们在后面还要被使用。</li></ol></blockquote><p>x86架构还提供了其他弹出和压入的指令，其中最常用的是pusha和pushad。它们将所有的寄存器都压入战中，并且常与popa和popad结合使用，后者从栈中弹出所有的寄存器。</p><p>pusha和pushad的具体功能如下。</p><blockquote><p>•    pusha以下面的顺序将所有16位寄存器压入栈中：AX、EX、DX 、BX 、SP、BP、SI、DI<br>• pushad以下面的顺序将所有32位寄存器压入栈中：EAX、ECX 、EDX 、EBX 、ESP、EBP、ESI、 EDI</p></blockquote><p><em>在shellcode中，如果要将寄存器的当前状态全部保存在栈上，以便稍后恢复，就常使用这些指令。编译器很少使用它们，因此，看到它们，通常说明是某人手工写的汇编代码或者shellcode。</em></p><h3 id="8-条件指令"><a href="#8-条件指令" class="headerlink" title="8. 条件指令"></a>8. 条件指令</h3><p>最常见的两个条件指令是test和cmp。</p><p>test指令与and指令的功能一样，但它并不会修改其使用的操作数。test指令只设置标志位。</p><p>对某个东西与它自身的test经常被用于检查它是否是一个NULL值。</p><p>cmp指令与sub指令的功能一样，但它不影响其操作数。cmp指令也是只用于设置标志位，其执行结果是，ZF和CF标志位可能发生变化。</p><h3 id="9-分支指令"><a href="#9-分支指令" class="headerlink" title="9. 分支指令"></a>9. 分支指令</h3><p>最常见的分支指令是跳转指令。程序中使用了大量的跳转指令，其中最简单的是jmp指令，它使得下一条要被执行的指令是其格式jmp location中指定位置的指令，又被称为无条件跳转，因为总会跳到目的位置去执行。这个简单的跳转无法满足所有的跳转需求。</p><p><img src="https://i.loli.net/2018/07/19/5b501e7188b0c.jpg" alt="mark"></p><h3 id="10-重复指令"><a href="#10-重复指令" class="headerlink" title="10. 重复指令"></a>10. 重复指令</h3><p>重复指令是一组操作数据缓冲区的指令。数据缓冲区通常是一个字节数组的形式，也可以是单字或者双字。</p><p>常见的数据缓冲区操作指令是movsx, cmpsx、stosx和scasx，其中x可以是b、w或者d，分别表示字节、字和双字。这些指令对任何形式的数据都有效。</p><p>在这些操作中，使用ESI和EDI寄存器。ESI是源索引寄存器，EDI是目的索引寄存器。还有ECX用作计数的变量。</p><p>这些指令还需要一 个前缀，用于对长度超过1的数据做操作。movsb指令本身只会移动一 个字节，而不使用ECX 寄存器。</p><p><img src="https://i.loli.net/2018/07/19/5b501e71a088e.jpg" alt="mark"></p><p>在x86下，使用重复前缀来做多字节操作。rep指令会增加ESI和EDI这两个偏移，减少ECX寄存器。rep前缀会不断重复，直至ECX=O。repe／repz和repne/repnz前缀则不断重复，直至ECX=O或直至ZF= 1或0。</p><p>movsb指令用于将一串字节从一个位置移动到另一 个位置。rep前缀经常与movsb一起使用，从而复制一串长度由ECX 决定的字节。从逻辑上说，rep movsb指令等价于C语言的memcpy函数。movsb指令从ESI指向地址取出一 个字节，将其存入ED I指向地址，然后根据方向标志（DF）的设置，将ESI和EDI的值加1或者减1。如果DF=O，则加，否则减。</p><p>在由C代码编译后的结果中，很少能看到DF标志。但是在shellcode里，人们有时候会调换方向标志，这样就可以反方向存储数据。如果有rep前缀，就会检查ECX是否为0，如果不等于0，则指令继续从ESI移动一个字节到EDI并将ECX 寄存器减1。这个过程会不断重复，直至ECX=0。</p><p>cmpsb指令用于比较两串字节，以确定其是否是相同的数据。cmpsb指令用ESI指向地址的字节减去EDI指向地址的字节，并更新相关的标志位。它经常与repe前缀一起使用。此时，cmpsb指令逐一比较两串字节，直至发现一处不同，或比较到头。cmpsb指令从地址ESI获得一 个字节，将其与ED I指向位置的字节进行比较，并设置标志位，然后对ESI和EDI分别加1。如果有「epe前缀，就检查ECX的值和标志位，如果ECX=O或者ZF=O，就停止重复。这相当于C语言中的memcmp函数。</p><p>scasb指令用于从一串字节中搜索一 个值。这个值由AL寄存器给出。它的工作方式与cmpsb一样，但是它是将ESI指向地址的字节与AL进行比较，而不是与EDI指向地址的字节比较。repe操作会使得这个比较不断继续，直到找到该字节，或者ECX=O。如果在这串字节中找到了那个值，则其位置会被存储在ESI中。</p><p>stosb指令用于将值存储到EDI指向的地址。它与scasb一样，但不是去搜索，而是将指定的字节存入EDI指向的地址。rep前缀与scasb一起使用后，就初始化了一段内存缓冲区，其中的每个字节都是相同的值。这等价于C语言的memset函数。</p><p><img src="https://i.loli.net/2018/07/19/5b501e71b359d.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501e7e0729d.jpg" alt="mark"></p><h3 id="11-C语言主函数和偏移"><a href="#11-C语言主函数和偏移" class="headerlink" title="11. C语言主函数和偏移"></a>11. C语言主函数和偏移</h3><p>一个标准C程序的主函数有两个参数，形式如下：<br><code>int main(int argc, char** argv)</code><br>参数argc和argv在运行时决定。其中，参数argc是一个整数，说明了命令行中参数的个数，包括程序名字本身：参数argv是一个字符串数据指针，指向了所有的命令行参数。</p><p><img src="https://i.loli.net/2018/07/19/5b501e7e24a3e.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501e7e38f9b.jpg" alt="mark"></p><h3 id="12-更多信息：Intel×86-Architecture-Manual"><a href="#12-更多信息：Intel×86-Architecture-Manual" class="headerlink" title="12. 更多信息：Intel×86 Architecture Manual"></a>12. 更多信息：Intel×86 Architecture Manual</h3><p><img src="https://i.loli.net/2018/07/19/5b501e7e50e23.jpg" alt="mark"><br><img src="https://i.loli.net/2018/07/19/5b501e7e66ddb.jpg" alt="mark"></p><p>From <a href="https://kabeor.github.io/第4章 x86反汇编速成班/">https://kabeor.github.io/第4章 x86反汇编速成班/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第4章-x86反汇编速成班&quot;&gt;&lt;a href=&quot;#第4章-x86反汇编速成班&quot; class=&quot;headerlink&quot; title=&quot;第4章 x86反汇编速成班&quot;&gt;&lt;/a&gt;第4章 x86反汇编速成班&lt;/h1&gt;&lt;h2 id=&quot;4x1-抽象层次&quot;&gt;&lt;a href=&quot;#4
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第二篇 静态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%8C%E7%AF%87-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
