<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>K&#39;s House</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kabeor.github.io/"/>
  <updated>2019-07-31T09:12:43.514Z</updated>
  <id>https://kabeor.github.io/</id>
  
  <author>
    <name>kabeor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018护网杯线上 APM233</title>
    <link href="https://kabeor.github.io/2018%E6%8A%A4%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8A%20APM233/"/>
    <id>https://kabeor.github.io/2018护网杯线上 APM233/</id>
    <published>2019-07-31T09:12:43.513Z</published>
    <updated>2019-07-31T09:12:43.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018护网杯线上-APM233"><a href="#2018护网杯线上-APM233" class="headerlink" title="2018护网杯线上 APM233"></a>2018护网杯线上 APM233</h1><p>MFC42的逆向</p><p><img src="https://i.loli.net/2019/07/31/5d4156590c9ba50005.jpg" alt></p><p>一共四层验证，IDA打开后基本全红，直接按P创建函数<br>花指令格式为<code>jz address+1;  jnz address+1;</code>,因此显示出address处的opcode，按D设为数据，address+1处创建函数，平衡栈帧即可</p><p>主流程<br><img src="https://i.loli.net/2019/07/31/5d41579664ffd31971.jpg" alt><br><img src="https://i.loli.net/2019/07/31/5d4157b6c3bce90900.jpg" alt></p><h2 id="Check1"><a href="#Check1" class="headerlink" title="Check1"></a>Check1</h2><p>第一层与字符串1d2e3c4a比较</p><h2 id="Check2"><a href="#Check2" class="headerlink" title="Check2"></a>Check2</h2><p><img src="https://i.loli.net/2019/07/31/5d415857c43ac44867.jpg" alt></p><p>z3直接计算<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">from z3 <span class="keyword">import</span> *</span><br><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">Dr0 = BitVec('Dr0',32)</span><br><span class="line">Dr1 = BitVec('Dr1',32)</span><br><span class="line">Dr2 = BitVec('Dr2',32)</span><br><span class="line">Dr3 = BitVec('Dr3',32)</span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">s.add(Dr0 &lt;= <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">s.add(Dr1 &lt;= <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">s.add(Dr2 &lt;= <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">s.add(Dr3 &lt;= <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">s.add(Dr1+Dr0 == <span class="number">0x899a9d9c</span>)</span><br><span class="line">s.add(Dr2+Dr1 == <span class="number">0x384989ED</span>)</span><br><span class="line">s.add(Dr3+Dr2 == <span class="number">0x2B2C85BC</span>)</span><br><span class="line">s.add(Dr0-Dr3 == <span class="number">0xAFAFDC11</span>)</span><br><span class="line"></span><br><span class="line">s.check()    </span><br><span class="line"></span><br><span class="line">m = s.model() </span><br><span class="line"></span><br><span class="line">Dr0 = int('%s'%m[Dr0])</span><br><span class="line">Dr1 = int('%s'%m[Dr1])</span><br><span class="line">Dr2 = int('%s'%m[Dr2])</span><br><span class="line">Dr3 = int('%s'%m[Dr3])</span><br><span class="line">    </span><br><span class="line">ans = '%s%s%s%s'%(p32(Dr0).encode('hex'),p32(Dr1).encode('hex'),p32(Dr2).encode('hex'),p32(Dr3).encode('hex'))</span><br><span class="line"></span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure></p><p>不知道为什么我这里的数值和别人的不一样，算出来的也不一样。。。正确结果应该是efbe3323adde6666feca1313beba1414</p><h2 id="Check3"><a href="#Check3" class="headerlink" title="Check3"></a>Check3</h2><p>各种反调试虚拟机检测，未检测到的返回值就是key：    0acb7935481efc12<br><img src="https://i.loli.net/2019/07/31/5d4158ff4387664889.jpg" alt></p><h2 id="Check4"><a href="#Check4" class="headerlink" title="Check4"></a>Check4</h2><p><img src="https://i.loli.net/2019/07/31/5d415a2bef10158583.jpg" alt></p><p><img src="https://i.loli.net/2019/07/31/5d415a3fd47ee42987.jpg" alt></p><p>要求玩家的位置不能与三个AI重合，玩家每次的可走的步数为1-4，AI的行动路线如下所示<br><code>a1 = [4, -1, 6, -1, 3, 2, 4, 1, 3, -1, 5, 1, 2, -1, 5, 1, 3, -2, 7, 0, 2, 3, 5, 0, 5, 0, 5, 2, 1, -2, 6, -1, 3, 3, 4, 0, 5, -1, 6, 0, 4, 0, 7, 0, 5, -2, 7, 2, 2, -1, 6, 2, 2, 1, 5, 0, 2, 0, 3, 0, 4, 0, 6, -1, 5, 0, 5, 3, 0, 5, 3, 2]</code><br><code>a2 = [2, 2, 3, 3, 3, -2, 7, 1, 1, 1, 5, 1, 0, 2, 5, 1, 0, 0, 4, 0, 7, 2, 2, 0, 4, 1, 3, 4, 0, 1, 6, -1, 5, -1, 3, 5, 1, 2, 5, 0, 5, 0, 2, 5, 1, 1, 5, 2, 2, 1, 2, 3, 5, -1, 4, 1, 2, -1, 7, 1, 2, 2, 1, 2, 5, 0, 5, 0, 5, -1, 3, 2]</code><br><code>a3 = [3, -1, 6, -1, 5, 0, 4, 0, 2, 5, 0, 5, 1, -1, 5, 1, 0, 2, 4, 0, 5, 0, 4, 0, 6, -1, 6, 1, 2, 1, 3, 3, 2, 3, 3, 0, 5, -1, 4, 0, 6, 0, 5, 0, 5, 1, 2, 2, 3, 0, 5, 5, 0, 0, 6, 2, -1, 1, 5, 1, 0, 3, 4, -1, 4, 5, 0, 2, 5, 1, 4, 1]</code><br>通过上述规则，可以得到玩家的路线为<br><code>[1, 4, 1, 3, 1, 4, 1, 2, 2, 3, 2, 1, 1, 4, 1, 1, 1, 4, 1, 4, 2, 3, 1, 4, 1, 4, 2, 1, 1, 4, 1, 3, 2, 3, 2, 3, 1, 4, 1, 4, 1, 4, 2, 3, 1, 4, 2, 2, 1, 4, 3, 2, 1, 4, 1, 1, 1, 4, 1, 2, 2, 3, 1, 4, 2, 3, 2, 3, 2, 3, 2, 3]</code><br>玩家的行动由输入b64encode后再将编码后的结果拆为两两一组</p><p>脚本<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode,b64encode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level4</span><span class="params">()</span>:</span></span><br><span class="line">    a1 = [<span class="number">4</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">-2</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">-2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">    a2 = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">-2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">    a3 = [<span class="number">3</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    pos1 = <span class="number">0</span></span><br><span class="line">    pos2 = <span class="number">0</span></span><br><span class="line">    pos3 = <span class="number">0</span></span><br><span class="line">    pos4 = <span class="number">0</span></span><br><span class="line">    choice = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a1)):</span><br><span class="line">        pos1 += a1[i]</span><br><span class="line">        pos2 += a2[i]</span><br><span class="line">        pos3 += a3[i]</span><br><span class="line">        <span class="keyword">if</span> (pos4 + <span class="number">4</span> != pos1) <span class="keyword">and</span> (pos4 + <span class="number">4</span> != pos2) <span class="keyword">and</span> (pos4 + <span class="number">4</span> != pos3):</span><br><span class="line">            t = <span class="number">4</span></span><br><span class="line">        <span class="keyword">elif</span> (pos4 + <span class="number">3</span> != pos1) <span class="keyword">and</span> (pos4 + <span class="number">3</span> != pos2) <span class="keyword">and</span> (pos4 + <span class="number">3</span> != pos3):</span><br><span class="line">            t = <span class="number">3</span></span><br><span class="line">        <span class="keyword">elif</span> (pos4 + <span class="number">2</span> != pos1) <span class="keyword">and</span> (pos4 + <span class="number">2</span> != pos2) <span class="keyword">and</span> (pos4 + <span class="number">2</span> != pos3):</span><br><span class="line">            t = <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = <span class="number">1</span></span><br><span class="line">        pos4 += t</span><br><span class="line">        choice.append(t<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> choice</span><br><span class="line"></span><br><span class="line">    b64 = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> choice</span><br><span class="line">    ans = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,len(choice),<span class="number">3</span>):</span><br><span class="line">        t = (choice[i]&lt;&lt;<span class="number">4</span>) + (choice[i+<span class="number">1</span>]&lt;&lt;<span class="number">2</span>) + choice[i+<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">print</span> t,</span><br><span class="line">        ans+=b64[t]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> ans</span><br><span class="line">    <span class="keyword">print</span> b64decode(ans)</span><br><span class="line"></span><br><span class="line"><span class="comment"># level1 1d2e3c4a</span></span><br><span class="line">level2()    <span class="comment"># efbe3323adde6666feca1313beba1414</span></span><br><span class="line"><span class="comment"># level3 0acb7935481efc12</span></span><br><span class="line">level4()    <span class="comment"># 21d03c42f365901cff</span></span><br></pre></td></tr></table></figure></p><p>程序输入有时间限制，可以找到时间call直接jmp，也可以鼠标模拟</p><p>鼠标点击模拟脚本<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymouse <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">m = PyMouse()</span><br><span class="line"></span><br><span class="line">k1 = <span class="string">"1d2e3c4a"</span></span><br><span class="line">key1 = list(k1)</span><br><span class="line">k2 = <span class="string">"efbe3323adde6666feca1313beba1414"</span></span><br><span class="line">key2 = list(k2)</span><br><span class="line">k3 = <span class="string">"0acb7935481efc12"</span></span><br><span class="line">key3 = list(k3)</span><br><span class="line">k4 = <span class="string">"21d03c42f365901cff"</span></span><br><span class="line">key4 = list(k4)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mnclick</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(y):</span><br><span class="line">        <span class="keyword">if</span>(x[i] == <span class="string">'0'</span>): m.click(<span class="number">1075</span>, <span class="number">418</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'1'</span>): m.click(<span class="number">1118</span>, <span class="number">418</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'2'</span>): m.click(<span class="number">1162</span>, <span class="number">418</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'3'</span>): m.click(<span class="number">1205</span>, <span class="number">418</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'4'</span>): m.click(<span class="number">1075</span>, <span class="number">465</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'5'</span>): m.click(<span class="number">1118</span>, <span class="number">465</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'6'</span>): m.click(<span class="number">1162</span>, <span class="number">465</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'7'</span>): m.click(<span class="number">1205</span>, <span class="number">465</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'8'</span>): m.click(<span class="number">1075</span>, <span class="number">511</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'9'</span>): m.click(<span class="number">1118</span>, <span class="number">511</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'a'</span>): m.click(<span class="number">1162</span>, <span class="number">511</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'b'</span>): m.click(<span class="number">1205</span>, <span class="number">511</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'c'</span>): m.click(<span class="number">1075</span>, <span class="number">558</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'d'</span>): m.click(<span class="number">1118</span>, <span class="number">558</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'e'</span>): m.click(<span class="number">1162</span>, <span class="number">558</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'f'</span>): m.click(<span class="number">1205</span>, <span class="number">558</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    m.click(<span class="number">670</span>, <span class="number">624</span>)</span><br><span class="line"></span><br><span class="line">mnclick(key1, <span class="number">8</span>)</span><br><span class="line">mnclick(key2, <span class="number">32</span>)</span><br><span class="line">mnclick(key3, <span class="number">16</span>)</span><br><span class="line">mnclick(key4, <span class="number">18</span>)</span><br></pre></td></tr></table></figure></p><p>按钮位置是用spy++查看窗口属性看到的</p><p>最后   flag{N0t_d1ff1cul7_r1ght?_3d34e}</p><p>From <a href="https://kabeor.github.io/2018护网杯线上 APM233/">https://kabeor.github.io/2018护网杯线上 APM233/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2018护网杯线上-APM233&quot;&gt;&lt;a href=&quot;#2018护网杯线上-APM233&quot; class=&quot;headerlink&quot; title=&quot;2018护网杯线上 APM233&quot;&gt;&lt;/a&gt;2018护网杯线上 APM233&lt;/h1&gt;&lt;p&gt;MFC42的逆向&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向， CTF" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C-CTF/"/>
    
  </entry>
  
  <entry>
    <title>SICNU-CTF逆向 Sign</title>
    <link href="https://kabeor.github.io/SICNU-CTF%E9%80%86%E5%90%91%20Sign/"/>
    <id>https://kabeor.github.io/SICNU-CTF逆向 Sign/</id>
    <published>2019-07-26T04:27:46.431Z</published>
    <updated>2019-07-26T04:35:11.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SICNU2018-CTF逆向-Sign"><a href="#SICNU2018-CTF逆向-Sign" class="headerlink" title="SICNU2018-CTF逆向 Sign"></a>SICNU2018-CTF逆向 Sign</h1><p>2018年五月川师的比赛题，一直放着没有看，今天清理文件拿出来看一下</p><p>x86,入口jmp一看就是VS编译，无壳无花</p><p>之前一直好奇大佬们是怎样做到秒题的，做完这道才题知道，只有敏锐的洞察力快速定位核心代码才是王道</p><p>main函数<br><img src="https://i.loli.net/2019/07/26/5d3a7c867363016763.jpg" alt></p><p>很显然有两个判断点<br>第一个直接看赋值v5的函数sub_401186，这道题有意思的点在于每个函数都会有一个二次跳转，因此如果不能及时定位到关键点，在限定的时间内很难分析出来<br><img src="https://i.loli.net/2019/07/26/5d3a7d54bc1be16220.jpg" alt><br>非常无用的跳转，一直想拿IDC脚本剔除，但可惜没什么思路<br>进入之后<br><img src="https://i.loli.net/2019/07/26/5d3a7d9d8e6f428329.jpg" alt></p><p>v8限定字符串长度，开头必须是 ‘SICNU{’  ,算上最后一个一定是‘}’，因此我们还要输入16个字符。<br>动态调试发现下面的判断也只判断了输入前6个字符，然后截断，并没有做其他操作</p><p>回到主函数看到第二个判定在v3，直接进入<br><img src="https://i.loli.net/2019/07/26/5d3a7ecb6d76846189.jpg" alt><br><img src="https://i.loli.net/2019/07/26/5d3a7ee02379c25978.jpg" alt></p><p>如图，动态调试发现，v1是对{后的输入每次取一字符，然后和key1密钥表异或，共操作六次<br>v2是剩余字符长度，其中除去反括号还有10个字符，这里sub_401230的功能F5识别出错，直接看汇编<br><img src="https://i.loli.net/2019/07/26/5d3a7ffddfe4436075.jpg" alt><br>rep stosd循环，ecx,11h为循环次数，eax初始0CCCCCCCCh，最后v2为固定值11</p><p>接下来判断是否是数字，是则+17，不是则与key2密钥表异或</p><p>接下来验证答案，要求C1等于key3-v20，C2等于key4-v13，所以写脚本直接反求即可</p><p>python脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a0 = [<span class="number">0xE5</span>, <span class="number">0xA6</span>, <span class="number">0xE4</span>, <span class="number">0xE2</span>, <span class="number">0xD4</span>, <span class="number">0x95</span>, <span class="number">0xEC</span>]</span><br><span class="line">a1 = [ <span class="number">0xFC</span>, <span class="number">0x11</span>, <span class="number">0x41</span>, <span class="number">0xC7</span>, <span class="number">0x66</span>, <span class="number">0x42</span>, <span class="number">0x5D</span>, <span class="number">0x68</span>, <span class="number">0x28</span>, <span class="number">0x3B</span>]</span><br><span class="line">key1 = [<span class="number">0xB2</span>, <span class="number">0xC3</span>, <span class="number">0xD5</span>, <span class="number">0xA1</span>, <span class="number">0xE4</span>, <span class="number">0xF8</span>, <span class="number">0xA9</span>]</span><br><span class="line">key2 = [<span class="number">0xA3</span>, <span class="number">0x45</span>, <span class="number">0xEA</span>, <span class="number">0x35</span>, <span class="number">0x3E</span>, <span class="number">0x26</span>, <span class="number">0x5D</span>, <span class="number">0x46</span>]</span><br><span class="line"></span><br><span class="line">C1 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">C1[i]=chr(key1[i]^a0[i])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"flag:    SICNU&#123;"</span>, end = <span class="string">''</span>)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">print(C1[a], end = <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line">C2 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">C2[i] = a1[j] - <span class="number">17</span></span><br><span class="line"><span class="keyword">if</span>(C2[i]&gt;=<span class="number">48</span> <span class="keyword">and</span> C2[i]&lt;=<span class="number">57</span>):</span><br><span class="line">C2[i] = chr(C2[i])</span><br><span class="line">i=i+<span class="number">1</span></span><br><span class="line">j=j+<span class="number">1</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">C2[i] = chr(key2[k] ^ a1[j])</span><br><span class="line">i=i+<span class="number">1</span></span><br><span class="line">j=j+<span class="number">1</span></span><br><span class="line">k=k+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">print(C2[a], end = <span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>flag<br><img src="https://i.loli.net/2019/07/26/5d3a8138d970b13890.jpg" alt></p><p>From <a href="https://kabeor.github.io/SICNU-CTF逆向 Sign/">https://kabeor.github.io/SICNU-CTF逆向 Sign/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SICNU2018-CTF逆向-Sign&quot;&gt;&lt;a href=&quot;#SICNU2018-CTF逆向-Sign&quot; class=&quot;headerlink&quot; title=&quot;SICNU2018-CTF逆向 Sign&quot;&gt;&lt;/a&gt;SICNU2018-CTF逆向 Sign&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向， CTF" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C-CTF/"/>
    
  </entry>
  
  <entry>
    <title>逆向分析加解密之TwoFish算法</title>
    <link href="https://kabeor.github.io/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%B9%8BTwoFish%E7%AE%97%E6%B3%95/"/>
    <id>https://kabeor.github.io/逆向分析加解密之TwoFish算法/</id>
    <published>2019-07-25T04:02:55.808Z</published>
    <updated>2019-07-31T02:30:41.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向分析加解密之TwoFish算法"><a href="#逆向分析加解密之TwoFish算法" class="headerlink" title="逆向分析加解密之TwoFish算法"></a>逆向分析加解密之TwoFish算法</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5807" target="_blank" rel="noopener">https://xz.aliyun.com/t/5807</a></p></blockquote><p>前几天某师傅给我发来一个逆向题，拿来分析发现竟是AES决赛算法之一的TwoFish算法，之前网上对此算法的逆向分析竟然一个都没有，对算法的介绍也只有寥寥数语，于是想准备在这里与大家分享对该算法的逆向分析以及CTF中此算法的变体。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>官方有一个68页的pdf，有兴趣可以看一下<br><a href="http://www.schneier.com/twofish-analysis-shiho.pdf" target="_blank" rel="noopener">http://www.schneier.com/twofish-analysis-shiho.pdf</a></p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://i.loli.net/2019/07/25/5d391b311e84491804.jpg" alt></p><p>TwoFish的意思应该就是这样交叉运算的形状吧</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>TwoFish加密需要明文(plain)和密钥(key)<br>总的来说进行一次加解密可分为三个环节</p><ol><li>Input whitening</li><li>16次循环</li><li>Output whitening</li></ol><h4 id="Input-whitening"><a href="#Input-whitening" class="headerlink" title="Input whitening"></a>Input whitening</h4><blockquote><ol><li>拓展密钥</li></ol></blockquote><p>在Twofish 算法中，规定密钥的长度 N = 128, N = 192, N = 256三种。也就是说密钥的长度可以在128-bit ~ 256-bit之间变化。</p><p>我们需要产生40个与密钥相关的K(i)，这里的K(i)是根据密钥算出来的32-bit数据<br>除此以外，我们还需要4个与密钥相关的S-box，也就是s(i)()。</p><p>为计算K和S，定义MDS矩阵</p><p><img src="https://i.loli.net/2019/07/25/5d392304b308519968.jpg" alt> </p><p>且对于MDS 矩阵，有限域GF的定义如下：<br><code>GF(2^8) ≡ GF(2)(x)/v(x)，其中v(x) = x^8 + x^6 + x^5 + x^3 + 1</code>   </p><p>此外还需要h函数</p><pre><code> y(k,j) = x(j)                     j = 0, ... ,3如果：k == 4    y(3,0) = q1[y(4,0)] xor l(3,0)    y(3,1) = q0[y(4,1)] xor l(3,1)    y(3,2) = q0[y(4,2)] xor l(3,2)    y(3,3) = q1[y(4,3)] xor l(3,3)如果：k &gt;= 3    y(2,0) = q1[y(3,0)] xor l(2,0)    y(2,1) = q1[y(3,1)] xor l(2,1)    y(2,2) = q0[y(3,2)] xor l(2,2)    y(2,3) = q0[y(3,3)] xor l(3,3)对于所有情况：    y0 = q1[q0[q0[y(2,0)] xor l(1,0)] xor l(0,0)]    y1 = q0[q0[q1[y(2,1)] xor l(1,1)] xor l(0,1)]    y2 = q1[q1[q0[y(2,2)] xor l(1,2)] xor l(0,2)]    y3 = q0[q1[q1[y(2,3)] xor l(1,3)] xor l(0,3)]</code></pre><p>实现代码稍后来说</p><blockquote><ol><li>输入白化</li></ol></blockquote><p>因为加密前的plain text是128 bits，也就是16 bytes。假设这16 bytes分别是p0, … ,p15。将p0, … ,p15分为4组：<br><code>P(i) = ∑p(4i+j)2^(8j)，其中i,j = 0, ... ,3</code></p><p>然后进行运算<code>R(0,i) = P(i) xor K(i)，其中i = 0, ... ,3</code></p><h4 id="16次运算"><a href="#16次运算" class="headerlink" title="16次运算"></a>16次运算</h4><p>将以下公式循环16次</p><pre><code>(F(r,0), F(r,1)) = F(R(r,0), R(r,1), r) R(r+1,0) = ROR(R(r,2) xor F(r,0), 1) R(r+1,1) = ROL(R(r,3), 1) xor F(r,1) R(r+1,2) = R(r,0) R(r+1,3) = R(r,1)</code></pre><p>其中，F函数为以下操作</p><pre><code>t0 = g(r0)t1 = rol(r1, 8)t1 = g(t1)o = 2*rF0 = (T0 +  T1 + K(2r+8)) mod 2^32F1 = (T0 + 2T1 + K(2r+9)) mod 2^32</code></pre><p>其中g函数为核心函数</p><pre><code>x(i) = [X/2^(8i)] mod 2^8  其中i = 0, ... ,3y(i) = s(i)(x(i))       其中i = 0, ... ,3</code></pre><p><img src="https://i.loli.net/2019/07/25/5d392756d7d6492028.jpg" alt> </p><pre><code>Z = ∑z(i)2^(8i)，其中i = 0, ... ,3</code></pre><h4 id="输出白化"><a href="#输出白化" class="headerlink" title="输出白化"></a>输出白化</h4><pre><code>C(i) = R(16,(i+2) mod 4) xor K(i+4)，其中i = 0, ... ,3</code></pre><p>最后计算组成密文</p><pre><code>c(i) = [C(i/4) / 2^(8(i mod 4))] mod 2^8，其中i = 0, ... ,15</code></pre><p>下面来逆向分析看一下实际实现吧</p><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>拿到题后PEID分析<br><img src="https://i.loli.net/2019/07/25/5d392ac4cd3a266075.jpg" alt><br>分析到了TwoFish算法</p><p>IDA分析一下，进入主函数看到流程<br><img src="https://i.loli.net/2019/07/25/5d392b24602bc32573.jpg" alt><br><img src="https://i.loli.net/2019/07/25/5d392b4b3d71797118.jpg" alt></p><p>发现有五个选项，选项名字在sub_402FDA中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_402FDA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"welcome to jiami jiemi game go.go.go."</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"1._jiemi_(admin only)"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"2._jiami_"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"3._jiemi__flag(admin only)"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"4.exit"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"5._yanzheng__"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有选项2和5可用，即加密和验证flag</p><p>进入验证函数sub_40302B查看<br><img src="https://i.loli.net/2019/07/25/5d392c3cbd53454896.jpg" alt></p><p>这里我已经注释出密文和key，因此我们只需要解密即可，但只用标准解密算法就可以吗？我们来验证一下</p><p>很明显加密函数为sub_402E5D(&amp;key, plain, &amp;v3);  参数v3传出密钥<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_BYTE *__<span class="function">cdecl <span class="title">sub_402E5D</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v3; <span class="comment">// ST1C_4</span></span><br><span class="line"></span><br><span class="line">  v3 = sub_401570(a1, <span class="number">128u</span>);                    <span class="comment">// a1 = key   密钥生成k和s</span></span><br><span class="line">  sub_401626(v3, a2, a3);                          <span class="comment">//输入白化，循环，输出白化</span></span><br><span class="line">  <span class="keyword">return</span> sub_401626(v3, (a2 + <span class="number">16</span>), a3 + <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面来结合标准实现分析<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_401570</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v2; <span class="comment">// ST1C_4</span></span><br><span class="line">  _BYTE *v3; <span class="comment">// ST18_4</span></span><br><span class="line">  <span class="keyword">void</span> *v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// ST14_4</span></span><br><span class="line"></span><br><span class="line">  v2 = sub_402D53(a1, a2 &gt;&gt; <span class="number">3</span>);                 <span class="comment">// key_t* tf_key = expand_key(s, len/8);  拓展密钥</span></span><br><span class="line">  v3 = sub_4025C6(v2);                          <span class="comment">// subkey_t *tf_subkey = Twofish_generate_subkey(tf_key);  生成密钥</span></span><br><span class="line">  v4 = <span class="built_in">malloc</span>(<span class="number">4260u</span>);</span><br><span class="line">  v5 = sub_401B7A(v4, v3, <span class="number">0x1010101</span>, *v2 &gt;&gt; <span class="number">3</span>); <span class="comment">// tf_twofish = Twofish_generate_ext_k_keys(tf_twofish,tf_subkey,0x01010101,(tf_key-&gt;len/8));  生成k</span></span><br><span class="line">  v6 = sub_401CF8(v5, v3, *v2 &gt;&gt; <span class="number">3</span>);            <span class="comment">// tf_twofish = Twofish_generate_ext_s_keys(tf_twofish,tf_subkey,(tf_key-&gt;len/8));  生成s</span></span><br><span class="line">  <span class="built_in">free</span>(v2[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">free</span>(v2);</span><br><span class="line">  <span class="built_in">free</span>(v3);</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>拓展密钥</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d3930a1cc7b017798.jpg" alt><br>可以看到题中对位数分析的判定进行了修改</p><blockquote><p>生成密钥</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d39312bb0d7d18656.jpg" alt><br>c实现<img src="https://i.loli.net/2019/07/25/5d3931a257bc836488.jpg" alt></p><p>rsm函数定义为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rsm(i,a,b,c,d,e,f,g,h)  \</span></span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>),a,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">1</span>),b,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">2</span>),c,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">3</span>),d,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">4</span>),e,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">5</span>),f,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">6</span>),g,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">7</span>),h,<span class="number">0x14d</span>)</span><br></pre></td></tr></table></figure><blockquote><p>k生成</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d3931f15177364722.jpg" alt><br>h函数内部，可以看出，IDA将二维数组直接一维化<br><img src="https://i.loli.net/2019/07/25/5d39322bb987d21871.jpg" alt></p><p>q0,q1都是256大小的数组<br><img src="https://i.loli.net/2019/07/25/5d3932450ddac91007.jpg" alt><br>标准<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> q[<span class="number">2</span>][<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* q0 */</span></span><br><span class="line">    &#123;<span class="number">0xa9</span>,<span class="number">0x67</span>,<span class="number">0xb3</span>,<span class="number">0xe8</span>,<span class="number">0x4</span>,<span class="number">0xfd</span>,<span class="number">0xa3</span>,<span class="number">0x76</span>,<span class="number">0x9a</span>,<span class="number">0x92</span>,<span class="number">0x80</span>,<span class="number">0x78</span>,<span class="number">0xe4</span>,<span class="number">0xdd</span>,<span class="number">0xd1</span>,<span class="number">0x38</span>,</span><br><span class="line"><span class="number">0xd</span>,<span class="number">0xc6</span>,<span class="number">0x35</span>,<span class="number">0x98</span>,<span class="number">0x18</span>,<span class="number">0xf7</span>,<span class="number">0xec</span>,<span class="number">0x6c</span>,<span class="number">0x43</span>,<span class="number">0x75</span>,<span class="number">0x37</span>,<span class="number">0x26</span>,<span class="number">0xfa</span>,<span class="number">0x13</span>,<span class="number">0x94</span>,<span class="number">0x48</span>,</span><br><span class="line"><span class="number">0xf2</span>,<span class="number">0xd0</span>,<span class="number">0x8b</span>,<span class="number">0x30</span>,<span class="number">0x84</span>,<span class="number">0x54</span>,<span class="number">0xdf</span>,<span class="number">0x23</span>,<span class="number">0x19</span>,<span class="number">0x5b</span>,<span class="number">0x3d</span>,<span class="number">0x59</span>,<span class="number">0xf3</span>,<span class="number">0xae</span>,<span class="number">0xa2</span>,<span class="number">0x82</span>,</span><br><span class="line"><span class="number">0x63</span>,<span class="number">0x1</span>,<span class="number">0x83</span>,<span class="number">0x2e</span>,<span class="number">0xd9</span>,<span class="number">0x51</span>,<span class="number">0x9b</span>,<span class="number">0x7c</span>,<span class="number">0xa6</span>,<span class="number">0xeb</span>,<span class="number">0xa5</span>,<span class="number">0xbe</span>,<span class="number">0x16</span>,<span class="number">0xc</span>,<span class="number">0xe3</span>,<span class="number">0x61</span>,</span><br><span class="line"><span class="number">0xc0</span>,<span class="number">0x8c</span>,<span class="number">0x3a</span>,<span class="number">0xf5</span>,<span class="number">0x73</span>,<span class="number">0x2c</span>,<span class="number">0x25</span>,<span class="number">0xb</span>,<span class="number">0xbb</span>,<span class="number">0x4e</span>,<span class="number">0x89</span>,<span class="number">0x6b</span>,<span class="number">0x53</span>,<span class="number">0x6a</span>,<span class="number">0xb4</span>,<span class="number">0xf1</span>,</span><br><span class="line"><span class="number">0xe1</span>,<span class="number">0xe6</span>,<span class="number">0xbd</span>,<span class="number">0x45</span>,<span class="number">0xe2</span>,<span class="number">0xf4</span>,<span class="number">0xb6</span>,<span class="number">0x66</span>,<span class="number">0xcc</span>,<span class="number">0x95</span>,<span class="number">0x3</span>,<span class="number">0x56</span>,<span class="number">0xd4</span>,<span class="number">0x1c</span>,<span class="number">0x1e</span>,<span class="number">0xd7</span>,</span><br><span class="line"><span class="number">0xfb</span>,<span class="number">0xc3</span>,<span class="number">0x8e</span>,<span class="number">0xb5</span>,<span class="number">0xe9</span>,<span class="number">0xcf</span>,<span class="number">0xbf</span>,<span class="number">0xba</span>,<span class="number">0xea</span>,<span class="number">0x77</span>,<span class="number">0x39</span>,<span class="number">0xaf</span>,<span class="number">0x33</span>,<span class="number">0xc9</span>,<span class="number">0x62</span>,<span class="number">0x71</span>,</span><br><span class="line"><span class="number">0x81</span>,<span class="number">0x79</span>,<span class="number">0x9</span>,<span class="number">0xad</span>,<span class="number">0x24</span>,<span class="number">0xcd</span>,<span class="number">0xf9</span>,<span class="number">0xd8</span>,<span class="number">0xe5</span>,<span class="number">0xc5</span>,<span class="number">0xb9</span>,<span class="number">0x4d</span>,<span class="number">0x44</span>,<span class="number">0x8</span>,<span class="number">0x86</span>,<span class="number">0xe7</span>,</span><br><span class="line"><span class="number">0xa1</span>,<span class="number">0x1d</span>,<span class="number">0xaa</span>,<span class="number">0xed</span>,<span class="number">0x6</span>,<span class="number">0x70</span>,<span class="number">0xb2</span>,<span class="number">0xd2</span>,<span class="number">0x41</span>,<span class="number">0x7b</span>,<span class="number">0xa0</span>,<span class="number">0x11</span>,<span class="number">0x31</span>,<span class="number">0xc2</span>,<span class="number">0x27</span>,<span class="number">0x90</span>,</span><br><span class="line"><span class="number">0x20</span>,<span class="number">0xf6</span>,<span class="number">0x60</span>,<span class="number">0xff</span>,<span class="number">0x96</span>,<span class="number">0x5c</span>,<span class="number">0xb1</span>,<span class="number">0xab</span>,<span class="number">0x9e</span>,<span class="number">0x9c</span>,<span class="number">0x52</span>,<span class="number">0x1b</span>,<span class="number">0x5f</span>,<span class="number">0x93</span>,<span class="number">0xa</span>,<span class="number">0xef</span>,</span><br><span class="line"><span class="number">0x91</span>,<span class="number">0x85</span>,<span class="number">0x49</span>,<span class="number">0xee</span>,<span class="number">0x2d</span>,<span class="number">0x4f</span>,<span class="number">0x8f</span>,<span class="number">0x3b</span>,<span class="number">0x47</span>,<span class="number">0x87</span>,<span class="number">0x6d</span>,<span class="number">0x46</span>,<span class="number">0xd6</span>,<span class="number">0x3e</span>,<span class="number">0x69</span>,<span class="number">0x64</span>,</span><br><span class="line"><span class="number">0x2a</span>,<span class="number">0xce</span>,<span class="number">0xcb</span>,<span class="number">0x2f</span>,<span class="number">0xfc</span>,<span class="number">0x97</span>,<span class="number">0x5</span>,<span class="number">0x7a</span>,<span class="number">0xac</span>,<span class="number">0x7f</span>,<span class="number">0xd5</span>,<span class="number">0x1a</span>,<span class="number">0x4b</span>,<span class="number">0xe</span>,<span class="number">0xa7</span>,<span class="number">0x5a</span>,</span><br><span class="line"><span class="number">0x28</span>,<span class="number">0x14</span>,<span class="number">0x3f</span>,<span class="number">0x29</span>,<span class="number">0x88</span>,<span class="number">0x3c</span>,<span class="number">0x4c</span>,<span class="number">0x2</span>,<span class="number">0xb8</span>,<span class="number">0xda</span>,<span class="number">0xb0</span>,<span class="number">0x17</span>,<span class="number">0x55</span>,<span class="number">0x1f</span>,<span class="number">0x8a</span>,<span class="number">0x7d</span>,</span><br><span class="line"><span class="number">0x57</span>,<span class="number">0xc7</span>,<span class="number">0x8d</span>,<span class="number">0x74</span>,<span class="number">0xb7</span>,<span class="number">0xc4</span>,<span class="number">0x9f</span>,<span class="number">0x72</span>,<span class="number">0x7e</span>,<span class="number">0x15</span>,<span class="number">0x22</span>,<span class="number">0x12</span>,<span class="number">0x58</span>,<span class="number">0x7</span>,<span class="number">0x99</span>,<span class="number">0x34</span>,</span><br><span class="line"><span class="number">0x6e</span>,<span class="number">0x50</span>,<span class="number">0xde</span>,<span class="number">0x68</span>,<span class="number">0x65</span>,<span class="number">0xbc</span>,<span class="number">0xdb</span>,<span class="number">0xf8</span>,<span class="number">0xc8</span>,<span class="number">0xa8</span>,<span class="number">0x2b</span>,<span class="number">0x40</span>,<span class="number">0xdc</span>,<span class="number">0xfe</span>,<span class="number">0x32</span>,<span class="number">0xa4</span>,</span><br><span class="line"><span class="number">0xca</span>,<span class="number">0x10</span>,<span class="number">0x21</span>,<span class="number">0xf0</span>,<span class="number">0xd3</span>,<span class="number">0x5d</span>,<span class="number">0xf</span>,<span class="number">0x0</span>,<span class="number">0x6f</span>,<span class="number">0x9d</span>,<span class="number">0x36</span>,<span class="number">0x42</span>,<span class="number">0x4a</span>,<span class="number">0x5e</span>,<span class="number">0xc1</span>,<span class="number">0xe0</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="comment">/* q1 */</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="number">0x75</span>,<span class="number">0xf3</span>,<span class="number">0xc6</span>,<span class="number">0xf4</span>,<span class="number">0xdb</span>,<span class="number">0x7b</span>,<span class="number">0xfb</span>,<span class="number">0xc8</span>,<span class="number">0x4a</span>,<span class="number">0xd3</span>,<span class="number">0xe6</span>,<span class="number">0x6b</span>,<span class="number">0x45</span>,<span class="number">0x7d</span>,<span class="number">0xe8</span>,<span class="number">0x4b</span>,</span><br><span class="line"><span class="number">0xd6</span>,<span class="number">0x32</span>,<span class="number">0xd8</span>,<span class="number">0xfd</span>,<span class="number">0x37</span>,<span class="number">0x71</span>,<span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x30</span>,<span class="number">0xf</span>,<span class="number">0xf8</span>,<span class="number">0x1b</span>,<span class="number">0x87</span>,<span class="number">0xfa</span>,<span class="number">0x6</span>,<span class="number">0x3f</span>,</span><br><span class="line"><span class="number">0x5e</span>,<span class="number">0xba</span>,<span class="number">0xae</span>,<span class="number">0x5b</span>,<span class="number">0x8a</span>,<span class="number">0x0</span>,<span class="number">0xbc</span>,<span class="number">0x9d</span>,<span class="number">0x6d</span>,<span class="number">0xc1</span>,<span class="number">0xb1</span>,<span class="number">0xe</span>,<span class="number">0x80</span>,<span class="number">0x5d</span>,<span class="number">0xd2</span>,<span class="number">0xd5</span>,</span><br><span class="line"><span class="number">0xa0</span>,<span class="number">0x84</span>,<span class="number">0x7</span>,<span class="number">0x14</span>,<span class="number">0xb5</span>,<span class="number">0x90</span>,<span class="number">0x2c</span>,<span class="number">0xa3</span>,<span class="number">0xb2</span>,<span class="number">0x73</span>,<span class="number">0x4c</span>,<span class="number">0x54</span>,<span class="number">0x92</span>,<span class="number">0x74</span>,<span class="number">0x36</span>,<span class="number">0x51</span>,</span><br><span class="line"><span class="number">0x38</span>,<span class="number">0xb0</span>,<span class="number">0xbd</span>,<span class="number">0x5a</span>,<span class="number">0xfc</span>,<span class="number">0x60</span>,<span class="number">0x62</span>,<span class="number">0x96</span>,<span class="number">0x6c</span>,<span class="number">0x42</span>,<span class="number">0xf7</span>,<span class="number">0x10</span>,<span class="number">0x7c</span>,<span class="number">0x28</span>,<span class="number">0x27</span>,<span class="number">0x8c</span>,</span><br><span class="line"><span class="number">0x13</span>,<span class="number">0x95</span>,<span class="number">0x9c</span>,<span class="number">0xc7</span>,<span class="number">0x24</span>,<span class="number">0x46</span>,<span class="number">0x3b</span>,<span class="number">0x70</span>,<span class="number">0xca</span>,<span class="number">0xe3</span>,<span class="number">0x85</span>,<span class="number">0xcb</span>,<span class="number">0x11</span>,<span class="number">0xd0</span>,<span class="number">0x93</span>,<span class="number">0xb8</span>,</span><br><span class="line"><span class="number">0xa6</span>,<span class="number">0x83</span>,<span class="number">0x20</span>,<span class="number">0xff</span>,<span class="number">0x9f</span>,<span class="number">0x77</span>,<span class="number">0xc3</span>,<span class="number">0xcc</span>,<span class="number">0x3</span>,<span class="number">0x6f</span>,<span class="number">0x8</span>,<span class="number">0xbf</span>,<span class="number">0x40</span>,<span class="number">0xe7</span>,<span class="number">0x2b</span>,<span class="number">0xe2</span>,</span><br><span class="line"><span class="number">0x79</span>,<span class="number">0xc</span>,<span class="number">0xaa</span>,<span class="number">0x82</span>,<span class="number">0x41</span>,<span class="number">0x3a</span>,<span class="number">0xea</span>,<span class="number">0xb9</span>,<span class="number">0xe4</span>,<span class="number">0x9a</span>,<span class="number">0xa4</span>,<span class="number">0x97</span>,<span class="number">0x7e</span>,<span class="number">0xda</span>,<span class="number">0x7a</span>,<span class="number">0x17</span>,</span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x94</span>,<span class="number">0xa1</span>,<span class="number">0x1d</span>,<span class="number">0x3d</span>,<span class="number">0xf0</span>,<span class="number">0xde</span>,<span class="number">0xb3</span>,<span class="number">0xb</span>,<span class="number">0x72</span>,<span class="number">0xa7</span>,<span class="number">0x1c</span>,<span class="number">0xef</span>,<span class="number">0xd1</span>,<span class="number">0x53</span>,<span class="number">0x3e</span>,</span><br><span class="line"><span class="number">0x8f</span>,<span class="number">0x33</span>,<span class="number">0x26</span>,<span class="number">0x5f</span>,<span class="number">0xec</span>,<span class="number">0x76</span>,<span class="number">0x2a</span>,<span class="number">0x49</span>,<span class="number">0x81</span>,<span class="number">0x88</span>,<span class="number">0xee</span>,<span class="number">0x21</span>,<span class="number">0xc4</span>,<span class="number">0x1a</span>,<span class="number">0xeb</span>,<span class="number">0xd9</span>,</span><br><span class="line"><span class="number">0xc5</span>,<span class="number">0x39</span>,<span class="number">0x99</span>,<span class="number">0xcd</span>,<span class="number">0xad</span>,<span class="number">0x31</span>,<span class="number">0x8b</span>,<span class="number">0x1</span>,<span class="number">0x18</span>,<span class="number">0x23</span>,<span class="number">0xdd</span>,<span class="number">0x1f</span>,<span class="number">0x4e</span>,<span class="number">0x2d</span>,<span class="number">0xf9</span>,<span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x4f</span>,<span class="number">0xf2</span>,<span class="number">0x65</span>,<span class="number">0x8e</span>,<span class="number">0x78</span>,<span class="number">0x5c</span>,<span class="number">0x58</span>,<span class="number">0x19</span>,<span class="number">0x8d</span>,<span class="number">0xe5</span>,<span class="number">0x98</span>,<span class="number">0x57</span>,<span class="number">0x67</span>,<span class="number">0x7f</span>,<span class="number">0x5</span>,<span class="number">0x64</span>,</span><br><span class="line"><span class="number">0xaf</span>,<span class="number">0x63</span>,<span class="number">0xb6</span>,<span class="number">0xfe</span>,<span class="number">0xf5</span>,<span class="number">0xb7</span>,<span class="number">0x3c</span>,<span class="number">0xa5</span>,<span class="number">0xce</span>,<span class="number">0xe9</span>,<span class="number">0x68</span>,<span class="number">0x44</span>,<span class="number">0xe0</span>,<span class="number">0x4d</span>,<span class="number">0x43</span>,<span class="number">0x69</span>,</span><br><span class="line"><span class="number">0x29</span>,<span class="number">0x2e</span>,<span class="number">0xac</span>,<span class="number">0x15</span>,<span class="number">0x59</span>,<span class="number">0xa8</span>,<span class="number">0xa</span>,<span class="number">0x9e</span>,<span class="number">0x6e</span>,<span class="number">0x47</span>,<span class="number">0xdf</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x6a</span>,<span class="number">0xcf</span>,<span class="number">0xdc</span>,</span><br><span class="line"><span class="number">0x22</span>,<span class="number">0xc9</span>,<span class="number">0xc0</span>,<span class="number">0x9b</span>,<span class="number">0x89</span>,<span class="number">0xd4</span>,<span class="number">0xed</span>,<span class="number">0xab</span>,<span class="number">0x12</span>,<span class="number">0xa2</span>,<span class="number">0xd</span>,<span class="number">0x52</span>,<span class="number">0xbb</span>,<span class="number">0x2</span>,<span class="number">0x2f</span>,<span class="number">0xa9</span>,</span><br><span class="line"><span class="number">0xd7</span>,<span class="number">0x61</span>,<span class="number">0x1e</span>,<span class="number">0xb4</span>,<span class="number">0x50</span>,<span class="number">0x4</span>,<span class="number">0xf6</span>,<span class="number">0xc2</span>,<span class="number">0x16</span>,<span class="number">0x25</span>,<span class="number">0x86</span>,<span class="number">0x56</span>,<span class="number">0x55</span>,<span class="number">0x9</span>,<span class="number">0xbe</span>,<span class="number">0x91</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>MDS矩阵运算<br><img src="https://i.loli.net/2019/07/25/5d39335e7c98176996.jpg" alt></p><blockquote><p>S-box生成</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d3933a271f7034024.jpg" alt></p><blockquote><p>输入白化，循环，输出白化  sub_401626</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d39363aca3b346223.jpg" alt></p><p>c实现<br><img src="https://i.loli.net/2019/07/25/5d393666d494e15914.jpg" alt></p><p>f函数<br><img src="https://i.loli.net/2019/07/25/5d39463d2a01720818.jpg" alt></p><h2 id="算法解密"><a href="#算法解密" class="headerlink" title="算法解密"></a>算法解密</h2><p>解密函数如下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_decryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *cypher, <span class="keyword">uint8_t</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> r0, r1, r2, r3, f0, f1, c2,c3;</span><br><span class="line">    <span class="comment">/* Input Whitenening */</span></span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">4</span>]^pack(cypher);</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">5</span>]^pack(cypher+<span class="number">4</span>);</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">6</span>]^pack(cypher+<span class="number">8</span>);</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">7</span>]^pack(cypher+<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The black box */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">15</span>; i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        Twofish_f(tf_twofish, i, r0, r1, &amp;f0, &amp;f1);</span><br><span class="line">        c2 = (rol(r2,<span class="number">1</span>)^f0);</span><br><span class="line">        c3 = ror((f1^r3),<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* swap */</span></span><br><span class="line">        r2 = r0;</span><br><span class="line">        r3 = r1;</span><br><span class="line">        r0 = c2;</span><br><span class="line">        r1 = c3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output Whitening */</span></span><br><span class="line">    c2 = r0;</span><br><span class="line">    c3 = r1;</span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">0</span>]^r2;</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">1</span>]^r3;</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">2</span>]^c2;</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">3</span>]^c3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]   = unpack(r0,i);</span><br><span class="line">        data[i+<span class="number">4</span>] = unpack(r1,i);</span><br><span class="line">        data[i+<span class="number">8</span>] = unpack(r2,i);</span><br><span class="line">        data[i+<span class="number">12</span>]= unpack(r3,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此TwoFish加解密代码如下</p><p>twofish.h<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TWOFISH__H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TWOFISH__H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWOFISH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  TWOFISH</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">twofish_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;</span><br><span class="line">    <span class="keyword">uint32_t</span> k[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> s[<span class="number">4</span>][<span class="number">256</span>];</span><br><span class="line">&#125;<span class="keyword">twofish_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish MDS Multiply Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   data</span></span><br><span class="line"><span class="comment"> * @param   cypher</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_encryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *data, <span class="keyword">uint8_t</span> *cypher)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Decryption Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @paramtf_twofish</span></span><br><span class="line"><span class="comment"> * @param   cypher</span></span><br><span class="line"><span class="comment"> * @param   data</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_decryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *cypher, <span class="keyword">uint8_t</span> *data)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Setup Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   s</span></span><br><span class="line"><span class="comment"> * @param   len</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">twofish_t</span>*  Twofish_setup(<span class="keyword">uint8_t</span> *s, <span class="keyword">uint32_t</span> len);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>tables.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">ifndef</span> __TABLES__H</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> __TABLES__H</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* The MDS Matrix */</span></span><br><span class="line"> <span class="keyword">uint8_t</span> mds[<span class="number">4</span>][<span class="number">4</span>]=</span><br><span class="line"> &#123;</span><br><span class="line">    &#123;<span class="number">0x01</span>, <span class="number">0xef</span>, <span class="number">0x5b</span>, <span class="number">0x5b</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x5b</span>, <span class="number">0xef</span>, <span class="number">0xef</span>, <span class="number">0x01</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xef</span>, <span class="number">0x5b</span>, <span class="number">0x01</span>, <span class="number">0xef</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xef</span>, <span class="number">0x01</span>, <span class="number">0xef</span>, <span class="number">0x5b</span>&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">uint8_t</span> q[<span class="number">2</span>][<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* q0 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line"><span class="number">0xa9</span>,<span class="number">0x67</span>,<span class="number">0xb3</span>,<span class="number">0xe8</span>,<span class="number">0x4</span>,<span class="number">0xfd</span>,<span class="number">0xa3</span>,<span class="number">0x76</span>,<span class="number">0x9a</span>,<span class="number">0x92</span>,<span class="number">0x80</span>,<span class="number">0x78</span>,<span class="number">0xe4</span>,<span class="number">0xdd</span>,<span class="number">0xd1</span>,<span class="number">0x38</span>,</span><br><span class="line"><span class="number">0xd</span>,<span class="number">0xc6</span>,<span class="number">0x35</span>,<span class="number">0x98</span>,<span class="number">0x18</span>,<span class="number">0xf7</span>,<span class="number">0xec</span>,<span class="number">0x6c</span>,<span class="number">0x43</span>,<span class="number">0x75</span>,<span class="number">0x37</span>,<span class="number">0x26</span>,<span class="number">0xfa</span>,<span class="number">0x13</span>,<span class="number">0x94</span>,<span class="number">0x48</span>,</span><br><span class="line"><span class="number">0xf2</span>,<span class="number">0xd0</span>,<span class="number">0x8b</span>,<span class="number">0x30</span>,<span class="number">0x84</span>,<span class="number">0x54</span>,<span class="number">0xdf</span>,<span class="number">0x23</span>,<span class="number">0x19</span>,<span class="number">0x5b</span>,<span class="number">0x3d</span>,<span class="number">0x59</span>,<span class="number">0xf3</span>,<span class="number">0xae</span>,<span class="number">0xa2</span>,<span class="number">0x82</span>,</span><br><span class="line"><span class="number">0x63</span>,<span class="number">0x1</span>,<span class="number">0x83</span>,<span class="number">0x2e</span>,<span class="number">0xd9</span>,<span class="number">0x51</span>,<span class="number">0x9b</span>,<span class="number">0x7c</span>,<span class="number">0xa6</span>,<span class="number">0xeb</span>,<span class="number">0xa5</span>,<span class="number">0xbe</span>,<span class="number">0x16</span>,<span class="number">0xc</span>,<span class="number">0xe3</span>,<span class="number">0x61</span>,</span><br><span class="line"><span class="number">0xc0</span>,<span class="number">0x8c</span>,<span class="number">0x3a</span>,<span class="number">0xf5</span>,<span class="number">0x73</span>,<span class="number">0x2c</span>,<span class="number">0x25</span>,<span class="number">0xb</span>,<span class="number">0xbb</span>,<span class="number">0x4e</span>,<span class="number">0x89</span>,<span class="number">0x6b</span>,<span class="number">0x53</span>,<span class="number">0x6a</span>,<span class="number">0xb4</span>,<span class="number">0xf1</span>,</span><br><span class="line"><span class="number">0xe1</span>,<span class="number">0xe6</span>,<span class="number">0xbd</span>,<span class="number">0x45</span>,<span class="number">0xe2</span>,<span class="number">0xf4</span>,<span class="number">0xb6</span>,<span class="number">0x66</span>,<span class="number">0xcc</span>,<span class="number">0x95</span>,<span class="number">0x3</span>,<span class="number">0x56</span>,<span class="number">0xd4</span>,<span class="number">0x1c</span>,<span class="number">0x1e</span>,<span class="number">0xd7</span>,</span><br><span class="line"><span class="number">0xfb</span>,<span class="number">0xc3</span>,<span class="number">0x8e</span>,<span class="number">0xb5</span>,<span class="number">0xe9</span>,<span class="number">0xcf</span>,<span class="number">0xbf</span>,<span class="number">0xba</span>,<span class="number">0xea</span>,<span class="number">0x77</span>,<span class="number">0x39</span>,<span class="number">0xaf</span>,<span class="number">0x33</span>,<span class="number">0xc9</span>,<span class="number">0x62</span>,<span class="number">0x71</span>,</span><br><span class="line"><span class="number">0x81</span>,<span class="number">0x79</span>,<span class="number">0x9</span>,<span class="number">0xad</span>,<span class="number">0x24</span>,<span class="number">0xcd</span>,<span class="number">0xf9</span>,<span class="number">0xd8</span>,<span class="number">0xe5</span>,<span class="number">0xc5</span>,<span class="number">0xb9</span>,<span class="number">0x4d</span>,<span class="number">0x44</span>,<span class="number">0x8</span>,<span class="number">0x86</span>,<span class="number">0xe7</span>,</span><br><span class="line"><span class="number">0xa1</span>,<span class="number">0x1d</span>,<span class="number">0xaa</span>,<span class="number">0xed</span>,<span class="number">0x6</span>,<span class="number">0x70</span>,<span class="number">0xb2</span>,<span class="number">0xd2</span>,<span class="number">0x41</span>,<span class="number">0x7b</span>,<span class="number">0xa0</span>,<span class="number">0x11</span>,<span class="number">0x31</span>,<span class="number">0xc2</span>,<span class="number">0x27</span>,<span class="number">0x90</span>,</span><br><span class="line"><span class="number">0x20</span>,<span class="number">0xf6</span>,<span class="number">0x60</span>,<span class="number">0xff</span>,<span class="number">0x96</span>,<span class="number">0x5c</span>,<span class="number">0xb1</span>,<span class="number">0xab</span>,<span class="number">0x9e</span>,<span class="number">0x9c</span>,<span class="number">0x52</span>,<span class="number">0x1b</span>,<span class="number">0x5f</span>,<span class="number">0x93</span>,<span class="number">0xa</span>,<span class="number">0xef</span>,</span><br><span class="line"><span class="number">0x91</span>,<span class="number">0x85</span>,<span class="number">0x49</span>,<span class="number">0xee</span>,<span class="number">0x2d</span>,<span class="number">0x4f</span>,<span class="number">0x8f</span>,<span class="number">0x3b</span>,<span class="number">0x47</span>,<span class="number">0x87</span>,<span class="number">0x6d</span>,<span class="number">0x46</span>,<span class="number">0xd6</span>,<span class="number">0x3e</span>,<span class="number">0x69</span>,<span class="number">0x64</span>,</span><br><span class="line"><span class="number">0x2a</span>,<span class="number">0xce</span>,<span class="number">0xcb</span>,<span class="number">0x2f</span>,<span class="number">0xfc</span>,<span class="number">0x97</span>,<span class="number">0x5</span>,<span class="number">0x7a</span>,<span class="number">0xac</span>,<span class="number">0x7f</span>,<span class="number">0xd5</span>,<span class="number">0x1a</span>,<span class="number">0x4b</span>,<span class="number">0xe</span>,<span class="number">0xa7</span>,<span class="number">0x5a</span>,</span><br><span class="line"><span class="number">0x28</span>,<span class="number">0x14</span>,<span class="number">0x3f</span>,<span class="number">0x29</span>,<span class="number">0x88</span>,<span class="number">0x3c</span>,<span class="number">0x4c</span>,<span class="number">0x2</span>,<span class="number">0xb8</span>,<span class="number">0xda</span>,<span class="number">0xb0</span>,<span class="number">0x17</span>,<span class="number">0x55</span>,<span class="number">0x1f</span>,<span class="number">0x8a</span>,<span class="number">0x7d</span>,</span><br><span class="line"><span class="number">0x57</span>,<span class="number">0xc7</span>,<span class="number">0x8d</span>,<span class="number">0x74</span>,<span class="number">0xb7</span>,<span class="number">0xc4</span>,<span class="number">0x9f</span>,<span class="number">0x72</span>,<span class="number">0x7e</span>,<span class="number">0x15</span>,<span class="number">0x22</span>,<span class="number">0x12</span>,<span class="number">0x58</span>,<span class="number">0x7</span>,<span class="number">0x99</span>,<span class="number">0x34</span>,</span><br><span class="line"><span class="number">0x6e</span>,<span class="number">0x50</span>,<span class="number">0xde</span>,<span class="number">0x68</span>,<span class="number">0x65</span>,<span class="number">0xbc</span>,<span class="number">0xdb</span>,<span class="number">0xf8</span>,<span class="number">0xc8</span>,<span class="number">0xa8</span>,<span class="number">0x2b</span>,<span class="number">0x40</span>,<span class="number">0xdc</span>,<span class="number">0xfe</span>,<span class="number">0x32</span>,<span class="number">0xa4</span>,</span><br><span class="line"><span class="number">0xca</span>,<span class="number">0x10</span>,<span class="number">0x21</span>,<span class="number">0xf0</span>,<span class="number">0xd3</span>,<span class="number">0x5d</span>,<span class="number">0xf</span>,<span class="number">0x0</span>,<span class="number">0x6f</span>,<span class="number">0x9d</span>,<span class="number">0x36</span>,<span class="number">0x42</span>,<span class="number">0x4a</span>,<span class="number">0x5e</span>,<span class="number">0xc1</span>,<span class="number">0xe0</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="comment">/* q1 */</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"><span class="number">0x75</span>,<span class="number">0xf3</span>,<span class="number">0xc6</span>,<span class="number">0xf4</span>,<span class="number">0xdb</span>,<span class="number">0x7b</span>,<span class="number">0xfb</span>,<span class="number">0xc8</span>,<span class="number">0x4a</span>,<span class="number">0xd3</span>,<span class="number">0xe6</span>,<span class="number">0x6b</span>,<span class="number">0x45</span>,<span class="number">0x7d</span>,<span class="number">0xe8</span>,<span class="number">0x4b</span>,</span><br><span class="line"><span class="number">0xd6</span>,<span class="number">0x32</span>,<span class="number">0xd8</span>,<span class="number">0xfd</span>,<span class="number">0x37</span>,<span class="number">0x71</span>,<span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x30</span>,<span class="number">0xf</span>,<span class="number">0xf8</span>,<span class="number">0x1b</span>,<span class="number">0x87</span>,<span class="number">0xfa</span>,<span class="number">0x6</span>,<span class="number">0x3f</span>,</span><br><span class="line"><span class="number">0x5e</span>,<span class="number">0xba</span>,<span class="number">0xae</span>,<span class="number">0x5b</span>,<span class="number">0x8a</span>,<span class="number">0x0</span>,<span class="number">0xbc</span>,<span class="number">0x9d</span>,<span class="number">0x6d</span>,<span class="number">0xc1</span>,<span class="number">0xb1</span>,<span class="number">0xe</span>,<span class="number">0x80</span>,<span class="number">0x5d</span>,<span class="number">0xd2</span>,<span class="number">0xd5</span>,</span><br><span class="line"><span class="number">0xa0</span>,<span class="number">0x84</span>,<span class="number">0x7</span>,<span class="number">0x14</span>,<span class="number">0xb5</span>,<span class="number">0x90</span>,<span class="number">0x2c</span>,<span class="number">0xa3</span>,<span class="number">0xb2</span>,<span class="number">0x73</span>,<span class="number">0x4c</span>,<span class="number">0x54</span>,<span class="number">0x92</span>,<span class="number">0x74</span>,<span class="number">0x36</span>,<span class="number">0x51</span>,</span><br><span class="line"><span class="number">0x38</span>,<span class="number">0xb0</span>,<span class="number">0xbd</span>,<span class="number">0x5a</span>,<span class="number">0xfc</span>,<span class="number">0x60</span>,<span class="number">0x62</span>,<span class="number">0x96</span>,<span class="number">0x6c</span>,<span class="number">0x42</span>,<span class="number">0xf7</span>,<span class="number">0x10</span>,<span class="number">0x7c</span>,<span class="number">0x28</span>,<span class="number">0x27</span>,<span class="number">0x8c</span>,</span><br><span class="line"><span class="number">0x13</span>,<span class="number">0x95</span>,<span class="number">0x9c</span>,<span class="number">0xc7</span>,<span class="number">0x24</span>,<span class="number">0x46</span>,<span class="number">0x3b</span>,<span class="number">0x70</span>,<span class="number">0xca</span>,<span class="number">0xe3</span>,<span class="number">0x85</span>,<span class="number">0xcb</span>,<span class="number">0x11</span>,<span class="number">0xd0</span>,<span class="number">0x93</span>,<span class="number">0xb8</span>,</span><br><span class="line"><span class="number">0xa6</span>,<span class="number">0x83</span>,<span class="number">0x20</span>,<span class="number">0xff</span>,<span class="number">0x9f</span>,<span class="number">0x77</span>,<span class="number">0xc3</span>,<span class="number">0xcc</span>,<span class="number">0x3</span>,<span class="number">0x6f</span>,<span class="number">0x8</span>,<span class="number">0xbf</span>,<span class="number">0x40</span>,<span class="number">0xe7</span>,<span class="number">0x2b</span>,<span class="number">0xe2</span>,</span><br><span class="line"><span class="number">0x79</span>,<span class="number">0xc</span>,<span class="number">0xaa</span>,<span class="number">0x82</span>,<span class="number">0x41</span>,<span class="number">0x3a</span>,<span class="number">0xea</span>,<span class="number">0xb9</span>,<span class="number">0xe4</span>,<span class="number">0x9a</span>,<span class="number">0xa4</span>,<span class="number">0x97</span>,<span class="number">0x7e</span>,<span class="number">0xda</span>,<span class="number">0x7a</span>,<span class="number">0x17</span>,</span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x94</span>,<span class="number">0xa1</span>,<span class="number">0x1d</span>,<span class="number">0x3d</span>,<span class="number">0xf0</span>,<span class="number">0xde</span>,<span class="number">0xb3</span>,<span class="number">0xb</span>,<span class="number">0x72</span>,<span class="number">0xa7</span>,<span class="number">0x1c</span>,<span class="number">0xef</span>,<span class="number">0xd1</span>,<span class="number">0x53</span>,<span class="number">0x3e</span>,</span><br><span class="line"><span class="number">0x8f</span>,<span class="number">0x33</span>,<span class="number">0x26</span>,<span class="number">0x5f</span>,<span class="number">0xec</span>,<span class="number">0x76</span>,<span class="number">0x2a</span>,<span class="number">0x49</span>,<span class="number">0x81</span>,<span class="number">0x88</span>,<span class="number">0xee</span>,<span class="number">0x21</span>,<span class="number">0xc4</span>,<span class="number">0x1a</span>,<span class="number">0xeb</span>,<span class="number">0xd9</span>,</span><br><span class="line"><span class="number">0xc5</span>,<span class="number">0x39</span>,<span class="number">0x99</span>,<span class="number">0xcd</span>,<span class="number">0xad</span>,<span class="number">0x31</span>,<span class="number">0x8b</span>,<span class="number">0x1</span>,<span class="number">0x18</span>,<span class="number">0x23</span>,<span class="number">0xdd</span>,<span class="number">0x1f</span>,<span class="number">0x4e</span>,<span class="number">0x2d</span>,<span class="number">0xf9</span>,<span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x4f</span>,<span class="number">0xf2</span>,<span class="number">0x65</span>,<span class="number">0x8e</span>,<span class="number">0x78</span>,<span class="number">0x5c</span>,<span class="number">0x58</span>,<span class="number">0x19</span>,<span class="number">0x8d</span>,<span class="number">0xe5</span>,<span class="number">0x98</span>,<span class="number">0x57</span>,<span class="number">0x67</span>,<span class="number">0x7f</span>,<span class="number">0x5</span>,<span class="number">0x64</span>,</span><br><span class="line"><span class="number">0xaf</span>,<span class="number">0x63</span>,<span class="number">0xb6</span>,<span class="number">0xfe</span>,<span class="number">0xf5</span>,<span class="number">0xb7</span>,<span class="number">0x3c</span>,<span class="number">0xa5</span>,<span class="number">0xce</span>,<span class="number">0xe9</span>,<span class="number">0x68</span>,<span class="number">0x44</span>,<span class="number">0xe0</span>,<span class="number">0x4d</span>,<span class="number">0x43</span>,<span class="number">0x69</span>,</span><br><span class="line"><span class="number">0x29</span>,<span class="number">0x2e</span>,<span class="number">0xac</span>,<span class="number">0x15</span>,<span class="number">0x59</span>,<span class="number">0xa8</span>,<span class="number">0xa</span>,<span class="number">0x9e</span>,<span class="number">0x6e</span>,<span class="number">0x47</span>,<span class="number">0xdf</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x6a</span>,<span class="number">0xcf</span>,<span class="number">0xdc</span>,</span><br><span class="line"><span class="number">0x22</span>,<span class="number">0xc9</span>,<span class="number">0xc0</span>,<span class="number">0x9b</span>,<span class="number">0x89</span>,<span class="number">0xd4</span>,<span class="number">0xed</span>,<span class="number">0xab</span>,<span class="number">0x12</span>,<span class="number">0xa2</span>,<span class="number">0xd</span>,<span class="number">0x52</span>,<span class="number">0xbb</span>,<span class="number">0x2</span>,<span class="number">0x2f</span>,<span class="number">0xa9</span>,</span><br><span class="line"><span class="number">0xd7</span>,<span class="number">0x61</span>,<span class="number">0x1e</span>,<span class="number">0xb4</span>,<span class="number">0x50</span>,<span class="number">0x4</span>,<span class="number">0xf6</span>,<span class="number">0xc2</span>,<span class="number">0x16</span>,<span class="number">0x25</span>,<span class="number">0x86</span>,<span class="number">0x56</span>,<span class="number">0x55</span>,<span class="number">0x9</span>,<span class="number">0xbe</span>,<span class="number">0x91</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>twofish.c<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"twofish.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tables.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xor(g,r)    (g^r)                   <span class="comment">/* Xor operation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ror(g,n)    ((g&gt;&gt;n)|(g&lt;&lt;(32-n)))    <span class="comment">/* Rotate right  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rol(g,n)    ((g<span class="meta-string">&lt;&lt;n)|(g&gt;&gt;(32-n)))    /* Rotate left   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nxt(g,r)    (*(g+r))                <span class="comment">/* Get next byte */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LITTILE_ENDIAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  LITTILE_ENDIAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unpack(g,r) ((g&gt;&gt;(r*8))&amp;0xff)                               <span class="comment">/* Extracts a byte from a word.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pack(g)     ((*(g))|(*(g+1)&lt;&lt;8)|(*(g+2)&lt;&lt;16)|(*(g+3)&lt;&lt;24))  <span class="comment">/* Converts four byte to a word. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rsm(i,a,b,c,d,e,f,g,h)  \</span></span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>),a,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">1</span>),b,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">2</span>),c,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">3</span>),d,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">4</span>),e,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">5</span>),f,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">6</span>),g,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">7</span>),h,<span class="number">0x14d</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> u(x,a)\</span></span><br><span class="line">        x[<span class="number">0</span>] = unpack(a,<span class="number">0</span>); \</span><br><span class="line">        x[<span class="number">1</span>] = unpack(a,<span class="number">1</span>); \</span><br><span class="line">        x[<span class="number">2</span>] = unpack(a,<span class="number">2</span>); \</span><br><span class="line">        x[<span class="number">3</span>] = unpack(a,<span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> release(a,b,c)  &#123; free(a); free(b);free(c); &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  TWOFISH</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">key_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;</span><br><span class="line">    <span class="keyword">uint8_t</span> *k;</span><br><span class="line">&#125;<span class="keyword">key_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">subkey_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;</span><br><span class="line">    <span class="keyword">uint8_t</span> s[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> me[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> mo[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">&#125;<span class="keyword">subkey_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Expand Key Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   s</span></span><br><span class="line"><span class="comment"> * @param   len</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">key_t</span>* expand_key(<span class="keyword">uint8_t</span> *s, <span class="keyword">uint32_t</span> len);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Galois Field Multiplication Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   x</span></span><br><span class="line"><span class="comment"> * @param   y</span></span><br><span class="line"><span class="comment"> * @param   m</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint8_t</span> gf(<span class="keyword">uint8_t</span> x, <span class="keyword">uint8_t</span> y, <span class="keyword">uint16_t</span> m);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Generate Subkeys Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_key</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">subkey_t</span>* Twofish_generate_subkey(<span class="keyword">key_t</span>* tf_key);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish h Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   x[]</span></span><br><span class="line"><span class="comment"> * @param   y[]</span></span><br><span class="line"><span class="comment"> * @param   s</span></span><br><span class="line"><span class="comment"> * @param   stage</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_h</span><span class="params">(<span class="keyword">uint8_t</span> x[],  <span class="keyword">uint8_t</span> y[], <span class="keyword">uint8_t</span> s[][<span class="number">4</span>], <span class="keyword">int</span> stage)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish MDS Multiply Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   y[]</span></span><br><span class="line"><span class="comment"> * @param   out[]</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_mds_mul</span><span class="params">(<span class="keyword">uint8_t</span> y[],  <span class="keyword">uint8_t</span> out[])</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Genrate Extended K Keys Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   tf_subkey</span></span><br><span class="line"><span class="comment"> * @param   p</span></span><br><span class="line"><span class="comment"> * @param   k</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_generate_ext_k_keys(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">subkey_t</span> *tf_subkey,<span class="keyword">uint32_t</span> p, <span class="keyword">uint8_t</span> k);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Genrate Extended S Keys Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   tf_subkey</span></span><br><span class="line"><span class="comment"> * @param   k</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_generate_ext_s_keys(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">subkey_t</span> *tf_subkey, <span class="keyword">uint8_t</span> k);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish f Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   r</span></span><br><span class="line"><span class="comment"> * @param   r0, r1</span></span><br><span class="line"><span class="comment"> * @param   f0, f1</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_f</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> r,<span class="keyword">uint32_t</span> r0, <span class="keyword">uint32_t</span> r1, <span class="keyword">uint32_t</span>* f0, <span class="keyword">uint32_t</span>* f1)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish g Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   x</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint32_t</span> Twofish_g(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint32_t</span> x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_setup(<span class="keyword">uint8_t</span> *s, <span class="keyword">uint32_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Expand the key if necessary. */</span></span><br><span class="line">    <span class="keyword">key_t</span>* tf_key = expand_key(s, len/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Generate subkeys: s and k */</span></span><br><span class="line">    <span class="keyword">subkey_t</span> *tf_subkey = Twofish_generate_subkey(tf_key);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* Generate 40 K keys */</span></span><br><span class="line">    <span class="keyword">twofish_t</span>* tf_twofish = (<span class="keyword">twofish_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">twofish_t</span>));</span><br><span class="line">    tf_twofish = Twofish_generate_ext_k_keys(tf_twofish,tf_subkey,<span class="number">0x01010101</span>,(tf_key-&gt;len/<span class="number">8</span>));</span><br><span class="line">    <span class="comment">/* Generate 4x256 S keys */</span></span><br><span class="line">    tf_twofish = Twofish_generate_ext_s_keys(tf_twofish,tf_subkey,(tf_key-&gt;len/<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free memory */</span></span><br><span class="line">    release(tf_key-&gt;k, tf_key, tf_subkey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tf_twofish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_encryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *data, <span class="keyword">uint8_t</span> *cypher)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> r0, r1, r2, r3, f0, f1, c2,c3;</span><br><span class="line">    <span class="comment">/* Input Whitenening */</span></span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">0</span>]^pack(data);</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">1</span>]^pack(data+<span class="number">4</span>);</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">2</span>]^pack(data+<span class="number">8</span>);</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">3</span>]^pack(data+<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The black box */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Twofish_f(tf_twofish, i, r0, r1, &amp;f0, &amp;f1);</span><br><span class="line">        c2 = ror((f0^r2), <span class="number">1</span>);</span><br><span class="line">        c3 = (f1^rol(r3,<span class="number">1</span>));</span><br><span class="line">        <span class="comment">/* swap */</span></span><br><span class="line">        r2 = r0;</span><br><span class="line">        r3 = r1;</span><br><span class="line">        r0 = c2;</span><br><span class="line">        r1 = c3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output Whitening */</span></span><br><span class="line">    c2 = r0;</span><br><span class="line">    c3 = r1;</span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">4</span>]^r2;</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">5</span>]^r3;</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">6</span>]^c2;</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">7</span>]^c3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cypher[i]   = unpack(r0,i);</span><br><span class="line">        cypher[i+<span class="number">4</span>] = unpack(r1,i);</span><br><span class="line">        cypher[i+<span class="number">8</span>] = unpack(r2,i);</span><br><span class="line">        cypher[i+<span class="number">12</span>]= unpack(r3,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_decryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *cypher, <span class="keyword">uint8_t</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> r0, r1, r2, r3, f0, f1, c2,c3;</span><br><span class="line">    <span class="comment">/* Input Whitenening */</span></span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">4</span>]^pack(cypher);</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">5</span>]^pack(cypher+<span class="number">4</span>);</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">6</span>]^pack(cypher+<span class="number">8</span>);</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">7</span>]^pack(cypher+<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The black box */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">15</span>; i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        Twofish_f(tf_twofish, i, r0, r1, &amp;f0, &amp;f1);</span><br><span class="line">        c2 = (rol(r2,<span class="number">1</span>)^f0);</span><br><span class="line">        c3 = ror((f1^r3),<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* swap */</span></span><br><span class="line">        r2 = r0;</span><br><span class="line">        r3 = r1;</span><br><span class="line">        r0 = c2;</span><br><span class="line">        r1 = c3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output Whitening */</span></span><br><span class="line">    c2 = r0;</span><br><span class="line">    c3 = r1;</span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">0</span>]^r2;</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">1</span>]^r3;</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">2</span>]^c2;</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">3</span>]^c3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]   = unpack(r0,i);</span><br><span class="line">        data[i+<span class="number">4</span>] = unpack(r1,i);</span><br><span class="line">        data[i+<span class="number">8</span>] = unpack(r2,i);</span><br><span class="line">        data[i+<span class="number">12</span>]= unpack(r3,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_f</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> r,<span class="keyword">uint32_t</span> r0, <span class="keyword">uint32_t</span> r1, <span class="keyword">uint32_t</span>* f0, <span class="keyword">uint32_t</span>* f1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> t0, t1, o;</span><br><span class="line">    t0 = Twofish_g(tf_twofish, r0);</span><br><span class="line">    t1 = rol(r1, <span class="number">8</span>);</span><br><span class="line">    t1 = Twofish_g(tf_twofish, t1);</span><br><span class="line">    o = <span class="number">2</span>*r;</span><br><span class="line">    *f0= (t0 + t1 + tf_twofish-&gt;k[o+<span class="number">8</span>]);</span><br><span class="line">    *f1= (t0 + (<span class="number">2</span>*t1) + tf_twofish-&gt;k[o+<span class="number">9</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_generate_ext_k_keys(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">subkey_t</span> *tf_subkey,<span class="keyword">uint32_t</span> p, <span class="keyword">uint8_t</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> a, b;</span><br><span class="line">    <span class="keyword">uint8_t</span> x[<span class="number">4</span>], y[<span class="number">4</span>], z[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i+=<span class="number">2</span>)                  <span class="comment">/* i = 40/2 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = (i*p);                          <span class="comment">/* 2*i*p */</span></span><br><span class="line">        b = (a+p);                          <span class="comment">/* ((2*i +1)*p */</span></span><br><span class="line">        u(x,a);</span><br><span class="line">        Twofish_h(x, y, tf_subkey-&gt;me, k);</span><br><span class="line">        Twofish_mds_mul(y,z);</span><br><span class="line">        a = pack(z);                        <span class="comment">/* Convert four bytes z[4] to a word (a). */</span></span><br><span class="line">        u(x,b);                             <span class="comment">/* Convert a word (b) to four bytes x[4]. */</span></span><br><span class="line">        Twofish_h(x, y, tf_subkey-&gt;mo, k);</span><br><span class="line">        Twofish_mds_mul(y,z);        </span><br><span class="line">        b = pack(z);</span><br><span class="line">        b = rol(b,<span class="number">8</span>);</span><br><span class="line">        tf_twofish-&gt;k[i] = ((a + b));</span><br><span class="line">        tf_twofish-&gt;k[i+<span class="number">1</span>] = rol(((a + (<span class="number">2</span>*b))),<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tf_twofish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_generate_ext_s_keys(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">subkey_t</span> *tf_subkey, <span class="keyword">uint8_t</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> x[<span class="number">4</span>], y[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x[<span class="number">0</span>] = x[<span class="number">1</span>] = x[<span class="number">2</span>] = x[<span class="number">3</span>] = i;</span><br><span class="line">        Twofish_h(x, y, tf_subkey-&gt;s, k);</span><br><span class="line">        <span class="comment">/* Special MDS multiplication */</span></span><br><span class="line">        tf_twofish-&gt;s[<span class="number">0</span>][i] = (gf(y[<span class="number">0</span>], mds[<span class="number">0</span>][<span class="number">0</span>],<span class="number">0x169</span>) |(gf(y[<span class="number">1</span>],mds[<span class="number">0</span>][<span class="number">1</span>],<span class="number">0x169</span>)&lt;&lt; <span class="number">8</span>)|(gf(y[<span class="number">2</span>], mds[<span class="number">0</span>][<span class="number">2</span>],<span class="number">0x169</span>)&lt;&lt;<span class="number">16</span>) |(gf(y[<span class="number">3</span>], mds[<span class="number">0</span>][<span class="number">3</span>], <span class="number">0x169</span>) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">        tf_twofish-&gt;s[<span class="number">1</span>][i] = (gf(y[<span class="number">0</span>], mds[<span class="number">1</span>][<span class="number">0</span>],<span class="number">0x169</span>) |(gf(y[<span class="number">1</span>],mds[<span class="number">1</span>][<span class="number">1</span>],<span class="number">0x169</span>)&lt;&lt; <span class="number">8</span>)|(gf(y[<span class="number">2</span>], mds[<span class="number">1</span>][<span class="number">2</span>],<span class="number">0x169</span>)&lt;&lt;<span class="number">16</span>) |(gf(y[<span class="number">3</span>], mds[<span class="number">1</span>][<span class="number">3</span>], <span class="number">0x169</span>) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">        tf_twofish-&gt;s[<span class="number">2</span>][i] = (gf(y[<span class="number">0</span>], mds[<span class="number">2</span>][<span class="number">0</span>],<span class="number">0x169</span>) |(gf(y[<span class="number">1</span>],mds[<span class="number">2</span>][<span class="number">1</span>],<span class="number">0x169</span>)&lt;&lt; <span class="number">8</span>)|(gf(y[<span class="number">2</span>], mds[<span class="number">2</span>][<span class="number">2</span>],<span class="number">0x169</span>)&lt;&lt;<span class="number">16</span>) |(gf(y[<span class="number">3</span>], mds[<span class="number">2</span>][<span class="number">3</span>], <span class="number">0x169</span>) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">        tf_twofish-&gt;s[<span class="number">3</span>][i] = (gf(y[<span class="number">0</span>], mds[<span class="number">3</span>][<span class="number">0</span>],<span class="number">0x169</span>) |(gf(y[<span class="number">1</span>],mds[<span class="number">3</span>][<span class="number">1</span>],<span class="number">0x169</span>)&lt;&lt; <span class="number">8</span>)|(gf(y[<span class="number">2</span>], mds[<span class="number">3</span>][<span class="number">2</span>],<span class="number">0x169</span>)&lt;&lt;<span class="number">16</span>) |(gf(y[<span class="number">3</span>], mds[<span class="number">3</span>][<span class="number">3</span>], <span class="number">0x169</span>) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tf_twofish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_mds_mul</span><span class="params">(<span class="keyword">uint8_t</span> y[],  <span class="keyword">uint8_t</span> out[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* MDS multiplication */</span></span><br><span class="line">    out[<span class="number">0</span>] = (gf(y[<span class="number">0</span>], mds[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0x169</span>)^gf(y[<span class="number">1</span>], mds[<span class="number">0</span>][<span class="number">1</span>], <span class="number">0x169</span>)^gf(y[<span class="number">2</span>], mds[<span class="number">0</span>][<span class="number">2</span>], <span class="number">0x169</span>)^gf(y[<span class="number">3</span>], mds[<span class="number">0</span>][<span class="number">3</span>], <span class="number">0x169</span>));</span><br><span class="line">    out[<span class="number">1</span>] = (gf(y[<span class="number">0</span>], mds[<span class="number">1</span>][<span class="number">0</span>], <span class="number">0x169</span>)^gf(y[<span class="number">1</span>], mds[<span class="number">1</span>][<span class="number">1</span>], <span class="number">0x169</span>)^gf(y[<span class="number">2</span>], mds[<span class="number">1</span>][<span class="number">2</span>], <span class="number">0x169</span>)^gf(y[<span class="number">3</span>], mds[<span class="number">1</span>][<span class="number">3</span>], <span class="number">0x169</span>));</span><br><span class="line">    out[<span class="number">2</span>] = (gf(y[<span class="number">0</span>], mds[<span class="number">2</span>][<span class="number">0</span>], <span class="number">0x169</span>)^gf(y[<span class="number">1</span>], mds[<span class="number">2</span>][<span class="number">1</span>], <span class="number">0x169</span>)^gf(y[<span class="number">2</span>], mds[<span class="number">2</span>][<span class="number">2</span>], <span class="number">0x169</span>)^gf(y[<span class="number">3</span>], mds[<span class="number">2</span>][<span class="number">3</span>], <span class="number">0x169</span>));</span><br><span class="line">    out[<span class="number">3</span>] = (gf(y[<span class="number">0</span>], mds[<span class="number">3</span>][<span class="number">0</span>], <span class="number">0x169</span>)^gf(y[<span class="number">1</span>], mds[<span class="number">3</span>][<span class="number">1</span>], <span class="number">0x169</span>)^gf(y[<span class="number">2</span>], mds[<span class="number">3</span>][<span class="number">2</span>], <span class="number">0x169</span>)^gf(y[<span class="number">3</span>], mds[<span class="number">3</span>][<span class="number">3</span>], <span class="number">0x169</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> Twofish_g(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint32_t</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (tf_twofish-&gt;s[<span class="number">0</span>][unpack(x,<span class="number">0</span>)]^tf_twofish-&gt;s[<span class="number">1</span>][unpack(x, <span class="number">1</span>)]^tf_twofish-&gt;s[<span class="number">2</span>][unpack(x,<span class="number">2</span>)]^tf_twofish-&gt;s[<span class="number">3</span>][unpack(x,<span class="number">3</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_h</span><span class="params">(<span class="keyword">uint8_t</span> x[],  <span class="keyword">uint8_t</span> out[], <span class="keyword">uint8_t</span> s[][<span class="number">4</span>], <span class="keyword">int</span> stage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> y[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>;++j)</span><br><span class="line">    &#123;</span><br><span class="line">        y[j] = x[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stage == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y[<span class="number">0</span>] = q[<span class="number">1</span>][y[<span class="number">0</span>]] ^ (s[<span class="number">3</span>][<span class="number">0</span>]);</span><br><span class="line">        y[<span class="number">1</span>] = q[<span class="number">0</span>][y[<span class="number">1</span>]] ^ (s[<span class="number">3</span>][<span class="number">1</span>]);</span><br><span class="line">        y[<span class="number">2</span>] = q[<span class="number">0</span>][y[<span class="number">2</span>]] ^ (s[<span class="number">3</span>][<span class="number">2</span>]);</span><br><span class="line">        y[<span class="number">3</span>] = q[<span class="number">1</span>][y[<span class="number">3</span>]] ^ (s[<span class="number">3</span>][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stage &gt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y[<span class="number">0</span>] = q[<span class="number">1</span>][y[<span class="number">0</span>]] ^ (s[<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">        y[<span class="number">1</span>] = q[<span class="number">1</span>][y[<span class="number">1</span>]] ^ (s[<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">        y[<span class="number">2</span>] = q[<span class="number">0</span>][y[<span class="number">2</span>]] ^ (s[<span class="number">2</span>][<span class="number">2</span>]);</span><br><span class="line">        y[<span class="number">3</span>] = q[<span class="number">0</span>][y[<span class="number">3</span>]] ^ (s[<span class="number">2</span>][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out[<span class="number">0</span>] = q[<span class="number">1</span>][q[<span class="number">0</span>][ q[<span class="number">0</span>][y[<span class="number">0</span>]] ^ (s[<span class="number">1</span>][<span class="number">0</span>])] ^ (s[<span class="number">0</span>][<span class="number">0</span>])];</span><br><span class="line">    out[<span class="number">1</span>] = q[<span class="number">0</span>][q[<span class="number">0</span>][ q[<span class="number">1</span>][y[<span class="number">1</span>]] ^ (s[<span class="number">1</span>][<span class="number">1</span>])] ^ (s[<span class="number">0</span>][<span class="number">1</span>])];</span><br><span class="line">    out[<span class="number">2</span>] = q[<span class="number">1</span>][q[<span class="number">1</span>][ q[<span class="number">0</span>][y[<span class="number">2</span>]] ^ (s[<span class="number">1</span>][<span class="number">2</span>])] ^ (s[<span class="number">0</span>][<span class="number">2</span>])];</span><br><span class="line">    out[<span class="number">3</span>] = q[<span class="number">0</span>][q[<span class="number">1</span>][ q[<span class="number">1</span>][y[<span class="number">3</span>]] ^ (s[<span class="number">1</span>][<span class="number">3</span>])] ^ (s[<span class="number">0</span>][<span class="number">3</span>])];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">subkey_t</span>* Twofish_generate_subkey(<span class="keyword">key_t</span>* tf_key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> k, r, g;</span><br><span class="line">    <span class="keyword">subkey_t</span> *tf_subkey = (<span class="keyword">subkey_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">subkey_t</span>));</span><br><span class="line">    k = tf_key-&gt;len/<span class="number">8</span>;                                  <span class="comment">/* k=N/64 */</span></span><br><span class="line">    <span class="keyword">for</span>(r=<span class="number">0</span>; r&lt;k;++r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Generate subkeys Me and Mo */</span></span><br><span class="line">        tf_subkey-&gt;me[r][<span class="number">0</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span>    );</span><br><span class="line">        tf_subkey-&gt;me[r][<span class="number">1</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">1</span>);</span><br><span class="line">        tf_subkey-&gt;me[r][<span class="number">2</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">2</span>);</span><br><span class="line">        tf_subkey-&gt;me[r][<span class="number">3</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">3</span>);</span><br><span class="line">        tf_subkey-&gt;mo[r][<span class="number">0</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">4</span>);</span><br><span class="line">        tf_subkey-&gt;mo[r][<span class="number">1</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">5</span>);</span><br><span class="line">        tf_subkey-&gt;mo[r][<span class="number">2</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">6</span>);</span><br><span class="line">        tf_subkey-&gt;mo[r][<span class="number">3</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">7</span>);</span><br><span class="line">        </span><br><span class="line">        g=k-r<span class="number">-1</span>;                                        <span class="comment">/* Reverse order */</span></span><br><span class="line">        <span class="comment">/* Generate subkeys S using RS matrix */</span></span><br><span class="line">        tf_subkey-&gt;s[g][<span class="number">0</span>] = rsm(r, <span class="number">0x01</span>, <span class="number">0xa4</span>, <span class="number">0x55</span>, <span class="number">0x87</span>, <span class="number">0x5a</span>, <span class="number">0x58</span>, <span class="number">0xdb</span>, <span class="number">0x9e</span>);</span><br><span class="line">        tf_subkey-&gt;s[g][<span class="number">1</span>] = rsm(r, <span class="number">0xa4</span>, <span class="number">0x56</span>, <span class="number">0x82</span>, <span class="number">0xf3</span>, <span class="number">0x1e</span>, <span class="number">0xc6</span>, <span class="number">0x68</span>, <span class="number">0xe5</span>);</span><br><span class="line">        tf_subkey-&gt;s[g][<span class="number">2</span>] = rsm(r, <span class="number">0x02</span>, <span class="number">0xa1</span>, <span class="number">0xfc</span>, <span class="number">0xc1</span>, <span class="number">0x47</span>, <span class="number">0xae</span>, <span class="number">0x3d</span>, <span class="number">0x19</span>);</span><br><span class="line">        tf_subkey-&gt;s[g][<span class="number">3</span>] = rsm(r, <span class="number">0xa4</span>, <span class="number">0x55</span>, <span class="number">0x87</span>, <span class="number">0x5a</span>, <span class="number">0x58</span>, <span class="number">0xdb</span>, <span class="number">0x9e</span>, <span class="number">0x03</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tf_subkey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">key_t</span>* expand_key(<span class="keyword">uint8_t</span> *s, <span class="keyword">uint32_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">/* Pad factor */</span></span><br><span class="line">    <span class="keyword">if</span> (len&lt;<span class="number">16</span>)       n = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (len&lt;<span class="number">24</span>)  n = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (len&lt;<span class="number">32</span>)  n = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">key_t</span>* tf_key = (<span class="keyword">key_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">key_t</span>));</span><br><span class="line">    <span class="keyword">uint8_t</span>* ss = (<span class="keyword">uint8_t</span>*)<span class="built_in">malloc</span>(n);</span><br><span class="line">    <span class="comment">/* Do actual padding. */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> g=<span class="number">0</span>; g&lt;n; ++g)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            *(ss+g) = *(s+g);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *(ss+g) = <span class="number">0x00</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tf_key-&gt;k = ss;</span><br><span class="line">    tf_key-&gt;len=n;</span><br><span class="line">    <span class="keyword">return</span> tf_key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> gf(<span class="keyword">uint8_t</span> x, <span class="keyword">uint8_t</span> y, <span class="keyword">uint16_t</span> m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> c, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">0x1</span>)</span><br><span class="line">            p ^= x;</span><br><span class="line">        c = x &amp; <span class="number">0x80</span>;</span><br><span class="line">        x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (c)</span><br><span class="line">            x ^= m;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>写一个main函数直接调用即可。</p><h2 id="CTF出题变化分析"><a href="#CTF出题变化分析" class="headerlink" title="CTF出题变化分析"></a>CTF出题变化分析</h2><p>TwoFish算法共有三处可发生变化以提高出题难度</p><ol><li>rsm函数，0x14d可替换为其他数字</li><li>Twofish_generate_ext_s_keys函数中gf的参数0x166可替换</li><li>Twofish_mds_mul函数中gf的参数0x166可替换</li></ol><p>对于这类分组加密算法，即使插件没有识别，只要看出相关函数结构，就可以很快确定具体算法，找到可能变化的参数，相应修改解密函数即可</p><p>附件中附上了题目和idb文件供自行分析</p><p>From <a href="https://kabeor.github.io/逆向分析加解密之TwoFish算法/">https://kabeor.github.io/逆向分析加解密之TwoFish算法/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逆向分析加解密之TwoFish算法&quot;&gt;&lt;a href=&quot;#逆向分析加解密之TwoFish算法&quot; class=&quot;headerlink&quot; title=&quot;逆向分析加解密之TwoFish算法&quot;&gt;&lt;/a&gt;逆向分析加解密之TwoFish算法&lt;/h1&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="TwoFish算法" scheme="https://kabeor.github.io/tags/TwoFish%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Capstone反汇编引擎数据类型及API分析及示例(三)</title>
    <link href="https://kabeor.github.io/Capstone%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E5%8F%8A%E7%A4%BA%E4%BE%8B(%E4%B8%89)/"/>
    <id>https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(三)/</id>
    <published>2019-07-22T05:20:08.274Z</published>
    <updated>2019-07-29T04:08:28.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Capstone反汇编引擎数据类型及API分析及示例-三"><a href="#Capstone反汇编引擎数据类型及API分析及示例-三" class="headerlink" title="Capstone反汇编引擎数据类型及API分析及示例(三)"></a>Capstone反汇编引擎数据类型及API分析及示例(三)</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5772" target="_blank" rel="noopener">https://xz.aliyun.com/t/5772</a></p></blockquote><h2 id="API分析"><a href="#API分析" class="headerlink" title="API分析"></a>API分析</h2><h3 id="cs-open"><a href="#cs-open" class="headerlink" title="cs_open"></a>cs_open</h3><p><code>cs_err CAPSTONE_API cs_open(cs_arch arch, cs_mode mode, csh *handle);</code></p><p>初始化cs句柄</p><p>参数<br>arch: 架构类型 (CS<em>ARCH</em><em>)<br>mode: 硬件模式. CS<em>MODE</em></em>在cs_mode数据类型中可查<br>handle: 指向句柄, 返回时更新<br>return: 创建成功返回CS_ERR_OK，否则返回cs_err枚举中对应的错误信息</p><p>实现代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_open</span><span class="params">(cs_arch arch, cs_mode mode, csh *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">ud</span>;</span></span><br><span class="line"><span class="keyword">if</span> (!cs_mem_malloc || !cs_mem_calloc || !cs_mem_realloc || !cs_mem_free || !cs_vsnprintf)</span><br><span class="line"><span class="comment">// Error: 使用cs_open()前, 必须使用cs_option(CS_OPT_MEM)进行动态内存管理的初始化</span></span><br><span class="line"><span class="keyword">return</span> CS_ERR_MEMSETUP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arch &lt; CS_ARCH_MAX &amp;&amp; cs_arch_init[arch]) &#123;</span><br><span class="line"><span class="comment">// 验证架构是否使用，方式：架构在枚举中且可初始化</span></span><br><span class="line"><span class="keyword">if</span> (mode &amp; cs_arch_disallowed_mode_mask[arch]) &#123;</span><br><span class="line">*handle = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_MODE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ud = cs_mem_calloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(*ud));</span><br><span class="line"><span class="keyword">if</span> (!ud) &#123;</span><br><span class="line"><span class="comment">// 内存不足</span></span><br><span class="line"><span class="keyword">return</span> CS_ERR_MEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ud-&gt;errnum = CS_ERR_OK;</span><br><span class="line">ud-&gt;arch = arch;</span><br><span class="line">ud-&gt;mode = mode;</span><br><span class="line"><span class="comment">// 默认情况指令不打开detail模式</span></span><br><span class="line">ud-&gt;detail = CS_OPT_OFF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认skipdata设置</span></span><br><span class="line">ud-&gt;skipdata_setup.mnemonic = SKIPDATA_MNEM;</span><br><span class="line"></span><br><span class="line">err = cs_arch_init[ud-&gt;arch](ud);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">cs_mem_free(ud);</span><br><span class="line">*handle = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*handle = (<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*handle = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_ARCH;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，cs_struct结构体包含更多细节设定，如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line">Printer_t printer;<span class="comment">// 打印asm</span></span><br><span class="line"><span class="keyword">void</span> *printer_info; <span class="comment">// 打印信息</span></span><br><span class="line">Disasm_t disasm;<span class="comment">// 反编译</span></span><br><span class="line"><span class="keyword">void</span> *getinsn_info; <span class="comment">// 打印辅助信息</span></span><br><span class="line">GetName_t reg_name;</span><br><span class="line">GetName_t insn_name;</span><br><span class="line">GetName_t group_name;</span><br><span class="line">GetID_t insn_id;</span><br><span class="line">PostPrinter_t post_printer;</span><br><span class="line">cs_err errnum;</span><br><span class="line">ARM_ITStatus ITBlock;<span class="comment">// ARM特殊选项</span></span><br><span class="line">cs_opt_value detail, imm_unsigned;</span><br><span class="line"><span class="keyword">int</span> syntax;<span class="comment">//ARM, Mips &amp; PPC等架构的基本asm语法打印</span></span><br><span class="line"><span class="keyword">bool</span> doing_mem;<span class="comment">// 在InstPrinter代码中处理内存操作数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> *insn_cache;<span class="comment">//为mapping.c建立缓存索引</span></span><br><span class="line">GetRegisterName_t get_regname;</span><br><span class="line"><span class="keyword">bool</span> skipdata;<span class="comment">// 如果反编译时要跳过数据，该项设置为True</span></span><br><span class="line"><span class="keyword">uint8_t</span> skipdata_size;<span class="comment">//要跳过bytes的数量</span></span><br><span class="line">cs_opt_skipdata skipdata_setup;<span class="comment">// 自定义skipdata设置</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *regsize_map;<span class="comment">//映射register大小 (目前仅支持x86)</span></span><br><span class="line">GetRegisterAccess_t reg_access;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insn_mnem</span> *<span class="title">mnem_list</span>;</span><span class="comment">// 自定义指令助记符的链接list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例(创建一个x86_64类型的cs句柄)：<br><code>cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)</code></p><h3 id="cs-close"><a href="#cs-close" class="headerlink" title="cs_close"></a>cs_close</h3><p><code>cs_err CAPSTONE_API cs_close(csh *handle);</code></p><p>释放句柄<br>参数<br>handle: 指向一个cs_open()打开的句柄<br>return: 释放成功返回CS_ERR_OK,否则返回cs_err枚举的错误信息</p><p>实现代码，可以看出释放句柄实质为将句柄值设置为0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_close</span><span class="params">(csh *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">ud</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insn_mnem</span> *<span class="title">next</span>, *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*handle == <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 句柄不可用</span></span><br><span class="line"><span class="keyword">return</span> CS_ERR_CSH;</span><br><span class="line"></span><br><span class="line">ud = (struct cs_struct *)(*handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ud-&gt;printer_info)</span><br><span class="line">cs_mem_free(ud-&gt;printer_info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放自定义助记符的链接list</span></span><br><span class="line">tmp = ud-&gt;mnem_list;</span><br><span class="line"><span class="keyword">while</span>(tmp) &#123;</span><br><span class="line">next = tmp-&gt;next;</span><br><span class="line">cs_mem_free(tmp);</span><br><span class="line">tmp = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_mem_free(ud-&gt;insn_cache);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(ud, <span class="number">0</span>, <span class="keyword">sizeof</span>(*ud));</span><br><span class="line">cs_mem_free(ud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle值设置为0，保证这个句柄在cs_close()释放后不可使用</span></span><br><span class="line">*handle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：<br><code>cs_close(&amp;handle);</code></p><h3 id="cs-option"><a href="#cs-option" class="headerlink" title="cs_option"></a>cs_option</h3><p><code>cs_err CAPSTONE_API cs_option(csh handle, cs_opt_type type, size_t value);</code></p><p>反编译引擎的运行时选项</p><p>handle: cs_open()打开的句柄<br>type: 设置选项的类型<br>value: 与type对应的选项值<br>return: 设置成功返回CS_ERR_OK,否则返回cs_err枚举的错误信息</p><p>注意: 在CS_OPT_MEM的情况下，handle可以是任何值，因此cs_option(handle, CS_OPT_MEM, value)必须在cs_open()之前被调用</p><p>实现代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_option</span><span class="params">(csh ud, cs_opt_type type, <span class="keyword">size_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line">cs_opt_mnem *opt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持在所有API前支持 (even cs_open())</span></span><br><span class="line"><span class="keyword">if</span> (type == CS_OPT_MEM) &#123;</span><br><span class="line">cs_opt_mem *mem = (cs_opt_mem *)value;</span><br><span class="line"></span><br><span class="line">cs_mem_malloc = mem-&gt;<span class="built_in">malloc</span>;</span><br><span class="line">cs_mem_calloc = mem-&gt;<span class="built_in">calloc</span>;</span><br><span class="line">cs_mem_realloc = mem-&gt;<span class="built_in">realloc</span>;</span><br><span class="line">cs_mem_free = mem-&gt;<span class="built_in">free</span>;</span><br><span class="line">cs_vsnprintf = mem-&gt;vsnprintf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"><span class="keyword">if</span> (!handle)</span><br><span class="line"><span class="keyword">return</span> CS_ERR_CSH;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_UNSIGNED:</span><br><span class="line">handle-&gt;imm_unsigned = (cs_opt_value)value;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_DETAIL:</span><br><span class="line">handle-&gt;detail = (cs_opt_value)value;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_SKIPDATA:</span><br><span class="line">handle-&gt;skipdata = (value == CS_OPT_ON);</span><br><span class="line"><span class="keyword">if</span> (handle-&gt;skipdata) &#123;</span><br><span class="line"><span class="keyword">if</span> (handle-&gt;skipdata_size == <span class="number">0</span>) &#123;</span><br><span class="line">handle-&gt;skipdata_size = skipdata_size(handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_SKIPDATA_SETUP:</span><br><span class="line"><span class="keyword">if</span> (value)</span><br><span class="line">handle-&gt;skipdata_setup = *((cs_opt_skipdata *)value);</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_MNEMONIC:</span><br><span class="line">opt = (cs_opt_mnem *)value;</span><br><span class="line"><span class="keyword">if</span> (opt-&gt;id) &#123;</span><br><span class="line"><span class="keyword">if</span> (opt-&gt;mnemonic) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insn_mnem</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新指令或替换现有指令</span></span><br><span class="line"><span class="comment">// 查看当前insn释放在list中</span></span><br><span class="line">tmp = handle-&gt;mnem_list;</span><br><span class="line"><span class="keyword">while</span>(tmp) &#123;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;insn.id == opt-&gt;id) &#123;</span><br><span class="line"><span class="comment">// f找到指令，替换助记符</span></span><br><span class="line">(<span class="keyword">void</span>)<span class="built_in">strncpy</span>(tmp-&gt;insn.mnemonic, opt-&gt;mnemonic, <span class="keyword">sizeof</span>(tmp-&gt;insn.mnemonic) - <span class="number">1</span>);</span><br><span class="line">tmp-&gt;insn.mnemonic[<span class="keyword">sizeof</span>(tmp-&gt;insn.mnemonic) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 如果没有就添加这条指令</span></span><br><span class="line"><span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">tmp = cs_mem_malloc(<span class="keyword">sizeof</span>(*tmp));</span><br><span class="line">tmp-&gt;insn.id = opt-&gt;id;</span><br><span class="line">(<span class="keyword">void</span>)<span class="built_in">strncpy</span>(tmp-&gt;insn.mnemonic, opt-&gt;mnemonic, <span class="keyword">sizeof</span>(tmp-&gt;insn.mnemonic) - <span class="number">1</span>);</span><br><span class="line">tmp-&gt;insn.mnemonic[<span class="keyword">sizeof</span>(tmp-&gt;insn.mnemonic) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="comment">// 新指令放在list最前面</span></span><br><span class="line">tmp-&gt;next = handle-&gt;mnem_list;</span><br><span class="line">handle-&gt;mnem_list = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">struct insn_mnem *prev, *tmp;</span><br><span class="line"></span><br><span class="line">tmp = handle-&gt;mnem_list;</span><br><span class="line">prev = tmp;</span><br><span class="line"><span class="keyword">while</span>(tmp) &#123;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;insn.id == opt-&gt;id) &#123;</span><br><span class="line"><span class="comment">// 删除指令</span></span><br><span class="line"><span class="keyword">if</span> (tmp == prev) &#123;</span><br><span class="line">handle-&gt;mnem_list = tmp-&gt;next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">prev-&gt;next = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cs_mem_free(tmp);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">prev = tmp;</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_MODE:</span><br><span class="line"><span class="comment">// 验证所请求的模式是否有效</span></span><br><span class="line"><span class="keyword">if</span> (value &amp; cs_arch_disallowed_mode_mask[handle-&gt;arch]) &#123;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OPTION;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cs_arch_option[handle-&gt;arch](handle, type, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例，更改反汇编后显示的语法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cs_option(handle, CS_OPT_SYNTAX, CS_OPT_SYNTAX_ATT);  <span class="comment">// 以AT&amp;T语法显示</span></span><br><span class="line">count = cs_disasm(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0x1000</span>, <span class="number">0</span>, &amp;insn);</span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span><span class="string">"Ix"</span><span class="string">":\t%s\t\t%s\n"</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disassemble given code!\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出</p><p><img src="https://i.loli.net/2019/07/22/5d35b1e72c20515640.jpg" alt></p><h3 id="cs-errno"><a href="#cs-errno" class="headerlink" title="cs_errno"></a>cs_errno</h3><p><code>cs_err CAPSTONE_API cs_errno(csh handle);</code></p><p>API出错时返回错误消息<br>参数<br>handle: cs_open()打开的句柄<br>return: 无错误返回CS_ERR_OK,否则返回cs_err枚举的错误信息</p><p>实现很简单，判断到句柄不存在直接返回CS_ERR_CSH</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle = <span class="number">0</span>;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cs_errno(handle);    <span class="comment">//关闭句柄后检查将报错</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出，错误码4即CS_ERR_CSH<br><img src="https://i.loli.net/2019/07/22/5d35bad79c9c384228.jpg" alt></p><h3 id="cs-strerror"><a href="#cs-strerror" class="headerlink" title="cs_strerror"></a>cs_strerror</h3><p><code>const char * CAPSTONE_API cs_strerror(cs_err code);</code></p><p>将上个API输出的错误码转换为详细错误信息</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * CAPSTONE_API <span class="title">cs_strerror</span><span class="params">(cs_err code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(code) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Unknown error code"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_OK:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"OK (CS_ERR_OK)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_MEM:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Out of memory (CS_ERR_MEM)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_ARCH:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid/unsupported architecture(CS_ERR_ARCH)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_HANDLE:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid handle (CS_ERR_HANDLE)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_CSH:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid csh (CS_ERR_CSH)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_MODE:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid mode (CS_ERR_MODE)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_OPTION:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid option (CS_ERR_OPTION)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_DETAIL:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Details are unavailable (CS_ERR_DETAIL)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_MEMSETUP:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Dynamic memory management uninitialized (CS_ERR_MEMSETUP)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_VERSION:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Different API version between core &amp; binding (CS_ERR_VERSION)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_DIET:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Information irrelevant in diet engine (CS_ERR_DIET)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_SKIPDATA:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Information irrelevant for 'data' instruction in SKIPDATA mode (CS_ERR_SKIPDATA)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_X86_ATT:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"AT&amp;T syntax is unavailable (CS_ERR_X86_ATT)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_X86_INTEL:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"INTEL syntax is unavailable (CS_ERR_X86_INTEL)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_X86_MASM:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"MASM syntax is unavailable (CS_ERR_X86_MASM)"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例，结合cs_errno使用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle = <span class="number">0</span>;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cs_strerror(cs_errno(handle));  <span class="comment">//直接输出报错信息</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/22/5d35bc1db170a33360.jpg" alt></p><h3 id="cs-disasm"><a href="#cs-disasm" class="headerlink" title="cs_disasm"></a>cs_disasm</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="function">CAPSTONE_API <span class="title">cs_disasm</span><span class="params">(csh handle,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *code, <span class="keyword">size_t</span> code_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">uint64_t</span> address,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">cs_insn **insn)</span></span>;</span><br></pre></td></tr></table></figure><p>给定缓冲区、大小、地址和编号，反编译机器码<br>API动态地分配内存来包含分解的指令，生成的指令将放在*insn中</p><p>注意： 必须释放分配的内存，以避免内存泄漏。对于需要动态分配稀缺内存的系统(如OS内核或固件)，API cs_disasm_iter()可能是比cs_disasm()更好的选择。原因是，使用cs_disasm()时，基于有限的可用内存，必须预先计算要分解多少条指令。</p><p>handle: cs_open()返回的句柄<br>code: 包含要反汇编的机器码的缓冲区。<br>code_size:上面代码缓冲区的大小。<br>address:给定原始代码缓冲区中的第一条指令的地址。<br>insn: 由这个API填写的指令数组。注意: insn将由这个函数分配，应该用cs_free () API释放<br>count: 需要分解的指令数量，或输入0分解所有指令<br>return:成功反汇编指令的数量，如果该函数未能反汇编给定的代码，则为0，失败时，调用cs_errno()获取错误代码。</p><p>源码分析</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="function">CAPSTONE_API <span class="title">cs_disasm</span><span class="params">(csh ud, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">uint64_t</span> offset, <span class="keyword">size_t</span> count, cs_insn **insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line">MCInst mci;</span><br><span class="line"><span class="keyword">uint16_t</span> insn_size;</span><br><span class="line"><span class="keyword">size_t</span> c = <span class="number">0</span>, i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> f = <span class="number">0</span>;<span class="comment">// 缓存中下一条指令的索引</span></span><br><span class="line">cs_insn *insn_cache;<span class="comment">// 缓存反汇编后的指令</span></span><br><span class="line"><span class="keyword">void</span> *total = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span> total_size = <span class="number">0</span>;<span class="comment">//所有insn的输出缓冲区的总大小</span></span><br><span class="line"><span class="keyword">bool</span> r;</span><br><span class="line"><span class="keyword">void</span> *tmp;</span><br><span class="line"><span class="keyword">size_t</span> skipdata_bytes;</span><br><span class="line"><span class="keyword">uint64_t</span> offset_org; <span class="comment">// 保存缓冲区的所有原始信息</span></span><br><span class="line"><span class="keyword">size_t</span> size_org;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *buffer_org;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cache_size = INSN_CACHE_SIZE;</span><br><span class="line"><span class="keyword">size_t</span> next_offset;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"><span class="keyword">if</span> (!handle) &#123;</span><br><span class="line"><span class="comment">// 修复方式:</span></span><br><span class="line"><span class="comment">// handle-&gt;errnum = CS_ERR_HANDLE;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重设ARM架构的IT block</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;arch == CS_ARCH_ARM)</span><br><span class="line">handle-&gt;ITBlock.size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_USE_SYS_DYN_MEM</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; count &lt;= INSN_CACHE_SIZE)</span><br><span class="line">cache_size = (<span class="keyword">unsigned</span> <span class="keyword">int</span>) count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存SKIPDATA原始偏移量</span></span><br><span class="line">buffer_org = buffer;</span><br><span class="line">offset_org = offset;</span><br><span class="line">size_org = size;</span><br><span class="line"></span><br><span class="line">total_size = <span class="keyword">sizeof</span>(cs_insn) * cache_size;</span><br><span class="line">total = cs_mem_malloc(total_size);</span><br><span class="line"><span class="keyword">if</span> (total == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// 内存不足</span></span><br><span class="line">handle-&gt;errnum = CS_ERR_MEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insn_cache = total;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">MCInst_Init(&amp;mci);</span><br><span class="line">mci.csh = handle;</span><br><span class="line"></span><br><span class="line">mci.address = offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;detail) &#123;</span><br><span class="line"><span class="comment">//给detail指针分配内存</span></span><br><span class="line">insn_cache-&gt;detail = cs_mem_malloc(<span class="keyword">sizeof</span>(cs_detail));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">insn_cache-&gt;detail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为non-detailed模式保存所有信息</span></span><br><span class="line">mci.flat_insn = insn_cache;</span><br><span class="line">mci.flat_insn-&gt;address = offset;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line"><span class="comment">//mnemonic &amp; op_str0填充</span></span><br><span class="line">mci.flat_insn-&gt;mnemonic[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">mci.flat_insn-&gt;op_str[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">r = handle-&gt;disasm(ud, buffer, size, &amp;mci, &amp;insn_size, offset, handle-&gt;getinsn_info);</span><br><span class="line"><span class="keyword">if</span> (r) &#123;</span><br><span class="line">SStream ss;</span><br><span class="line">SStream_Init(&amp;ss);</span><br><span class="line"></span><br><span class="line">mci.flat_insn-&gt;size = insn_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内部指令操作码映射到公共insn ID</span></span><br><span class="line">handle-&gt;insn_id(handle, insn_cache, mci.Opcode);</span><br><span class="line"></span><br><span class="line">handle-&gt;printer(&amp;mci, &amp;ss, handle-&gt;printer_info);</span><br><span class="line">fill_insn(handle, insn_cache, ss.buffer, &amp;mci, handle-&gt;post_printer, buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整opcode (X86)</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;arch == CS_ARCH_X86)</span><br><span class="line">insn_cache-&gt;id += mci.popcode_adjust;</span><br><span class="line"></span><br><span class="line">next_offset = insn_size;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 遇到中断指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为detail指针释放内存</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;detail) &#123;</span><br><span class="line">cs_mem_free(insn_cache-&gt;detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!handle-&gt;skipdata || handle-&gt;skipdata_size &gt; size)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;skipdata_setup.callback) &#123;</span><br><span class="line">skipdata_bytes = handle-&gt;skipdata_setup.callback(buffer_org, size_org,</span><br><span class="line">(<span class="keyword">size_t</span>)(offset - offset_org), handle-&gt;skipdata_setup.user_data);</span><br><span class="line"><span class="keyword">if</span> (skipdata_bytes &gt; size)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!skipdata_bytes)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">skipdata_bytes = handle-&gt;skipdata_size;</span><br><span class="line"></span><br><span class="line">insn_cache-&gt;id = <span class="number">0</span>;</span><br><span class="line">insn_cache-&gt;address = offset;</span><br><span class="line">insn_cache-&gt;size = (<span class="keyword">uint16_t</span>)skipdata_bytes;</span><br><span class="line"><span class="built_in">memcpy</span>(insn_cache-&gt;bytes, buffer, skipdata_bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line">insn_cache-&gt;mnemonic[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">insn_cache-&gt;op_str[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="built_in">strncpy</span>(insn_cache-&gt;mnemonic, handle-&gt;skipdata_setup.mnemonic,</span><br><span class="line"><span class="keyword">sizeof</span>(insn_cache-&gt;mnemonic) - <span class="number">1</span>);</span><br><span class="line">skipdata_opstr(insn_cache-&gt;op_str, buffer, skipdata_bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">insn_cache-&gt;detail = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">next_offset = skipdata_bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一条新指令进入缓存</span></span><br><span class="line">f++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反汇编了一条指令</span></span><br><span class="line">c++;</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; c == count)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (f == cache_size) &#123;</span><br><span class="line">cache_size = cache_size * <span class="number">8</span> / <span class="number">5</span>; </span><br><span class="line">total_size += (<span class="keyword">sizeof</span>(cs_insn) * cache_size);</span><br><span class="line">tmp = cs_mem_realloc(total, total_size);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;<span class="comment">//内存不足</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;detail) &#123;</span><br><span class="line">insn_cache = (cs_insn *)total;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; c; i++, insn_cache++)</span><br><span class="line">cs_mem_free(insn_cache-&gt;detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_mem_free(total);</span><br><span class="line">*insn = <span class="literal">NULL</span>;</span><br><span class="line">handle-&gt;errnum = CS_ERR_MEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total = tmp;</span><br><span class="line"><span class="comment">//在最后一条指令之后继续填充缓存</span></span><br><span class="line">insn_cache = (cs_insn *)((<span class="keyword">char</span> *)total + <span class="keyword">sizeof</span>(cs_insn) * c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将f重置为0，从一开始就填入缓存</span></span><br><span class="line">f = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">insn_cache++;</span><br><span class="line"></span><br><span class="line">buffer += next_offset;</span><br><span class="line">size -= next_offset;</span><br><span class="line">offset += next_offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!c) &#123;</span><br><span class="line"><span class="comment">//未反汇编任何指令</span></span><br><span class="line">cs_mem_free(total);</span><br><span class="line">total = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (f != cache_size) &#123;</span><br><span class="line"><span class="comment">// 没有完全使用最后一个缓存，缩小大小</span></span><br><span class="line">tmp = cs_mem_realloc(total, total_size - (cache_size - f) * <span class="keyword">sizeof</span>(*insn_cache));</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;<span class="comment">// 内存不足</span></span><br><span class="line"><span class="comment">// 释放所有detail指针</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;detail) &#123;</span><br><span class="line">insn_cache = (cs_insn *)total;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; c; i++, insn_cache++)</span><br><span class="line">cs_mem_free(insn_cache-&gt;detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_mem_free(total);</span><br><span class="line">*insn = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_MEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*insn = total;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例，x86_64:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle = <span class="number">0</span>;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count = cs_disasm(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0x1000</span>, <span class="number">0</span>, &amp;insn);   <span class="comment">//所有指令，基址0x1000，放入insn</span></span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span><span class="string">"Ix"</span><span class="string">":\t%s\t\t%s\n"</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disassemble given code!\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出</p><p><img src="https://i.loli.net/2019/07/22/5d35c5087d17d31194.jpg" alt></p><p>From <a href="https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(三">https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(三)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Capstone反汇编引擎数据类型及API分析及示例-三&quot;&gt;&lt;a href=&quot;#Capstone反汇编引擎数据类型及API分析及示例-三&quot; class=&quot;headerlink&quot; title=&quot;Capstone反汇编引擎数据类型及API分析及示例(三)&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="反汇编" scheme="https://kabeor.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Capstone反汇编引擎数据类型及API分析及示例(二)</title>
    <link href="https://kabeor.github.io/Capstone%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E5%8F%8A%E7%A4%BA%E4%BE%8B(%E4%BA%8C)/"/>
    <id>https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(二)/</id>
    <published>2019-07-21T04:55:52.086Z</published>
    <updated>2019-07-27T02:17:41.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Capstone反汇编引擎数据类型及API分析及示例-二"><a href="#Capstone反汇编引擎数据类型及API分析及示例-二" class="headerlink" title="Capstone反汇编引擎数据类型及API分析及示例(二)"></a>Capstone反汇编引擎数据类型及API分析及示例(二)</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5761" target="_blank" rel="noopener">https://xz.aliyun.com/t/5761</a></p></blockquote><p>上篇分析了Capstone开放的数据类型，下面就来正式看看API吧<br>官方开放的API只有二十个左右，但为了能写的更易懂，我将结合实例，分多篇写。<br>API中作者将capstone缩写为cs，下面我也用这种方式描述</p><h2 id="API分析"><a href="#API分析" class="headerlink" title="API分析"></a>API分析</h2><h3 id="cs-malloc-t"><a href="#cs-malloc-t" class="headerlink" title="cs_malloc_t"></a>cs_malloc_t</h3><p><code>void* (CAPSTONE_API *cs_malloc_t)(size_t size);</code></p><p>cs的动态内存分配，用于<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_mem</span> &#123;</span></span><br><span class="line"><span class="keyword">cs_malloc_t</span> <span class="built_in">malloc</span>;</span><br><span class="line"><span class="keyword">cs_calloc_t</span> <span class="built_in">calloc</span>;</span><br><span class="line"><span class="keyword">cs_realloc_t</span> <span class="built_in">realloc</span>;</span><br><span class="line"><span class="keyword">cs_free_t</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="keyword">cs_vsnprintf_t</span> vsnprintf;</span><br><span class="line">&#125; cs_opt_mem;</span><br></pre></td></tr></table></figure></p><p>cs_malloc_t定义于capstone.lib和capstone.dll的cs.c中，<br><img src="https://i.loli.net/2019/07/21/5d33f804831d248926.jpg" alt></p><blockquote><p>在用户模式下，cs_mem_malloc默认使用系统malloc</p><p>Windows driver模式下，<code>cs_malloc_t cs_mem_malloc = cs_winkernel_malloc;</code><br>cs_winkernel_malloc定义于\capstone-4.0.1\windows\winkernel_mm.c,</p></blockquote><p>实现代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * CAPSTONE_API <span class="title">cs_winkernel_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 长度不能分配为0</span></span><br><span class="line">NT_ASSERT(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// FP; NonPagedPool用于支持 Windows 7 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> prefast(suppress : 30030)<span class="comment">// 分配可执行的POOL_TYPE内存</span></span></span><br><span class="line"><span class="keyword">size_t</span> number_of_bytes = <span class="number">0</span>;</span><br><span class="line">CS_WINKERNEL_MEMBLOCK *block = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 特定的值能造成溢出</span></span><br><span class="line"><span class="comment">// 如果value中的和超出或低于类型容量，函数将返回NULL。</span></span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(RtlSizeTAdd(size, <span class="keyword">sizeof</span>(CS_WINKERNEL_MEMBLOCK), &amp;number_of_bytes))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(</span><br><span class="line">NonPagedPool, number_of_bytes, CS_WINKERNEL_POOL_TAG);</span><br><span class="line"><span class="keyword">if</span> (!block) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">block-&gt;size = size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> block-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>OSX kernel模式下，<code>cs_malloc_t cs_mem_malloc = kern_os_malloc;</code>，这里暂且不探讨。</p></blockquote><h3 id="cs-calloc-t"><a href="#cs-calloc-t" class="headerlink" title="cs_calloc_t"></a>cs_calloc_t</h3><p><code>void* (CAPSTONE_API *cs_calloc_t)(size_t nmemb, size_t size);</code></p><p>cs申请内存并初始化<br>用于<code>struct cs_opt_mem</code>，定义于cs.c<br>用户模式： <code>cs_calloc_t cs_mem_calloc = calloc;</code>,使用系统calloc<br>Windows driver模式： <code>cs_calloc_t cs_mem_calloc = cs_winkernel_calloc;</code><br>实现代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * CAPSTONE_API <span class="title">cs_winkernel_calloc</span><span class="params">(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> total = n * size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *new_ptr = cs_winkernel_malloc(total);</span><br><span class="line"><span class="keyword">if</span> (!new_ptr) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> RtlFillMemory(new_ptr, total, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OSX kernel模式： <code>cs_calloc_t cs_mem_calloc = cs_kern_os_calloc;</code><br><img src="https://i.loli.net/2019/07/21/5d340703367d259403.jpg" alt><br>直接调用kern_os_malloc了</p><h3 id="cs-realloc-t"><a href="#cs-realloc-t" class="headerlink" title="cs_realloc_t"></a>cs_realloc_t</h3><p><code>void* (CAPSTONE_API *cs_realloc_t)(void *ptr, size_t size);</code></p><p>cs重新分配内存<br>用于<code>struct cs_opt_mem</code>，定义于cs.c<br>用户模式： <code>cs_realloc_t cs_mem_realloc = realloc;</code>,调用系统realloc<br>Windows driver模式： <code>cs_realloc_t cs_mem_realloc = cs_winkernel_realloc;</code></p><p>实现代码，可以看出是利用cs_winkernel_malloc重新申请</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * CAPSTONE_API <span class="title">cs_winkernel_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *new_ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span> current_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> smaller_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line"><span class="keyword">return</span> cs_winkernel_malloc(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_ptr = cs_winkernel_malloc(size);</span><br><span class="line"><span class="keyword">if</span> (!new_ptr) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">current_size = CONTAINING_RECORD(ptr, CS_WINKERNEL_MEMBLOCK, data)-&gt;size;</span><br><span class="line">smaller_size = (current_size &lt; size) ? current_size : size;</span><br><span class="line">RtlCopyMemory(new_ptr, ptr, smaller_size);</span><br><span class="line">cs_winkernel_free(ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> new_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OSX kernel模式： <code>cs_realloc_t cs_mem_realloc = kern_os_realloc;</code></p><h3 id="cs-free-t"><a href="#cs-free-t" class="headerlink" title="cs_free_t"></a>cs_free_t</h3><p><code>typedef void (CAPSTONE_API *cs_free_t)(void *ptr);</code></p><p>cs释放内存<br>用于<code>struct cs_opt_mem</code>，定义于cs.c<br>用户模式： <code>cs_free_t cs_mem_free = free;</code>,调用系统free<br>Windows driver模式： <code>cs_free_t cs_mem_free = cs_winkernel_free;</code></p><p>实现代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> CAPSTONE_API <span class="title">cs_winkernel_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">ExFreePoolWithTag(CONTAINING_RECORD(ptr, CS_WINKERNEL_MEMBLOCK, data), CS_WINKERNEL_POOL_TAG);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OSX kernel模式：  <code>cs_free_t cs_mem_free = kern_os_free;</code></p><h3 id="cs-vsnprintf-t"><a href="#cs-vsnprintf-t" class="headerlink" title="cs_vsnprintf_t"></a>cs_vsnprintf_t</h3><p><code>int (CAPSTONE_API *cs_vsnprintf_t)(char *str, size_t size, const char *format, va_list ap);</code></p><p>按size大小输出到字符串str中</p><p>用户模式：<br><img src="https://i.loli.net/2019/07/21/5d340c613ba1e61273.jpg" alt><br>值得注意的是，如果系统为wince，将使用_vsnprintf函数<br>vsnprintf ()和_vsnprintf()对于驱动程序都是可用的，但是它们有一些不同。<br>在需要返回值和设置空终止符时应使用vsnprintf()</p><p>vsnprintf定义在stdio.h<br><img src="https://i.loli.net/2019/07/21/5d340d423babc62961.jpg" alt></p><p>Windows driver模式： <code>cs_vsnprintf_t cs_vsnprintf = cs_winkernel_vsnprintf;</code></p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> CAPSTONE_API <span class="title">cs_winkernel_vsnprintf</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list argptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = _vsnprintf(buffer, count, format, argptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// _vsnprintf()在字符串被截断时返回-1，在整个字符串被存储但“buffer”末尾没有“\0”时返回“count”。在这两种情况下，都需要手动添加空终止符。</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">-1</span> || (<span class="keyword">size_t</span>)result == count) &#123;</span><br><span class="line">buffer[count - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">// 在返回-1时，函数必须获取并返回一些本来要写入的字符。因此，通过重试使用temp buffer进行相同的转换，这个缓冲区就可能足够大来完成格式化，并且获得很多本应写入的字符。</span></span><br><span class="line"><span class="keyword">char</span>* tmp = cs_winkernel_malloc(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = _vsnprintf(tmp, <span class="number">0x1000</span>, format, argptr);</span><br><span class="line">NT_ASSERT(result != <span class="number">-1</span>);</span><br><span class="line">cs_winkernel_free(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OSX kernel模式： <code>cs_vsnprintf_t cs_vsnprintf = vsnprintf;</code>，使用默认vsnprintf</p><h3 id="cs-skipdata-cb-t"><a href="#cs-skipdata-cb-t" class="headerlink" title="cs_skipdata_cb_t"></a>cs_skipdata_cb_t</h3><p>size_t (CAPSTONE_API <em>cs_skipdata_cb_t)(const uint8_t </em>code, size_t code_size, size_t offset, void *user_data);</p><p>SKIPDATA选项的用户自定义回调函数。</p><p>code:包含要分解的代码的输入缓冲区。和传递给cs_disasm()的缓冲区相同。<br>code_size:上面的code缓冲区的大小(以字节为单位)。<br>offset:上面提到的输入缓冲区code中当前检查字节的位置。<br>user_data:用户数据通过cs_opt_skipdata结构中的@user_data字段传递给cs_option()。<br>return:返回要跳过的字节数，或者0表示立即停止反汇编。</p><p>cs_skipdata_cb_t在<code>struct cs_opt_skipdata</code>中调用，下面来看一个例子<br>分析写在注释中<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">cs_opt_type opt_skipdata;</span><br><span class="line"><span class="keyword">size_t</span> skipdata;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span>  <span class="comment">//输出机器码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE32 <span class="meta-string">"\x8d\x4c\x32\x08\x01\xd8\x81\xc6\x34\x12\x00\x00\x00\x91\x92"</span>  <span class="comment">//测试用机器码</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RANDOM_CODE <span class="meta-string">"\xed\x00\x00\x00\x00\x1a\x5a\x0f\x1f\xff\xc2\x09\x80\x00\x00\x00\x07\xf7\xeb\x2a\xff\xff\x7f\x57\xe3\x01\xff\xff\x7f\x57\xeb\x00\xf0\x00\x00\x24\xb2\x4f\x00\x78"</span></span></span><br><span class="line"></span><br><span class="line">cs_opt_skipdata skipdata = &#123;</span><br><span class="line"><span class="comment">// 把默认 "data" 描述符从 ".byte" 重命名为 "db"</span></span><br><span class="line"><span class="string">"db"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[2] = &#123;</span>         <span class="comment">//以默认描述符和自定义描述符两种方式建立一个数组</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_32,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE32,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 32 (Intel syntax) - Skip data"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_32,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE32,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 32 (Intel syntax) - Skip data with custom mnemonic"</span>,</span><br><span class="line">CS_OPT_INVALID,</span><br><span class="line">CS_OPT_OFF,</span><br><span class="line">CS_OPT_SKIPDATA_SETUP,</span><br><span class="line">(<span class="keyword">size_t</span>)&amp; skipdata,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;   <span class="comment">//建立capstone句柄</span></span><br><span class="line"><span class="keyword">uint64_t</span> address = <span class="number">0x1000</span>;  <span class="comment">//设置起始地址</span></span><br><span class="line">cs_insn* insn;  <span class="comment">//具体信息结构体</span></span><br><span class="line">cs_err err;  <span class="comment">//错误枚举</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">size_t</span> count;  <span class="comment">//成功反汇编行数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);  <span class="comment">//错误检查</span></span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开SKIPDATA 模式</span></span><br><span class="line">cs_option(handle, CS_OPT_SKIPDATA, CS_OPT_ON);</span><br><span class="line">cs_option(handle, platforms[i].opt_skipdata, platforms[i].skipdata);</span><br><span class="line"></span><br><span class="line">count = cs_disasm(handle, platforms[i].code, platforms[i].size, address, <span class="number">0</span>, &amp;insn);</span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;  <span class="comment">//输出汇编</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s\n"</span>,</span><br><span class="line">insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一行代码后打印偏移</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\n"</span>, insn[j - <span class="number">1</span>].address + insn[j - <span class="number">1</span>].size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放cs_disasm()申请的内存</span></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disasm given code!\n"</span>);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下，可以看出，默认的 .byte数据类型被改为db描述符<br><img src="https://i.loli.net/2019/07/21/5d3457518e35444335.jpg" alt></p><h3 id="cs-version"><a href="#cs-version" class="headerlink" title="cs_version"></a>cs_version</h3><p><code>unsigned int CAPSTONE_API cs_version(int *major, int *minor);</code></p><p>用来输出capstone版本号<br>参数<br>major: API主版本<br>minor: API次版本<br>return: 返回主次版本的16进制，如4.0版本返回 0x0400</p><p>通过分析源码发现<br><img src="https://i.loli.net/2019/07/21/5d345fe61e3c630129.jpg" alt></p><p><img src="https://i.loli.net/2019/07/21/5d34602a326f528259.jpg" alt><br>该版本定义于cs.c中，编译后不可更改，不接受自定义版本</p><p>示例1：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> cs_version(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> version = test();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%X"</span>, version);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/21/5d3465239ff2d14595.jpg" alt></p><p>示例2，强行修改版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ma[] = &#123; <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> mi[] = &#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cs_version(ma, mi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> version = test();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%X"</span>, version);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><img src="https://i.loli.net/2019/07/21/5d3465bc7716b49405.jpg" alt><br>可以看到并不能改变</p><h3 id="cs-support"><a href="#cs-support" class="headerlink" title="cs_support"></a>cs_support</h3><p>bool CAPSTONE_API cs_support(int query);</p><p>用来检查capstone库是否支持参数输入的架构或处于某编译选项<br>通过查看源码得知，共有四种查询参数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> CAPSTONE_API <span class="title">cs_support</span><span class="params">(<span class="keyword">int</span> query)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (query == CS_ARCH_ALL)</span><br><span class="line"><span class="keyword">return</span> all_arch == ((<span class="number">1</span> &lt;&lt; CS_ARCH_ARM) | (<span class="number">1</span> &lt;&lt; CS_ARCH_ARM64) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_MIPS) | (<span class="number">1</span> &lt;&lt; CS_ARCH_X86) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_PPC) | (<span class="number">1</span> &lt;&lt; CS_ARCH_SPARC) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_SYSZ) | (<span class="number">1</span> &lt;&lt; CS_ARCH_XCORE) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_M68K) | (<span class="number">1</span> &lt;&lt; CS_ARCH_TMS320C64X) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_M680X) | (<span class="number">1</span> &lt;&lt; CS_ARCH_EVM));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)query &lt; CS_ARCH_MAX)</span><br><span class="line"><span class="keyword">return</span> all_arch &amp; (<span class="number">1</span> &lt;&lt; query);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (query == CS_SUPPORT_DIET) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (query == CS_SUPPORT_X86_REDUCE) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CAPSTONE_HAS_X86) &amp;&amp; defined(CAPSTONE_X86_REDUCE)</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unsupported query</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例1(CS_ARCH_ALL，检查是否支持所有架构)：<br><img src="https://i.loli.net/2019/07/21/5d3469069954048775.jpg" alt></p><p>示例2(CS<em>ARCH</em>*，检查是否支持指定架构)<br><img src="https://i.loli.net/2019/07/21/5d34698a9ee7d33247.jpg" alt></p><p>示例3(检查是否处于DIET编译模式)：<br><img src="https://i.loli.net/2019/07/21/5d346a147b7e947704.jpg" alt></p><p>示例4(检查是否处于X86_REDUCE编译模式)：<br><img src="https://i.loli.net/2019/07/21/5d346a844b5b058873.jpg" alt>)</p><p>From <a href="https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(二">https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(二)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Capstone反汇编引擎数据类型及API分析及示例-二&quot;&gt;&lt;a href=&quot;#Capstone反汇编引擎数据类型及API分析及示例-二&quot; class=&quot;headerlink&quot; title=&quot;Capstone反汇编引擎数据类型及API分析及示例(二)&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="反汇编" scheme="https://kabeor.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Capstone反汇编引擎数据类型及API分析及示例(一)</title>
    <link href="https://kabeor.github.io/Capstone%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E5%8F%8A%E7%A4%BA%E4%BE%8B(%E4%B8%80)/"/>
    <id>https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(一)/</id>
    <published>2019-07-20T07:14:11.341Z</published>
    <updated>2019-07-26T04:39:24.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Capstone反汇编引擎数据类型及API分析及示例-一"><a href="#Capstone反汇编引擎数据类型及API分析及示例-一" class="headerlink" title="Capstone反汇编引擎数据类型及API分析及示例(一)"></a>Capstone反汇编引擎数据类型及API分析及示例(一)</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5753" target="_blank" rel="noopener">https://xz.aliyun.com/t/5753</a></p></blockquote><p>最近准备用开源的反汇编引擎做个项目，研究了OllyDebug的ODDisasm，disasm与assembl部分代码的思想都很值得学习，但毕竟是2000年的产物，指令集只支持x86，也没有对语义的深度分析，于是转向了对Capstone的研究。</p><p>Capstone反汇编引擎可以说是如今世界上最优秀的反汇编引擎，IDA，Radare2，Qemu等著名项目都使用了Capstone Engine，所以选择它来开发是一个不错的选择。<br>但在开发时发现官方并未给出详细API文档，网上也没有类似的分析，因此想到自己阅读源码和试验，由此写出了一个简单的非官方版本的API手册，希望能与大家分享。</p><h2 id="0x0-开发准备"><a href="#0x0-开发准备" class="headerlink" title="0x0 开发准备"></a>0x0 开发准备</h2><p>  Capstone官网： <a href="http://www.capstone-engine.org" target="_blank" rel="noopener">http://www.capstone-engine.org</a></p><h3 id="自行编译lib和dll方法"><a href="#自行编译lib和dll方法" class="headerlink" title="自行编译lib和dll方法"></a>自行编译lib和dll方法</h3><p>  源码： <a href="https://github.com/aquynh/capstone/archive/4.0.1.zip" target="_blank" rel="noopener">https://github.com/aquynh/capstone/archive/4.0.1.zip</a></p><p>  下载后解压<br>  文件结构如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   .                   &lt;- 主要引擎core engine + README + 编译文档COMPILE.TXT 等</span><br><span class="line">├── arch            &lt;- 各语言反编译支持的代码实现</span><br><span class="line">│   ├── AArch64     &lt;- ARM64 (aka ARMv8) 引擎</span><br><span class="line">│   ├── ARM         &lt;- ARM 引擎</span><br><span class="line">│   ├── EVM         &lt;- Ethereum 引擎</span><br><span class="line">│   ├── M680X       &lt;- M680X 引擎</span><br><span class="line">│   ├── M68K        &lt;- M68K 引擎</span><br><span class="line">│   ├── Mips        &lt;- Mips 引擎</span><br><span class="line">│   ├── PowerPC     &lt;- PowerPC 引擎</span><br><span class="line">│   ├── Sparc       &lt;- Sparc 引擎</span><br><span class="line">│   ├── SystemZ     &lt;- SystemZ 引擎</span><br><span class="line">│   ├── TMS320C64x  &lt;- TMS320C64x 引擎</span><br><span class="line">│   ├── X86         &lt;- X86 引擎</span><br><span class="line">│   └── XCore       &lt;- XCore 引擎</span><br><span class="line">├── bindings        &lt;- 中间件</span><br><span class="line">│   ├── java        &lt;- Java 中间件 + 测试代码</span><br><span class="line">│   ├── ocaml       &lt;- Ocaml 中间件 + 测试代码</span><br><span class="line">│   └── python      &lt;- Python 中间件 + 测试代码</span><br><span class="line">├── contrib         &lt;- 社区代码</span><br><span class="line">├── cstool          &lt;- Cstool 检测工具源码</span><br><span class="line">├── docs            &lt;- 文档，主要是capstone的实现思路</span><br><span class="line">├── include         &lt;- C头文件</span><br><span class="line">├── msvc            &lt;- Microsoft Visual Studio 支持（Windows）</span><br><span class="line">├── packages        &lt;- Linux/OSX/BSD包</span><br><span class="line">├── windows         &lt;- Windows 支持(Windows内核驱动编译)</span><br><span class="line">├── suite           &lt;- Capstone开发测试工具</span><br><span class="line">├── tests           &lt;- C语言测试用例</span><br><span class="line">└── xcode           &lt;- Xcode 支持 (MacOSX 编译)</span><br></pre></td></tr></table></figure></p><p>下面演示Windows10使用Visual Studio2019编译</p><p>复制msvc文件夹到一个比较清爽的位置（强迫症专用），内部结构如下：</p><p><img src="https://i.loli.net/2019/07/20/5d32b771e4c0118081.jpg" alt></p><p>VS打开capstone.sln项目文件，解决方案自动载入这些</p><p><img src="https://i.loli.net/2019/07/20/5d32b810db76b87698.jpg" alt></p><p>可以看到支持的所有语言都在这里了，如果都需要的话，直接编译就好了，只需要其中几种，则右键解决方案-&gt;属性-&gt;配置属性  如下</p><p><img src="https://i.loli.net/2019/07/20/5d32b92a26e1328865.jpg" alt></p><p>生成选项中勾选你需要的支持项即可<br>编译后会在当前文件夹Debug目录下生成capstone.lib静态编译库和capstone.dll动态库这样就可以开始使用Capstone进行开发了</p><p>如果不想自己编译，官方也提供了官方编译版本<br>Win32： <a href="https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win32.zip" target="_blank" rel="noopener">https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win32.zip</a><br>Win64： <a href="https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win64.zip" target="_blank" rel="noopener">https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win64.zip</a></p><p>选x32或x64将影响后面开发的位数</p><h3 id="引擎调用测试"><a href="#引擎调用测试" class="headerlink" title="引擎调用测试"></a>引擎调用测试</h3><p>新建一个VS项目，将..\capstone-4.0.1\include\capstone中的头文件以及编译好的lib和dll文件全部拷贝到新建项目的主目录下</p><p><img src="https://i.loli.net/2019/07/20/5d32bbbde025889046.jpg" alt></p><p>在VS解决方案中，头文件添加现有项capstone.h，资源文件中添加capstone.lib，重新生成解决方案</p><p><img src="https://i.loli.net/2019/07/20/5d32bc284c4e175661.jpg" alt></p><p>那么现在来测试一下我们自己的capstone引擎吧</p><p>主文件写入如下代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cinttypes&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count = cs_disasm(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0x1000</span>, <span class="number">0</span>, &amp;insn);</span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span><span class="string">"Ix"</span><span class="string">":\t%s\t\t%s\n"</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disassemble given code!\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上这是官方给出的C语言开发唯一几个例子之一，但注意到代码cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)，测试的是archx64的反编译，因此编译选项也需要设置为x64，除此以外，如果你的项目像我一样是c++开发，那么printf(“0x%””Ix””:\t%s\t\t%s\n”, insn[j].address, insn[j].mnemonic, insn[j].op_str);处官方给出的”0x%”PRIx64”:\t%s\t\t%s\n”应修改为我这里的”0x%””Ix””:\t%s\t\t%s\n”，这是inttypes支持问题。</p><p>运行结果<br><img src="https://i.loli.net/2019/07/20/5d32ca5adbd7040022.jpg" alt></p><h2 id="0x1-数据类型及API分析"><a href="#0x1-数据类型及API分析" class="headerlink" title="0x1 数据类型及API分析"></a>0x1 数据类型及API分析</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="csh"><a href="#csh" class="headerlink" title="csh"></a>csh</h4><p>用于生成调用capstone API的句柄<br><code>size_t csh</code> </p><blockquote><p>用法： <code>csh handle;</code></p></blockquote><h4 id="cs-arch"><a href="#cs-arch" class="headerlink" title="cs_arch"></a>cs_arch</h4><p>架构选择</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">enum</span> cs_arch &#123;</span><br><span class="line">CS_ARCH_ARM = <span class="number">0</span>,<span class="comment">///&lt; ARM 架构 (包括 Thumb, Thumb-2)</span></span><br><span class="line">CS_ARCH_ARM64,<span class="comment">///&lt; ARM-64, 也叫 AArch64</span></span><br><span class="line">CS_ARCH_MIPS,<span class="comment">///&lt; Mips 架构</span></span><br><span class="line">   CS_ARCH_X86,<span class="comment">///&lt; X86 架构 (包括 x86 &amp; x86-64)</span></span><br><span class="line">CS_ARCH_PPC,<span class="comment">///&lt; PowerPC 架构</span></span><br><span class="line">CS_ARCH_SPARC,<span class="comment">///&lt; Sparc 架构</span></span><br><span class="line">CS_ARCH_SYSZ,<span class="comment">///&lt; SystemZ 架构</span></span><br><span class="line">CS_ARCH_XCORE,<span class="comment">///&lt; XCore 架构</span></span><br><span class="line">CS_ARCH_M68K,<span class="comment">///&lt; 68K 架构</span></span><br><span class="line">CS_ARCH_TMS320C64X,<span class="comment">///&lt; TMS320C64x 架构</span></span><br><span class="line">CS_ARCH_M680X,<span class="comment">///&lt; 680X 架构</span></span><br><span class="line">CS_ARCH_EVM,<span class="comment">///&lt; Ethereum 架构</span></span><br><span class="line">CS_ARCH_MAX,</span><br><span class="line">CS_ARCH_ALL = <span class="number">0xFFFF</span>, <span class="comment">// All 架构 - for cs_support()</span></span><br><span class="line">&#125; cs_arch;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API中cs_arch参数填入枚举内容，如API中cs_open(cs_arch arch, cs_mode mode, csh *handle);第一个参数填CS_ARCH_X86则支持X86 架构</p></blockquote><h4 id="cs-mode"><a href="#cs-mode" class="headerlink" title="cs_mode"></a>cs_mode</h4><p>模式选择</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_mode &#123;</span><br><span class="line">CS_MODE_LITTLE_ENDIAN = <span class="number">0</span>,<span class="comment">///&lt; little-endian 模式 (default 模式)</span></span><br><span class="line">CS_MODE_ARM = <span class="number">0</span>,<span class="comment">///&lt; 32-bit ARM</span></span><br><span class="line">CS_MODE_16 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,<span class="comment">///&lt; 16-bit 模式 (X86)</span></span><br><span class="line">CS_MODE_32 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,<span class="comment">///&lt; 32-bit 模式 (X86)</span></span><br><span class="line">CS_MODE_64 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,<span class="comment">///&lt; 64-bit 模式 (X86, PPC)</span></span><br><span class="line">CS_MODE_THUMB = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,<span class="comment">///&lt; ARM's Thumb 模式, 包括 Thumb-2</span></span><br><span class="line">CS_MODE_MCLASS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,<span class="comment">///&lt; ARM's Cortex-M 系列</span></span><br><span class="line">CS_MODE_V8 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,<span class="comment">///&lt; ARM解码方式ARMv8 A32 </span></span><br><span class="line">CS_MODE_MICRO = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; MicroMips 模式 (MIPS)</span></span><br><span class="line">CS_MODE_MIPS3 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">///&lt; Mips III ISA</span></span><br><span class="line">CS_MODE_MIPS32R6 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">///&lt; Mips32r6 ISA</span></span><br><span class="line">CS_MODE_MIPS2 = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">///&lt; Mips II ISA</span></span><br><span class="line">CS_MODE_V9 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; SparcV9 模式 (Sparc)</span></span><br><span class="line">CS_MODE_QPX = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; Quad Processing eXtensions 模式 (PPC)</span></span><br><span class="line">CS_MODE_M68K_000 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">///&lt; M68K 68000 模式</span></span><br><span class="line">CS_MODE_M68K_010 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">///&lt; M68K 68010 模式</span></span><br><span class="line">CS_MODE_M68K_020 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">///&lt; M68K 68020 模式</span></span><br><span class="line">CS_MODE_M68K_030 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; M68K 68030 模式</span></span><br><span class="line">CS_MODE_M68K_040 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">///&lt; M68K 68040 模式</span></span><br><span class="line">CS_MODE_M68K_060 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">///&lt; M68K 68060 模式</span></span><br><span class="line">CS_MODE_BIG_ENDIAN = <span class="number">1</span> &lt;&lt; <span class="number">31</span>,<span class="comment">///&lt; big-endian 模式</span></span><br><span class="line">CS_MODE_MIPS32 = CS_MODE_32,<span class="comment">///&lt; Mips32 ISA (Mips)</span></span><br><span class="line">CS_MODE_MIPS64 = CS_MODE_64,<span class="comment">///&lt; Mips64 ISA (Mips)</span></span><br><span class="line">CS_MODE_M680X_6301 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">///&lt; M680X Hitachi 6301,6303 模式</span></span><br><span class="line">CS_MODE_M680X_6309 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">///&lt; M680X Hitachi 6309 模式</span></span><br><span class="line">CS_MODE_M680X_6800 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">///&lt; M680X Motorola 6800,6802 模式</span></span><br><span class="line">CS_MODE_M680X_6801 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; M680X Motorola 6801,6803 模式</span></span><br><span class="line">CS_MODE_M680X_6805 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">///&lt; M680X Motorola/Freescale 6805 模式</span></span><br><span class="line">CS_MODE_M680X_6808 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">///&lt; M680X Motorola/Freescale/NXP 68HC08 模式</span></span><br><span class="line">CS_MODE_M680X_6809 = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">///&lt; M680X Motorola 6809 模式</span></span><br><span class="line">CS_MODE_M680X_6811 = <span class="number">1</span> &lt;&lt; <span class="number">8</span>, <span class="comment">///&lt; M680X Motorola/Freescale/NXP 68HC11 模式</span></span><br><span class="line">CS_MODE_M680X_CPU12 = <span class="number">1</span> &lt;&lt; <span class="number">9</span>, <span class="comment">///&lt; M680X Motorola/Freescale/NXP CPU12</span></span><br><span class="line"><span class="comment">///&lt; 用于 M68HC12/HCS12</span></span><br><span class="line">CS_MODE_M680X_HCS08 = <span class="number">1</span> &lt;&lt; <span class="number">10</span>, <span class="comment">///&lt; M680X Freescale/NXP HCS08 模式</span></span><br><span class="line">&#125; cs_mode;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API中cs_mode参数填入枚举内容，如API中cs_open(cs_arch arch, cs_mode mode, csh *handle);第二个参数填CS_MODE_64则支持X64模式</p></blockquote><h4 id="cs-opt-mem"><a href="#cs-opt-mem" class="headerlink" title="cs_opt_mem"></a>cs_opt_mem</h4><p>内存操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_mem</span> &#123;</span></span><br><span class="line"><span class="keyword">cs_malloc_t</span> <span class="built_in">malloc</span>;</span><br><span class="line"><span class="keyword">cs_calloc_t</span> <span class="built_in">calloc</span>;</span><br><span class="line"><span class="keyword">cs_realloc_t</span> <span class="built_in">realloc</span>;</span><br><span class="line"><span class="keyword">cs_free_t</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="keyword">cs_vsnprintf_t</span> vsnprintf;</span><br><span class="line">&#125; cs_opt_mem;</span><br></pre></td></tr></table></figure><blockquote><p>用法：可使用用户自定义的malloc/calloc/realloc/free/vsnprintf()函数，默认使用系统自带malloc(), calloc(), realloc(), free() &amp; vsnprintf()</p></blockquote><h4 id="cs-opt-mnem"><a href="#cs-opt-mnem" class="headerlink" title="cs_opt_mnem"></a>cs_opt_mnem</h4><p>自定义助记符</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_mnem</span> &#123;</span></span><br><span class="line"><span class="comment">/// 需要自定义的指令ID</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="comment">/// 自定义的助记符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mnemonic;</span><br><span class="line">&#125; cs_opt_mnem;</span><br></pre></td></tr></table></figure><h4 id="cs-opt-type"><a href="#cs-opt-type" class="headerlink" title="cs_opt_type"></a>cs_opt_type</h4><p>反编译的运行时选项</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_opt_type &#123;</span><br><span class="line">CS_OPT_INVALID = <span class="number">0</span>,<span class="comment">///&lt; 无特殊要求</span></span><br><span class="line">CS_OPT_SYNTAX,<span class="comment">///&lt; 汇编输出语法</span></span><br><span class="line">CS_OPT_DETAIL,<span class="comment">///&lt; 将指令结构分解为多个细节</span></span><br><span class="line">CS_OPT_MODE,<span class="comment">///&lt; 运行时改变引擎模式</span></span><br><span class="line">CS_OPT_MEM,<span class="comment">///&lt; 用户定义的动态内存相关函数</span></span><br><span class="line">CS_OPT_SKIPDATA, <span class="comment">///&lt; 在反汇编时跳过数据。然后引擎将处于SKIPDATA模式</span></span><br><span class="line">CS_OPT_SKIPDATA_SETUP, <span class="comment">///&lt; 为SKIPDATA选项设置用户定义函数</span></span><br><span class="line">CS_OPT_MNEMONIC, <span class="comment">///&lt;自定义指令助记符</span></span><br><span class="line">CS_OPT_UNSIGNED, <span class="comment">///&lt; 以无符号形式打印立即操作数</span></span><br><span class="line">&#125; cs_opt_type;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API cs_option(csh handle, cs_opt_type type, size_t value);中第二个参数</p></blockquote><h4 id="cs-opt-value"><a href="#cs-opt-value" class="headerlink" title="cs_opt_value"></a>cs_opt_value</h4><p>运行时选项值(与cs_opt_type关联)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_opt_value &#123;</span><br><span class="line">CS_OPT_OFF = <span class="number">0</span>,  <span class="comment">///&lt; 关闭一个选项 - 默认为CS_OPT_DETAIL, CS_OPT_SKIPDATA, CS_OPT_UNSIGNED.</span></span><br><span class="line">CS_OPT_ON = <span class="number">3</span>, <span class="comment">///&lt; 打开一个选项 (CS_OPT_DETAIL, CS_OPT_SKIPDATA).</span></span><br><span class="line">CS_OPT_SYNTAX_DEFAULT = <span class="number">0</span>, <span class="comment">///&lt; 默认asm语法 (CS_OPT_SYNTAX).</span></span><br><span class="line">CS_OPT_SYNTAX_INTEL, <span class="comment">///&lt; X86 Intel asm语法 - 默认开启 X86 (CS_OPT_SYNTAX).</span></span><br><span class="line">CS_OPT_SYNTAX_ATT,   <span class="comment">///&lt; X86 ATT 汇编语法 (CS_OPT_SYNTAX).</span></span><br><span class="line">CS_OPT_SYNTAX_NOREGNAME, <span class="comment">///&lt; 只打印寄存器名和编号 (CS_OPT_SYNTAX)</span></span><br><span class="line">CS_OPT_SYNTAX_MASM, <span class="comment">///&lt; X86 Intel Masm 语法 (CS_OPT_SYNTAX).</span></span><br><span class="line">&#125; cs_opt_value;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API cs_option(csh handle, cs_opt_type type, size_t value);中第三个参数</p></blockquote><h4 id="cs-op-type"><a href="#cs-op-type" class="headerlink" title="cs_op_type"></a>cs_op_type</h4><p>通用指令操作数类型，在所有架构中保持一致</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_op_type &#123;</span><br><span class="line">CS_OP_INVALID = <span class="number">0</span>,  <span class="comment">///&lt; 未初始化/无效的操作数</span></span><br><span class="line">CS_OP_REG,          <span class="comment">///&lt; 寄存器操作数</span></span><br><span class="line">CS_OP_IMM,          <span class="comment">///&lt; 立即操作数</span></span><br><span class="line">CS_OP_MEM,          <span class="comment">///&lt; 内存操作数</span></span><br><span class="line">CS_OP_FP,           <span class="comment">///&lt; 浮点数</span></span><br><span class="line">&#125; cs_op_type;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p></blockquote><h4 id="cs-ac-type"><a href="#cs-ac-type" class="headerlink" title="cs_ac_type"></a>cs_ac_type</h4><p>通用指令操作数访问类型，在所有架构中保持一致<br>可以组合访问类型，例如:CS_AC_READ | CS_AC_WRITE</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_ac_type &#123;</span><br><span class="line">CS_AC_INVALID = <span class="number">0</span>,        <span class="comment">///&lt; 未初始化/无效的访问类型</span></span><br><span class="line">CS_AC_READ    = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,   <span class="comment">///&lt; 操作数从内存或寄存器中读取</span></span><br><span class="line">CS_AC_WRITE   = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,   <span class="comment">///&lt; 操作数从内存或寄存器中写入</span></span><br><span class="line">&#125; cs_ac_type;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p></blockquote><h4 id="cs-group-type"><a href="#cs-group-type" class="headerlink" title="cs_group_type"></a>cs_group_type</h4><p>公共指令组，在所有架构中保持一致</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cs_group_type &#123;</span><br><span class="line">CS_GRP_INVALID = <span class="number">0</span>,  <span class="comment">///&lt; 未初始化/无效指令组</span></span><br><span class="line">CS_GRP_JUMP,    <span class="comment">///&lt; 所有跳转指令(条件跳转+直接跳转+间接跳转)</span></span><br><span class="line">CS_GRP_CALL,    <span class="comment">///&lt; 所有调用指令</span></span><br><span class="line">CS_GRP_RET,     <span class="comment">///&lt; 所有返回指令</span></span><br><span class="line">CS_GRP_INT,     <span class="comment">///&lt; 所有中断指令(int+syscall)</span></span><br><span class="line">CS_GRP_IRET,    <span class="comment">///&lt; 所有中断返回指令</span></span><br><span class="line">CS_GRP_PRIVILEGE,    <span class="comment">///&lt; 所有特权指令</span></span><br><span class="line">CS_GRP_BRANCH_RELATIVE, <span class="comment">///&lt; 所有相关分支指令</span></span><br><span class="line">&#125; cs_group_type;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p></blockquote><h4 id="cs-opt-skipdata"><a href="#cs-opt-skipdata" class="headerlink" title="cs_opt_skipdata"></a>cs_opt_skipdata</h4><p>用户自定义设置SKIPDATA选项</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_skipdata</span> &#123;</span></span><br><span class="line"><span class="comment">/// Capstone认为要跳过的数据是特殊的“指令”</span></span><br><span class="line"><span class="comment">/// 用户可以在这里指定该指令的“助记符”字符串</span></span><br><span class="line"><span class="comment">/// 默认情况下(@mnemonic为NULL)， Capstone使用“.byte”</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mnemonic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用户定义的回调函数，当Capstone命中数据时调用</span></span><br><span class="line"><span class="comment">/// 如果这个回调返回的值是正数(&gt;0)，Capstone将跳过这个字节数并继续。如果回调返回0,Capstone将停止反汇编并立即从cs_disasm()返回</span></span><br><span class="line"><span class="comment">/// 注意:如果这个回调指针为空，Capstone会根据架构跳过一些字节，如下所示:</span></span><br><span class="line"><span class="comment">/// Arm:     2 bytes (Thumb mode) or 4 bytes.</span></span><br><span class="line"><span class="comment">/// Arm64:   4 bytes.</span></span><br><span class="line"><span class="comment">/// Mips:    4 bytes.</span></span><br><span class="line"><span class="comment">/// M680x:   1 byte.</span></span><br><span class="line"><span class="comment">/// PowerPC: 4 bytes.</span></span><br><span class="line"><span class="comment">/// Sparc:   4 bytes.</span></span><br><span class="line"><span class="comment">/// SystemZ: 2 bytes.</span></span><br><span class="line"><span class="comment">/// X86:     1 bytes.</span></span><br><span class="line"><span class="comment">/// XCore:   2 bytes.</span></span><br><span class="line"><span class="comment">/// EVM:     1 bytes.</span></span><br><span class="line"><span class="keyword">cs_skipdata_cb_t</span> callback; <span class="comment">// 默认值为 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用户自定义数据将被传递给@callback函数指针</span></span><br><span class="line"><span class="keyword">void</span> *user_data;</span><br><span class="line">&#125; cs_opt_skipdata;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p><h4 id="cs-detail"><a href="#cs-detail" class="headerlink" title="cs_detail"></a>cs_detail</h4><p>注意:只有当CS_OPT_DETAIL = CS_OPT_ON时，cs_detail中的所有信息才可用</p></blockquote><p>在arch/ARCH/ARCHDisassembler.c的ARCH_getInstruction中初始化为memset(., 0, offsetof(cs_detail, ARCH)+sizeof(cs_ARCH))</p><p>如果cs_detail发生了变化，特别是在union之后添加了字段，那么相应地更新arch/ arch/ archdisassembly .c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_detail</span> &#123;</span></span><br><span class="line"><span class="keyword">uint16_t</span> regs_read[<span class="number">12</span>]; <span class="comment">///&lt; 这个参数读取隐式寄存器列表</span></span><br><span class="line"><span class="keyword">uint8_t</span> regs_read_count; <span class="comment">///&lt; 这个参数读取隐式寄存器计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span> regs_write[<span class="number">20</span>]; <span class="comment">///&lt; 这个参数修改隐式寄存器列表</span></span><br><span class="line"><span class="keyword">uint8_t</span> regs_write_count; <span class="comment">///&lt; 这个参数修改隐式寄存器计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> groups[<span class="number">8</span>]; <span class="comment">///&lt; 此指令所属的指令组的列表</span></span><br><span class="line"><span class="keyword">uint8_t</span> groups_count; <span class="comment">///&lt; 此指令所属的组的数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 特定于体系结构的信息</span></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">cs_x86 x86;     <span class="comment">///&lt; X86 架构, 包括 16-bit, 32-bit &amp; 64-bit 模式</span></span><br><span class="line">cs_arm64 arm64; <span class="comment">///&lt; ARM64 架构 (aka AArch64)</span></span><br><span class="line">cs_arm arm;     <span class="comment">///&lt; ARM 架构 (包括 Thumb/Thumb2)</span></span><br><span class="line">cs_m68k m68k;   <span class="comment">///&lt; M68K 架构</span></span><br><span class="line">cs_mips mips;   <span class="comment">///&lt; MIPS 架构</span></span><br><span class="line">cs_ppc ppc;    <span class="comment">///&lt; PowerPC 架构</span></span><br><span class="line">cs_sparc sparc; <span class="comment">///&lt; Sparc 架构</span></span><br><span class="line">cs_sysz sysz;   <span class="comment">///&lt; SystemZ 架构</span></span><br><span class="line">cs_xcore xcore; <span class="comment">///&lt; XCore 架构</span></span><br><span class="line">cs_tms320c64x tms320c64x;  <span class="comment">///&lt; TMS320C64x 架构</span></span><br><span class="line">cs_m680x m680x; <span class="comment">///&lt; M680X 架构</span></span><br><span class="line">cs_evm evm;    <span class="comment">///&lt; Ethereum 架构</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; cs_detail;</span><br></pre></td></tr></table></figure><h4 id="cs-insn"><a href="#cs-insn" class="headerlink" title="cs_insn"></a>cs_insn</h4><p>指令的详细信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_insn</span> &#123;</span></span><br><span class="line"><span class="comment">/// 指令ID(基本上是一个用于指令助记符的数字ID)</span></span><br><span class="line"><span class="comment">/// 应在相应架构的头文件中查找'[ARCH]_insn' enum中的指令id，如ARM.h中的'arm_insn'代表ARM, X86.h中的'x86_insn'代表X86等…</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="comment">/// 注意:在Skipdata模式下，这个id字段的“data”指令为0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令地址 (EIP)</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令长度</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">uint16_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 此指令的机器码，其字节数由上面的@size表示</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">uint8_t</span> bytes[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令的Ascii文本助记符</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">char</span> mnemonic[CS_MNEMONIC_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令操作数的Ascii文本</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">char</span> op_str[<span class="number">160</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// cs_detail指针</span></span><br><span class="line"><span class="comment">/// 注意:只有同时满足以下两个要求时，detail指针才有效:</span></span><br><span class="line"><span class="comment">/// (1) CS_OP_DETAIL = CS_OPT_ON</span></span><br><span class="line"><span class="comment">/// (2) 引擎未处于Skipdata模式(CS_OP_SKIPDATA选项设置为CS_OPT_ON)</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 注意2:当处于Skipdata模式或detail模式关闭时，即使这个指针不是NULL，它的内容仍然是不相关的。</span></span><br><span class="line">cs_detail *detail;</span><br><span class="line">&#125; cs_insn;</span><br></pre></td></tr></table></figure><h4 id="cs-err"><a href="#cs-err" class="headerlink" title="cs_err"></a>cs_err</h4><p>Capstone API遇到的各类型的错误时cs_errno()的返回值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> cs_err &#123;</span><br><span class="line">CS_ERR_OK = <span class="number">0</span>,   <span class="comment">///&lt; 无错误</span></span><br><span class="line">CS_ERR_MEM,      <span class="comment">///&lt; 内存不足: cs_open(), cs_disasm(), cs_disasm_iter()</span></span><br><span class="line">CS_ERR_ARCH,     <span class="comment">///&lt; 不支持的架构: cs_open()</span></span><br><span class="line">CS_ERR_HANDLE,   <span class="comment">///&lt;句柄不可用: cs_op_count(), cs_op_index()</span></span><br><span class="line">CS_ERR_CSH,      <span class="comment">///&lt; csh参数不可用: cs_close(), cs_errno(), cs_option()</span></span><br><span class="line">CS_ERR_MODE,     <span class="comment">///&lt; 无效的或不支持的模式: cs_open()</span></span><br><span class="line">CS_ERR_OPTION,   <span class="comment">///&lt; 无效的或不支持的选项: cs_option()</span></span><br><span class="line">CS_ERR_DETAIL,   <span class="comment">///&lt; 信息不可用，因为detail选项是关闭的</span></span><br><span class="line">CS_ERR_MEMSETUP, <span class="comment">///&lt; 动态内存管理未初始化(见 CS_OPT_MEM)</span></span><br><span class="line">CS_ERR_VERSION,  <span class="comment">///&lt; 不支持版本 (bindings)</span></span><br><span class="line">CS_ERR_DIET,     <span class="comment">///&lt; 在“diet”引擎中访问不相关的数据</span></span><br><span class="line">CS_ERR_SKIPDATA, <span class="comment">///&lt; 在SKIPDATA模式下访问与“数据”指令无关的数据</span></span><br><span class="line">CS_ERR_X86_ATT,  <span class="comment">///&lt; X86 AT&amp;T 语法不支持(在编译时退出)</span></span><br><span class="line">CS_ERR_X86_INTEL, <span class="comment">///&lt; X86 Intel 语法不支持(在编译时退出)</span></span><br><span class="line">CS_ERR_X86_MASM, <span class="comment">///&lt; X86 Intel 语法不支持(在编译时退出)</span></span><br><span class="line">&#125; cs_err;</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(一">https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(一)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Capstone反汇编引擎数据类型及API分析及示例-一&quot;&gt;&lt;a href=&quot;#Capstone反汇编引擎数据类型及API分析及示例-一&quot; class=&quot;headerlink&quot; title=&quot;Capstone反汇编引擎数据类型及API分析及示例(一)&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="反汇编" scheme="https://kabeor.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C++调用线程实现QQ消息循环发送</title>
    <link href="https://kabeor.github.io/C++%E8%B0%83%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0QQ%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E5%8F%91%E9%80%81/"/>
    <id>https://kabeor.github.io/C++调用线程实现QQ消息循环发送/</id>
    <published>2019-04-24T11:35:50.051Z</published>
    <updated>2019-04-24T11:44:48.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-调用线程实现QQ消息循环发送"><a href="#C-调用线程实现QQ消息循环发送" class="headerlink" title="C++调用线程实现QQ消息循环发送"></a>C++调用线程实现QQ消息循环发送</h1><p>##函数原型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned long _beginthread(  </span><br><span class="line">             void(_cdecl *start_address)(void *), //声明为void (*start_address)(void *)形式  </span><br><span class="line">             unsigned stack_size, //是线程堆栈大小，一般默认为0  </span><br><span class="line">             void *arglist //向线程传递的参数，一般为结构体</span><br><span class="line">           ); </span><br><span class="line"></span><br><span class="line">unsigned long _beginthreadex( //推荐使用   </span><br><span class="line">             void *security,//安全属性，NULL表示默认安全性  </span><br><span class="line">             unsigned stack_size, //是线程堆栈大小，一般默认为0  </span><br><span class="line">             unsigned(_stdcall  *start_address)(void *),//声明为unsigned(*start_address)(void *)形式  </span><br><span class="line">             void *argilist,//向线程传递的参数，一般为结构体  </span><br><span class="line">             unsigned initflag, //新线程的初始状态，0表示立即执行，CREATE_SUSPEND表示创建后挂起。  </span><br><span class="line">             unsigned *thrdaddr //该变量存放线程标识符，它是CreateThread函数中的线程ID。); //创建成功条件下的将线程句柄转化为unsigned long型返回，创建失败条件下返回0</span><br></pre></td></tr></table></figure></p><blockquote><p>使用_beginthreadex而不是CreateThread的原因</p></blockquote><p> _beginthreadex在内部调用了CreateThread，在调用之前_beginthreadex做了很多的工作，从而使得它比CreateThread更安全。</p><p>通常建议使用_beginthreadex函数，而不是CreateThread函数，这使得线程中的代码不需要考虑C/C++代码的线程安全性，除非你清楚地知道在新的线程中不会调用到线程不安全的C/C++代码，这时候放心地使用CreateThread也无可厚非(实际上这种情况很难判定)。_beginthreadex保证了某些C/C++运行库代码的线程安全性，而CreateThread没有对这些特殊的C/C++代码做出保证，这里再次强调这两个函数的区别。不要含糊地认为CreateThread的设计存在缺陷，CreateThread的功能并不专门针对于C/C++运行库，理所当然不必为其多线程安全性而负责。</p><p>##实现<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> _<span class="function">stdcall <span class="title">ThreadOne</span><span class="params">(<span class="keyword">void</span>* Parg)</span>                   <span class="comment">//stdcall自动平衡堆栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入发送次数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i &lt; j; i++)</span><br><span class="line">&#123;</span><br><span class="line">SendMessage((HWND)<span class="number">0x002401E8</span>, WM_PASTE, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">//获取窗口线程   获取剪切板内容</span></span><br><span class="line">        Sleep(<span class="number">300</span>);</span><br><span class="line">keybd_event(VK_RETURN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);                  <span class="comment">//模拟按下回车</span></span><br><span class="line">keybd_event(VK_RETURN, <span class="number">0</span>, KEYEVENTF_KEYUP, <span class="number">0</span>);    <span class="comment">//模拟弹起回车</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_beginthreadex(<span class="literal">NULL</span>,<span class="literal">NULL</span>,ThreadOne,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);        <span class="comment">//线程调用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入发送次数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>From <a href="https://kabeor.github.io/C++调用线程实现QQ消息循环发送/">https://kabeor.github.io/C++调用线程实现QQ消息循环发送/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-调用线程实现QQ消息循环发送&quot;&gt;&lt;a href=&quot;#C-调用线程实现QQ消息循环发送&quot; class=&quot;headerlink&quot; title=&quot;C++调用线程实现QQ消息循环发送&quot;&gt;&lt;/a&gt;C++调用线程实现QQ消息循环发送&lt;/h1&gt;&lt;p&gt;##函数原型&lt;br&gt;&lt;f
      
    
    </summary>
    
      <category term="Code" scheme="https://kabeor.github.io/categories/Code/"/>
    
    
      <category term="C++多线程" scheme="https://kabeor.github.io/tags/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>OD常用断点</title>
    <link href="https://kabeor.github.io/OD%E5%B8%B8%E7%94%A8%E6%96%AD%E7%82%B9/"/>
    <id>https://kabeor.github.io/OD常用断点/</id>
    <published>2019-03-31T05:59:00.857Z</published>
    <updated>2019-03-20T13:34:16.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OD常用断点"><a href="#OD常用断点" class="headerlink" title="OD常用断点"></a>OD常用断点</h1><h2 id="INT-3断点"><a href="#INT-3断点" class="headerlink" title="INT 3断点"></a>INT 3断点</h2><blockquote><p>原理： 当执行一个INT 3断点时，该地址处的内容被调试器用INT 3 指令替换，此时OD将INT 3隐藏，显示中断前的指令</p><p>INT 3机器码为0xCC<br>   <code>004013A5  CC D0404000</code><br>68被替换为CC</p></blockquote><p>INT3断点可设置无限个，但改变了程序机器码，容易被检测，如检测API首地址是否为0xCC。绕过方式，将断点设在函数内部或末尾。</p><p>F2或命令行 bp设置</p><h2 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h2><blockquote><p>原理<br>与DRx调试寄存器有关</p><p>Dr0~3用于设置硬件断点，即在调试器中经常使用的bpm断点，由于只有4个断点寄存器，所以最多只能设置4个bpm断点。Dr7是一些控制位，用于控制断点的方式，Dr6用于显示是哪些引起断点的原因。</p></blockquote><p><img src="https://i.loli.net/2019/02/14/5c64ea4e1430a.jpg" alt></p><p>硬件断点不会将指令首字节修改为CC</p><p>菜单Breakpoint  &gt; hardware,on execution 或命令行 “HE 地址”设置</p><h2 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h2><blockquote><p>原理： 对所设的地址赋予不可访问/不可写入属性，当访问或写入时会产生异常，OD截获异常后比较是否是断点地址，如果是就中断。</p></blockquote><p>只能下一个内存断点<br>Breakpoint &gt; memory, on write/access设置，F9运行</p><p>硬件访问/写入断点在触发硬件断点的下一条指令处下断，内存断点在触发断点的指令处下断。</p><h2 id="内存访问一次性断点"><a href="#内存访问一次性断点" class="headerlink" title="内存访问一次性断点"></a>内存访问一次性断点</h2><p>ALT+M显示内存，在相应段上右键Set break-on-access或F2对整个内存块设置该类断点<br>这个断点是一次性断点，当所在段被读取或执行时中断，然后断点被删除</p><p>捕捉调用或返回某模块时使用。</p><h2 id="消息断点"><a href="#消息断点" class="headerlink" title="消息断点"></a>消息断点</h2><p>当某个特定窗口函数接收到特定消息时，消息断点将使程序中断。<br>INT 3断点可在程序启动前设置，消息断点只能在窗口被创建后设置并拦截消息。</p><p>运行窗口程序，菜单View &gt; Windows或W按钮，列出窗口相关参数，右键Actualize刷新。对应位置右键Message breakpoint on ClassProc进行设置。想要返回程序领空，应对.text段下内存访问断点。</p><h2 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h2><h3 id="寄存器条件中断"><a href="#寄存器条件中断" class="headerlink" title="寄存器条件中断"></a>寄存器条件中断</h3><p>Shift+F2</p><h3 id="存储器条件中断"><a href="#存储器条件中断" class="headerlink" title="存储器条件中断"></a>存储器条件中断</h3><p>标出各参数对应ESP地址 栈窗口右键Address &gt; Relative to ESP</p><p>相应API用Shift+F2设置断点</p><h3 id="条件记录断点"><a href="#条件记录断点" class="headerlink" title="条件记录断点"></a>条件记录断点</h3><p>Shift+F4</p><p>From <a href="https://kabeor.github.io/OD常用断点/">https://kabeor.github.io/OD常用断点/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OD常用断点&quot;&gt;&lt;a href=&quot;#OD常用断点&quot; class=&quot;headerlink&quot; title=&quot;OD常用断点&quot;&gt;&lt;/a&gt;OD常用断点&lt;/h1&gt;&lt;h2 id=&quot;INT-3断点&quot;&gt;&lt;a href=&quot;#INT-3断点&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>(Sequence List)顺序表算法分析</title>
    <link href="https://kabeor.github.io/(Sequence%20List)%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://kabeor.github.io/(Sequence List)顺序表算法分析/</id>
    <published>2019-03-31T05:59:00.378Z</published>
    <updated>2019-04-24T11:30:38.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sequence-List-顺序表算法分析"><a href="#Sequence-List-顺序表算法分析" class="headerlink" title="(Sequence List)顺序表算法分析"></a>(Sequence List)顺序表算法分析</h1><h2 id="一-Struct实现"><a href="#一-Struct实现" class="headerlink" title="一 Struct实现"></a>一 Struct实现</h2><blockquote><p>动态存储分配<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100  <span class="comment">//初始化顺序表最大容量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT 10    <span class="comment">//默认增加空间量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* elem;         <span class="comment">//一维数组</span></span><br><span class="line">    <span class="keyword">int</span> length;         <span class="comment">//线性表当前长度</span></span><br><span class="line">    <span class="keyword">int</span> listsize;       <span class="comment">//当前数组容量</span></span><br><span class="line">    <span class="keyword">int</span> incrementsize;  <span class="comment">//增加空间量</span></span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure></p><p>初始化</p></blockquote><p>构造一个空的顺序表L</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList_Sq</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> maxsize = LIST_INIT_SIZE, <span class="keyword">int</span> incresize = LISTINCREMENT)</span></span></span><br><span class="line"><span class="function"></span>&#123;                                        <span class="comment">//构建最大容量maxsize的顺序表L</span></span><br><span class="line">    L.elem = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(maxsize * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));  <span class="comment">//申请内存</span></span><br><span class="line">    <span class="keyword">if</span> (!L.elem)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.listsize = maxsize;</span><br><span class="line">    L.incrementsize = incresize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>求表长</p></blockquote><p>返回当前顺序表L元素个数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength_Sq</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>查找元素</p></blockquote><p>从第一个元素起，一次和待查找元素e相比较，找到则返回该元素在L中的位序，查找成功；否则返回-1，查找失败。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, <span class="keyword">char</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;      <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span> (L.elem[i] == e)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>插入元素</p></blockquote><p>假设顺序表中有length个元素，在第i(0&lt;=i&lt;=length)个元素前插入新元素e时，需要将第length-1至第i个位置(共length-i个)依次后移，然后插入e到第i个位置，length加1，返回true。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert_Sq</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> i, <span class="keyword">char</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; L.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L.length &gt; L.listsize) &#123;</span><br><span class="line">        L.elem = (<span class="keyword">char</span>*)<span class="built_in">realloc</span>(L.elem, (L.listsize + L.incrementsize) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="keyword">if</span> (!L.elem)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        L.listsize += L.incrementsize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = L.length; j &gt; i; j--)      <span class="comment">//后移</span></span><br><span class="line">        L.elem[j] = L.elem[j - <span class="number">1</span>];</span><br><span class="line">    L.elem[i] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>删除元素</p></blockquote><p>与插入相反，需要删除第i(0&lt;=i&lt;=length)个元素，将第i至第length-1个位置(共length-i个)依次前移，length减1，返回true。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDetect_Sq</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> i, <span class="keyword">char</span>&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; L.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (L.length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.elem[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= L.length - <span class="number">1</span>; j++)</span><br><span class="line">        L.elem[j - <span class="number">1</span>] = L.elem[j];</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>取元素</p></blockquote><p>直接返回元素，不需要移动</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetElem_Sq</span><span class="params">(SqList L, <span class="keyword">int</span> i, <span class="keyword">char</span>&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; L.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (L.length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.elem[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>遍历表</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListTraverse_Sq</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; L.elem[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>释放表</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList_Sq</span><span class="params">(SqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(L.elem);</span><br><span class="line">    L.listsize = <span class="number">0</span>;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-Vector实现"><a href="#二-Vector实现" class="headerlink" title="二 Vector实现"></a>二 Vector实现</h2><blockquote><p>Vector常用操作</p></blockquote><ol><li><p>push_back 在数组的最后添加一个数据</p></li><li><p>pop_back 去掉数组的最后一个数据</p></li><li><p>at 得到编号位置的数据</p></li><li><p>begin 得到数组头的指针</p></li><li><p>end 得到数组的最后一个单元+1的指针</p></li><li><p>front 得到数组头的引用</p></li><li><p>back 得到数组的最后一个单元的引用</p></li><li><p>max_size 得到vector最大可以是多大</p></li><li><p>capacity 当前vector分配的大小</p></li><li><p>size 当前使用数据的大小</p></li><li><p>resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</p></li><li><p>reserve 改变当前vecotr所分配空间的大小</p></li><li><p>erase 删除指针指向的数据项</p></li><li><p>clear 清空当前的vector</p></li><li><p>rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)</p></li><li><p>rend 将vector反转构的结束指针返回(其实就是原来的begin-1)</p></li><li><p>empty 判断vector是否为空</p></li><li><p>swap 与另一个vector交换数据</p></li></ol><blockquote><p>初始化</p></blockquote><p>只需将顺序表长度置零</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> sqlist::init()</span><br><span class="line">&#123;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>清空 </p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> sqlist::clear()</span><br><span class="line">&#123;</span><br><span class="line">    v.clear();</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>判断是否为空<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> sqlist::is_empty()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (len == <span class="number">0</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取数据</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Seqlist_t sqlist::get_elem(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> v.at(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>查找数据</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sqlist::get_locate(Seqlist_t e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (e.element == v.at(i).element)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> (i != len) ? (i) : (<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在尾部添加数据</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> sqlist::add_back(Seqlist_t e)</span><br><span class="line">&#123;</span><br><span class="line">    v.push_back(e);</span><br><span class="line">    len++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>删除最后一个数据</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> sqlist::delete_back()</span><br><span class="line">&#123;</span><br><span class="line">    v.pop_back();</span><br><span class="line">    len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>指定位置插入数据</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> sqlist::insert_elem(Seqlist_t e, <span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    v.insert(v.begin() + i, e);</span><br><span class="line">    len++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>删除指定位置数据</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> sqlist::delete_elem(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    v.erase(v.begin() + i);</span><br><span class="line">    len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>遍历数据</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> sqlist::traverse()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The element is "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v.at(i).element &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/(Sequence List">https://kabeor.github.io/(Sequence List)顺序表算法分析/</a>顺序表算法分析/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sequence-List-顺序表算法分析&quot;&gt;&lt;a href=&quot;#Sequence-List-顺序表算法分析&quot; class=&quot;headerlink&quot; title=&quot;(Sequence List)顺序表算法分析&quot;&gt;&lt;/a&gt;(Sequence List)顺序表算法分析
      
    
    </summary>
    
      <category term="Code" scheme="https://kabeor.github.io/categories/Code/"/>
    
    
      <category term="数据结构" scheme="https://kabeor.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB图像处理常用函数</title>
    <link href="https://kabeor.github.io/MATLAB%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>https://kabeor.github.io/MATLAB图像处理常用函数/</id>
    <published>2019-01-27T13:00:32.081Z</published>
    <updated>2019-01-28T01:19:26.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MATLAB图像处理常用函数"><a href="#MATLAB图像处理常用函数" class="headerlink" title="MATLAB图像处理常用函数"></a>MATLAB图像处理常用函数</h1><p>期末考完一直在忙着写机器学习图像识别的项目，简单记录一下</p><h2 id="数字图像的读取"><a href="#数字图像的读取" class="headerlink" title="数字图像的读取"></a>数字图像的读取</h2><blockquote><p>imread<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imread( ‘filename’ );</span><br><span class="line">其中，filename是一个含有图像文件全名的字符串,包括文件的扩展名。单引号‘’来界定filename字符串。结尾处用分号在MATLAB中用于取消输出。</span><br><span class="line"></span><br><span class="line">size(I);</span><br><span class="line">函数size可以给出图像的行数和列数。如果size前面没有变量，则存在ans变量里。如果有变量，比如[M，N]=size(I);则该命令将返回函数的行数M和列数N。</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="数字图像显示"><a href="#数字图像显示" class="headerlink" title="数字图像显示"></a>数字图像显示</h2><blockquote><p>imshow(I, G)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">G是显示该图像的灰度级数，若将G省略，则默认的灰度级数为256</span><br></pre></td></tr></table></figure></p><p>imshow(I, [low high])<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">会将所有小于或等于low的值都显示为黑色，所有大于或等于high的值都显示为白色。界于low和high之间的值将以默认的级数显示为中等亮度值。</span><br></pre></td></tr></table></figure></p><p>imshow(I,[])<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以将变量low设置为数组f的最小值，将变量high设置为数组f的最大值。该函数用来显示动态范围较小的图像时非常有用。</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="图像保存"><a href="#图像保存" class="headerlink" title="图像保存"></a>图像保存</h2><blockquote><p>imwrite(f, ’filename’)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该函数的功能是使用函数imwrite可以将图像写到磁盘上的filename命令的文件中。Filename必须包含文件的扩展名。</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="图像类型转换"><a href="#图像类型转换" class="headerlink" title="图像类型转换"></a>图像类型转换</h2><blockquote><p>G=im2bw(I,T)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该函数的功能就是将亮度图像I转换为一幅二值图像G。在亮度图像中，亮度值小于T的像素点全部转换为二值图像中值为0的像素点；在亮度图像中，亮度值大于T的像素点全部转换为二值图像中值为1的像素点。</span><br></pre></td></tr></table></figure></p><p>G=rgb2gray(I)<br><code>该函数将彩色图像数组I转换为灰度图像G。</code></p></blockquote><h2 id="图像的几何操作"><a href="#图像的几何操作" class="headerlink" title="图像的几何操作"></a>图像的几何操作</h2><blockquote><p>imread 加<br>imsubtract 减</p><p>imresize 缩放<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imresize(A,scale,method)</span><br><span class="line">imresize(A,[mrows ncols],method)</span><br><span class="line">method</span><br><span class="line">Nearest:最近邻插值</span><br><span class="line">Bilinear:双线性插值</span><br><span class="line">Bicubic:双三次插值，系统默认值</span><br></pre></td></tr></table></figure></p><p>imrotate(A,angle,method) 旋转<br>逆时针为正，顺时针为负。</p></blockquote><h2 id="亮度变换"><a href="#亮度变换" class="headerlink" title="亮度变换"></a>亮度变换</h2><blockquote><p>imadjust<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g=imadjust(f,[low_in high_in],[low_out high_out], gamma)</span><br><span class="line"></span><br><span class="line">将图像f中的亮度值映像到g中的新值，即将low_in至high_in之间的值映射到low_out至high_out之间的值。</span><br><span class="line">low_in以下的值映射为low_out, high_in以上的值映射为high_out.</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="图像直方图函数"><a href="#图像直方图函数" class="headerlink" title="图像直方图函数"></a>图像直方图函数</h2><blockquote><p>imhist</p></blockquote><h2 id="滤波函数"><a href="#滤波函数" class="headerlink" title="滤波函数"></a>滤波函数</h2><blockquote><p>线性空间滤波函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B=imfilter(A,H)</span><br><span class="line">A是输入图像，B是滤波后的输出图像，H是滤波模板</span><br><span class="line"></span><br><span class="line">imfilter(I,fspecial(&apos;average&apos;,[3 3]));</span><br></pre></td></tr></table></figure></p><p>高斯滤波<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imfilter(I,fspecial(&apos;gaussian&apos;,[3 3]));</span><br></pre></td></tr></table></figure></p><p>中值滤波<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">medfilt2(I,[3,3]);</span><br></pre></td></tr></table></figure></p></blockquote><p>From <a href="https://kabeor.github.io/MATLAB图像处理常用函数/">https://kabeor.github.io/MATLAB图像处理常用函数/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MATLAB图像处理常用函数&quot;&gt;&lt;a href=&quot;#MATLAB图像处理常用函数&quot; class=&quot;headerlink&quot; title=&quot;MATLAB图像处理常用函数&quot;&gt;&lt;/a&gt;MATLAB图像处理常用函数&lt;/h1&gt;&lt;p&gt;期末考完一直在忙着写机器学习图像识别的项目，
      
    
    </summary>
    
      <category term="Code" scheme="https://kabeor.github.io/categories/Code/"/>
    
    
      <category term="matlab, 图像处理" scheme="https://kabeor.github.io/tags/matlab-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第15章  对抗反汇编</title>
    <link href="https://kabeor.github.io/%E7%AC%AC15%E7%AB%A0%20%20%E5%AF%B9%E6%8A%97%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    <id>https://kabeor.github.io/第15章  对抗反汇编/</id>
    <published>2018-10-18T10:42:41.480Z</published>
    <updated>2019-02-14T03:21:29.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第15章-对抗反汇编"><a href="#第15章-对抗反汇编" class="headerlink" title="第15章  对抗反汇编"></a>第15章  对抗反汇编</h1><h2 id="1-何谓对抗反汇编技术"><a href="#1-何谓对抗反汇编技术" class="headerlink" title="1. 何谓对抗反汇编技术"></a>1. 何谓对抗反汇编技术</h2><p>实现对抗反汇编时，恶意代码编写者会创建一段代码序列，欺骗反汇编器，让反汇编器展示与真正执行的代码不同的指令列表。</p><h2 id="2-挫败反汇编算法"><a href="#2-挫败反汇编算法" class="headerlink" title="2. 挫败反汇编算法"></a>2. 挫败反汇编算法</h2><p>对抗反汇编技术是基于反汇编算法的天生漏洞而产生的。为了清晰地显示反汇编代码，反汇编器在事前都会做某种特定的假设。一旦这种假设不成立，恶意代码作者就有机会欺骗分析人员。</p><p>反汇编算法可以分为两种：线性反汇编算法和面向代码流的反汇编算法。其中线性反汇编算法容易实现，但也易出错。</p><h3 id="线性反汇编"><a href="#线性反汇编" class="headerlink" title="线性反汇编"></a>线性反汇编</h3><p>线性反汇编策略是遍历一个代码段,一次一条指令的线性反汇编,从不偏离。反汇编器使用的这个基本策略已经被反汇编写作教程采用,并且被调试器广泛使用。线性反汇编用已经反汇编的指!令大小来决定下一个要反汇编的字节,而不考虑代码流的控制指令</p><blockquote><p>利用反汇编库libdisasm，C实现基于线性反汇编算法的反汇编器</p></blockquote><p><img src="https://i.loli.net/2018/10/18/5bc8774662859.jpg" alt=""></p><p>本例中,名为 buffer的数据缓冲区包含需要反汇编的指令。函数x86 disasm将会用刚刚反汇编过的具体指令填充一个数据结构,然后返回这个指令的大小。如果反汇编是一条合法指令,这个循环会用size值递增 position变量(如1所示),否则递增1(如2所示)</p><p>这个代码片段中的许多指令拥有多个字节,恶意代码编写者利用线性反汇编算法的关键方法是植入能够组成多字节指令机器码的数据字节。例如,标准的本地ca11指令有5个字节,以机器码0xE8开头。如果16字节数据组成一个以值0xE8结尾的开关表,那么当反汇编器碰到Call指令的机器码时会将接下来的4个字节当作操作数对待,而不是当作下一个函数的开头。</p><p>线性反汇编算法不能区分代码与数据,因此最容易被恶意代码挫败。</p><h3 id="面向代码流的反汇编"><a href="#面向代码流的反汇编" class="headerlink" title="面向代码流的反汇编"></a>面向代码流的反汇编</h3><p>面向代码流的反汇编与线性反汇编的主要不同在于，面向代码流的反汇编器并不盲目地反汇编整个缓冲区，也不假设代码段中仅包含指令而不包含数据。相反，它会检查每一条指令，然后建立一个需要反汇编的地址列表。</p><p>如果IDAPro产生了不正确的反汇编代码，你可以利用键盘上的C键或D键，手动将指令转换成数据或者将数据转换成指令。步骤如下：</p><ol><li>按C键可以将光标位置的数据转换成代码。</li><li>按D键可以将光标位置的代码转换成数据。</li></ol><h2 id="3-对抗反汇编技术"><a href="#3-对抗反汇编技术" class="headerlink" title="3. 对抗反汇编技术"></a>3. 对抗反汇编技术</h2><p>恶意代码最常见的对抗反汇编技术的主要方法是利用反汇编器选择算法和假设算法的漏洞，使反汇编器产生错误的反汇编代码。</p><h3 id="相同目标的跳转指令"><a href="#相同目标的跳转指令" class="headerlink" title="相同目标的跳转指令"></a>相同目标的跳转指令</h3><p>恶意代码中最常见的对抗反汇编技术是使用指向同一目的地址的两个连续条件跳转指令。</p><p>如果jz1oc_512指令之后是jnz loc_512，则总是跳转到loc_512。jz指令与jnz指令的结合，在效果上等于无条件跳转指令jmp，因为反汇编器每次只反汇编一条指令，所以并不会意识到这种情况。当反汇编器遇到jnz指令时，依然会反汇编这个指令的false分支，尽管事实上这个分支永远不会执行。</p><h3 id="固定条件的跳转指令"><a href="#固定条件的跳转指令" class="headerlink" title="固定条件的跳转指令"></a>固定条件的跳转指令</h3><p>在恶意代码中，另一种常见的对抗反汇编技术是由跳转条件总是相同的一条跳转指令构成的。</p><p><img src="https://i.loli.net/2018/11/22/5bf6910ff2758.jpg" alt=""></p><p>注意这段代码以xor eax，eax指令开头，这条指令的作用是将EAX寄存器置0，与此同时它也会设置标志寄存器的zero标志。下一条指令是条件跳转指令，如果标志寄存器zero标志被置位，它就会执行跳转。事实上，这根本不是条件跳转，因为在程序的这个位置，我们可以保证zero标志总是被置位的。</p><blockquote><p>xor指令与相邻jz指令的永假关系</p></blockquote><p><img src="https://i.loli.net/2018/11/22/5bf6917871865.jpg" alt=""></p><h3 id="无效的反汇编指令"><a href="#无效的反汇编指令" class="headerlink" title="无效的反汇编指令"></a>无效的反汇编指令</h3><p>前面讨论的简单的对抗反汇编技术是巧妙地在条件跳转指令之后放一个字节，这种技术的思路是，从这个字节开始反汇编，阻止其后真正的指令被反汇编，因为插入的字节是一个多字节指令的机器码。我们称这样的字节为流氓字节，因为它不属于程序的一部分，只是用在代码段迷感反汇编器。</p><p>但是，如果流氓字节不能被忽略，如果它是合法指令的一部分，且在运行时能够被正确执行怎么办？这里，我们碰到一个棘手的问题，所有给定字节都是多字节指令的一部分，而且它们都能够被执行。目前业内没有一个反汇编器能够将单个字节表示为两条指令的组成部分，然而处理器并没有这种限制。</p><blockquote><p>内部跳转的jmp指令</p></blockquote><p><img src="https://i.loli.net/2018/11/22/5bf69651b711b.jpg" alt=""></p><p>当试图表达这个反汇编序列时，会十分困惑，因为如果将字节FF作为jmp指令的一部分，那么就不能作为inc eax指令的开头来进行显示。字节FF同时作为两条实际运行指令的一部分，而现代反汇编器并没有办法表达这种情况。这4个字节序列首先递增EAX，然后递减EAX。实际上，这是一个复杂的NOP序列，几乎可以插入程序的任何位置，从而破坏有效的反汇编链。为了解决这个问题，恶意代码分析人员常使用IDC或者IDAPython脚本，调用PatchByte函数，用NOP指令序列替换这个字节序列，另一种办法是使用D键将这样的字符序列全部转换成数据，让这4个字节之后的反汇编恢复正常。</p><blockquote><p>多层内部调转序列</p></blockquote><p><img src="https://i.loli.net/2018/11/22/5bf697244514f.jpg" alt=""></p><p>在字节序列中，第一条指令是4字节的mov指令，其最后2个字节被高亮显示，因为它既是mov指令的一部分，同时也作为随后运行的一条指令。第一条指令会用数据填充AX寄存器。第二条指令xor会归零这个寄存器，且将标志寄存器zero置0。第三条指令是一个条件跳转指令，当标志寄存器zero标志置位时，它执行跳转。实际上它不是一个条件跳转，因为它的前一条指令总是设置zero标志。反汇编器会反汇编紧跟jz的指令，该指令以字节0xE8开头，0xE8是一个5字节call指令的机器码。然而这条以0xE8开头的指令实际上永远不会执行。</p><p>在这种情况下，反汇编器不能正确反汇编jz指令目标，因为这个字节已经被正确表达为mov指令的一部分。jz指令指向的代码总会被执行，因为jz指令运行时，zero标志总是被置位。指令z跳转到4字节的mov指令中间。mov指令的最后两个字节是存放在寄存器中的操作数。当单独反汇编或者运行这个操作数时，它又会组成一个jmp指令，这条jmp指令会从指令末尾向前跳转5个字节。</p><blockquote><p>IDAPython将字节换成NOP</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NopBytes</span><span class="params">(start,length)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length):</span><br><span class="line">    PatchByte(start+i, <span class="number">0x90</span>)</span><br><span class="line">MakeCode(start)</span><br><span class="line">NopBytes(起始地址,长度)</span><br></pre></td></tr></table></figure><h3 id="用IDA-PRO对指令进行NOP替换"><a href="#用IDA-PRO对指令进行NOP替换" class="headerlink" title="用IDA PRO对指令进行NOP替换"></a>用IDA PRO对指令进行NOP替换</h3><p>如下脚本的作用是创建一个热键ALT+N，一旦脚本运行，无论用户何时按下ALT+N组合键，IDAPro都会使用NOP指令替换当前光标位置处的字节。它也能简单地将光标移到下一条指令处，从而使替换大块代码变得更容易。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"></span><br><span class="line">idaapi.Compileline(<span class="string">'static n_key()&#123; RunPythonStatement("nopIt()");&#125;'</span>)</span><br><span class="line"></span><br><span class="line">AddHotkey(<span class="string">"Alt-N"</span>,<span class="string">"n_key"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nopIt</span><span class="params">()</span>:</span></span><br><span class="line">    start=ScreenEA()</span><br><span class="line">    end=NextHead(start)</span><br><span class="line">    <span class="keyword">for</span> ea <span class="keyword">in</span> range(start, end): PatchByte(ea,<span class="number">0x90</span>)</span><br><span class="line">    Jump(end) Refresh()</span><br></pre></td></tr></table></figure><h2 id="4-混淆控制流图"><a href="#4-混淆控制流图" class="headerlink" title="4. 混淆控制流图"></a>4. 混淆控制流图</h2><h3 id="函数指针问题"><a href="#函数指针问题" class="headerlink" title="函数指针问题"></a>函数指针问题</h3><p>在C语言程序中刻意使用函数指针，这可以大大降低反汇编器自动推导出程序流的信息量。如果在汇编语言中刻意使用函数指针或者在源码中构造不标准的函数指针格式，会导致在没有动态分析的前提下很难进行逆向工程。</p><h3 id="在IDA-Pro中添加代码的交叉引用"><a href="#在IDA-Pro中添加代码的交叉引用" class="headerlink" title="在IDA Pro中添加代码的交叉引用"></a>在IDA Pro中添加代码的交叉引用</h3><p>使用IDC中名为AddCodeXref的函数。它有三个参数：交叉引用来源的位置、交叉引用指向的位置，以及流的类型。这个函数可以支持多个不同的流类型，但最常用的是普通call指令类型fl_CF，或是跳转指令的类型fl_JF。</p><h3 id="滥用返回指针"><a href="#滥用返回指针" class="headerlink" title="滥用返回指针"></a>滥用返回指针</h3><p>在程序中，call指令和jmp指令并不是唯一转换控制流的指令。与call指令对应的指令是retn（也被表示为ret）。call指令与jmp指令功能类似，不同的是它将函数返回地址压入到栈中，返回点是紧随call指令的一个内存地址。</p><p>call指令等同于jmp指令加push指令，retn指令等同于jmp指令加pop指令。retn指令首先从栈顶弹出一个值（返回值地址），然后跳转到这个值所表示的地址处。retn通常被用来返回一个函数调用，但由于体系结构的限制，它不能用于一般的执行控制流。</p><p>当retn指令不以函数调用返回的方式被使用时，这种技术的最显著结果是反汇编器不能显示代码中任何要跳转的交又引用目标。另一个显著的结果是反汇编器会提前结束这个函数。</p><h3 id="滥用结构化异常处理"><a href="#滥用结构化异常处理" class="headerlink" title="滥用结构化异常处理"></a>滥用结构化异常处理</h3><p>结构化异常处理（SEH）提供一种控制流的方法，该方法不能被反汇编器采用，但可以用来欺骗反汇编器。SEH是×86体系结构的一种功能，旨在为程序提供一种智能处理错误条件的方法。编程语言例如C++，Ada等，严重依赖异常处理，并且在x86系统上编译时会自动翻译成SEH。</p><p>异常触发可能有多种原因，例如访问一个无效内存区域、除零等。也可以调用函数RaiseException产生额外的软件异常。</p><p>SEH链是一个函数列表，设计它的目的是处理线程中的异常。列表中的每个函数，要么处理异常，要么将异常传递到列表中的下一个函数。如果一个异常总是被传递到最后一个异常处理函数处，就会被认为是一个不能处理的异常。这种情况下，最后一个异常处理函数会负责弹出一个熟悉的消息对话框，通知用户“an unhandled exception has occurred”。在大多数进程中，异常是有规律地产生的，但在到达最后状态（使程序崩溃并通知用户）之前，异常都会被静悄悄的处理。</p><p>为了查找SEH链，操作系统会检查FS段寄存器。这个寄存器包含一个段选择子，使用段选择子可以得到线程环境块（TEB）。TEB中第一个数据结构是线程信息块（TIB）。TIB中的第一个元素（即TIB的第一个字节）就是SEH链的指针。SEH链是一个简单的8字节数据结构链表，这个8字节数据结构叫作EXCEPTION_REGISTRATION记录。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct_EXCEPTION_RECISTRATION&#123;</span><br><span class="line">    DWORD prev；</span><br><span class="line">DWORD handler；</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure></p><p>EXCEPTION_REGISTRATION记录的第一个元素是一个指向前一个记录的指针。第二个元素则是一个指向异常处理函数的指针。</p><p>从概念上讲，这个链表以栈的方式进行操作。第一个调用的是最后一个加入链表的记录。由于子进程的调用与嵌套的异常处理块的原因，SEH链的增长和缩小等同于程序中异常处理层的改变，所以SEH记录总是建在栈上。</p><p>利用SEH实现变相控制程序流，并不需要在意当前异常处理链有多少个记录，只需要了解怎么将自己的异常处理添加到链表的头部</p><p><img src="https://i.loli.net/2018/11/22/5bf69c4ebab61.jpg" alt="">。</p><p>为了将一条记录添加到这个链中，我们需要在栈上构造一条新记录。因为记录结构由两个DWORD变量组成，所以使用两个push指令来完成。栈是向上增长的，所以第一个push进栈的是异常处理函数指针，第二个push进栈的是下一条记录的指针。当添加一条记录到链表的头部时，下一条记录需要完成的异常处理是当前的栈项，它由fs[e]指针给出。下面是实现这一功能的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push ExceptionHandler </span><br><span class="line">push fs:[0]</span><br><span class="line">mov fs:[0]，esp</span><br></pre></td></tr></table></figure></p><p>异常发生时，将首先调用函数ExceptionHandler。这个动作会受到微软的软件数据执行保护机制（软件DEP，也被称为SafeSEH）的限制。</p><p>软件DEP是一项安全功能，它的目的是阻止程序运行过程中添加第三方的异常处理。对于硬编码的代码，有几种方法能够绕过这种技术，例如使用支持SafeSEH指令的汇编器。另外，使用微软的C编译器也能达到此目的，添加/SAFESEH:NO到链接器命令行，就可使这种限制无效。</p><p>当调用ExceptionHandler函数时，栈将被大幅改变。幸运的是，要达到我们的目的，没必要检查添加到栈中的所有数据。我们必须知道怎么返回异常发生前的栈位置。回想一下，我们的目的是混淆控制流且使程序不能正确处理异常。</p><p>当异常处理被调用时，操作系统添加了其他的SEH处理。为了让程序恢复正常操作，不仅要将我们的异常处理从异常处理链中断开，还要将系统添加的异常处理从异常处理链中断开。因此，我们需要从esp+8处而不是esp处取出原始的栈指针。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov esp，[esp+8]</span><br><span class="line">mov eax，fs:[0]</span><br><span class="line">mov eax，[eax]mov eax，[eax]</span><br><span class="line">mov fs:[0]，eax add esp，8</span><br></pre></td></tr></table></figure></p><h3 id="5-挫败栈帧分析"><a href="#5-挫败栈帧分析" class="headerlink" title="5. 挫败栈帧分析"></a>5. 挫败栈帧分析</h3><p>为了解决栈帧的轻微调整（用栈帧分析的固有易犯错特性偶尔会导致这种情况发生），在IDA Pro中，将光标放到某个特定反汇编行上，然后通过按ALT+K组合键，输入调整的栈指针值。</p><p>From <a href="https://kabeor.github.io/第15章  对抗反汇编/">https://kabeor.github.io/第15章  对抗反汇编/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第15章-对抗反汇编&quot;&gt;&lt;a href=&quot;#第15章-对抗反汇编&quot; class=&quot;headerlink&quot; title=&quot;第15章  对抗反汇编&quot;&gt;&lt;/a&gt;第15章  对抗反汇编&lt;/h1&gt;&lt;h2 id=&quot;1-何谓对抗反汇编技术&quot;&gt;&lt;a href=&quot;#1-何谓对抗反汇
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第五篇 逆向工程" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%BA%94%E7%AF%87-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SUS十一欢乐赛 re200 maze</title>
    <link href="https://kabeor.github.io/SUS%E5%8D%81%E4%B8%80%E6%AC%A2%E4%B9%90%E8%B5%9B%20re200%20maze/"/>
    <id>https://kabeor.github.io/SUS十一欢乐赛 re200 maze/</id>
    <published>2018-10-07T02:51:14.484Z</published>
    <updated>2018-10-07T04:24:56.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SUS十一欢乐赛-re200-maze"><a href="#SUS十一欢乐赛-re200-maze" class="headerlink" title="SUS十一欢乐赛 re200 maze"></a>SUS十一欢乐赛 re200 maze</h1><p><img src="https://i.loli.net/2018/10/07/5bb9757376a67.jpg" alt=""></p><p>x64的ELF，载入IDA64</p><p>题目已经告诉是迷宫了，搜索一下字符串</p><p><img src="https://i.loli.net/2018/10/07/5bb9764bbf2b6.jpg" alt=""></p><p>看到map<br><code>oooo*oooooxxxxoxxooxooooxoooxxoxxxooooxxxooxooooxooxxooooxxxoxooooxoxxxxoooooooox</code></p><p>但目前不知道map规格，于是跟随SUSCTF{字符跳转，F5</p><p><img src="https://i.loli.net/2018/10/07/5bb977240df3c.jpg" alt=""></p><p>很明显第18行检查输入长度是否为18<br><code>if (std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length(&amp;v12) != 18 )</code></p><p>下面是方向控制 awsd</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for ( i = 0; i &lt;= 17; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = *(char *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](&amp;v12, i);</span><br><span class="line">    if ( v5 == &apos;d&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      ++v10;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v5 &gt; &apos;d&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v5 == &apos;s&apos; )</span><br><span class="line">      &#123;</span><br><span class="line">        v10 += 9;</span><br><span class="line">      &#125;</span><br><span class="line">      else if ( v5 == &apos;w&apos; )</span><br><span class="line">      &#123;</span><br><span class="line">        v10 -= 9;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v5 == &apos;a&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      --v10;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由上下换行加减9可以判断出，<strong>map每行9个字符</strong>，于是得到map</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">oooo*oooo</span><br><span class="line">oxxxxoxxo</span><br><span class="line">oxooooxoo</span><br><span class="line">oxxoxxxoo</span><br><span class="line">ooxxxooxo</span><br><span class="line">oooxooxxo</span><br><span class="line">oooxxxoxo</span><br><span class="line">oooxoxxxx</span><br><span class="line">oooooooox</span><br></pre></td></tr></table></figure><p>判定边界o<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ( *(_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](&amp;map, v10) == &apos;o&apos; )</span><br><span class="line">  break;</span><br></pre></td></tr></table></figure></p><p>到达终点<em><br>`if ( </em>(_BYTE <em>)std::__cxx11::basic_string&lt;char,std::char_traits<char>,std::allocator<char>&gt;::operator<a href="&amp;map, v10"></a> == ‘</char></char></em>‘ )`</p><p>v10原值为80，从0开始为第81位，于是从最后一个x出发，到达最上面*<br>走的步骤为<br><code>waaawaawwawawwdddw</code></p><p>刚好18位，运行程序，输入步骤，拿到flag</p><p><img src="https://i.loli.net/2018/10/07/5bb97f0197437.jpg" alt=""></p><p>From <a href="https://kabeor.github.io/SUS十一欢乐赛 re200 maze/">https://kabeor.github.io/SUS十一欢乐赛 re200 maze/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SUS十一欢乐赛-re200-maze&quot;&gt;&lt;a href=&quot;#SUS十一欢乐赛-re200-maze&quot; class=&quot;headerlink&quot; title=&quot;SUS十一欢乐赛 re200 maze&quot;&gt;&lt;/a&gt;SUS十一欢乐赛 re200 maze&lt;/h1&gt;&lt;p&gt;&lt;i
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>RC4加密算法及逆向方法初探</title>
    <link href="https://kabeor.github.io/RC4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8F%8A%E9%80%86%E5%90%91%E6%96%B9%E6%B3%95%E5%88%9D%E6%8E%A2/"/>
    <id>https://kabeor.github.io/RC4加密算法及逆向方法初探/</id>
    <published>2018-09-24T03:28:51.989Z</published>
    <updated>2018-09-24T07:13:36.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RC4加密算法及逆向方法初探"><a href="#RC4加密算法及逆向方法初探" class="headerlink" title="RC4加密算法及逆向方法初探"></a>RC4加密算法及逆向方法初探</h1><p>看来可以写一个系列了</p><p>之前的两篇</p><p><a href="https://kabeor.cn/CRC%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95%E5%8F%8A%E9%80%86%E5%90%91%E6%96%B9%E6%B3%95%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">CRC校验算法及逆向方法初探</a></p><p><a href="https://kabeor.cn/Base-N%E7%AE%97%E6%B3%95%E5%8F%8A%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">Base-N算法及逆向初探</a></p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>RC4（来自Rivest Cipher 4的缩写）是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。 —-wiki <a href="https://zh.wikipedia.org/zh-hans/RC4" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/RC4</a></p><h3 id="加密-解密-原理"><a href="#加密-解密-原理" class="headerlink" title="加密(解密)原理"></a>加密(解密)原理</h3><blockquote><p>RC4由伪随机数生成器和异或运算组成。RC4的密钥长度可变，范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个S盒。S盒用来加密数据，而且在加密过程中S盒会变化。</p></blockquote><p><strong>由于异或运算的对合性，RC4加密解密使用同一套算法。</strong></p><h3 id="C代码表示"><a href="#C代码表示" class="headerlink" title="C代码表示"></a>C代码表示</h3><p>先来看内部的几个基本变量</p><ol><li><p>S-Box 也就是所谓的S盒，是一个256长度的char型数组，每个单元都是一个字节，算法运行的任何时候，S都包括0-255的8比特数的排列组合，只不过值的位置发生了变换。</p></li><li><p>密钥K char key[256] 密钥的长度keylen与明文长度、密钥流的长度没有必然关系</p></li><li>临时向量k 长度也为256，每个单元也是一个字节。如果密钥的长度是256字节，就直接把密钥的值赋给k，否则，轮转地将密钥的每个字节赋给k</li></ol><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><blockquote><p>包含三个参数</p><p>参数1是一个256长度的char型数组，定义为: unsigned char sBox[256];</p><p>参数2是密钥，其内容可以随便定义：char key[256];</p><p>参数3是密钥的长度，Len = strlen(key);</p></blockquote><p>初始化长度为256的S盒。第一个for循环将0到255的互不重复的元素装入S盒。第二个for循环根据密钥打乱S盒。</p><p>i确保S-box的每个元素都得到处理，j保证S-box的搅乱是随机的。</p><p><img src="https://i.loli.net/2018/09/24/5ba8681ba7c54.jpg" alt=""></p><p><img src="https://i.loli.net/2018/09/24/5ba8682730f8d.jpg" alt=""></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_init</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *s,<span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">long</span> Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> k[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> tmp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) </span><br><span class="line">&#123;</span><br><span class="line">        s[i]=i;</span><br><span class="line">        k[i]=key[i%Len];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">        j=(j+s[i]+k[i])%<span class="number">256</span>;</span><br><span class="line">        tmp=s[i];</span><br><span class="line">        s[i]=s[j];     <span class="comment">//交换s[i]和s[j]</span></span><br><span class="line">        s[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-加解密"><a href="#2-加解密" class="headerlink" title="2. 加解密"></a>2. 加解密</h4><blockquote><p>包含三个参数</p><p>参数1是上边rc4_init函数中，被搅乱的S-box;</p><p>参数2是需要加密的数据data;</p><p>参数3是data的长度.</p></blockquote><p>每收到一个字节，就进行while循环。通过一定的算法定位S盒中的一个元素，并与输入字节异或，得到k。循环中还改变了S盒。如果输入的是明文，输出的就是密文；如果输入的是密文，输出的就是明文。</p><p><img src="https://i.loli.net/2018/09/24/5ba8683b7feb5.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_crypt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *s,<span class="keyword">unsigned</span> <span class="keyword">char</span> *Data,<span class="keyword">unsigned</span> <span class="keyword">long</span> Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;Len;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        i=(i+<span class="number">1</span>)%<span class="number">256</span>;</span><br><span class="line">        j=(j+s[i])%<span class="number">256</span>;</span><br><span class="line">        tmp=s[i];</span><br><span class="line">        s[i]=s[j];      <span class="comment">//交换s[x]和s[y]</span></span><br><span class="line">        s[j]=tmp;</span><br><span class="line">        t=(s[i]+s[j])%<span class="number">256</span>;</span><br><span class="line">        Data[k]^=s[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-主函数"><a href="#3-主函数" class="headerlink" title="3. 主函数"></a>3. 主函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> s[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;, s2[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//S-box</span></span><br><span class="line">    <span class="keyword">char</span> key[<span class="number">256</span>] = &#123; <span class="string">"justfortest"</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> pData[<span class="number">512</span>] = <span class="string">"这是一个用来加密的数据Data"</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len = <span class="built_in">strlen</span>(pData);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pData=%s\n"</span>, pData);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"key=%s,length=%d\n\n"</span>, key, <span class="built_in">strlen</span>(key));</span><br><span class="line">    rc4_init(s, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key, <span class="built_in">strlen</span>(key)); <span class="comment">//已经完成了初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"完成对S[i]的初始化，如下：\n\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02X"</span>, s[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; (i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">256</span>; i++)           <span class="comment">//用s2[i]暂时保留经过初始化的s[i]，很重要的！！！</span></span><br><span class="line">    &#123;</span><br><span class="line">        s2[i] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"已经初始化，现在加密:\n\n"</span>);</span><br><span class="line">    rc4_crypt(s, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)pData, len);<span class="comment">//加密</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pData=%s\n\n"</span>, pData);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"已经加密，现在解密:\n\n"</span>);</span><br><span class="line">    <span class="comment">//rc4_init(s,(unsignedchar*)key,strlen(key));//初始化密钥</span></span><br><span class="line">    rc4_crypt(s2, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)pData, len);<span class="comment">//解密</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pData=%s\n\n"</span>, pData);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>拿今年九月安恒杯 NewDriver这道来看</p><p>栈平衡一下，然后f5</p><p><img src="https://i.loli.net/2018/09/24/5ba880432dd93.jpg" alt=""></p><p>限制输入33位<br>base64加密<br>rc4加密</p><p>base64改了密码表，但结构很清晰，具体识别方法看我上一篇</p><p>rc4共有两个函数 sub_E41000,sub_E410E0<br>下面来具体分析这两个函数，具体解释都放在图里了，看图即可。</p><h3 id="sub-E41000-初始化"><a href="#sub-E41000-初始化" class="headerlink" title="sub_E41000 初始化"></a>sub_E41000 初始化</h3><p>函数头如下，三个值<br><code>sub_E41000(&amp;v6, &amp;v10, strlen(&amp;v10));</code><br>对应上面源码<br><code>void rc4_init(unsigned char *s,unsigned char *key, unsigned long Len)</code></p><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><p><img src="https://i.loli.net/2018/09/24/5ba88343732b6.jpg" alt=""></p><h4 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h4><p>将0到255的互不重复的元素装入S盒</p><p><img src="https://i.loli.net/2018/09/24/5ba88746b7e93.jpg" alt=""></p><p>打乱S盒</p><p><img src="https://i.loli.net/2018/09/24/5ba8885101b9f.jpg" alt=""></p><h3 id="sub-E410E0-加密"><a href="#sub-E410E0-加密" class="headerlink" title="sub_E410E0 加密"></a>sub_E410E0 加密</h3><p><code>sub_E410E0(&amp;v6, v3, strlen(v3));</code><br>对应上面源码<br><code>void rc4_crypt(unsigned char *s,unsigned char *Data,unsigned long Len)</code></p><h4 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __usercall sub_E410E0@&lt;eax&gt;(<span class="keyword">int</span> result@&lt;eax&gt;, <span class="keyword">int</span> a2, <span class="keyword">unsigned</span> <span class="keyword">int</span> a3)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v6; <span class="comment">// dl</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v3 = (v3 + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">      v6 = *(v3 + result);</span><br><span class="line">      v4 = (v6 + v4) % <span class="number">256</span>;</span><br><span class="line">      *(v3 + result) = *(v4 + result);</span><br><span class="line">      *(v4 + result) = v6;</span><br><span class="line">      *(v5++ + a2) ^= *((v6 + *(v3 + result)) % <span class="number">256</span> + result);  <span class="comment">//   Data[k]^=s[t];</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v5 &lt; a3 );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪代码看的就很清晰了，IDA分析时将数组按指针形式显示</p><h4 id="反汇编-1"><a href="#反汇编-1" class="headerlink" title="反汇编"></a>反汇编</h4><p><img src="https://i.loli.net/2018/09/24/5ba889f6b7478.jpg" alt=""></p><p><img src="https://i.loli.net/2018/09/24/5ba88a3f95be8.jpg" alt=""></p><p>0FFFFFF00h取负就是256</p><h2 id="魔改RC4"><a href="#魔改RC4" class="headerlink" title="魔改RC4"></a>魔改RC4</h2><p>其实RC4魔改还是比较难的，稍有改变，整个算法就完全不同了。因此，大多数赛题将rc4与其他算法进行组合来加密flag</p><p>常见变化位置</p><ol><li>密钥经过上一步的其他加密后传入</li><li>s盒内部数据固定</li><li>rc4加密后数据进行重加密</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>个人感觉rc4重点理解算法即可，并且对内部多次限制256次循环，mod256，以及对数据strlen的读取的特点注意即可</p><hr><p>参考网址：<br><a href="https://zh.wikipedia.org/zh-hans/RC4" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/RC4</a><br><a href="https://zh.wikipedia.org/wiki/S%E7%9B%92" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/S%E7%9B%92</a><br><a href="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/rc4/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/special/rc4/</a></p><p>From <a href="https://kabeor.github.io/RC4加密算法及逆向方法初探/">https://kabeor.github.io/RC4加密算法及逆向方法初探/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RC4加密算法及逆向方法初探&quot;&gt;&lt;a href=&quot;#RC4加密算法及逆向方法初探&quot; class=&quot;headerlink&quot; title=&quot;RC4加密算法及逆向方法初探&quot;&gt;&lt;/a&gt;RC4加密算法及逆向方法初探&lt;/h1&gt;&lt;p&gt;看来可以写一个系列了&lt;/p&gt;
&lt;p&gt;之前的两
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>第14章  恶意代码的网络特征</title>
    <link href="https://kabeor.github.io/%E7%AC%AC14%E7%AB%A0%20%20%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%89%B9%E5%BE%81/"/>
    <id>https://kabeor.github.io/第14章  恶意代码的网络特征/</id>
    <published>2018-09-22T13:04:32.171Z</published>
    <updated>2018-09-23T09:28:41.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第14章-恶意代码的网络特征"><a href="#第14章-恶意代码的网络特征" class="headerlink" title="第14章  恶意代码的网络特征"></a>第14章  恶意代码的网络特征</h1><h2 id="1-网络应对措施"><a href="#1-网络应对措施" class="headerlink" title="1. 网络应对措施"></a>1. 网络应对措施</h2><p>网络行为的基本属性包括IP地址、TCP与UDP端口、域名，以及流量内容等，网络和安全设备可以利用它们，来提供网络应对措施。根据IP地址和端口，防火墙和路由器可以限制对网络的访问。</p><p>配置DNS服务器，可以将一个已知的恶意域名重定向到内部主机，这被称为sinkhole技术。配置代理服务器，可以检测或者阻止访问某些域名。</p><h3 id="在原始环境中观察代码"><a href="#在原始环境中观察代码" class="headerlink" title="在原始环境中观察代码"></a>在原始环境中观察代码</h3><blockquote><p>真实环境捕获的信息将提供恶意应用程序真实行为的最佳视图，而恶意代码可以被编程，以加入探测实验环境的能力。</p><p>活跃恶意代码的真实场景信息能够提供独特的视角，来加快分析过程。真实流量提供了恶意代码在两个端点（客户端和服务器端）之间的通信信息，然而，在实验环境里，分析者通常只能获取其中一端的信息。而分析恶意代码如何接收内容（也就是解析例程），比起分析恶意代码如何产生内容，往往会更具挑战性。因此，双向的样本流量可以帮助分析师加快恶意代码解析例程的分析进度。</p><p>此外，当你被动地查看信息时，不存在泄露给攻击者分析活动的风险。</p></blockquote><h3 id="恶意行为的痕迹"><a href="#恶意行为的痕迹" class="headerlink" title="恶意行为的痕迹"></a>恶意行为的痕迹</h3><h3 id="OPSEC-操作安全性"><a href="#OPSEC-操作安全性" class="headerlink" title="OPSEC=操作安全性"></a>OPSEC=操作安全性</h3><p>OPSEC是政府和军方的一个术语，用来描述防止敌方获取敏感信息的过程。</p><h2 id="2-安全地调查在线攻击者"><a href="#2-安全地调查在线攻击者" class="headerlink" title="2.安全地调查在线攻击者"></a>2.安全地调查在线攻击者</h2><h3 id="间接性策略"><a href="#间接性策略" class="headerlink" title="间接性策略"></a>间接性策略</h3><p>一种间接策略是使用某些旨在提供匿名的服务或者机制，例如Tor，一个开放的代理，或者基于Web的匿名器。</p><p>另一种策略是使用专门的机器来研究，通常是虚拟机。</p><p>隐藏专用机器的具体位置的方法</p><ol><li>使用匿名的蜂窝连接。</li><li>通过安全shell（SSH）或者一个虚拟私有网络（VPN），将你的连接通过远程的基础设施来进行隧道传输。</li><li>使用运行在云服务中的一个临时远程机器，例如亚马逊的弹性计算云（亚马逊EC2）。</li></ol><h3 id="获取IP地址和域名信息"><a href="#获取IP地址和域名信息" class="headerlink" title="获取IP地址和域名信息"></a>获取IP地址和域名信息</h3><blockquote><p>Domain Tools（<a href="http://www.domaintools.com/）" target="_blank" rel="noopener">http://www.domaintools.com/）</a></p></blockquote><p>这个网站提供了whois历史记录的查询，能够进行反向IP查询，来显示所有解析成某个特定IP地址的域名，以及反向whois查询。反向whois查询允许基于联系人信息的元数据，来进行whois记录查询。</p><blockquote><p>RobTex（http:/www.robtex.com/）</p></blockquote><p>这个网站能提供指向单个IP地址的多个域名信息，另外也集成其他一些有价值的信息</p><blockquote><p>BFK DNS logger（<a href="http://www.bfk.de/bfk_dnslogger_en.htm/）" target="_blank" rel="noopener">http://www.bfk.de/bfk_dnslogger_en.htm/）</a></p></blockquote><p>这个网站使用被动DNS监测信息。</p><h2 id="3-基于内容的网络应对措施"><a href="#3-基于内容的网络应对措施" class="headerlink" title="3. 基于内容的网络应对措施"></a>3. 基于内容的网络应对措施</h2><h3 id="使用Snort进行入侵检测"><a href="#使用Snort进行入侵检测" class="headerlink" title="使用Snort进行入侵检测"></a>使用Snort进行入侵检测</h3><p>Snort是最流行的入侵检测系统之一。Snort被用来生成网络特征或者规则，这些规则由一系列元素（被称作是规则选项）连接在一起，而只有这些元素均为真时，规则才会被触发。主要的规则选项被分为：识别内容元素的规则选项（在Snort系统术语中被称为负载规则选项），以及内容无关的规则选项（称作非负载规则选项）。非负载规则选项的例子中包括某些特定标志位，TCP或IP头中的特定值，以及包负载的大小。</p><blockquote><p>Snort规则关键字描述</p></blockquote><p><img src="https://i.loli.net/2018/09/23/5ba7513ac3cdd.jpg" alt=""></p><h3 id="深入观察"><a href="#深入观察" class="headerlink" title="深入观察"></a>深入观察</h3><p><img src="https://i.loli.net/2018/09/23/5ba751667c26b.jpg" alt=""></p><h2 id="4-结合动态和静态分析技术"><a href="#4-结合动态和静态分析技术" class="headerlink" title="4. 结合动态和静态分析技术"></a>4. 结合动态和静态分析技术</h2><h3 id="过度分析的危险"><a href="#过度分析的危险" class="headerlink" title="过度分析的危险"></a>过度分析的危险</h3><blockquote><p>恶意代码分析深入级别</p></blockquote><p><img src="https://i.loli.net/2018/09/23/5ba7522329dfb.jpg" alt=""></p><h3 id="在众目睽睽下隐藏"><a href="#在众目睽睽下隐藏" class="headerlink" title="在众目睽睽下隐藏"></a>在众目睽睽下隐藏</h3><ol><li>攻击者模拟现有的协议</li><li>攻击者利用现有的基础设施</li><li>利用客户端发出的信令</li></ol><h3 id="理解周边代码"><a href="#理解周边代码" class="headerlink" title="理解周边代码"></a>理解周边代码</h3><p>网络行为有两种类型：发送数据和接收数据。分析发送出去的数据通常比较容易，因为无论恶意代码何时运行，它都会产生出便于分析的样本。</p><h3 id="寻找网络操作代码"><a href="#寻找网络操作代码" class="headerlink" title="寻找网络操作代码"></a>寻找网络操作代码</h3><p><img src="https://i.loli.net/2018/09/23/5ba7536b5bb82.jpg" alt=""></p><h3 id="了解网络内容的来源"><a href="#了解网络内容的来源" class="headerlink" title="了解网络内容的来源"></a>了解网络内容的来源</h3><p>特征生成中最有价值的元素是恶意代码中的硬编码数据。恶意代码发送的网络流量是从一组有限数据源中构造的。创建出有效特征，需要对每一块网络内容的数据来源有所了解。</p><p>下面是一些基本的数据源：</p><ol><li>随机数据（例如调用生成伪随机值函数所返回的数据）。</li><li>来源于标准网络库的数据（例如调用HTTPSendRequest创建的GET请求）。</li><li>来源于恶意代码的硬编码数据（例如一个硬编码的User-Agent字符串）。</li><li>关于主机及其配置信息的数据（例如主机名，根据系统时钟的当前时间、CPU速率等）。</li><li>从其他来源接收的数据，例如远程服务器或者文件系统（例如，服务器发送的用于加密的随机数、本地文件，以及键盘记录器捕获信息等）。</li></ol><h3 id="硬编码数据-vs-临时数据"><a href="#硬编码数据-vs-临时数据" class="headerlink" title="硬编码数据 vs. 临时数据"></a>硬编码数据 vs. 临时数据</h3><p>与使用高层网络API（如COM接口）相比，恶意代码使用低层网络API（如Winsock）时，需要更多手动生成的内容来模仿常见流量。更多的手动生成内容就意味着更多的硬编码数据，从而增加了恶意代码编写者犯错误的可能性，你可以利用这些错误来生成网络特征。</p><h3 id="确定和利用编码步骤"><a href="#确定和利用编码步骤" class="headerlink" title="确定和利用编码步骤"></a>确定和利用编码步骤</h3><h3 id="创建特征"><a href="#创建特征" class="headerlink" title="创建特征"></a>创建特征</h3><h3 id="分析解析例程"><a href="#分析解析例程" class="headerlink" title="分析解析例程"></a>分析解析例程</h3><h3 id="针对多个元素"><a href="#针对多个元素" class="headerlink" title="针对多个元素"></a>针对多个元素</h3><h2 id="5-了解攻击者的意图"><a href="#5-了解攻击者的意图" class="headerlink" title="5. 了解攻击者的意图"></a>5. 了解攻击者的意图</h2><blockquote><p>利用攻击者的弱点</p></blockquote><ol><li>专注属于两端之间的协议元素</li><li>专注于已知的任何协议元素作为密钥的部分</li><li>确定流量中不太明显的协议元素</li></ol><p>From <a href="https://kabeor.github.io/第14章  恶意代码的网络特征/">https://kabeor.github.io/第14章  恶意代码的网络特征/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第14章-恶意代码的网络特征&quot;&gt;&lt;a href=&quot;#第14章-恶意代码的网络特征&quot; class=&quot;headerlink&quot; title=&quot;第14章  恶意代码的网络特征&quot;&gt;&lt;/a&gt;第14章  恶意代码的网络特征&lt;/h1&gt;&lt;h2 id=&quot;1-网络应对措施&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第四篇 恶意代码功能篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AF%87-%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%8A%9F%E8%83%BD%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux程序破解与反破解</title>
    <link href="https://kabeor.github.io/Linux%E7%A8%8B%E5%BA%8F%E7%A0%B4%E8%A7%A3%E4%B8%8E%E5%8F%8D%E7%A0%B4%E8%A7%A3/"/>
    <id>https://kabeor.github.io/Linux程序破解与反破解/</id>
    <published>2018-09-15T14:54:44.059Z</published>
    <updated>2018-09-15T14:57:21.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux程序破解与反破解"><a href="#Linux程序破解与反破解" class="headerlink" title="Linux程序破解与反破解"></a>Linux程序破解与反破解</h1><h2 id="1-许可证密钥位于二进制文件内"><a href="#1-许可证密钥位于二进制文件内" class="headerlink" title="1. 许可证密钥位于二进制文件内"></a>1. 许可证密钥位于二进制文件内</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc==<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Checking License: %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"AAAA-Z10N-42-OK"</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Access Granted!\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"WRONG!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: &lt;key&gt;\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat 1.c</span><br><span class="line">gcc 1.c –o test1</span><br><span class="line">./test1 AAAA-Z10N-42-OK</span><br><span class="line"></span><br><span class="line">Crack：  strings test1</span><br></pre></td></tr></table></figure><h2 id="扰乱密钥加密"><a href="#扰乱密钥加密" class="headerlink" title="扰乱密钥加密"></a>扰乱密钥加密</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc==<span class="number">2</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Checking License: %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(argv[<span class="number">1</span>]); i++) </span><br><span class="line">            &#123;</span><br><span class="line">                sum+= (<span class="keyword">int</span>)argv[<span class="number">1</span>][i];  <span class="comment">//ASCII累加</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Value: %d\n"</span>, sum);</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">916</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Access Granted!\n"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"WRONG!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: &lt;key&gt;\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keygen2.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_key</span><span class="params">(key)</span>:</span></span><br><span class="line">    char_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> key:</span><br><span class="line">        char_sum += ord(c)</span><br><span class="line">    sys.stdout.write(<span class="string">"&#123;0:3&#125; | &#123;1&#125;      \r"</span>.format(char_sum, key))    <span class="comment"># print</span></span><br><span class="line">    sys.stdout.flush()                                               <span class="comment"># 一秒输出一行</span></span><br><span class="line">    <span class="keyword">return</span> char_sum</span><br><span class="line"></span><br><span class="line">key = <span class="string">""</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    key += random.choice(<span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_"</span>)</span><br><span class="line">    s = check_key(key)</span><br><span class="line">    <span class="keyword">if</span> s &gt; <span class="number">916</span>:</span><br><span class="line">        key = <span class="string">""</span></span><br><span class="line">    <span class="keyword">elif</span> s==<span class="number">916</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Found valid key: &#123;0&#125;"</span>.format(key)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将输入key的ASCII累加，与注册码魔术值比较，达到隐藏密钥的效果</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/09/15/5b9d1ccc080af.jpg" alt=""></p><h2 id="使用FUZZ进行反调试"><a href="#使用FUZZ进行反调试" class="headerlink" title="使用FUZZ进行反调试"></a>使用FUZZ进行反调试</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">"cp test2 test2_fuzz"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flip_byte</span><span class="params">(in_bytes)</span>:</span></span><br><span class="line">    i = random.randint(<span class="number">0</span>,len(in_bytes))</span><br><span class="line">    c = chr(random.randint(<span class="number">0</span>,<span class="number">0xFF</span>))</span><br><span class="line">    <span class="keyword">return</span> in_bytes[:i]+c+in_bytes[i+<span class="number">1</span>:]         <span class="comment"># 随机字符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy_binary</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"test2"</span>, <span class="string">"rb"</span>) <span class="keyword">as</span> orig_f, open(<span class="string">"test2_fuzz"</span>, <span class="string">"wb"</span>) <span class="keyword">as</span> new_f:   <span class="comment"># 二进制复制</span></span><br><span class="line">        new_f.write(flip_byte(orig_f.read()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(fn1, fn2)</span>:</span>                                          <span class="comment"># 检查fuzz文件能否运行</span></span><br><span class="line">    <span class="keyword">with</span> open(fn1) <span class="keyword">as</span> f1, open(fn2) <span class="keyword">as</span> f2:</span><br><span class="line">        <span class="keyword">return</span> f1.read()==f2.read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_output</span><span class="params">()</span>:</span>                                                           <span class="comment"># 检查文件是否存在</span></span><br><span class="line">    os.system(<span class="string">"(./test2_fuzz ; ./test2_fuzz AAAA-Z10N-42-OK) &gt; fuzz_output"</span>)</span><br><span class="line">    <span class="keyword">return</span> compare(<span class="string">"orig_output"</span>, <span class="string">"fuzz_output"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_gdb</span><span class="params">()</span>:</span></span><br><span class="line">    os.system(<span class="string">"echo disassemble main | gdb test2_fuzz &gt; fuzz_gdb"</span>)           <span class="comment"># 重定向到新文件</span></span><br><span class="line">    <span class="keyword">return</span> compare(<span class="string">"orig_gdb"</span>, <span class="string">"fuzz_gdb"</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">def check_radare():</span></span><br><span class="line"><span class="string">    os.system('echo -e "aaa\ns sym.main\npdf" | radare2 test2_fuzz &gt; fuzz_radare')</span></span><br><span class="line"><span class="string">    return compare("orig_radare", "fuzz_radare")</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    copy_binary()</span><br><span class="line">    <span class="keyword">if</span> check_output() <span class="keyword">and</span> <span class="keyword">not</span> check_gdb(): <span class="comment"># and not check_radare():</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"FOUND POSSIBLE FAIL\n\n\n"</span></span><br><span class="line">        os.system(<span class="string">"tail fuzz_gdb"</span>)</span><br><span class="line">        <span class="comment"># os.system("tail fuzz_radare")</span></span><br><span class="line">        raw_input()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出orig二进制文件</span><br><span class="line"></span><br><span class="line">     (./test2_fuzz  ; ./test2_fuzz  AAAA-Z10N-42-OK)  &gt;  orig_output</span><br><span class="line">     echo disassemble main | gdb test2_fuzz &gt; orig_gdb</span><br><span class="line"></span><br><span class="line">Fuzz</span><br><span class="line">     ./fuzz.py</span><br><span class="line"></span><br><span class="line">验证</span><br><span class="line">    gdb test2_fuzz</span><br><span class="line">    disassemble main</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/Linux程序破解与反破解/">https://kabeor.github.io/Linux程序破解与反破解/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux程序破解与反破解&quot;&gt;&lt;a href=&quot;#Linux程序破解与反破解&quot; class=&quot;headerlink&quot; title=&quot;Linux程序破解与反破解&quot;&gt;&lt;/a&gt;Linux程序破解与反破解&lt;/h1&gt;&lt;h2 id=&quot;1-许可证密钥位于二进制文件内&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Base-N算法及逆向初探</title>
    <link href="https://kabeor.github.io/Base-N%E7%AE%97%E6%B3%95%E5%8F%8A%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/"/>
    <id>https://kabeor.github.io/Base-N算法及逆向初探/</id>
    <published>2018-09-07T11:31:32.919Z</published>
    <updated>2018-09-07T13:19:37.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Base-N算法及逆向初探"><a href="#Base-N算法及逆向初探" class="headerlink" title="Base-N算法及逆向初探"></a>Base-N算法及逆向初探</h1><p>上次研究了<a href="https://kabeor.cn/CRC%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95%E5%8F%8A%E9%80%86%E5%90%91%E6%96%B9%E6%B3%95%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">CRC校验</a>，这次来看一下Base-N系列的算法吧</p><p>在CTF的算法逆向中Base系列算是最常见的了，各种组合和变体，下面就具体来说说吧。</p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><blockquote><p>Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2^6=64，所以每6个比特为一个单元，对应某个可打印字符。3个字节有24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。它可用来作为电子邮件的传输编码。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。一些如uuencode的其他编码方法，和之后BinHex的版本使用不同的64字符集来代表6个二进制数字，但是不被称为Base64。</p><p>Base64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据，包括MIME的电子邮件及XML的一些复杂数据。           —–维基百科 <a href="https://zh.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Base64</a></p></blockquote><h4 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则"></a>编码规则</h4><blockquote><p>第一步，将每三个字节作为一组，一共是24个二进制位<br>第二步，将这24个二进制位分为四组，每个组有6个二进制位<br>第三步，在每组前面加两个00，扩展成32个二进制位，即四个字节<br>第四步，根据下表，得到扩展后的每个字节的对应符号，这就是Base64的编码值</p></blockquote><p><img src="https://i.loli.net/2018/09/07/5b9264fbaee7c.jpg" alt=""></p><blockquote><p>如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：先使用0字节值在末尾补足，使其能够被3整除，然后再进行Base64的编码。在编码后的Base64文本后加上一个或两个=号，代表补足的字节数。也就是说，当最后剩余两个八位字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；如果最后剩余一个八位字节（1个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。 参考下表：</p></blockquote><p><img src="https://i.loli.net/2018/09/07/5b9265e357faa.jpg" alt=""></p><h4 id="C代码实现"><a href="#C代码实现" class="headerlink" title="C代码实现"></a>C代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;string.h&quot;   </span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line"></span><br><span class="line">const char base[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;; </span><br><span class="line">static char find_pos(char ch);</span><br><span class="line">char *base64_encode(const char* data, int data_len,int *len);</span><br><span class="line">char *base64_decode(const char* data, int data_len,int *len);   </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *找到ch在base中的位置 </span><br><span class="line"> */</span><br><span class="line">static char find_pos(char ch)    </span><br><span class="line">&#123;   </span><br><span class="line">    //the last position (the only) in base[] </span><br><span class="line">    char *ptr = (char*)strrchr(base, ch);  </span><br><span class="line">    return (ptr - base);   </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *BASE64编码 </span><br><span class="line"> */</span><br><span class="line">char *base64_encode(const char* data, int data_len,int *len)   </span><br><span class="line">&#123;      </span><br><span class="line">    int prepare = 0;   </span><br><span class="line">    int ret_len;   </span><br><span class="line">    *len=0;</span><br><span class="line">    int temp = 0;   </span><br><span class="line">    char *ret = NULL;   </span><br><span class="line">    char *f = NULL;   </span><br><span class="line">    int tmp = 0;   </span><br><span class="line">    char changed[4];   </span><br><span class="line">    int i = 0;   </span><br><span class="line">    ret_len = data_len / 3;   </span><br><span class="line">    temp = data_len % 3;   </span><br><span class="line">    if (temp &gt; 0)   </span><br><span class="line">    &#123;   </span><br><span class="line">        ret_len += 1;   </span><br><span class="line">    &#125;   </span><br><span class="line">    //最后一位以&apos;&apos;结束  </span><br><span class="line">    ret_len = ret_len*4 + 1;   </span><br><span class="line">    ret = (char *)malloc(ret_len);   </span><br><span class="line"></span><br><span class="line">    if ( ret == NULL)   </span><br><span class="line">    &#123;   </span><br><span class="line">        printf(&quot;No enough memory.n&quot;);   </span><br><span class="line">        exit(0);   </span><br><span class="line">    &#125;   </span><br><span class="line">    memset(ret, 0, ret_len);   </span><br><span class="line">    f = ret; </span><br><span class="line">    //tmp记录data中移动位置   </span><br><span class="line">    while (tmp &lt; data_len)   </span><br><span class="line">    &#123;   </span><br><span class="line">        temp = 0;   </span><br><span class="line">        prepare = 0;   </span><br><span class="line">        memset(changed, 0, 4);   </span><br><span class="line">        while (temp &lt; 3)   </span><br><span class="line">        &#123;      </span><br><span class="line">            if (tmp &gt;= data_len)   </span><br><span class="line">            &#123;   </span><br><span class="line">                break;   </span><br><span class="line">            &#125;  </span><br><span class="line">            //将data前8*3位移入prepare的低24位  </span><br><span class="line">            prepare = ((prepare &lt;&lt; 8) | (data[tmp] &amp; 0xFF));   </span><br><span class="line">            tmp++;   </span><br><span class="line">            temp++;   </span><br><span class="line">        &#125;   </span><br><span class="line">        //将有效数据移到以prepare的第24位起始位置 </span><br><span class="line">        prepare = (prepare&lt;&lt;((3-temp)*8));   </span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; 4 ;i++ )   </span><br><span class="line">        &#123;   </span><br><span class="line">            //最后一位或两位 </span><br><span class="line">            if (temp &lt; i)   </span><br><span class="line">            &#123;   </span><br><span class="line">                changed[i] = 0x40;   </span><br><span class="line">            &#125;   </span><br><span class="line">            else</span><br><span class="line">            &#123;   </span><br><span class="line">                //24位数据 </span><br><span class="line">                changed[i] = (prepare&gt;&gt;((3-i)*6)) &amp; 0x3F;   </span><br><span class="line">            &#125;   </span><br><span class="line">            *f = base[changed[i]];   </span><br><span class="line"></span><br><span class="line">            f++; </span><br><span class="line">            (*len)++;  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    *f = &apos;&apos;;   </span><br><span class="line"></span><br><span class="line">    return ret;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *BASE64解码 </span><br><span class="line"> */</span><br><span class="line">char *base64_decode(const char *data, int data_len,int *len)   </span><br><span class="line">&#123;   </span><br><span class="line">    int ret_len = (data_len / 4) * 3+1;   </span><br><span class="line">    int equal_count = 0;   </span><br><span class="line">    char *ret = NULL;   </span><br><span class="line">    char *f = NULL;   </span><br><span class="line">    *len=0;</span><br><span class="line">    int tmp = 0;   </span><br><span class="line">    int temp = 0;   </span><br><span class="line">    char need[3];   </span><br><span class="line">    int prepare = 0;   </span><br><span class="line">    int i = 0;   </span><br><span class="line">    if (*(data + data_len - 1) == &apos;=&apos;)   </span><br><span class="line">    &#123;   </span><br><span class="line">        equal_count += 1;   </span><br><span class="line">    &#125;   </span><br><span class="line">    if (*(data + data_len - 2) == &apos;=&apos;)   </span><br><span class="line">    &#123;   </span><br><span class="line">        equal_count += 1;   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    ret = (char *)malloc(ret_len);   </span><br><span class="line">    if (ret == NULL)   </span><br><span class="line">    &#123;   </span><br><span class="line">        printf(&quot;No enough memory.n&quot;);   </span><br><span class="line">        exit(0);   </span><br><span class="line">    &#125;   </span><br><span class="line">    memset(ret, 0, ret_len);   </span><br><span class="line">    f = ret;   </span><br><span class="line">    while (tmp &lt; (data_len - equal_count))   </span><br><span class="line">    &#123;   </span><br><span class="line">        temp = 0;   </span><br><span class="line">        prepare = 0;   </span><br><span class="line">        memset(need, 0, 4);   </span><br><span class="line">        while (temp &lt; 4)   </span><br><span class="line">        &#123;   </span><br><span class="line">            if (tmp &gt;= (data_len - equal_count))   </span><br><span class="line">            &#123;   </span><br><span class="line">                break;   </span><br><span class="line">            &#125;   </span><br><span class="line">            prepare = (prepare &lt;&lt; 6) | (find_pos(data[tmp]));   </span><br><span class="line">            temp++;   </span><br><span class="line">            tmp++;   </span><br><span class="line">        &#125;   </span><br><span class="line">        prepare = prepare &lt;&lt; ((4-temp) * 6);   </span><br><span class="line">        for (i=0; i&lt;3 ;i++ )   </span><br><span class="line">        &#123;   </span><br><span class="line">            if (i == temp)   </span><br><span class="line">            &#123;   </span><br><span class="line">                break;   </span><br><span class="line">            &#125;   </span><br><span class="line">            *f = (char)((prepare&gt;&gt;((2-i)*8)) &amp; 0xFF);   </span><br><span class="line">            f++;</span><br><span class="line">            (*len)++;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    *f = &apos;&apos;; </span><br><span class="line">    if(data[data_len-1]==&apos;=&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        (*len)--;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    while(*(--f)==&apos;&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">      (*len)--;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    */</span><br><span class="line">    return ret;   </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    char *former = &quot;hello&quot;;</span><br><span class="line">    int len1,len2;</span><br><span class="line">    printf(&quot;%sn&quot;,former);</span><br><span class="line">    char *after = base64_encode(former, 5,&amp;len1);</span><br><span class="line">    printf(&quot;%d %sn&quot;,len1,after);</span><br><span class="line">    former = base64_decode(after, len1,&amp;len2);</span><br><span class="line">    printf(&quot;%d %sn&quot;,len2,former);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆向识别后面一块说，先来看看Base32吧</p><h3 id="Base32"><a href="#Base32" class="headerlink" title="Base32"></a>Base32</h3><h4 id="编码规则-1"><a href="#编码规则-1" class="headerlink" title="编码规则"></a>编码规则</h4><p> Base32这种数据编码机制，主要用来把二进制数据编码成可见的字符串，其编码规则是：任意给定一个二进制数据，以5个位(bit)为一组进行切分(base64以6个位(bit)为一组)，对切分而成的每个组进行编码得到1个可见字符。Base32编码表字符集中的字符总数为25=32个，这也是Base32名字的由来。</p><p> 下面是Base32的table</p><p> <img src="https://i.loli.net/2018/09/07/5b926bef87d6a.jpg" alt=""></p><h4 id="C代码实现-1"><a href="#C代码实现-1" class="headerlink" title="C代码实现"></a>C代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//base32 表包含 0~9 以及小写字母 (去除&apos;a&apos;,&apos;i&apos;,&apos;l&apos;,&apos;o&apos;)，</span><br><span class="line">//共 32 个字符</span><br><span class="line">static const char base32_alphabet[32] = &#123;</span><br><span class="line">        &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;,</span><br><span class="line">        &apos;8&apos;, &apos;9&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;,</span><br><span class="line">        &apos;h&apos;, &apos;j&apos;, &apos;k&apos;, &apos;m&apos;, &apos;n&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;,</span><br><span class="line">        &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 匹配 base32_alphabet</span><br><span class="line"> */</span><br><span class="line">int find_number(char m) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0; i &lt; 32; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(m == base32_alphabet[i])</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * base32 编码</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">char* base32_encode(char *bin_source)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int j = 0;</span><br><span class="line">    static char str[10];</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;strlen(bin_source);++i)&#123;</span><br><span class="line">        if((i+1)%5==0)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            int num = (bin_source[i]-&apos;0&apos;)+(bin_source[i-1]-&apos;0&apos;)*2\</span><br><span class="line">            +(bin_source[i-2]-&apos;0&apos;)*2*2+(bin_source[i-3]-&apos;0&apos;)*2*2*2\</span><br><span class="line">            +(bin_source[i-4]-&apos;0&apos;)*2*2*2*2;</span><br><span class="line"></span><br><span class="line">            str[j-1] = base32_alphabet[num];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * base32 解码</span><br><span class="line"> */</span><br><span class="line">int* base32_decode(char *str_source)&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    static int dec[50];</span><br><span class="line">    int count=0;</span><br><span class="line">    for(i=0;i&lt;strlen(str_source);++i)&#123;</span><br><span class="line">        for(j=5-1;j&gt;=0;--j)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            //位运算十进制转二进制</span><br><span class="line">            dec[count-1] = find_number(str_source[i])&gt;&gt;(j%5)&amp;1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>前面写了这么多，终于到重头戏逆向了，先简略概括一下基本运算法则吧</p><blockquote><p>base64编码是用64（2的6次方）个ASCII字符来表示256（2的8次方）个ASCII字符，也就是三位二进制数组经过编码后变为四位的ASCII字符显示，长度比原来增加1/3。</p><p>同样，base32就是用32（2的5次方）个特定ASCII码来表示256个ASCII码。所以，5个ASCII字符经过base32编码后会变为8个字符（公约数为40），长度增加3/5.不足8n用“=”补足。</p><p>base16就是用16（2的4次方）个特定ASCII码表示256个ASCII字符。1个ASCII字符经过base16编码后会变为2个字符，长度增加一倍。不足2n用“=”补足</p></blockquote><p>Base32在比赛中常见到，就拿Base32的题来举例了</p><p>两道题的完整wp都在博客里 ,(<a href="https://kabeor.cn/2017%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8A%E8%B5%9BNonstandard/" target="_blank" rel="noopener">https://kabeor.cn/2017%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8A%E8%B5%9BNonstandard/</a>          ,<br><a href="https://kabeor.cn/2018%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%20RE(1)%20Simple%20Base-N/" target="_blank" rel="noopener">https://kabeor.cn/2018%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%20RE(1)%20Simple%20Base-N/</a>)</p><p>提取重点部分来说</p><h3 id="1-数据"><a href="#1-数据" class="headerlink" title="1. 数据"></a>1. 数据</h3><p>Base系列的补位“=”算是最明显的提示标志了，搜索字符串时见到类似下图就可以考虑Base了</p><p><img src="https://i.loli.net/2018/07/15/5b4b3ffbc388a.jpg" alt=""></p><h3 id="2-反汇编伪代码"><a href="#2-反汇编伪代码" class="headerlink" title="2. 反汇编伪代码"></a>2. 反汇编伪代码</h3><p>IDA F5，看到大量移位，如图</p><p><img src="https://i.loli.net/2018/07/15/5b4b3ffbea9c0.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        v14 = v13;</span><br><span class="line">        HIDWORD(v15) = v19;</span><br><span class="line">        LODWORD(v15) = v23 &amp; 0xFFFFFFF8;</span><br><span class="line">        HIDWORD(v16) = v30 | ((unsigned __int64)(v18 &amp; 1) &gt;&gt; 24);</span><br><span class="line">        LODWORD(v16) = (((v23 &amp; 0xFFFFFFF8) &lt;&lt; 8) + (v18 &amp; 0xFFFFFFC0 | ((v23 &amp; 7) &lt;&lt; 8)) + (v18 &amp; 0x3E)) &lt;&lt; 8;</span><br><span class="line">        v17 = ((v14 &amp; 0x1F)</span><br><span class="line">             + __PAIR__(</span><br><span class="line">                 HIDWORD(v14) | (unsigned int)((unsigned __int64)(v20 &amp; 3) &gt;&gt; 24),</span><br><span class="line">                 v14 &amp; 0xFFFFFFE0 | ((v20 &amp; 3) &lt;&lt; 8))</span><br><span class="line">             + ((__PAIR__(</span><br><span class="line">                   v31 | (unsigned int)((unsigned __int64)(v21 &amp; 0xF) &gt;&gt; 24),</span><br><span class="line">                   v20 &amp; 0xFFFFFF80 | ((v21 &amp; 0xF) &lt;&lt; 8))</span><br><span class="line">               + ((__PAIR__(</span><br><span class="line">                     (__PAIR__(v15 &gt;&gt; 24, (v23 &amp; 0xFFFFFFF8) &lt;&lt; 8)</span><br><span class="line">                    + __PAIR__(</span><br><span class="line">                        v29 | (unsigned int)((unsigned __int64)(v23 &amp; 7) &gt;&gt; 24),</span><br><span class="line">                        v18 &amp; 0xFFFFFFC0 | ((v23 &amp; 7) &lt;&lt; 8))</span><br><span class="line">                    + (v18 &amp; 0x3E)) &gt;&gt; 24,</span><br><span class="line">                     v21 &amp; 0xFFFFFFF0 | ((v18 &amp; 1) &lt;&lt; 8))</span><br><span class="line">                 + v16) &lt;&lt; 8)</span><br><span class="line">               + (v20 &amp; 0x7C)) &lt;&lt; 8)) &gt;&gt; 32;</span><br><span class="line">        HIDWORD(v14) = (v14 &amp; 0x1F)</span><br><span class="line">                     + (v14 &amp; 0xFFFFFFE0 | ((v20 &amp; 3) &lt;&lt; 8))</span><br><span class="line">                     + (((v20 &amp; 0xFFFFFF80 | ((v21 &amp; 0xF) &lt;&lt; 8))</span><br><span class="line">                       + (((v21 &amp; 0xFFFFFFF0 | ((v18 &amp; 1) &lt;&lt; 8)) + (_DWORD)v16) &lt;&lt; 8)</span><br><span class="line">                       + (v20 &amp; 0x7C)) &lt;&lt; 8);</span><br><span class="line">        *v24 = byte_403020[(unsigned __int8)v17 &gt;&gt; 3];</span><br><span class="line">        v24[1] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 30) &amp; 0x1F];</span><br><span class="line">        v24[2] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 25) &amp; 0x1F];</span><br><span class="line">        v24[3] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 20) &amp; 0x1F];</span><br><span class="line">        v24[4] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 15) &amp; 0x1F];</span><br><span class="line">        v24[5] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 10) &amp; 0x1F];</span><br><span class="line">        LOBYTE(v16) = __PAIR__(v17, HIDWORD(v14)) &gt;&gt; 5;</span><br><span class="line">        v3 = v25;</span><br><span class="line">        v24[6] = byte_403020[v16 &amp; 0x1F];</span><br><span class="line">        LOBYTE(v16) = byte_403020[BYTE4(v14) &amp; 0x1F];</span><br><span class="line">        v2 = v32;</span><br><span class="line">        v24[7] = v16;</span><br><span class="line">        v24 += 8;</span><br><span class="line">      &#125;</span><br><span class="line">      while ( v8 &lt; v25 );</span><br><span class="line">      result = v28;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v22 &gt; 0 )</span><br><span class="line">      memset(&amp;result[v26], 61u, v22);</span><br><span class="line">    *(&amp;v28[v26] + v22) = 0;</span><br><span class="line">    result = v28;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心算法提取出来了，我们看到了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LODWORD(v16) = (((v23 &amp; 0xFFFFFFF8) &lt;&lt; 8) + (v18 &amp; 0xFFFFFFC0 | ((v23 &amp; 7) &lt;&lt; 8)) + (v18 &amp; 0x3E)) &lt;&lt; 8;</span><br></pre></td></tr></table></figure></p><p>和<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v24[1] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 30) &amp; 0x1F];</span><br><span class="line">v24[2] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 25) &amp; 0x1F];</span><br><span class="line">v24[3] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 20) &amp; 0x1F];</span><br><span class="line">v24[4] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 15) &amp; 0x1F];</span><br><span class="line">v24[5] = byte_403020[(__PAIR__(v17, HIDWORD(v14)) &gt;&gt; 10) &amp; 0x1F];</span><br></pre></td></tr></table></figure></p><p>每次取5个比特，分别赋给8个值，每个值5个位 ,显然的base32</p><h3 id="3-table"><a href="#3-table" class="headerlink" title="3. table"></a>3. table</h3><p>table一般在核心算法的上一层函数，数据段也有所显现，当然table也许会被加密或者替换，但都是类似异或，转换进制，运算，奇偶位之类的，照着写脚本就好，</p><p>像下图这样就是经过了字母倒序，奇数小写偶数大写，尾部追加得到table</p><p><img src="https://i.loli.net/2018/07/15/5b4b3ffc33cd8.jpg" alt=""></p><h2 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h2><p>Python3脚本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = &quot;密文&quot;</span><br><span class="line">table = &quot;表&quot;</span><br><span class="line"></span><br><span class="line">def find(x):</span><br><span class="line">    if(x==&apos;=&apos;):</span><br><span class="line">        return 0</span><br><span class="line">    return table.index(x)</span><br><span class="line"></span><br><span class="line">for i in range(len(s)//8):</span><br><span class="line">    p = s[i*8:i*8+8]</span><br><span class="line">    t = 0</span><br><span class="line">    for j in p:</span><br><span class="line">        t = t&lt;&lt;5</span><br><span class="line">        t += find(j)</span><br><span class="line">    for j in range(5):</span><br><span class="line">        print(chr((t&amp;0xff00000000)&gt;&gt;32), end=&apos;&apos;)</span><br><span class="line">        t = t&lt;&lt;8</span><br></pre></td></tr></table></figure></p><h2 id="魔改Base"><a href="#魔改Base" class="headerlink" title="魔改Base"></a><strong>魔改Base</strong></h2><p>经过上面的分析也就可以知道Base中可变的几个部分</p><p>CTF中常见的变化位置有下面几个</p><blockquote><ol><li>table</li></ol></blockquote><p>这个上面提到了。。</p><blockquote><ol><li>移位数据变化</li></ol></blockquote><p>从例子可以看出决定了题中Base-N的N是多少的是移位个数和移位距离<br>只要抓住算法的核心思想就能很快识别出来</p><blockquote><ol><li>组合</li></ol></blockquote><p>很多题都会通过组合加密的方式来提升题目难度，Base中应该就是加密密文和table了</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>差不多就是这样了，Base-N相对来说只要熟悉模板就能很快识别了。</p><p>希望自己能坚持下去，分析不同的算法：）</p><p>From <a href="https://kabeor.github.io/Base-N算法及逆向初探/">https://kabeor.github.io/Base-N算法及逆向初探/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Base-N算法及逆向初探&quot;&gt;&lt;a href=&quot;#Base-N算法及逆向初探&quot; class=&quot;headerlink&quot; title=&quot;Base-N算法及逆向初探&quot;&gt;&lt;/a&gt;Base-N算法及逆向初探&lt;/h1&gt;&lt;p&gt;上次研究了&lt;a href=&quot;https://kabe
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>第八届swpu网络安全大赛逆向r2 r3</title>
    <link href="https://kabeor.github.io/%E7%AC%AC%E5%85%AB%E5%B1%8Aswpu%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E9%80%86%E5%90%91r2%20r3/"/>
    <id>https://kabeor.github.io/第八届swpu网络安全大赛逆向r2 r3/</id>
    <published>2018-09-04T02:31:49.195Z</published>
    <updated>2018-09-04T03:07:48.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八届swpu网络安全大赛逆向r2-r3"><a href="#第八届swpu网络安全大赛逆向r2-r3" class="headerlink" title="第八届swpu网络安全大赛逆向r2 r3"></a>第八届swpu网络安全大赛逆向r2 r3</h1><p>也是以前的题了</p><h2 id="R2：bin100"><a href="#R2：bin100" class="headerlink" title="R2：bin100"></a>R2：bin100</h2><p>打开程序<br><img src="https://i.loli.net/2018/09/04/5b8deefecd76d.jpg" alt=""></p><p>。。。。。什么也没有<br>尝试输入，输到16位后提醒重试<br>用OD打开</p><p>界面像是输序列号，正好在看雪论坛看到以下内容</p><p><img src="https://i.loli.net/2018/09/04/5b8def1d19c71.jpg" alt=""></p><p>于是查找windowtextA</p><p><img src="https://i.loli.net/2018/09/04/5b8def2d25c46.jpg" alt=""><br><img src="https://i.loli.net/2018/09/04/5b8def34d0fae.jpg" alt=""></p><p>一直F8，看到cmp，应该是判断输入是否满足16位<br>打开IDA ，F5看伪代码</p><p><img src="https://i.loli.net/2018/09/04/5b8def45a9635.jpg" alt=""></p><p>然后接下来应记下关键跳转的地址，在IDA中分析，<br>输入的数字经过一系列计算，最后与一个字符串对比<br>得出flag</p><h2 id="R3：bin200"><a href="#R3：bin200" class="headerlink" title="R3：bin200"></a>R3：bin200</h2><p>先查壳</p><p><img src="https://i.loli.net/2018/09/04/5b8defbc9e8a2.jpg" alt=""></p><p>VC++写的<br>先用IDA调试：<br>查找字符串，发现一串数字08067<br>跟随后F5</p><p><img src="https://i.loli.net/2018/09/04/5b8defccf0ede.jpg" alt=""></p><p>可以看到result=8，应该是要对比已通关数和总关数8<br>然后跟着往下发现对比的if语句，找到相等时的跳转的地址，在OD上找到这个地址，就可以找出flag</p><p>From <a href="https://kabeor.github.io/第八届swpu网络安全大赛逆向r2 r3/">https://kabeor.github.io/第八届swpu网络安全大赛逆向r2 r3/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第八届swpu网络安全大赛逆向r2-r3&quot;&gt;&lt;a href=&quot;#第八届swpu网络安全大赛逆向r2-r3&quot; class=&quot;headerlink&quot; title=&quot;第八届swpu网络安全大赛逆向r2 r3&quot;&gt;&lt;/a&gt;第八届swpu网络安全大赛逆向r2 r3&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>ebCTF2013 RE</title>
    <link href="https://kabeor.github.io/ebCTF2013%20RE/"/>
    <id>https://kabeor.github.io/ebCTF2013 RE/</id>
    <published>2018-09-04T02:22:39.277Z</published>
    <updated>2018-09-04T03:07:48.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ebCTF2013-RE"><a href="#ebCTF2013-RE" class="headerlink" title="ebCTF2013 RE"></a>ebCTF2013 RE</h2><p>今天在看以前的笔记时看到了这篇，觉得有意思，就放上来了</p><p>放入IDA中分析，先看下流程：</p><p><img src="https://i.loli.net/2018/09/04/5b8decf7c9753.jpg" alt=""></p><p>找到主函数，空格<br>可以看到具体的一些步骤和相互之间的关系</p><p><img src="https://i.loli.net/2018/09/04/5b8ded2313e2b.jpg" alt=""><br><img src="https://i.loli.net/2018/09/04/5b8ded2c4d7b8.jpg" alt=""></p><p>大体就是这样<br>点击view-&gt;open subviews-&gt;strings  可以看到分析出的字符串</p><p><img src="https://i.loli.net/2018/09/04/5b8ded509b665.jpg" alt=""></p><p>这就是程序运行时的流程，可以看出，我们需要投掷3-1-3-3-7，这几乎是不可能的，所以我们需要改动跳转的判断条件。</p><p>F5键可以打开插件HexRays 查看伪代码</p><p><img src="https://i.loli.net/2018/09/04/5b8ded60a561a.jpg" alt=""></p><p>可以看出这里的判断条件<br>于是结合流程图我们可以看出，应该修改的是每一部分最后一个跳转，此语句本来是jnz跳转，我们只需把它修改成jz即可</p><p>通过edit-&gt;patch program-&gt;change byte 修改机器码，把原来开头的75改为74即可</p><p>最后运行一下发现每次成功后flag都会一闪而过</p><p>于是我们应该把最后的跳转到retn的jmp给nop掉<br>大功告成</p><p><img src="https://i.loli.net/2018/09/04/5b8dede193bfb.jpg" alt=""></p><p>From <a href="https://kabeor.github.io/ebCTF2013 RE/">https://kabeor.github.io/ebCTF2013 RE/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ebCTF2013-RE&quot;&gt;&lt;a href=&quot;#ebCTF2013-RE&quot; class=&quot;headerlink&quot; title=&quot;ebCTF2013 RE&quot;&gt;&lt;/a&gt;ebCTF2013 RE&lt;/h2&gt;&lt;p&gt;今天在看以前的笔记时看到了这篇，觉得有意思，就放上来了&lt;/p
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>第13章  数据加密</title>
    <link href="https://kabeor.github.io/%E7%AC%AC13%E7%AB%A0%20%20%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"/>
    <id>https://kabeor.github.io/第13章  数据加密/</id>
    <published>2018-08-31T07:33:12.166Z</published>
    <updated>2018-09-02T12:37:09.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第13章-数据加密"><a href="#第13章-数据加密" class="headerlink" title="第13章  数据加密"></a>第13章  数据加密</h1><h2 id="13x1-分析加密算法的目的"><a href="#13x1-分析加密算法的目的" class="headerlink" title="13x1 分析加密算法的目的"></a>13x1 分析加密算法的目的</h2><p>恶意代码用加密来达到各种各样的目的。最常见的是加密网络通信，同时，恶意代码也会用加密来隐藏它的内部工作。例如，恶意代码编写者可能因为如下目的而使用加密：</p><blockquote><p>·隐藏配置信息。例如，命令和控制服务器域名。<br>·窃取信息之前将它保存到一个临时文件。<br>·存储需要使用的字符串，并在使用前对其解密。<br>·将恶意代码伪装成一个合法的工具，隐藏恶意代码活动中使用的字符串。</p></blockquote><p>分析加密算法时，我们的目标由两部分组成:识别加密算法，然后根据识别的加密算法解密攻击者的秘密。</p><h2 id="13x2-简单的加密算法"><a href="#13x2-简单的加密算法" class="headerlink" title="13x2 简单的加密算法"></a>13x2 简单的加密算法</h2><h3 id="1-凯撒密码"><a href="#1-凯撒密码" class="headerlink" title="1. 凯撒密码"></a>1. 凯撒密码</h3><h3 id="2-XOR"><a href="#2-XOR" class="headerlink" title="2. XOR"></a>2. XOR</h3><p>XOR加密使用一个静态字节值，通过与该值执行逻辑异或运算来修改明文中的每个字节。</p><blockquote><p>暴力破解XOR加密</p></blockquote><p>由于文件中的每个字符只有256种可能的值，对于一个计算机来说很容易并且能够足够快地使用255个单字节密钥来异或文件头部，然后将输出与期望的可执行文件头部进行比较。可以使用一个脚本来执行用255个密钥的XOR加密。</p><blockquote><p>保留NULL的单字节XOR加密</p></blockquote><p>单字节加密的一个漏洞：它对使用十六进制编辑器手动扫描加密内容的用户缺乏有效的隐蔽性。如果加密内容中有大量的NULL字节，那么单字节密钥变得十分明显。</p><p>与标准的XOR加密策略不同，保留NULL的单字节XOR加密策略有两个例外。</p><ol><li>如果明文中字符是NULL或者密钥本身，则被跳过。</li><li>如果明文中字符既不是NULL也不是密码本身，则将被使用XOR密钥加密。</li></ol><p><img src="https://i.loli.net/2018/08/31/5b88f4d7dc022.jpg" alt=""></p><h4 id="用IDA-Pro识别XOR循环"><a href="#用IDA-Pro识别XOR循环" class="headerlink" title="用IDA Pro识别XOR循环"></a>用IDA Pro识别XOR循环</h4><p>在反汇编中，通过循环语句中间使用XOR指令的小循环语句找到了XOR循环。用IDA Pro找到XOR循环的一个最简单方法是搜索指令中XOR指令，如下：<br>1.确保你正在查看代码（窗口的标题应该包含“IDAView”）。<br>2.选择Search→Text。<br>3.在文本搜索对话框中输入xor，选中Find all occurrences复选框，然后单击OK按钮。</p><p>搜索到XOR指令并不意味着它一定用于加密。XOR指令可以用于不同的目的，其用途之一就是清空寄存器的内容。XOR指令以三种形式存在。</p><ol><li>用寄存器自身XOR。</li><li>用一个常量（或一个内存引用）XOR。</li><li>使用一个不同寄存器（或一个内存引用）XOR。</li></ol><p>最常见的是第一种形式，因为寄存器与自身异或是清零寄存器的一种有效方式。幸运的是，清零寄存器与数据加密无关，所以可以忽略它。</p><p>XOR加密循环可能使用另外两种形式中的一种：用一个常量异或一个寄存器，或者用一个不同的寄存器异或一个寄存器。如果你幸运，XOR加密是一个常量异或寄存器的XOR，因为通过它，可以确认你可能发现了加密，并且也可以知道密钥。</p><p>加密的迹象之一就是含有一个包含XOR函数的嵌套循环。</p><h3 id="3-其他一些简单的加密策略"><a href="#3-其他一些简单的加密策略" class="headerlink" title="3. 其他一些简单的加密策略"></a>3. 其他一些简单的加密策略</h3><p><img src="https://i.loli.net/2018/08/31/5b88f66b1a17f.jpg" alt=""></p><h3 id="4-Base64"><a href="#4-Base64" class="headerlink" title="4. Base64"></a>4. Base64</h3><p>术语Base64来自于多用途Internet邮件扩展（MIME）标准。虽然Base64最初用于加密传输的邮件附件，但是现在它却广泛用于HTTP和XML。</p><p>Base64编码将二进制数据转换成64个字符的有限字符集。对于不同类型的Base64加密，有多种不同的策略或字母表。但是它们都使用64个主要的字符，另外，它们通常用一个额外字符表示填充，通常是“=”。</p><p>最常用的字符集是MIME Base64，它使用A~Z、a~z和0~9作为前62个值，+和/作为最后两个值。由于需要将数据压缩成一个较小字符集，给Base64加密后的数据会比原始的数据长。对于3个字节的二进制文件，加密后是至少4个字节的Base64加密数据。</p><blockquote><p>数据转化成Base64</p></blockquote><p>原始数据转换成Base64的过程相当标准。它使用24位（3个字节）的块。第一个字符被放到最重要的位置，第二个字符放在中间的8位，第三个字符放在最不重要的后8位。接下来，从最重要位置的开始，位被读入到6个块中。</p><p><img src="https://i.loli.net/2018/08/31/5b88f7ca698a5.jpg" alt=""></p><p>上图展示转换发生的过程，最上面一行是原始的字符串（ATT）。第二行是ATT的半字节表示（半字节等于4位）。中间一行用来表示ATT的实际位。第四行以6位段十进制表示位值。最后，最终的字符串通过十进制索引参考字符串得出字符。</p><p>由上图可见，字母A相应的比特位是01000001。A字母的前6位被转换成Base64加密的单字符Q。字母A的最后两位（01）和字母T前四位（0101）被转化成Base64加密的第二个字符V（010101）。</p><p>将Base64解密成原始的数据遵循相同的过程，但是过程是相反的。首先将每个Base64字符转换成6个比特位，将所有比特位按顺序存放。然后，以八位一组读取比特位，每组8个比特位表示原始数据的字节。</p><blockquote><p>识别和解密Base64</p></blockquote><p>在技术上，填充字符是可选的，并且它们对解密的准确性不是必须的。恶意代码知道避免使用这种填充字符，想必是为了使它们看起来不像Base64编码并避免网络特征。</p><p>因为Base64加密的实现通常使用索引字符串，含有Base64加密的代码经常会存在这个64字符组成的加密字符串。通常情况下，索引Base64的字符串由可打印字符组成（或者它会破坏该算法的意图），因此可以很容易用眼睛察觉字符串输出。</p><p>第二个可以被用来确认使用Base64加密算法的证据是存在一个单独填充字符（常为“=”），这个单独的填充字符常被硬编码到执行加密的函数中。</p><h2 id="13x3-常见的加密算法"><a href="#13x3-常见的加密算法" class="headerlink" title="13x3 常见的加密算法"></a>13x3 常见的加密算法</h2><p>简单的加密算法与现代的加密算法不同，它们等同于替换算法。现代的加密算法考虑了增加指数级的计算能力，并且确保设计的算法需要大量的计算能力，从而使破解它们不切实际。</p><p>先前我们讨论的简单加密策略并不试图对暴力破解方法加以保护，它们的主要目的是隐藏。随着时间的推移，加密算法逐渐改进和发展，并且它们已经深入到计算机应用的各个方面，例如网页浏览器中的SSL，无线接入点使用的加密等等。那么，为什么恶意代码不使用这种加密算法来隐藏敏感信息呢？恶意代码使用简单的加密策略是因为它们容易且足够使用。此外，使用标准的加密存在一些潜在的漏洞，特别是对于恶意代码来说：</p><ol><li>加密库很大，所以恶意代码需要静态的集成或者链接到已有的代码中。</li><li>链接主机上现有的代码可能降低可移植性。</li><li>标准加密库比较容易探测（通过函数导入，函数匹配或者加密常量标识）。</li><li>对称加密算法需要考虑如何隐藏密钥。</li></ol><p>很多标准加密算法都依赖于一个强大的密钥来存储它们的秘密。算法本身是公开的，但是如果没有密钥，几乎不可能（也就说它需要大量工作）破解加密的密文。要确保解密费时费力，通常情况下，密钥必须足够长从而使得测试所有可能的密钥不那么容易。对于恶意代码可能使用的标准加密算法，关键是不仅要识别加密算法，而且还要识别密钥。</p><p>有一些简单方法可以识别标准加密。它们包括查找字符串和引用加密函数的导入，使用一些工具寻找特定的内容。</p><h3 id="1-识别字符串和导入"><a href="#1-识别字符串和导入" class="headerlink" title="1. 识别字符串和导入"></a>1. 识别字符串和导入</h3><p>一种识别标准加密算法的方法是识别涉及加密算法使用的字符串。当加密库（如OpenSSL）被静态地编译到恶意代码时，这种情况便会发生。</p><p>另外一种查找标准加密算法的方法是识别引用导入的加密函数。</p><h3 id="2-查找加密常量"><a href="#2-查找加密常量" class="headerlink" title="2. 查找加密常量"></a>2. 查找加密常量</h3><p>第三种检测加密的基本方法是使用可以搜索常见加密常量的工具，这里，我们使用IDA Pro的FindCrypt2和Krypto ANALyzer插件。</p><blockquote><p>使用FindCrypt2</p></blockquote><p>IDAPro有一个叫做FindCrypt2插件，包含在IDAPro的SDK中，它搜索程序中任何与加密算法相关的已知常量。这样做效果很好，因为多数加密算法会使用一些神秘的常量类型。所谓神秘常量则是与基本加密算法结构相关的一些固定位串。</p><p><strong><em>注意：一些加密算法并不使用神秘常量，值得注意的是，国际数据加密（IDEA）算法和RC4算法动态地创建它们的结构，因此它们不在可识别的算法之中。恶意代码常使用RC4算法，因为它体积小，在软件中易于实现，并且没有明显的加密常量。</em></strong></p><p>与IDAPRO的插件FindCrypt2原理相同的一个工具是Krypto ANALyzer（KANAL）。KANAL是PEiD的一个插件，它拥有一个范围更广的常量集合（作为结果可能更加容易产生误报）。除此之外，KANAL还能够识别Base64编码表以及加密相关的导入函数。</p><h3 id="3-查找高熵值内容"><a href="#3-查找高熵值内容" class="headerlink" title="3. 查找高熵值内容"></a>3. 查找高熵值内容</h3><p>识别加密算法的另一方法是查找高熵值的内容。除了识别潜在的明显的加密常量或者加密密钥外，这种技术也可以识别加密内容本身。由于这种技术的影响广泛，可以适用于没有找到加密常量的地方（如RC4）。</p><p><strong><em>警告：高嫡内容技术相当迟钝，最好作为最后一种使用手段。多种类型的内容，如图片、电影、音频文件以及其他压缩数据等，也会显示高篇值，除了它们的头部特征之外，很难与加密内容进行区分。</em></strong></p><p>IDA的熵值插件(<a href="http://www.smokedchicken.org/2010/06/idaentropy-plugin.html" target="_blank" rel="noopener">http://www.smokedchicken.org/2010/06/idaentropy-plugin.html</a> )是针对PE文件使用这种技术的一个工具。将ida-entplw文件放置到IDAPro的插件目录，就可以将这个插件载入到IDA Pro。</p><p>包含64个不同字节值的64字节字符串拥有最高可能的熵值，这64个值与熵值6相关（指6比特位的熵），因为6比特位表示的数字是64。</p><p>另外一种可能有用的设置是大小为256的块，其熵值大于7.9。这也意味一个256个连续字节的字符串几乎反应出所有256个可能的字节值。</p><p>IDAPro的熵值插件还有一个提供图形化概览感兴趣区域的工具，可以用它来引导你选择最大熵评分值，同时也帮助你确定关注范围。绘图按钮产生一个图，它将高熵值区域显示为亮条，将低熵值区域显示为暗条。在图上移动鼠标光标，可以看到图中某些点的原始熵值。因为熵的地图在打印格式下很难准确表达。</p><h2 id="13x4-自定义加密"><a href="#13x4-自定义加密" class="headerlink" title="13x4 自定义加密"></a>13x4 自定义加密</h2><p>恶意代码常使用自创的加密方案，一种方案是将多个简单加密方法组装到一起。例如，恶意代码可以先执行一次XOR加密，然后在XOR加密基础上执行Base64加密。另外一种方案就是开发一种与标准加密算法相似的自定义加密算法。</p><h3 id="1-识别自定义加密"><a href="#1-识别自定义加密" class="headerlink" title="1. 识别自定义加密"></a>1. 识别自定义加密</h3><p>发现加密算法的艰难历程是从可疑的输入或者输出开始跟踪运行的线程。输入和输出是一个通用分类，无论恶意代码是发送网络数据包，写入文件或者写入标准输出，这都是输出。如果怀疑输出中包含加密数据，那么加密函数应该出现在输出之前。</p><p>相反，解密则出现在输入之后。例如，假设你确认了一个输入函数，则你首先应该识别出跟输入有关的数据元素，然后向后跟踪执行路径，找到访问相关数据元素的新函数。如果你到达一个函数的末尾，你应该在调用函数发生的地方继续，并且再次注意数据的位置。多数情况下，加密函数离输入函数不远。除了反向跟踪执行路径外，输出函数也是类似的。</p><h3 id="2-攻击者使用自定义加密的优势"><a href="#2-攻击者使用自定义加密的优势" class="headerlink" title="2. 攻击者使用自定义加密的优势"></a>2. 攻击者使用自定义加密的优势</h3><p>对于攻击者，自定义加密方法拥有它自身的优势，主要是因为它们保留了简单加密策略的特点（体积小和加密不明显），同时使逆向工作变得十分困难。逆向这种类型的加密（也就是识别加密过程并且开发解密器）比标准加密方法是否更加困难存在一些争议。</p><p>对于多种标准加密来说，如果识别了加密算法并且发现了密钥，则很容易使用标准的函数库来编写解密器。对于自定义加密，攻击者可以根据自己的需要创建任意的加密方案，它们可能使用也可能不使用一个明显的密钥。正如前面的例子中介绍的，密钥嵌入到代码中，甚至攻击者使用了一个密钥并且被我们发现，但是，不可能存在一个免费的函数库供我们实现解密。</p><h2 id="13x5-解密"><a href="#13x5-解密" class="headerlink" title="13x5 解密"></a>13x5 解密</h2><p>重现恶意代码中的加密或解密函数的两种基本方法</p><ol><li>重新编写函数</li><li>使用恶意代码中存在的函数</li></ol><h3 id="1-自解密"><a href="#1-自解密" class="headerlink" title="1. 自解密"></a>1. 自解密</h3><p>最经济的解密方法是:无论算法是否已知,让程序正常活动期间自己完成解密。我们称这种方法为自解密。如果你在调试器中暂停了恶意程序,并且注意到内存中的一个字符串,在你运行字符函数时你没有看到它,那么你已经使用自解密技术。无论先前被隐藏的信息在何处被解密,中断解密过程并做进一步分析,比尝试着确定使用了何种加密机制和尝试构造解密器更加容易虽然自解密是一种廉价且有效的解密方式,但是它也有缺点。首先,为了确认执行的每一个解密实例,你都必须要分离解密函数,并且在解密例程之后直接设置断点。更重要的是,如果恶意代码没有解密你感兴趣的信息(或你不知道如何欺骗恶意代码让其这么做),那你就会很倒霉。由于这些原因,使用这种技术的关键是提供更多控制。</p><h3 id="2-手动执行解密函数"><a href="#2-手动执行解密函数" class="headerlink" title="2. 手动执行解密函数"></a>2. 手动执行解密函数</h3><p>对于简单的加密和编码方法，通常你可以使用编程语言提供的标准函数。</p><p>对于缺少标准解密函数的简单加密方法，如XOR加密或使用修改字母表的的Base64加密，最简单的方法是使用你选择语言中的程序或脚本的加密函数。</p><p><strong>Base64脚本</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import string</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">example_string=&apos; VChpcyBpcyBhIHR1c3Qgc3RyawSn&apos;</span><br><span class="line">print base64. decodestring(example_string)</span><br></pre></td></tr></table></figure></p><p><strong>保留NULL字节的XOR加密算法的Python脚本</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def null_preserving_xor(input_char,key_char):</span><br><span class="line">    if(input_char s= key_char or input_char == chr(0x00)): </span><br><span class="line">        return input_char </span><br><span class="line">else: </span><br><span class="line">        return chr(ord(input_char)^ord(key_char))</span><br></pre></td></tr></table></figure></p><p>这个函数需要两个字符：一个输入字符，一个密钥字符，并且输出一个转换后的字符。为了使用保留NULL的单字节XOR加密算法来转换一个字符串或者一个更长的内容，将它们的每一个输入字符和一个相同密钥一起传给这个子例程（函数）。</p><p><strong>自定义Base64编码的脚本</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import string</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">s = &quot;&quot;</span><br><span class="line">custom=&quot;9ZABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxyz012345678+/&quot;</span><br><span class="line">Base64=&quot;ABCDEFCHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><br><span class="line"></span><br><span class="line">ciphertext=&apos;TEgobxZobxZgCFPkb20&apos;</span><br><span class="line"></span><br><span class="line">for ch in ciphertext: </span><br><span class="line">    if(ch in Base64): </span><br><span class="line">    s = s + Base64[string.find(custom, str(ch))]</span><br><span class="line">    elif(ch == &apos;=&apos;):</span><br><span class="line">        s += &apos;=&apos;</span><br><span class="line">result = base64.decodestring(s)</span><br></pre></td></tr></table></figure></p><p>对于标准的加密算法，最好是使用代码库中提供的现有实现。一个基于Python的加密库叫做PyCrypto（hup://www.dlitz.net/software/pycrypto/ ），它提供了各种各样的加密函数。类似的库也存在于其他不同的语言中</p><p><strong>DES脚本</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from Crypto.Cipher import DES </span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">obj = DES.new(&quot;password&quot;, DES. MODE_ECB)</span><br><span class="line">cfile=open(&apos;encrypted_file&apos;,&apos;r&apos;)</span><br><span class="line">cbuf=f.read()</span><br><span class="line">print obj.decrypt(cbuf)</span><br></pre></td></tr></table></figure></p><p>利用导入的PyCrypto库，脚本打开一个名为encrypted_file的加密文件，并且使用密码pas sword，用电子密码本（ECB）模式进行了DES破解。</p><p>分组加密与DES加密类似，它使用不同的加密模式将一个单密钥应用到任意长度的明文流中，并且在库调用时指定模式。最简单的模式是ECB，它将分组密码应用到每个单独的明文块上。</p><p>脚本加密算法有多种可用的变种。前面的例子为编写自己的解密器提供了一个有效的选项类型。</p><p>攻击者编写自己版本的加密算法，通常要保留加密算法的简单性与良好的定义（以标准加密算法为例）。在处理非常复杂而且不标准的加密算法时，由于很难模拟算法，因此会成为更艰巨的挑战。</p><h3 id="3-使用通用的解密规范"><a href="#3-使用通用的解密规范" class="headerlink" title="3. 使用通用的解密规范"></a>3. 使用通用的解密规范</h3><p>在自解密中，试图让恶意代码自己解密时，你应该让恶意代码以正常方式运行，并且让其在合适的时间停止。但是，当你能够控制它的时候便没有了让其按照正常方式运行的理由。</p><p>一旦分离了加密或者解密例程，并且知道了它们的参数，则完全有可能使用规范让恶意代码解密任意内容，因此应该有效利用恶意代码本身来对付恶意代码。</p><p>From <a href="https://kabeor.github.io/第13章  数据加密/">https://kabeor.github.io/第13章  数据加密/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第13章-数据加密&quot;&gt;&lt;a href=&quot;#第13章-数据加密&quot; class=&quot;headerlink&quot; title=&quot;第13章  数据加密&quot;&gt;&lt;/a&gt;第13章  数据加密&lt;/h1&gt;&lt;h2 id=&quot;13x1-分析加密算法的目的&quot;&gt;&lt;a href=&quot;#13x1-分析加密
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第四篇 恶意代码功能篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AF%87-%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%8A%9F%E8%83%BD%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第12章  隐蔽的恶意代码启动</title>
    <link href="https://kabeor.github.io/%E7%AC%AC12%E7%AB%A0%20%20%E9%9A%90%E8%94%BD%E7%9A%84%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%90%AF%E5%8A%A8/"/>
    <id>https://kabeor.github.io/第12章  隐蔽的恶意代码启动/</id>
    <published>2018-08-18T02:09:07.280Z</published>
    <updated>2018-09-02T12:36:53.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第12章-隐蔽的恶意代码启动"><a href="#第12章-隐蔽的恶意代码启动" class="headerlink" title="第12章  隐蔽的恶意代码启动"></a>第12章  隐蔽的恶意代码启动</h1><h2 id="12x1-启动器（Launcher）"><a href="#12x1-启动器（Launcher）" class="headerlink" title="12x1 启动器（Launcher）"></a>12x1 启动器（Launcher）</h2><p>启动器（也称为加载器）是一种设置自身或其他恶意代码片段以达到即时或将来秘密运行的恶意代码。启动器的目的是安装一些东西，以使恶意行为对用户隐藏。</p><p>启动器经常包含它要加载的恶意代码。最常见的情况是在它的资源节中包含一个可执行文件或者DLL。正常情况下，Windows PE文件格式中的资源节是供可执行程序使用的，但并不应该是可执行程序的组成代码。正常资源节的内容包括图标、图片、菜单以及字符串。启动器通常在资源节存储恶意代码，当启动器运行时，它在运行嵌入的可执行程序或者DLL程序之前，从资源节将恶意代码提取出来。</p><p>恶意代码启动器通常需要以管理员权限运行，或者通过提权拥有这些权限。普通的用户进程不能执行本章讨论的技术。事实上，启动器可能会包含一些提权代码，这提供了识别启动器的另一种方法。</p><h2 id="12x2-进程注入"><a href="#12x2-进程注入" class="headerlink" title="12x2 进程注入"></a>12x2 进程注入</h2><p>隐藏启动的最流行技术是进程注入。顾名思义，这种技术是将代码注入到另外一个正在运行的进程中，而被注入的进程会不知不觉地运行注入的代码。恶意代码编写者试图通过进程注入技术隐藏代码的行为，有时他们也试图使用这种技术绕过基于主机的防火墙和那些针对进程的安全机制。</p><p>VirtualAllocEx函数用来在另外一个进程中分配一块内存空间。WriteProcessMemory函数用来向VirtualAllocEx函数分配的地址空间写数据。</p><h3 id="1-DLL注入"><a href="#1-DLL注入" class="headerlink" title="1. DLL注入"></a>1. DLL注入</h3><p>DLL注入将代码注入到一个远程进程，并让远程进程调用LoadLibrary，从而强制远程进程加载一个DLL程序到它的进程上下文。一旦被感染的进程加载了恶意DLL程序，OS会自动地调用DLLMain函数，DLLMain函数由这个DLL程序的作者编写。这个函数包含的代码拥有与被注入进程访问系统的相同权限。通常情况下，恶意DLL程序除了DLLMain函数之外，拥有很少的内容，并且它所做的任何操作看起来似乎都来自于被感染的进程。</p><p>为了将恶意DLL注入到一个主机进程，启动器恶意代码必须获取受害进程的句柄。最常用的方法是使用Windows API函数CreateToolhelp32Snapshot、Process32First和Process32Next，来查找进程列表中的目标进程。一旦发现目标进程，启动器会提取目标进程的进程标识（PID），然后用提取的PID调用OpenProcess，以获取目标进程的句柄。</p><p>DLL注入使用CreateRemoteThread函数，这个函数可以让启动器恶意代码在远程进程中创建并运行一个新的线程。使用CreateRemoteThread时，需要传入三个比较重要的参数：OpenProcess函数获得的进程句柄（hProcess），注入线程的入口点（lpStartAddress）以及线程的参数（hpParameter）。例如，线程的入口点可能被设置为Loadlibrary函数的地址，并且恶意DLL名字作为它的参数。这会触发受害进程用恶意DLL名字作为参数调用LoadLibrary，因此恶意DLL就可以加载到受害进程中（假设LoadLibrary函数在受害进程的内存空间中有效，并且恶意DLL的名字字符串存在于同一个进程空间）。</p><p>恶意代码编写者通常使用函数VirtualAllocEx，为恶意动态库的名字字符串创建内存空间。如果提供远程进程的句柄，VirtualAllocEx函数将在远程进程中分配内存空间。</p><p>调用CreateRemoteThread之前，调用的最后一个函数是WriteProcessMemory。这个函数将恶意DLL程序的名字字符串写入到VirtualAllocEx分配的内存空间中。</p><h3 id="2-直接注入"><a href="#2-直接注入" class="headerlink" title="2. 直接注入"></a>2. 直接注入</h3><p>同DLL注入一样，直接注入也涉及在远程进程的内存空间中分配和插入代码。直接注入同DLL注入类似，它们都使用了许多相同的WindowsAPI函数。不同的是，它并不用单独编写一个DLL并且强制远程进程载入它，而是直接将恶意代码注入到远程进程中。</p><p>直接注入比DLL注入更加灵活，但是要想注入的代码在不对宿主进程产生副作用的前提下成功运行，直接注入需要大量的定制代码。这种技术可以被用来注入编译过的代码，但更多的时候，它用来注入shellcode.</p><p>直接注入比DLL注入更加灵活，但是要想注入的代码在不对宿主进程产生副作用的前提下成功运行，直接注入需要大量的定制代码。这种技术可以被用来注入编译过的代码，但更多的时候，它用来注入shellcode.</p><p>在应用直接注入技术的恶意代码中，经常会发现如下三个函数：VirtualAllocEx、writeProcessMenory和CreateRemoteThread。通常会有两次virtualAllocEx和WriteProcessMemory调用。第一次调用是分配内存空间并写入远程线程使用的数据。第二次调用分配内存空间并且写入远程线程代码。CreateRemoteThread调用包含远程线程代码的位置（lpStartAddress）和数据（lpParameter）。</p><p>由于远程线程使用的数据和函数都必须位于受害进程空间内，所以正常编译的程序都无法工作。例如，字符串不在正常的.data段中，需要调用函数LoadLibrary/GetProcAddress来访问未载入的函数。另外，还有一些其他的限制，但我们在这里不做深入探究。基本上，直接注入技术要求恶意代码编写者或者精通汇编语言代码，或者是仅仅注入相对简单的shellcode。</p><p>要分析远程线程的代码，你可能需要调试恶意代码，并且在反汇编器中，转储WriteprocessMemory调用发生前所有的内存缓存区，以便进行分析。由于这些缓存区经常包含shellcode，因此你需要掌握shellcode分析技巧.</p><h2 id="12x3-进程替换"><a href="#12x3-进程替换" class="headerlink" title="12x3 进程替换"></a>12x3 进程替换</h2><p>除了注入代码到一个宿主程序外，一些恶意代码还会使用一种被称为进程替换方法，将一个可执行文件重写到一个运行进程的内存空间。当恶意代码编写者想要将恶意代码伪装成一个合法进程，并且不会产生DLL注入让进程崩溃的危险时，他们会使用进程替换技术。</p><p>这种技术让恶意代码与被替换进程拥有相同的特权级。例如，如果一段恶意代码执行了一次针对进程svchost.exe的进程替换攻击，用户会看到一个名为svchost.exe的进程从C:Windows\System32目录中启动，并很可能认为它没有什么风险（这是一种常见的恶意代码攻击方式）。</p><p>进程替换的关键是以挂起状态创建一个进程。这也就意味着这个进程将会被载入内存，但是它的主线程被挂起。在外部的程序恢复主线程之前，这个程序将不做任何事情，恢复主线程后，才开始执行。</p><p>一旦进程被创建，接下来就要用恶意的可执行文件替换受害进程的内存空间，通常会使用函数ZwUnmapViewofSection来释放由参数指向的所有内存。解除内存映射之后，加载器通常执行函数VirtualAllocEx为恶意代码分配新的内存，并且用函数WriteProcessMemory将恶意代码的每个段写入到受害进程的内存空间，这些操作常在一个循环中进行。</p><p>最后一步，恶意代码恢复受害进程的环境，通过调用SetThreadContext函数，让入口点指向恶意的代码，让其获得运行。最后，调用ResumeThread函数，初始化恶意代码并进行执行，而此时它已经替换了受害进程。</p><p>进程替换是恶意代码伪装成非恶意程序的一种有效方法。通过伪装成受害进程，恶意代码可以绕过防火墙和入侵防御系统（IPS），并且使它看起来像正常的Windows进程，从而让它逃避探测。</p><p>此外，通过使用原始的二进制路径，恶意代码还可以欺骗精明的用户，当查看进程列表时，他们只能看到执行是已知、有效的二进制程序，而并不会意识到它已经被解除了映射，并被替换成了恶意程序。</p><h2 id="12x4-钩子-Hook-注入"><a href="#12x4-钩子-Hook-注入" class="headerlink" title="12x4 钩子(Hook)注入"></a>12x4 钩子(Hook)注入</h2><p>钩子注入是一种利用Windows钩子（Hook）加载恶意代码的方法，恶意代码用它拦截发往某个应用程序的消息。恶意代码编写者可以用挂钩注入，来完成以下两种事情。</p><ol><li>保证无论何时拦截到一个特殊消息，恶意代码都会被运行。</li><li>保证一个特殊的DLL被载入到受害进程的内存空间。</li></ol><h3 id="1-本地和远程钩子（Hook）"><a href="#1-本地和远程钩子（Hook）" class="headerlink" title="1. 本地和远程钩子（Hook）"></a>1. 本地和远程钩子（Hook）</h3><p>有两种类型的Windows钩子：</p><ol><li>本地钩子被用来观察和操纵发往进程内部的消息。</li><li>远程钩子被用来观察和操纵发往一个远程进程的消息（系统中的另一个进程）。</li></ol><p>远程钩子有两种形式：上层和底层。上层的远程挂钩要求钩子例程是DLL程序的一个导出函数。它被操作系统映射到被挂钩线程或者系统所有线程的进程地址空间。底层远程钩子则要求钩子例程被保护在安装钩子的进程中。这个例程在操作系统获得处理事件的机会前被通知。</p><h3 id="2-使用钩子的击键记录器"><a href="#2-使用钩子的击键记录器" class="headerlink" title="2. 使用钩子的击键记录器"></a>2. 使用钩子的击键记录器</h3><p>钩子注入常被一种叫做击键记录器的恶意程序所使用，被用来记录击键。击键可以分别使用WH_KEYBOARD和WH_KEYBOARD_LL钩子例程类型，来注册上层和底层的钩子。</p><p>对于WH_KEYBOARD例程，钩子通常运行在远程进程的上下文空间中，也可以运行在安装钩子的进程空间中。对于WH_KEYBOARD_LL例程，事件直接发送到安装钩子的进程，所以钩子运行在创建钩子的进程中。无论使用哪种钩子类型，击键记录器都可以截获击键，并且在传递到进程或者系统之前，把它们记录到文件或是修改。</p><h3 id="3-使用SetWindowsHookEx"><a href="#3-使用SetWindowsHookEx" class="headerlink" title="3. 使用SetWindowsHookEx"></a>3. 使用SetWindowsHookEx</h3><p>用来执行远程Windows挂钩的主要函数是SetwindowsHookEx，它拥有如下参数：</p><ol><li>idHook 指定要安装的钩子例程的类型。</li><li>lpfn钩子例程指针。</li><li>hMod对于上层的钩子，它来标识包含lpfn定义的钩子例程的DLL句柄。对于底层钩子，它来标识包含1pfn例程的本地模块句柄。</li><li>dwThreadId 指定与钩子例程关联的线程标识，如果这个参数为0，则挂钩例程将绑定与调用线程同在一个桌面的所有线程。当为底层钩子时必须被设置为0。</li></ol><p>钩子例程可以包含处理消息（当它们从系统产生后）的代码，也可以什么也不做。无论如何，钩子例程都必须调用CallNextHookEx，这可以保证调用链中下一个钩子例程能够得到消息，并且保证系统继续正常运行。</p><h3 id="4-目标线程"><a href="#4-目标线程" class="headerlink" title="4. 目标线程"></a>4. 目标线程</h3><p>当制定dwThreadId时，恶意代码通常决定载入到dw某个系统线程，或者载入到所有线程。也就是说，仅当它是击键记录器或者类似的程序时，恶意代码才载入到所有线程（目的是拦截消息）。然而，载入到所有的线程会降低系统的运行速度，并且可能触发入侵防护系统。因此，如果是简单载入一个DLL到远程进程，则注入单个线程会保持恶意代码的隐蔽性。</p><p>指定单线程为目标，要求查找进程列表中的目标进程，如果碰到目标进程没有运行，恶意代码要先启动它。如果一个恶意的应用程序挂钩了一个经常使用的Windows消息，它很有可能会触发入侵防御系统，所以恶意代码通常会挂钩一个不常使用的消息，如WH_CBT（一个用于计算机训练的消息）。</p><h2 id="12x5-Detours"><a href="#12x5-Detours" class="headerlink" title="12x5 Detours"></a>12x5 Detours</h2><p>Detours是微软研究院1999年开发的一个代码库。它的初衷是作为一个来扩展已有操作系统和应用程序功能的简单工具。Detours开发库让开发人员对二进制应用程序进行修改变得简单可行。</p><p>同样，恶意代码编写者也喜欢Detours库，他们使用Detours库执行对导入表的修改，挂载DLL到已有程序文件，并且向运行的进程添加函数钩子等。</p><p>恶意代码编写者最常使用Detours库，来添加一个新的DLL到硬盘上的二进制文件。恶意代码修改PE结构，并且创建一个名为.detour的段，它通常位于导出表和调试符号之间。.detour段在新的导入地址表中包含了原始的PE头部。使用Detours库提供的setdll工具，恶意代码编写者修改PE头部，使其指向新的导入表。</p><h2 id="12x6-APC注入"><a href="#12x6-APC注入" class="headerlink" title="12x6 APC注入"></a>12x6 APC注入</h2><p>在本章的前面，我们看到通过CreateRemoteThread函数创建一个线程就可以使用远程进程中的一个函数。然而，线程创建需要系统开销，所以调用一个现有的线程会更加高效。Windows的异步过程调用（APC）可以满足这种要求。</p><p>APC可以让一个线程在它正常的执行路径运行之前执行一些其他的代码。每一个线程都有一个附加的APC队列，它们在线程处于可警告的等待状态时被处理。例如它们调用如WaitForSingleObjectEx、waitForMultipleobjectsEx和SleepEx函数等。实质上，这些函数给了线程一个处理等待APC的机会。</p><p>如果应用程序在线程可警告等待状态时（未运行之前）排入一个APC队列，那么线程将从调用APC函数开始。线程逐个调用APC队列中的所有APC。当APC队列完成时，线程才继续沿着它规定的路径执行。恶意代码编写者为了让他们的代码立即获得执行，他们用APC抢占可警告等待状态的线程。</p><p>APC有两种存在形式：</p><ol><li>为系统或者驱动生成的APC，被称为内核模式APC。</li><li>为应用程序生成的APC，被称为用户模式APC。<br>恶意代码可以使用APC注入技术，让内核空间或者用户空间中生成用户模式的APC.</li></ol><h3 id="1-用户模式下APC注入"><a href="#1-用户模式下APC注入" class="headerlink" title="1. 用户模式下APC注入"></a>1. 用户模式下APC注入</h3><p>线程可以使用API函数QueueUserAPC排入一个让远程线程调用的函数。运行用户模式的APC要求线程必须处于可警告等待状态，因此恶意代码会查看进程中是否有可能进入这个状态的目标线程。幸运的是，对恶意代码分析师来说，WaitForSingleObjectEx是最常使用的Windows API调用，并且有很多处于可警告等待状态的线程。</p><p>让我们来检查一下QueueUserAPC的参数：pfnAPC、hThread以及dwData。QueueUserAPC要求句柄为hThread的线程使用参数dwData运行pfnAPC定义的函数。</p><blockquote><p>注意：分析过程中，你可以通过查找恶意代码查询目标进程的API调用，如Create Toolhelp32Snapshot、Process32First和Process32Next 来发现目标线程的代码。在这些代码之后的经常是Thread32First和Thread32Next调用，它们通常被包含在一个在目标进程中查找目标线程的循环中。另外，恶意代码也会利用参数SYSTEM_PROCESS_INFORMATION调用Nt/ZwQuerySystemlnformation来发现目标进程。</p></blockquote><h3 id="2-内核模式的APC注入"><a href="#2-内核模式的APC注入" class="headerlink" title="2. 内核模式的APC注入"></a>2. 内核模式的APC注入</h3><p>恶意代码驱动和Rootkit也常常希望在用户空间中执行代码，但是对它们来说这样做并不容易。一种方法是在内核空间执行APC注入。恶意的驱动可创建一个APC，然后分配用户模式进程中的一个线程（最常见的是suchost.exe）运行它。这种类型APC通常由shellcode组成。</p><p>设备驱动利用两个主要的函数来使用APC: KeInitializeApc和KeInsertQueueApc.</p><p>From <a href="https://kabeor.github.io/第12章  隐蔽的恶意代码启动/">https://kabeor.github.io/第12章  隐蔽的恶意代码启动/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第12章-隐蔽的恶意代码启动&quot;&gt;&lt;a href=&quot;#第12章-隐蔽的恶意代码启动&quot; class=&quot;headerlink&quot; title=&quot;第12章  隐蔽的恶意代码启动&quot;&gt;&lt;/a&gt;第12章  隐蔽的恶意代码启动&lt;/h1&gt;&lt;h2 id=&quot;12x1-启动器（Launch
      
    
    </summary>
    
      <category term="病毒分析" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
      <category term="《恶意代码分析实战》笔记" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="第四篇 恶意代码功能篇" scheme="https://kabeor.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%9B%9B%E7%AF%87-%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%8A%9F%E8%83%BD%E7%AF%87/"/>
    
    
      <category term="病毒分析" scheme="https://kabeor.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
